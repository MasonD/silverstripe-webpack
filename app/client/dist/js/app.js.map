{"version":3,"sources":["webpack:///js/app.js","webpack:///webpack/bootstrap bf4e87ea9ffc4b0f0978","webpack:///external \"jQuery\"","webpack:///./node_modules/bootstrap/js/dist/util.js?2617","webpack:///./app/client/src/js/_events.js","webpack:///./node_modules/popper.js/dist/esm/popper.js","webpack:///(webpack)/buildin/global.js","webpack:///./node_modules/hammerjs/hammer.js","webpack:///./app/client/src/js/app.js","webpack:///./app/client/src/js/_components/_ui.spinner.js","webpack:///./app/client/src/js/_components/_ui.carousel.js","webpack:///./app/client/src/js/_components/_ui.menu.js","webpack:///./app/client/src/js/_components/_ui.form.storage.js","webpack:///./app/client/src/js/_components/_ui.ajax.js","webpack:///./app/client/src/js/main.js","webpack:///./node_modules/bootstrap/js/dist/util.js","webpack:///./node_modules/bootstrap/js/dist/alert.js","webpack:///./node_modules/bootstrap/js/dist/button.js","webpack:///./node_modules/bootstrap/js/dist/carousel.js","webpack:///./node_modules/bootstrap/js/dist/collapse.js","webpack:///./node_modules/bootstrap/js/dist/dropdown.js","webpack:///./node_modules/bootstrap/js/dist/modal.js","webpack:///./node_modules/bootstrap/js/dist/tooltip.js","webpack:///./node_modules/bootstrap/js/dist/popover.js","webpack:///./node_modules/bootstrap/js/dist/tooltip.js?6cae","webpack:///./node_modules/bootstrap/js/dist/scrollspy.js","webpack:///./node_modules/bootstrap/js/dist/tab.js","webpack:///./node_modules/offcanvas-bootstrap/dist/js/bootstrap.offcanvas.js","webpack:///./node_modules/jquery-hammerjs/jquery.hammer.js","webpack:///./node_modules/pouchdb/dist/pouchdb.js","webpack:///./app/client/src/js/_components/routes/index.js","webpack:///./node_modules/routie/index.js","webpack:///./node_modules/path-browserify/index.js","webpack:///(webpack)/node_modules/process/browser.js","webpack:///./node_modules/smooth-scroll/dist/smooth-scroll.min.js","webpack:///./app/client/src/img nonrecursive \\.(png|jpe","webpack:///./app/client/src/img/icon-cfpb.png","webpack:///./app/client/src/img/icon-lender.png","webpack:///./app/client/src/img/logo.png","webpack:///./node_modules/font-awesome nonrecursive \\.(otf|eot|svg|ttf|woff|woff2)$"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","i","l","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","default","object","property","prototype","hasOwnProperty","p","s","jQuery","$","Util","toType","obj","toString","match","toLowerCase","getSpecialTransitionEndEvent","bindType","TRANSITION_END","delegateType","handle","event","target","is","this","handleObj","handler","apply","arguments","transitionEndEmulator","duration","_this","called","one","setTimeout","triggerTransitionEnd","getUID","prefix","Math","random","document","getElementById","getSelectorFromElement","element","selector","getAttribute","find","length","err","getTransitionDurationFromElement","transitionDuration","css","parseFloat","split","reflow","offsetHeight","trigger","supportsTransitionEnd","Boolean","isElement","nodeType","typeCheckConfig","componentName","config","configTypes","expectedTypes","value","valueType","RegExp","test","Error","toUpperCase","fn","emulateTransitionEnd","special","AJAX","LOADED","__webpack_exports__","global","microtaskDebounce","window","Promise","resolve","then","taskDebounce","scheduled","timeoutDuration","isFunction","functionToCheck","getType","getStyleComputedProperty","getComputedStyle","getParentNode","nodeName","parentNode","host","getScrollParent","body","ownerDocument","_getStyleComputedProp","overflow","overflowX","overflowY","isIE","version","isIE11","isIE10","getOffsetParent","documentElement","noOffsetParent","offsetParent","nextElementSibling","indexOf","isOffsetContainer","firstElementChild","getRoot","node","findCommonOffsetParent","element1","element2","order","compareDocumentPosition","Node","DOCUMENT_POSITION_FOLLOWING","start","end","range","createRange","setStart","setEnd","commonAncestorContainer","contains","element1root","getScroll","side","upperSide","html","scrollingElement","includeScroll","rect","subtract","scrollTop","scrollLeft","modifier","top","bottom","left","right","getBordersSize","styles","axis","sideA","sideB","getSize","computedStyle","max","getWindowSizes","height","width","getClientRect","offsets","_extends","getBoundingClientRect","e","result","sizes","clientWidth","clientHeight","horizScrollbar","offsetWidth","vertScrollbar","getOffsetRectRelativeToArbitraryNode","children","parent","fixedPosition","isHTML","childrenRect","parentRect","scrollParent","borderTopWidth","borderLeftWidth","marginTop","marginLeft","getViewportOffsetRectRelativeToArtbitraryNode","excludeScroll","relativeOffset","innerWidth","innerHeight","isFixed","getFixedPositionOffsetParent","parentElement","el","getBoundaries","popper","reference","padding","boundariesElement","boundaries","boundariesNode","_getWindowSizes","getArea","_ref","computeAutoPlacement","placement","refRect","rects","sortedAreas","keys","map","key","area","sort","a","b","filteredAreas","filter","_ref2","computedPlacement","variation","getReferenceOffsets","state","getOuterSizes","x","marginBottom","y","marginRight","getOppositePlacement","hash","replace","matched","getPopperOffsets","referenceOffsets","popperRect","popperOffsets","isHoriz","mainSide","secondarySide","measurement","secondaryMeasurement","arr","check","Array","findIndex","prop","cur","runModifiers","modifiers","data","ends","slice","forEach","function","console","warn","enabled","update","isDestroyed","instance","arrowStyles","attributes","flipped","options","positionFixed","flip","originalPlacement","position","isCreated","onUpdate","onCreate","isModifierEnabled","modifierName","some","getSupportedPropertyName","prefixes","upperProp","charAt","toCheck","style","destroy","removeAttribute","willChange","disableEventListeners","removeOnDestroy","removeChild","getWindow","defaultView","attachToScrollParents","callback","scrollParents","isBody","addEventListener","passive","push","setupEventListeners","updateBound","scrollElement","eventsEnabled","enableEventListeners","scheduleUpdate","removeEventListeners","removeEventListener","cancelAnimationFrame","isNumeric","isNaN","isFinite","setStyles","unit","setAttributes","setAttribute","applyStyle","arrowElement","applyStyleOnLoad","modifierOptions","computeStyle","legacyGpuAccelerationOption","gpuAcceleration","offsetParentRect","floor","round","prefixedProperty","invertTop","invertLeft","x-placement","arrow","isModifierRequired","requestingName","requestedName","requesting","isRequired","_requesting","requested","_data$offsets$arrow","querySelector","_data$offsets","isVertical","len","sideCapitalized","altSide","opSide","arrowElementSize","center","popperMarginSide","popperBorderSide","sideValue","min","getOppositeVariation","clockwise","counter","index","validPlacements","concat","reverse","placementOpposite","flipOrder","behavior","BEHAVIORS","FLIP","CLOCKWISE","COUNTERCLOCKWISE","step","refOffsets","overlapsRef","overflowsLeft","overflowsRight","overflowsTop","overflowsBottom","overflowsBoundaries","flippedVariation","flipVariations","keepTogether","toValue","str","parseOffset","offset","basePlacement","useHeight","fragments","frag","trim","divider","search","splitRegex","ops","op","mergeWithPrevious","reduce","index2","preventOverflow","transformProp","popperStyles","transform","priority","primary","escapeWithReference","secondary","shift","shiftvariation","shiftOffsets","hide","bound","inner","subtractLength","isBrowser","longerTimeoutBrowsers","navigator","userAgent","supportsMicroTasks","debounce","MSInputMethodContext","documentMode","classCallCheck","Constructor","TypeError","createClass","defineProperties","props","descriptor","writable","protoProps","staticProps","assign","source","placements","onLoad","Defaults","Popper","requestAnimationFrame","bind","jquery","Utils","PopperUtils","Ot","g","Function","eval","__WEBPACK_AMD_DEFINE_RESULT__","exportName","undefined","setTimeoutContext","timeout","context","bindFn","invokeArrayArg","arg","isArray","each","iterator","deprecate","method","message","deprecationMessage","stack","log","inherit","child","base","properties","childP","baseP","create","constructor","_super","boolOrFn","val","args","TYPE_FUNCTION","ifUndefined","val1","val2","addEventListeners","types","splitStr","type","hasParent","inStr","inArray","src","findByKey","toArray","uniqueArray","results","values","prefixed","camelProp","VENDOR_PREFIXES","uniqueId","_uniqueId","getWindowForElement","doc","parentWindow","Input","manager","self","inputTarget","domHandler","ev","enable","init","createInputInstance","inputClass","SUPPORT_POINTER_EVENTS","PointerEventInput","SUPPORT_ONLY_TOUCH","TouchInput","SUPPORT_TOUCH","TouchMouseInput","MouseInput","inputHandler","eventType","input","pointersLen","pointers","changedPointersLen","changedPointers","isFirst","INPUT_START","isFinal","INPUT_END","INPUT_CANCEL","session","computeInputData","emit","recognize","prevInput","pointersLength","firstInput","simpleCloneInputData","firstMultiple","offsetCenter","getCenter","timeStamp","now","deltaTime","angle","getAngle","distance","getDistance","computeDeltaXY","offsetDirection","getDirection","deltaX","deltaY","overallVelocity","getVelocity","overallVelocityX","overallVelocityY","abs","scale","getScale","rotation","getRotation","maxPointers","computeIntervalInputData","srcEvent","offsetDelta","prevDelta","velocity","velocityX","velocityY","direction","last","lastInterval","COMPUTE_INTERVAL","v","clientX","clientY","DIRECTION_NONE","DIRECTION_LEFT","DIRECTION_RIGHT","DIRECTION_UP","DIRECTION_DOWN","p1","p2","PROPS_XY","sqrt","atan2","PI","PROPS_CLIENT_XY","evEl","MOUSE_ELEMENT_EVENTS","evWin","MOUSE_WINDOW_EVENTS","pressed","POINTER_ELEMENT_EVENTS","POINTER_WINDOW_EVENTS","store","pointerEvents","SingleTouchInput","evTarget","SINGLE_TOUCH_TARGET_EVENTS","SINGLE_TOUCH_WINDOW_EVENTS","started","normalizeSingleTouches","all","touches","changed","changedTouches","TOUCH_TARGET_EVENTS","targetIds","getTouches","allTouches","INPUT_MOVE","identifier","targetTouches","changedTargetTouches","touch","mouse","primaryTouch","lastTouches","recordTouches","eventData","setLastTouch","lastTouch","lts","removeLastTouch","splice","DEDUP_TIMEOUT","isSyntheticEvent","t","dx","dy","DEDUP_DISTANCE","TouchAction","set","cleanTouchActions","actions","TOUCH_ACTION_NONE","hasPanX","TOUCH_ACTION_PAN_X","hasPanY","TOUCH_ACTION_PAN_Y","TOUCH_ACTION_MANIPULATION","TOUCH_ACTION_AUTO","Recognizer","defaults","id","STATE_POSSIBLE","simultaneous","requireFail","stateStr","STATE_CANCELLED","STATE_ENDED","STATE_CHANGED","STATE_BEGAN","directionStr","getRecognizerByNameIfManager","otherRecognizer","recognizer","AttrRecognizer","PanRecognizer","pX","pY","PinchRecognizer","PressRecognizer","_timer","_input","RotateRecognizer","SwipeRecognizer","TapRecognizer","pTime","pCenter","count","Hammer","recognizers","preset","Manager","handlers","oldCssProps","touchAction","toggleCssProps","item","add","recognizeWith","requireFailure","cssProps","triggerDomEvent","gestureEvent","createEvent","initEvent","gesture","dispatchEvent","TEST_ELEMENT","createElement","Date","output","nextKey","extend","dest","merge","MOBILE_REGEX","DIRECTION_HORIZONTAL","DIRECTION_VERTICAL","DIRECTION_ALL","MOUSE_INPUT_MAP","mousedown","mousemove","mouseup","button","which","pointerType","POINTER_INPUT_MAP","pointerdown","pointermove","pointerup","pointercancel","pointerout","IE10_POINTER_TYPE_ENUM","2","3","4","5","MSPointerEvent","PointerEvent","removePointer","eventTypeNormalized","isTouch","storeIndex","pointerId","SINGLE_TOUCH_INPUT_MAP","touchstart","touchmove","touchend","touchcancel","TOUCH_INPUT_MAP","inputEvent","inputData","isMouse","sourceCapabilities","firesTouchEvents","PREFIXED_TOUCH_ACTION","NATIVE_TOUCH_ACTION","TOUCH_ACTION_MAP","touchMap","cssSupports","CSS","supports","compute","getTouchAction","join","preventDefaults","prevented","preventDefault","hasNone","isTapPointer","isTapMovement","isTapTouchTime","preventSrc","STATE_RECOGNIZED","dropRecognizeWith","dropRequireFailure","hasRequireFailures","canRecognizeWith","additionalEvent","tryEmit","canEmit","inputDataClone","reset","process","attrTest","optionPointers","isRecognized","isValid","threshold","directionTest","hasMoved","inOut","time","validPointers","validMovement","validTime","clearTimeout","taps","interval","posThreshold","validTouchTime","failTimeout","validInterval","validMultiTap","tapCount","VERSION","domEvents","userSelect","touchSelect","touchCallout","contentZooming","userDrag","tapHighlightColor","stop","force","stopped","curRecognizer","existing","remove","on","events","off","STATE_FAILED","Tap","Pan","Swipe","Pinch","Rotate","Press","_classCallCheck","_ui_carousel__classCallCheck","_ui_menu__classCallCheck","_ui_form_storage__classCallCheck","_ui_ajax__classCallCheck","main__classCallCheck","importAll","r","external__jQuery_","external__jQuery__default","_events","_events_default","_createClass","SpinnerUI","show","_ui_spinner","_ui_carousel__createClass","_ui_menu__createClass","CarouselUI","dispose","$e","attr","$items","$indicators","append","prepend","carousel","hammer","_ui_form_storage__createClass","NAME","DATA_KEY","SlidingMenu","_element","$element","addClass","click","removeClass","removeData","_jQueryInterface","noConflict","JQUERY_NO_CONFLICT","ready","jsSlidingMenu","_typeof","STORAGE","localStorage","FormStorage","$elements","getItem","change","setItem","submit","clear","jsFormStorage","Symbol","_ui_ajax__createClass","_ui_ajax_AjaxUI","G","D","$Html","$Body","AjaxUI","$this","parents","load","url","MainUI","updateLocation","absoluteLocation","URLDetails","relative","substring","location","href","history","pushState","ajax","page","title","sync","async","dataType","cache","error","jqXHR","statusText","ga","success","status","getResponseHeader","js","regions","replaceRegion","preload","$head","eventName","items","Deferred","promise","dfds","dfd","always","when","$region","empty","jsAjaxUI","Title","ClassName","onpopstate","$existingLink","hasClass","_ui_ajax","w","smooth_scroll_min","smooth_scroll_min_default","main__createClass","smoothScroll","W","$AlertNotify","$SiteWideMessage","visibilityState","updateOnlineStatus","onLine","ScrollTo","animateScroll","speed","setInterval","complete","datastatus","reload","loadImages","getScript","fonts","WebFont","google","families","print","substr","msg","cls","fadeOut","alert","fadeIn","play","$imgs","$imgUrls","$imgLazyUrls","lazySrc","_defineProperties","Selector","DISMISS","Event","CLOSE","CLOSED","CLICK_DATA_API","ALERT","FADE","SHOW","Alert","_proto","close","rootElement","_getRootElement","_triggerCloseEvent","isDefaultPrevented","_removeElement","closest","closeEvent","_destroyElement","detach","_handleDismiss","alertInstance","ACTIVE","BUTTON","FOCUS","DATA_TOGGLE_CARROT","DATA_TOGGLE","INPUT","FOCUS_BLUR_DATA_API","Button","toggle","triggerChangeEvent","addAriaPressed","checked","activeElement","hasAttribute","classList","focus","toggleClass","_objectSpread","ownKeys","getOwnPropertySymbols","sym","getOwnPropertyDescriptor","_defineProperty","EVENT_KEY","Default","keyboard","slide","pause","wrap","DefaultType","Direction","NEXT","PREV","LEFT","RIGHT","SLIDE","SLID","KEYDOWN","MOUSEENTER","MOUSELEAVE","TOUCHEND","LOAD_DATA_API","CAROUSEL","ITEM","ACTIVE_ITEM","NEXT_PREV","INDICATORS","DATA_SLIDE","DATA_RIDE","Carousel","_items","_interval","_activeElement","_isPaused","_isSliding","touchTimeout","_config","_getConfig","_indicatorsElement","_addEventListeners","next","_slide","nextWhenVisible","hidden","prev","cycle","clearInterval","to","activeIndex","_getItemIndex","_this2","_keydown","tagName","makeArray","_getItemByDirection","isNextDirection","isPrevDirection","lastItemIndex","delta","itemIndex","_triggerSlideEvent","relatedTarget","eventDirectionName","targetIndex","fromIndex","slideEvent","from","_setActiveIndicatorElement","nextIndicator","directionalClassName","orderClassName","_this3","activeElementIndex","nextElement","nextElementIndex","isCycling","slidEvent","action","_dataApiClickHandler","slideIndex","$carousel","SHOWN","HIDE","HIDDEN","COLLAPSE","COLLAPSING","COLLAPSED","Dimension","WIDTH","HEIGHT","ACTIVES","Collapse","_isTransitioning","_triggerArray","tabToggles","elem","_selector","_parent","_getParent","_addAriaAndCollapsedClass","actives","activesData","not","startEvent","dimension","_getDimension","setTransitioning","capitalizedDimension","scrollSize","$elem","isTransitioning","_getTargetFromElement","triggerArray","isOpen","currentTarget","$trigger","$target","REGEXP_KEYDOWN","ARROW_UP_KEYCODE","CLICK","KEYDOWN_DATA_API","KEYUP_DATA_API","DISABLED","DROPUP","DROPRIGHT","DROPLEFT","MENURIGHT","MENULEFT","POSITION_STATIC","FORM_CHILD","MENU","NAVBAR_NAV","VISIBLE_ITEMS","AttachmentMap","TOP","TOPEND","BOTTOM","BOTTOMEND","RIGHTEND","LEFTEND","boundary","display","Dropdown","_popper","_menu","_getMenuElement","_inNavbar","_detectNavbar","disabled","_getParentFromElement","isActive","_clearMenus","showEvent","referenceElement","_getPopperConfig","noop","stopPropagation","_getPlacement","$parentDropdown","offsetConf","popperConfig","toggles","dropdownMenu","hideEvent","_dataApiKeydownHandler","backdrop","FOCUSIN","RESIZE","CLICK_DISMISS","KEYDOWN_DISMISS","MOUSEUP_DISMISS","MOUSEDOWN_DISMISS","SCROLLBAR_MEASURER","BACKDROP","OPEN","DIALOG","DATA_DISMISS","FIXED_CONTENT","STICKY_CONTENT","NAVBAR_TOGGLER","Modal","_dialog","_backdrop","_isShown","_isBodyOverflowing","_ignoreBackdropClick","_scrollbarWidth","_checkScrollbar","_setScrollbar","_adjustDialog","_setEscapeEvent","_setResizeEvent","_showBackdrop","_showElement","transition","_hideModal","handleUpdate","ELEMENT_NODE","appendChild","_enforceFocus","shownEvent","transitionComplete","_this4","has","_this5","_this6","_this7","_resetAdjustments","_resetScrollbar","_removeBackdrop","_this8","animate","className","appendTo","backdropTransitionDuration","callbackRemove","_backdropTransitionDuration","isModalOverflowing","scrollHeight","paddingLeft","paddingRight","_getScrollbarWidth","_this9","actualPadding","calculatedPadding","actualMargin","calculatedMargin","margin","scrollDiv","scrollbarWidth","_this10","BSCLS_PREFIX_REGEX","animation","template","delay","container","fallbackPlacement","AUTO","HoverState","OUT","INSERTED","FOCUSOUT","TOOLTIP","TOOLTIP_INNER","ARROW","Trigger","HOVER","MANUAL","Tooltip","_isEnabled","_timeout","_hoverState","_activeTrigger","tip","_setListeners","disable","toggleEnabled","dataKey","_getDelegateConfig","_isWithActiveTrigger","_enter","_leave","getTipElement","isWithContent","isInTheDom","tipId","setContent","attachment","_getAttachment","addAttachmentClass","_handlePopperPlacementChange","_fixTransition","prevHoverState","_cleanTipClass","getTitle","CLASS_PREFIX","$tip","setElementContent","content","text","eventIn","eventOut","_fixTitle","titleType","tabClass","initConfigAnimation","_inheritsLoose","subClass","superClass","__proto__","TITLE","CONTENT","Popover","_Tooltip","_getContent","ACTIVATE","SCROLL","DROPDOWN_ITEM","DROPDOWN_MENU","DATA_SPY","NAV_LIST_GROUP","NAV_LINKS","NAV_ITEMS","LIST_ITEMS","DROPDOWN","DROPDOWN_ITEMS","DROPDOWN_TOGGLE","OffsetMethod","OFFSET","POSITION","ScrollSpy","_scrollElement","_offsets","_targets","_activeTarget","_scrollHeight","_process","refresh","autoMethod","offsetMethod","offsetBase","_getScrollTop","_getScrollHeight","targetSelector","targetBCR","pageYOffset","_getOffsetHeight","maxScroll","_activate","_clear","queries","$link","scrollSpys","$spy","tab","ACTIVE_UL","DROPDOWN_ACTIVE_CHILD","Tab","previous","listElement","itemSelector","hiddenEvent","activeElements","active","_transitionComplete","dropdownChild","dropdownElement","__webpack_provided_window_dot_jQuery","__bind","me","Offcanvas","OffcanvasDropdown","OffcanvasTouch","_clickEvent","nav","dropdown","offcanvas","_getFade","_getCss","_touchEnd","_touchMove","_touchStart","endThreshold","startThreshold","outerWidth","maxStartThreshold","currentX","fade","startX","originalEvent","pageX","outerHeight","sendEvents","_clearCss","bodyOverflow","-webkit-transform","-webkit-transition-duration","-moz-transform","-moz-transition","-o-transform","-o-transition","opacity","_sendEventsAfter","_sendEventsBefore","_documentClicked","_close","_open","_clicked","_navbarHeight","_transformSupported","clickedEl","asSupport","regex","translate3D","cssText","bsOffcanvas","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_ARRAY__","factory","hammerify","$el","originalEmit","require","f","define","u","code","1","_dereq_","argsArray","fun","useColors","WebkitAppearance","firebug","exception","table","parseInt","$1","formatArgs","namespace","humanize","diff","color","lastC","save","namespaces","storage","removeItem","debug","env","DEBUG","chrome","local","colors","formatters","j","JSON","stringify","9","selectColor","charCodeAt","createDebug","curr","ms","prevTime","coerce","unshift","format","formatter","instances","names","skips","8","EventEmitter","_maxListeners","isNumber","isObject","isUndefined","defaultMaxListeners","setMaxListeners","er","listeners","addListener","listener","newListener","warned","trace","once","removeListener","fired","list","removeAllListeners","listenerCount","evlistener","emitter","nextTick","draining","oldQueue","queue","immediate","task","scheduleDrain","Mutation","MutationObserver","WebKitMutationObserver","observer","createTextNode","observe","characterData","setImmediate","MessageChannel","scriptEl","onreadystatechange","channel","port1","onmessage","port2","postMessage","6","ctor","superCtor","super_","TempCtor","7","INTERNAL","resolver","PENDING","outcome","safelyResolveThenable","QueueItem","onFulfilled","onRejected","callFulfilled","otherCallFulfilled","callRejected","otherCallRejected","unwrap","func","returnValue","reject","getThen","thenable","onError","onSuccess","tryToUnwrap","tryCatch","out","reason","iterable","resolved","resolveFromAll","outValue","race","response","REJECTED","FULFILLED","catch","parse","String","exec","h","fmtShort","fmtLong","plural","ceil","long","defaultSetTimout","defaultClearTimeout","runTimeout","cachedSetTimeout","runClearTimeout","marker","cachedClearTimeout","cleanUpNextTick","currentQueue","queueIndex","drainQueue","run","Item","array","browser","argv","versions","prependListener","prependOnceListener","binding","cwd","chdir","dir","umask","10","amd","glob","SparkMD5","md5cycle","k","md5blk","md5blks","md5blk_array","md51","tail","tmp","lo","hi","md51_array","subarray","Uint8Array","rhex","hex_chr","hex","toUtf8","unescape","encodeURIComponent","utf8Str2ArrayBuffer","returnUInt8Array","buff","ArrayBuffer","arrayBuffer2Utf8Str","fromCharCode","concatenateArrayBuffers","first","second","byteLength","buffer","hexToBinaryString","bytes","clamp","num","targetArray","sourceArray","begin","appendBinary","contents","_buff","_length","_hash","raw","ret","_finish","getState","setState","hashBinary","11","v1","v4","uuid","14","15","12","bytesToUuid","buf","bth","byteToHex","13","getRandomValues","crypto","msCrypto","rnds8","rnds","_nodeId","clockseq","_clockseq","seedBytes","rng","msecs","getTime","nsecs","_lastNSecs","dt","_lastMSecs","tl","tmh","ii","16","pop","metaStack","lastMetaElement","lastElementIndex","arrayPrefix","objPrefix","res","collationIndex","parsedNum","numChar","parsedString","lastCh","numConsecutiveSlashes","ch","arrayElement","objElement","17","_interopDefault","ex","isBinaryObject","Blob","cloneArrayBuffer","cloneBinaryObject","size","webkitSlice","isPlainObject","proto","getPrototypeOf","Ctor","funcToString","objectCtorString","clone","newObject","toISOString","getArguments","toPromise","usedCB","PouchPromise","fulfill","resp","mesg","logApiCall","logArgs","origCallback","responseArgs","adapterFun","_closed","_destroyed","taskqueue","isReady","addTask","failed","mangle","unmangle","Map$1","_store","Set$1","pick","identityFunction","formatResultForOpenRevsGet","ok","bulkGet","db","opts","collapseResultsAndFinish","perDocResults","docs","info","checkDone","numDone","numDocs","gotResult","docIndex","nextBatch","allRequests","upTo","MAX_NUM_CONCURRENT_REQUESTS","batch","processBatch","docId","docIdx","docRequests","requestsById","docOpts","open_revs","request","rev","formatResult","param","requests","ExportedMap","isChromeApp","hasLocalStorage","hasLocal","attachBrowserEvents","onChanged","db_name","dbName","newValue","attachEvent","Changes","_listeners","guardedConsole","randomNumber","maxTimeout","defaultBackOff","explainError","PouchError","createError","CustomPouchError","generateErrorFromResponse","UNKNOWN_ERROR","tryFilter","req","BAD_REQUEST","filterChange","hasFilter","query","query_params","filterReturn","include_docs","attachments","att","_attachments","stub","flatten","arrs","invalidIdError","INVALID_ID","RESERVED_ID","MISSING_ID","isRemote","_remote","ee","parseDesignDocFunctionName","parts","normalizeDesignDocFunctionName","normalized","parseUri","parser","uri","encoded","decodeURIComponent","qName","qParser","$0","$2","scopeEval","scope","upsert","diffFun","docRev","_rev","newDoc","updated","_id","tryAndPut","put","uuidV4","winningRev","metadata","winningId","winningPos","winningDeleted","toVisit","rev_tree","tree","ids","branches","pos","deleted","traverseRevTree","revs","newCtx","ctx","sortByPos","collectLeaves","leaves","isLeaf","acc","collectConflicts","win","conflicts","leaf","compactTree","revHash","rootToLeaf","paths","sortByPos$1","binarySearch","comparator","mid","low","high","insertSorted","idx","pathToTree","path","numStemmed","root","currentLeaf","compareTree","mergeTree","in_tree1","in_tree2","tree1","tree2","merged","doMerge","dontExpand","restree","branch","t1","t2","candidateParents","trees","parentIdx","elements","elementsLen","stem","depth","stemmedRevs","stemmed","newTree","revExists","splitRev","targetPos","targetId","getTrees","isDeleted","isLocalId","latest","historyNode","historyRev","tryCatchInChangeListener","pending","lastSeq","Changes$2","onDestroy","cancel","onChange","isCancelled","validateChanges","processChange","changeList","changes","_conflicts","compare","yankError","cleanDocs","_deleted","atts","compareByIdThenRev","idCompare","_revisions","computeHeight","edges","prnt","rev$$1","edge","allDocsKeysParse","skip","limit","descending","doNextCompaction","_compactionQueue","last_seq","_compact","attachmentNameError","AbstractPouchDB","TaskQueue$1","parseAdapter","adapter","adapters","PouchDB","preferredAdapters","adapterName","use_prefix","prepareForDestruction","onDestroyed","from_constructor","onClosed","__opts","auto_compaction","prefixedName","backend","_adapter","valid","fail","debugPouch","logs","logId","getFieldFromDoc","parsedField","compare$1","parseField","fieldName","fields","current","isCombinationalField","field","combinationFields","getKey","getValue","mergeAndedSelectors","selectors","matcher","$eq","fieldMatchers","operator","mergeGtGte","mergeLtLte","mergeNe","mergeEq","$gte","$gt","$lte","$lt","$ne","massageSelector","wasAnded","$and","orOrNor","subSelector","$not","pad","padWith","upToLength","targetLength","padLeft","collate","normalizeKey","ai","bi","stringCollate","arrayCollate","objectCollate","Infinity","origKey","toJSON","indexify","numToIndexableString","toIndexableString","objKey","SEP","parseNumber","originalIdx","neg","numAsString","magAsString","MAGNITUDE_DIGITS","magnitude","MIN_MAGNITUDE","parseIndexableString","parsedStr","ak","bk","expFormat","toExponential","magForComparison","magString","factor","factorStr","toFixed","createFieldSorter","getFieldValuesAsArray","sorting","aRow","bRow","aFieldValues","bFieldValues","collation","filterInMemoryFields","rows","requestDef","inMemoryFields","row","rowFilter","fieldSorter","every","docFieldValue","matchCominationalSelector","matchSelector","userOperator","userValue","orMatchers","matchers","fieldExists","fieldIsNotUndefined","modField","divisor","mod","arrayContainsValue","arrayContainsAllValues","arraySize","regexMatch","typeMatch","matchesSelector","rowsMatched","evalFilter","evalView","validate","filterName","normalize","view","shouldFilter","changesHandler","doc_ids","viewName","ddoc","mapFun","views","MISSING_DOC","doChanges","filterFun","filters","applyChangesFilterPlugin","_changesFilterPlugin","toObject","parseRevisionInfo","INVALID_REV","makeRevTreeFromRevisions","revisions","revisionIds","parseDoc","newEdits","nRevNum","newRevId","revInfo","_rev_tree","specialKey","reservedWords","DOC_VALIDATION","dataWords","createBlob","Builder","BlobBuilder","MSBlobBuilder","MozBlobBuilder","WebKitBlobBuilder","builder","getBlob","binaryStringToArrayBuffer","bin","binStringToBluffer","binString","b64ToBluffer","b64","thisAtob","arrayBufferToBinaryString","binary","readAsBinaryString","blob","FileReader","FileReaderSync","readAsArrayBuffer","reader","hasBinaryString","onloadend","blobToBinaryString","blobOrBuffer","blobToBase64","base64","thisBtoa","rawToBase64","sliceBlob","appendBlob","arrayBuffer","appendString","string","binaryMd5","setImmediateShim","loadNextChunk","done","currentChunk","chunkSize","chunks","inputIsString","MD5_CHUNK_SIZE","Md5","stringMd5","parseBase64","BAD_ARG","preprocessString","blobType","asBinary","content_type","digest","preprocessBlob","md5","preprocessAttachment","preprocessAttachments","docInfos","docv","overallErr","docInfo","processedAttachment","recv","updateDoc","revLimit","cb","writeDoc","previousWinningRev","previouslyDeleted","isRoot","REV_CONFLICT","newRev","rev_map","newRevIsDeleted","winningRev$$1","winningRevIsDeleted","rootIsMissing","processDocs","api","fetchedDocs","tx","overallCallback","insertDoc","resultsIdx","checkAllDocsDone","docsDone","docsToDo","new_edits","idsToDocs","currentDoc","docWritten","nextDoc","safeJsonParse","vuvuzela","safeJsonStringify","json","idbError","evt","IDB_ERROR","encodeMetadata","deletedOrLocal","seq","decodeMetadata","storedObject","decodeDoc","_doc_id_rev","lastIndexOf","readBlobData","asBlob","fetchAttachmentsIfNecessary","txn","fetchAttachment","attObj","objectStore","ATTACH_STORE","onsuccess","postProcessAttachments","attNames","$inject_Object_assign","compactRevs","deleteOrphanedAttachments","possiblyOrphanedDigests","attAndSeqStore","IDBKeyRange","attStore","delete","seqStore","BY_SEQ_STORE","ATTACH_AND_SEQ_STORE","openCursor","only","cursor","digestSeq","primaryKey","continue","openTransactionSafely","idb","stores","mode","transaction","idbBulkDocs","dbOpts","startTransaction","DOC_STORE","LOCAL_STORE","META_STORE","txnResult","onabort","ontimeout","oncomplete","docStore","bySeqStore","attachStore","attachAndSeqStore","metaStore","metaDoc","updateDocCountIfReady","verifyAttachments","preconditionErrored","fetchExistingDocs","onAllDocsProcessed","allDocsProcessed","idbProcessDocs","revs_limit","docCount","docCountDelta","numFetched","readMetadata","changesHandler$$1","notify","_meta","verifyAttachment","MISSING_STUB","finish","digests","filename","attErr","isUpdate","writeAttachments","finishDoc","afterPutDoc","revsToDelete","metadataToStore","afterPutMetadata","afterPutDocError","insertAttachmentMappings","putReq","onerror","collectResults","attachmentSaved","revpos","saveAttachment","attsAdded","attsToAdd","newAtt","docInfoError","blobSupport","runBatchedCursor","keyRange","batchSize","onBatch","onGetAll","valuesBatch","keysBatch","pseudoCursor","onGetAllKeys","continuePseudoCursor","newKeyRange","lastKey","upper","upperOpen","lowerBound","getAll","getAllKeys","onCursor","allDocsKeys","createKeyRange","inclusiveEnd","upperBound","idbAllDocs","fetchDocAsynchronously","docIdRevIndex","allDocsInner","batchValues","batchValue","batchKeys","onResultsReady","returnVal","total_rows","update_seq","updateSeq","onTxnComplete","keyRangeError","startkey","endkey","inclusive_end","maxKey","checkBlobSupport","blob$$1","DETECT_BLOB_SUPPORT_STORE","matchedChrome","matchedEdge","countDocs","tryCode","applyNext","running","enqueueTask","processMetadataAndWinningDoc","winningDoc","filtered","numResults","returnDocs","onBatchDone","winningDocs","metadatas","fetchWinningDocAndMetadata","onGetMetadata","docIdRev","docIds","docIdsToMetadata","continuous","ExportedSet","since","return_docs","objectStores","IdbPouch","thisCallback","createSchema","createObjectStore","keyPath","autoIncrement","createIndex","unique","addDeletedOrLocalIndex","createLocalStoreSchema","migrateLocalStore","localStore","seqCursor","addAttachAndSeqStore","migrateAttsAndSeqs","digestMap","migrateMetadata","decodeMetadataCompat","onGetMetadataSeq","metadataSeq","instanceId","_bulkDocs","reqOpts","_get","attachId","blobData","_info","doc_count","idb_attachment_format","_allDocs","_changes","cachedDBs","_getRevisionTree","_doCompaction","_getLocal","_putLocal","oldRev","oStore","oldDoc","_removeLocal","_destroy","openReq","openReqList","indexedDB","deleteDatabase","cached","tryStorageOption","open","ADAPTER_VERSION","onupgradeneeded","migration","migrations","oldVersion","completeSetup","storedMetaDoc","storeMetaDocIfReady","instanceKey","onversionchange","blobSupportPromise","IDBPouch","decodeUtf8","escape","hexToInt","charCode","parseHexUtf8","parseHexUtf16","parseHexString","encoding","quote","escapeBlob","unescapeBlob","stringifyDoc","unstringifyDoc","qMarks","select","joiner","where","orderBy","compactRevs$1","deleteOrphans","seqs","sql","ATTACH_AND_SEQ_STORE$1","executeSql","digestsToCheck","nonOrphanedDigests","ATTACH_STORE$1","BY_SEQ_STORE$1","websqlError","errorNameMatch","errorName","errorReason","WSQ_ERROR","websqlBulkDocs","websqlChanges","_name","cnt","sqlArgs","deletedInt","insertId","dataWritten","fetchSql","attachmentErr","revsToCompact","DOC_STORE$1","metadataStr","params","websqlProcessDocs","userDocs","docInfoErrors","openDatabaseWithOpts","websql","description","openDBSafely","openDB","cachedResult","cachedDatabases","fetchAttachmentsIfNecessary$1","attOpts","_","WebSqlPouch","dbCreated","runMigration2","DOC_STORE_WINNINGSEQ_INDEX_SQL","BY_SEQ_STORE_DELETED_INDEX_SQL","runMigration3","LOCAL_STORE$1","doNext","runMigration4","updateRows","doc_id_rev","doc_id","BY_SEQ_STORE_DOC_ID_REV_INDEX_SQL","runMigration5","nextPage","SELECT_DOCS","DOC_STORE_AND_BY_SEQ_JOINER","pageSize","digestSeqs","digestSeqPairs","pair","attachAndRev","ATTACH_AND_SEQ_STORE_ATTACH_INDEX_SQL","ATTACH_AND_SEQ_STORE_SEQ_INDEX_SQL","runMigration6","runMigration7","checkEncoding","onGetInstanceId","idRequests","onGetVersion","dbVersion","meta","META_STORE$1","attach","initSeq","initSeqArgs","ADAPTER_VERSION$1","setupDone","dbid","tasks","nextMigration","fetchVersion","db_version","getMaxSeq","latest$$1","websqlOpts","POUCH_VERSION","openDBResult","readTransaction","theSeq","theDocCount","websql_encoding","latestRev","totalRows","criteria","destinctKeys","bindingStr","selectStmt","reportChange","maxSeq","escaped","putLocal","rowsAffected","removeLocal","canOpenTestDB","openDatabase","isValidWebSQL","hasLS","localStorageKey","openedTestDB","openDB$2","WebSQLPouch","_opts","WebSqlPouch$1","wrappedFetch","wrappedPromise","fetch","fetchRequest","timer","headers","Headers","fetchOptions","credentials","processData","fetchResponse","statusCode","abort","xhRequest","xhr","timedout","abortReq","cleanUp","timeoutReq","onprogress","upload","XMLHttpRequest","withCredentials","Accept","responseType","setRequestHeader","readyState","responseText","send","hasXhr","defaultBody","ajaxCore","missing","ajax$1","ua","isSafari","isTrident","isEdge","shouldCacheBust","hasArgs","pool","promiseFactories","runNext","runNextBatch","thisErr","readAttachmentsAsBlobOrBuffer","encodeDocId","preprocessAttachments$2","hasUrlPrefix","protocol","getHost","user","password","auth","username","genDBUrl","genUrl","pathDel","port","paramsToStr","HttpPouch","userOpts","reqAjax","ajaxOpts","defaultHeaders","_ajax","ajaxPromise","adapterFun$$1","setup","skipSetup","skip_setup","setupPromise","dbUrl","encodeAttachmentId","attachmentId","nAuth","token","Authorization","uuid$$1","compact","ping","compact_running","doBulkGet","doBulkGetShim","MAX_SIMULTANEOUS_REVS","numBatches","subOpts","batchNum","supportsBulkGet","supportsBulkGetMap","fetchAttachments","filenames","fetchAllAttachments","docOrDocs","revs_info","docOrId","optsOrRev","getAttachment","removeAttachment","putAttachment","Content-Type","_put","allDocs","start_key","end_key","paramStr","batch_size","CHANGES_BATCH_SIZE","heartbeat","DEFAULT_HEARTBEAT","requestTimeout","CHANGES_TIMEOUT_BUFFER","leftToFetch","feed","seq_interval","param_name","lastFetchedSeq","aborted","xhrOpts","fetched","raw_results_length","finished","revsDiff","HttpPouch$1","QueryParseError","captureStackTrace","NotFoundError","BuiltInError","promisedCallback","callbackify","fin","finalPromiseFactory","sequentialize","promiseFactory","that","uniq","theSet","mapToKeysArray","createBuiltInError","sum","jLen","jNum","evalFunctionWithEval","TaskQueue$2","createViewSignature","reduceFun","createView","sourceDB","temporary","localDocName","cachedViews","viewSignature","_cachedViews","promiseForView","diffFunction","fullViewName","depDbs","depDbName","registerDependentDatabase","lastSeqDoc","parseViewName","isGenOne","emitError","getBuiltIn","reduceFunString","builtInReduce","_sum","_count","_stats","mapper","origMap","reducer","ddocValidator","abstract","viewCleanup","isGenOne$1","fileHasChanged","localDoc","remoteDoc","getDocAttachments","getDocAttachmentsFromTargetOrSource","doCheckForLocalAttachments","createBulkGetOpts","diffs","missingRev","getDocs","getAllDocs","bulkGetOpts","bulkGetResponse","cancelled","bulkGetInfo","resultDocs","hasAttachments","hasConflicts","fetchRevisionOneDocs","getRevisionOneDocs","returnResult","updateCheckpoint","checkpoint","session_id","replicator","REPLICATOR","CHECKPOINT_VERSION","CHECKPOINT_HISTORY_SIZE","Checkpointer","compareReplicationLogs","srcDoc","tgtDoc","compareReplicationHistory","sourceHistory","targetHistory","S","sourceRest","T","targetRest","hasSessionId","LOWEST_SEQ","sessionId","rest","isForbiddenError","backOff","retry","back_off_function","backOffSet","current_back_off","STARTING_BACK_OFF","removeBackOffSetter","sortObjectPropertiesByKey","queryParams","generateReplicationId","filterViewName","queryData","md5sum","replicate","initCheckpointer","checkpointer","repId","checkpointOpts","writeSourceCheckpoint","writeTargetCheckpoint","writeDocs","changedDocs","currentBatch","bulkOpts","bulkDocs","completeReplication","errorsById","errorsNo","doc_write_failures","docs_written","errors","finishBatch","outResult","writingCheckpoint","writeCheckpoint","getChanges","onCheckpointError","getDiffs","getBatchDocs","got","docs_read","startNextBatch","batches","processPendingBatch","abortReplication","pendingBatch","changesOpts","live","changesCompleted","replicationCompleted","fatalError","end_time","onChangesComplete","changesPending","onChangesError","abortChanges","batches_limit","_abortChanges","startChanges","getCheckpoint","start_time","_addedListeners","Replication","toPouch","PouchConstructor","replicateWrapper","replicateRet","sync$1","Sync","pullChange","pushChange","pushDenied","pullDenied","pushPaused","pullPaused","pushActive","pullActive","removeAll","isChange","isDenied","isPaused","removed","addOneListener","canceled","optsPush","optsPull","pull","replication","replicateMethods","other","lie","inherits","mangled","Map","Set","species","eventFunction","inprogress","notifyLocalWindows","nextSource","MISSING_BULK_DOCS","QUERY_PARSE_ERROR","NOT_AN_OBJECT","newPromise","post","putDoc","oldRevId","oldRevNum","newRevNum","createAttachment","prevrevpos","was_delete","addToMissing","revId","processDoc","missingForId","missingObj","compactDocument","maxHeight","revTree","candidates","promises","onComplete","finishOpenRevs","splittedRev","revNo","currentPath","hashIndex","indexOfRev","howMany","_revs_info","incompatibleOpt","_type","attachmentError","dependentDb","dependentDbs","depDB","destroyDb","usePrefix","deletedMap","trueName","execute","eventEmitter","Pouch","destructListeners","_destructionListeners","dbList","addToPreferredAdapters","plugin","__defaults","defaultOpts","PouchAlt","$elemMatch","$allMatch","$exists","$mod","neValue","$in","$nin","$size","$all","$regex","$type","atob","btoa","platform","hasFetch","persistentQueues","tempViewQueue","CHANGES_BATCH_SIZE$1","sumsqr","_sumsqr","tryMap","tryReduce","rereduce","sortByKeyThenValue","keyCompare","sliceResults","rowToDocId","postprocessAttachments","addHttpParam","paramName","asJson","coerceInteger","integerCandidate","asNumber","Number","coerceOptions","group_level","checkPositiveInteger","number","checkQueryParseError","startkeyName","endkeyName","group","optionName","httpQuery","keysAsString","customQuery","_query","customViewCleanup","_viewCleanup","defaultsTo","getDocsToPersist","docIdsToChangesAndEmits","getKeyValueDocs","processKeyValueDocs","kvDocsRes","kvDocs","oldKeys","indexableKeysToKeyValues","keyValue","newKeys","kvDoc","metaDocId","defaultMetaDoc","docData","saveKeyValues","listOfDocsToPersist","docsToPersist","getQueue","updateView","updateViewInQueue","mapResults","processNextBatch","currentSeq","createDocIdsToChangesAndEmits","createIndexableKeysToKeyValues","emittedKeyValue","complexKey","reduceView","shouldGroup","groups","lvl","POSITIVE_INFINITY","groupKey","reduceTry","queryView","queryViewInQueue","fetchFromView","viewOpts","expectedKeys","parsedKeyAndDocId","onMapResultsReady","finalResults","shouldReduce","allDocsRes","docIdsToDocs","fetchPromises","keyStart","keyEnd","httpViewCleanup","localViewCleanup","docsToViews","designDocName","viewsToStatus","ddocName","viewDBNames","statusIsGood","viewDBName","dbsToDelete","destroyPromises","queryPromised","stale","abstractQuery","mapreduce","updateTarget","updateSource","comparisons","targetDoc","sourceDoc","cleanup","_readyCalled","__WEBPACK_IMPORTED_MODULE_0__events__","__WEBPACK_IMPORTED_MODULE_0__events___default","__WEBPACK_IMPORTED_MODULE_1_routie__","__WEBPACK_IMPORTED_MODULE_1_routie___default","navigation","carousel:id:num","methods","__slice","_map","subpath","normalizeArray","allowAboveRoot","up","xs","splitPathRe","splitPath","resolvedPath","resolvedAbsolute","isAbsolute","trailingSlash","fromParts","toParts","samePartsLength","outputParts","sep","delimiter","dirname","basename","ext","extname","ignore","header","topOnEmptyHash","clip","easing","customEasing","updateURL","popstate","emitEvents","Element","matchMedia","matches","InvalidCharacterError","offsetTop","anchor","outline","scrollTo","CustomEvent","bubbles","detail","E","O","I","cancelScroll","C","L","A","H","q","Q","metaKey","ctrlKey","hostname","pathname","webpackContext","webpackContextResolve","./icon-cfpb.png","./icon-lender.png","./logo.png","webpackEmptyContext"],"mappings":"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","file":"js/app.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"app/client/dist/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 6);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports) {\n\nmodule.exports = jQuery;\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function($) {/**\n * --------------------------------------------------------------------------\n * Bootstrap (v4.1.1): util.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n * --------------------------------------------------------------------------\n */\nvar Util = function ($) {\n  /**\n   * ------------------------------------------------------------------------\n   * Private TransitionEnd Helpers\n   * ------------------------------------------------------------------------\n   */\n  var TRANSITION_END = 'transitionend';\n  var MAX_UID = 1000000;\n  var MILLISECONDS_MULTIPLIER = 1000; // Shoutout AngusCroll (https://goo.gl/pxwQGp)\n\n  function toType(obj) {\n    return {}.toString.call(obj).match(/\\s([a-z]+)/i)[1].toLowerCase();\n  }\n\n  function getSpecialTransitionEndEvent() {\n    return {\n      bindType: TRANSITION_END,\n      delegateType: TRANSITION_END,\n      handle: function handle(event) {\n        if ($(event.target).is(this)) {\n          return event.handleObj.handler.apply(this, arguments); // eslint-disable-line prefer-rest-params\n        }\n\n        return undefined; // eslint-disable-line no-undefined\n      }\n    };\n  }\n\n  function transitionEndEmulator(duration) {\n    var _this = this;\n\n    var called = false;\n    $(this).one(Util.TRANSITION_END, function () {\n      called = true;\n    });\n    setTimeout(function () {\n      if (!called) {\n        Util.triggerTransitionEnd(_this);\n      }\n    }, duration);\n    return this;\n  }\n\n  function setTransitionEndSupport() {\n    $.fn.emulateTransitionEnd = transitionEndEmulator;\n    $.event.special[Util.TRANSITION_END] = getSpecialTransitionEndEvent();\n  }\n  /**\n   * --------------------------------------------------------------------------\n   * Public Util Api\n   * --------------------------------------------------------------------------\n   */\n\n\n  var Util = {\n    TRANSITION_END: 'bsTransitionEnd',\n    getUID: function getUID(prefix) {\n      do {\n        // eslint-disable-next-line no-bitwise\n        prefix += ~~(Math.random() * MAX_UID); // \"~~\" acts like a faster Math.floor() here\n      } while (document.getElementById(prefix));\n\n      return prefix;\n    },\n    getSelectorFromElement: function getSelectorFromElement(element) {\n      var selector = element.getAttribute('data-target');\n\n      if (!selector || selector === '#') {\n        selector = element.getAttribute('href') || '';\n      }\n\n      try {\n        var $selector = $(document).find(selector);\n        return $selector.length > 0 ? selector : null;\n      } catch (err) {\n        return null;\n      }\n    },\n    getTransitionDurationFromElement: function getTransitionDurationFromElement(element) {\n      if (!element) {\n        return 0;\n      } // Get transition-duration of the element\n\n\n      var transitionDuration = $(element).css('transition-duration');\n      var floatTransitionDuration = parseFloat(transitionDuration); // Return 0 if element or transition duration is not found\n\n      if (!floatTransitionDuration) {\n        return 0;\n      } // If multiple durations are defined, take the first\n\n\n      transitionDuration = transitionDuration.split(',')[0];\n      return parseFloat(transitionDuration) * MILLISECONDS_MULTIPLIER;\n    },\n    reflow: function reflow(element) {\n      return element.offsetHeight;\n    },\n    triggerTransitionEnd: function triggerTransitionEnd(element) {\n      $(element).trigger(TRANSITION_END);\n    },\n    // TODO: Remove in v5\n    supportsTransitionEnd: function supportsTransitionEnd() {\n      return Boolean(TRANSITION_END);\n    },\n    isElement: function isElement(obj) {\n      return (obj[0] || obj).nodeType;\n    },\n    typeCheckConfig: function typeCheckConfig(componentName, config, configTypes) {\n      for (var property in configTypes) {\n        if (Object.prototype.hasOwnProperty.call(configTypes, property)) {\n          var expectedTypes = configTypes[property];\n          var value = config[property];\n          var valueType = value && Util.isElement(value) ? 'element' : toType(value);\n\n          if (!new RegExp(expectedTypes).test(valueType)) {\n            throw new Error(componentName.toUpperCase() + \": \" + (\"Option \\\"\" + property + \"\\\" provided type \\\"\" + valueType + \"\\\" \") + (\"but expected type \\\"\" + expectedTypes + \"\\\".\"));\n          }\n        }\n      }\n    }\n  };\n  setTransitionEndSupport();\n  return Util;\n}($);\n//# sourceMappingURL=util.js.map\n\n/*** EXPORTS FROM exports-loader ***/\nmodule.exports = Util;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports) {\n\n/**\n * Add your global events here\n */\n\nmodule.exports = {\n  AJAX: 'ajax-load',\n  LOADED: 'load'\n};\n\n/***/ }),\n/* 3 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* WEBPACK VAR INJECTION */(function(global) {/**!\n * @fileOverview Kickass library to create and place poppers near their reference elements.\n * @version 1.14.3\n * @license\n * Copyright (c) 2016 Federico Zivolo and contributors\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\nvar isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined';\n\nvar longerTimeoutBrowsers = ['Edge', 'Trident', 'Firefox'];\nvar timeoutDuration = 0;\nfor (var i = 0; i < longerTimeoutBrowsers.length; i += 1) {\n  if (isBrowser && navigator.userAgent.indexOf(longerTimeoutBrowsers[i]) >= 0) {\n    timeoutDuration = 1;\n    break;\n  }\n}\n\nfunction microtaskDebounce(fn) {\n  var called = false;\n  return function () {\n    if (called) {\n      return;\n    }\n    called = true;\n    window.Promise.resolve().then(function () {\n      called = false;\n      fn();\n    });\n  };\n}\n\nfunction taskDebounce(fn) {\n  var scheduled = false;\n  return function () {\n    if (!scheduled) {\n      scheduled = true;\n      setTimeout(function () {\n        scheduled = false;\n        fn();\n      }, timeoutDuration);\n    }\n  };\n}\n\nvar supportsMicroTasks = isBrowser && window.Promise;\n\n/**\n* Create a debounced version of a method, that's asynchronously deferred\n* but called in the minimum time possible.\n*\n* @method\n* @memberof Popper.Utils\n* @argument {Function} fn\n* @returns {Function}\n*/\nvar debounce = supportsMicroTasks ? microtaskDebounce : taskDebounce;\n\n/**\n * Check if the given variable is a function\n * @method\n * @memberof Popper.Utils\n * @argument {Any} functionToCheck - variable to check\n * @returns {Boolean} answer to: is a function?\n */\nfunction isFunction(functionToCheck) {\n  var getType = {};\n  return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';\n}\n\n/**\n * Get CSS computed property of the given element\n * @method\n * @memberof Popper.Utils\n * @argument {Eement} element\n * @argument {String} property\n */\nfunction getStyleComputedProperty(element, property) {\n  if (element.nodeType !== 1) {\n    return [];\n  }\n  // NOTE: 1 DOM access here\n  var css = getComputedStyle(element, null);\n  return property ? css[property] : css;\n}\n\n/**\n * Returns the parentNode or the host of the element\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @returns {Element} parent\n */\nfunction getParentNode(element) {\n  if (element.nodeName === 'HTML') {\n    return element;\n  }\n  return element.parentNode || element.host;\n}\n\n/**\n * Returns the scrolling parent of the given element\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @returns {Element} scroll parent\n */\nfunction getScrollParent(element) {\n  // Return body, `getScroll` will take care to get the correct `scrollTop` from it\n  if (!element) {\n    return document.body;\n  }\n\n  switch (element.nodeName) {\n    case 'HTML':\n    case 'BODY':\n      return element.ownerDocument.body;\n    case '#document':\n      return element.body;\n  }\n\n  // Firefox want us to check `-x` and `-y` variations as well\n\n  var _getStyleComputedProp = getStyleComputedProperty(element),\n      overflow = _getStyleComputedProp.overflow,\n      overflowX = _getStyleComputedProp.overflowX,\n      overflowY = _getStyleComputedProp.overflowY;\n\n  if (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {\n    return element;\n  }\n\n  return getScrollParent(getParentNode(element));\n}\n\nvar isIE11 = isBrowser && !!(window.MSInputMethodContext && document.documentMode);\nvar isIE10 = isBrowser && /MSIE 10/.test(navigator.userAgent);\n\n/**\n * Determines if the browser is Internet Explorer\n * @method\n * @memberof Popper.Utils\n * @param {Number} version to check\n * @returns {Boolean} isIE\n */\nfunction isIE(version) {\n  if (version === 11) {\n    return isIE11;\n  }\n  if (version === 10) {\n    return isIE10;\n  }\n  return isIE11 || isIE10;\n}\n\n/**\n * Returns the offset parent of the given element\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @returns {Element} offset parent\n */\nfunction getOffsetParent(element) {\n  if (!element) {\n    return document.documentElement;\n  }\n\n  var noOffsetParent = isIE(10) ? document.body : null;\n\n  // NOTE: 1 DOM access here\n  var offsetParent = element.offsetParent;\n  // Skip hidden elements which don't have an offsetParent\n  while (offsetParent === noOffsetParent && element.nextElementSibling) {\n    offsetParent = (element = element.nextElementSibling).offsetParent;\n  }\n\n  var nodeName = offsetParent && offsetParent.nodeName;\n\n  if (!nodeName || nodeName === 'BODY' || nodeName === 'HTML') {\n    return element ? element.ownerDocument.documentElement : document.documentElement;\n  }\n\n  // .offsetParent will return the closest TD or TABLE in case\n  // no offsetParent is present, I hate this job...\n  if (['TD', 'TABLE'].indexOf(offsetParent.nodeName) !== -1 && getStyleComputedProperty(offsetParent, 'position') === 'static') {\n    return getOffsetParent(offsetParent);\n  }\n\n  return offsetParent;\n}\n\nfunction isOffsetContainer(element) {\n  var nodeName = element.nodeName;\n\n  if (nodeName === 'BODY') {\n    return false;\n  }\n  return nodeName === 'HTML' || getOffsetParent(element.firstElementChild) === element;\n}\n\n/**\n * Finds the root node (document, shadowDOM root) of the given element\n * @method\n * @memberof Popper.Utils\n * @argument {Element} node\n * @returns {Element} root node\n */\nfunction getRoot(node) {\n  if (node.parentNode !== null) {\n    return getRoot(node.parentNode);\n  }\n\n  return node;\n}\n\n/**\n * Finds the offset parent common to the two provided nodes\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element1\n * @argument {Element} element2\n * @returns {Element} common offset parent\n */\nfunction findCommonOffsetParent(element1, element2) {\n  // This check is needed to avoid errors in case one of the elements isn't defined for any reason\n  if (!element1 || !element1.nodeType || !element2 || !element2.nodeType) {\n    return document.documentElement;\n  }\n\n  // Here we make sure to give as \"start\" the element that comes first in the DOM\n  var order = element1.compareDocumentPosition(element2) & Node.DOCUMENT_POSITION_FOLLOWING;\n  var start = order ? element1 : element2;\n  var end = order ? element2 : element1;\n\n  // Get common ancestor container\n  var range = document.createRange();\n  range.setStart(start, 0);\n  range.setEnd(end, 0);\n  var commonAncestorContainer = range.commonAncestorContainer;\n\n  // Both nodes are inside #document\n\n  if (element1 !== commonAncestorContainer && element2 !== commonAncestorContainer || start.contains(end)) {\n    if (isOffsetContainer(commonAncestorContainer)) {\n      return commonAncestorContainer;\n    }\n\n    return getOffsetParent(commonAncestorContainer);\n  }\n\n  // one of the nodes is inside shadowDOM, find which one\n  var element1root = getRoot(element1);\n  if (element1root.host) {\n    return findCommonOffsetParent(element1root.host, element2);\n  } else {\n    return findCommonOffsetParent(element1, getRoot(element2).host);\n  }\n}\n\n/**\n * Gets the scroll value of the given element in the given side (top and left)\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @argument {String} side `top` or `left`\n * @returns {number} amount of scrolled pixels\n */\nfunction getScroll(element) {\n  var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'top';\n\n  var upperSide = side === 'top' ? 'scrollTop' : 'scrollLeft';\n  var nodeName = element.nodeName;\n\n  if (nodeName === 'BODY' || nodeName === 'HTML') {\n    var html = element.ownerDocument.documentElement;\n    var scrollingElement = element.ownerDocument.scrollingElement || html;\n    return scrollingElement[upperSide];\n  }\n\n  return element[upperSide];\n}\n\n/*\n * Sum or subtract the element scroll values (left and top) from a given rect object\n * @method\n * @memberof Popper.Utils\n * @param {Object} rect - Rect object you want to change\n * @param {HTMLElement} element - The element from the function reads the scroll values\n * @param {Boolean} subtract - set to true if you want to subtract the scroll values\n * @return {Object} rect - The modifier rect object\n */\nfunction includeScroll(rect, element) {\n  var subtract = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n  var scrollTop = getScroll(element, 'top');\n  var scrollLeft = getScroll(element, 'left');\n  var modifier = subtract ? -1 : 1;\n  rect.top += scrollTop * modifier;\n  rect.bottom += scrollTop * modifier;\n  rect.left += scrollLeft * modifier;\n  rect.right += scrollLeft * modifier;\n  return rect;\n}\n\n/*\n * Helper to detect borders of a given element\n * @method\n * @memberof Popper.Utils\n * @param {CSSStyleDeclaration} styles\n * Result of `getStyleComputedProperty` on the given element\n * @param {String} axis - `x` or `y`\n * @return {number} borders - The borders size of the given axis\n */\n\nfunction getBordersSize(styles, axis) {\n  var sideA = axis === 'x' ? 'Left' : 'Top';\n  var sideB = sideA === 'Left' ? 'Right' : 'Bottom';\n\n  return parseFloat(styles['border' + sideA + 'Width'], 10) + parseFloat(styles['border' + sideB + 'Width'], 10);\n}\n\nfunction getSize(axis, body, html, computedStyle) {\n  return Math.max(body['offset' + axis], body['scroll' + axis], html['client' + axis], html['offset' + axis], html['scroll' + axis], isIE(10) ? html['offset' + axis] + computedStyle['margin' + (axis === 'Height' ? 'Top' : 'Left')] + computedStyle['margin' + (axis === 'Height' ? 'Bottom' : 'Right')] : 0);\n}\n\nfunction getWindowSizes() {\n  var body = document.body;\n  var html = document.documentElement;\n  var computedStyle = isIE(10) && getComputedStyle(html);\n\n  return {\n    height: getSize('Height', body, html, computedStyle),\n    width: getSize('Width', body, html, computedStyle)\n  };\n}\n\nvar classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\n\n\n\n\nvar defineProperty = function (obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n};\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\n/**\n * Given element offsets, generate an output similar to getBoundingClientRect\n * @method\n * @memberof Popper.Utils\n * @argument {Object} offsets\n * @returns {Object} ClientRect like output\n */\nfunction getClientRect(offsets) {\n  return _extends({}, offsets, {\n    right: offsets.left + offsets.width,\n    bottom: offsets.top + offsets.height\n  });\n}\n\n/**\n * Get bounding client rect of given element\n * @method\n * @memberof Popper.Utils\n * @param {HTMLElement} element\n * @return {Object} client rect\n */\nfunction getBoundingClientRect(element) {\n  var rect = {};\n\n  // IE10 10 FIX: Please, don't ask, the element isn't\n  // considered in DOM in some circumstances...\n  // This isn't reproducible in IE10 compatibility mode of IE11\n  try {\n    if (isIE(10)) {\n      rect = element.getBoundingClientRect();\n      var scrollTop = getScroll(element, 'top');\n      var scrollLeft = getScroll(element, 'left');\n      rect.top += scrollTop;\n      rect.left += scrollLeft;\n      rect.bottom += scrollTop;\n      rect.right += scrollLeft;\n    } else {\n      rect = element.getBoundingClientRect();\n    }\n  } catch (e) {}\n\n  var result = {\n    left: rect.left,\n    top: rect.top,\n    width: rect.right - rect.left,\n    height: rect.bottom - rect.top\n  };\n\n  // subtract scrollbar size from sizes\n  var sizes = element.nodeName === 'HTML' ? getWindowSizes() : {};\n  var width = sizes.width || element.clientWidth || result.right - result.left;\n  var height = sizes.height || element.clientHeight || result.bottom - result.top;\n\n  var horizScrollbar = element.offsetWidth - width;\n  var vertScrollbar = element.offsetHeight - height;\n\n  // if an hypothetical scrollbar is detected, we must be sure it's not a `border`\n  // we make this check conditional for performance reasons\n  if (horizScrollbar || vertScrollbar) {\n    var styles = getStyleComputedProperty(element);\n    horizScrollbar -= getBordersSize(styles, 'x');\n    vertScrollbar -= getBordersSize(styles, 'y');\n\n    result.width -= horizScrollbar;\n    result.height -= vertScrollbar;\n  }\n\n  return getClientRect(result);\n}\n\nfunction getOffsetRectRelativeToArbitraryNode(children, parent) {\n  var fixedPosition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n  var isIE10 = isIE(10);\n  var isHTML = parent.nodeName === 'HTML';\n  var childrenRect = getBoundingClientRect(children);\n  var parentRect = getBoundingClientRect(parent);\n  var scrollParent = getScrollParent(children);\n\n  var styles = getStyleComputedProperty(parent);\n  var borderTopWidth = parseFloat(styles.borderTopWidth, 10);\n  var borderLeftWidth = parseFloat(styles.borderLeftWidth, 10);\n\n  // In cases where the parent is fixed, we must ignore negative scroll in offset calc\n  if (fixedPosition && parent.nodeName === 'HTML') {\n    parentRect.top = Math.max(parentRect.top, 0);\n    parentRect.left = Math.max(parentRect.left, 0);\n  }\n  var offsets = getClientRect({\n    top: childrenRect.top - parentRect.top - borderTopWidth,\n    left: childrenRect.left - parentRect.left - borderLeftWidth,\n    width: childrenRect.width,\n    height: childrenRect.height\n  });\n  offsets.marginTop = 0;\n  offsets.marginLeft = 0;\n\n  // Subtract margins of documentElement in case it's being used as parent\n  // we do this only on HTML because it's the only element that behaves\n  // differently when margins are applied to it. The margins are included in\n  // the box of the documentElement, in the other cases not.\n  if (!isIE10 && isHTML) {\n    var marginTop = parseFloat(styles.marginTop, 10);\n    var marginLeft = parseFloat(styles.marginLeft, 10);\n\n    offsets.top -= borderTopWidth - marginTop;\n    offsets.bottom -= borderTopWidth - marginTop;\n    offsets.left -= borderLeftWidth - marginLeft;\n    offsets.right -= borderLeftWidth - marginLeft;\n\n    // Attach marginTop and marginLeft because in some circumstances we may need them\n    offsets.marginTop = marginTop;\n    offsets.marginLeft = marginLeft;\n  }\n\n  if (isIE10 && !fixedPosition ? parent.contains(scrollParent) : parent === scrollParent && scrollParent.nodeName !== 'BODY') {\n    offsets = includeScroll(offsets, parent);\n  }\n\n  return offsets;\n}\n\nfunction getViewportOffsetRectRelativeToArtbitraryNode(element) {\n  var excludeScroll = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n  var html = element.ownerDocument.documentElement;\n  var relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);\n  var width = Math.max(html.clientWidth, window.innerWidth || 0);\n  var height = Math.max(html.clientHeight, window.innerHeight || 0);\n\n  var scrollTop = !excludeScroll ? getScroll(html) : 0;\n  var scrollLeft = !excludeScroll ? getScroll(html, 'left') : 0;\n\n  var offset = {\n    top: scrollTop - relativeOffset.top + relativeOffset.marginTop,\n    left: scrollLeft - relativeOffset.left + relativeOffset.marginLeft,\n    width: width,\n    height: height\n  };\n\n  return getClientRect(offset);\n}\n\n/**\n * Check if the given element is fixed or is inside a fixed parent\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @argument {Element} customContainer\n * @returns {Boolean} answer to \"isFixed?\"\n */\nfunction isFixed(element) {\n  var nodeName = element.nodeName;\n  if (nodeName === 'BODY' || nodeName === 'HTML') {\n    return false;\n  }\n  if (getStyleComputedProperty(element, 'position') === 'fixed') {\n    return true;\n  }\n  return isFixed(getParentNode(element));\n}\n\n/**\n * Finds the first parent of an element that has a transformed property defined\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @returns {Element} first transformed parent or documentElement\n */\n\nfunction getFixedPositionOffsetParent(element) {\n  // This check is needed to avoid errors in case one of the elements isn't defined for any reason\n  if (!element || !element.parentElement || isIE()) {\n    return document.documentElement;\n  }\n  var el = element.parentElement;\n  while (el && getStyleComputedProperty(el, 'transform') === 'none') {\n    el = el.parentElement;\n  }\n  return el || document.documentElement;\n}\n\n/**\n * Computed the boundaries limits and return them\n * @method\n * @memberof Popper.Utils\n * @param {HTMLElement} popper\n * @param {HTMLElement} reference\n * @param {number} padding\n * @param {HTMLElement} boundariesElement - Element used to define the boundaries\n * @param {Boolean} fixedPosition - Is in fixed position mode\n * @returns {Object} Coordinates of the boundaries\n */\nfunction getBoundaries(popper, reference, padding, boundariesElement) {\n  var fixedPosition = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n\n  // NOTE: 1 DOM access here\n\n  var boundaries = { top: 0, left: 0 };\n  var offsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, reference);\n\n  // Handle viewport case\n  if (boundariesElement === 'viewport') {\n    boundaries = getViewportOffsetRectRelativeToArtbitraryNode(offsetParent, fixedPosition);\n  } else {\n    // Handle other cases based on DOM element used as boundaries\n    var boundariesNode = void 0;\n    if (boundariesElement === 'scrollParent') {\n      boundariesNode = getScrollParent(getParentNode(reference));\n      if (boundariesNode.nodeName === 'BODY') {\n        boundariesNode = popper.ownerDocument.documentElement;\n      }\n    } else if (boundariesElement === 'window') {\n      boundariesNode = popper.ownerDocument.documentElement;\n    } else {\n      boundariesNode = boundariesElement;\n    }\n\n    var offsets = getOffsetRectRelativeToArbitraryNode(boundariesNode, offsetParent, fixedPosition);\n\n    // In case of HTML, we need a different computation\n    if (boundariesNode.nodeName === 'HTML' && !isFixed(offsetParent)) {\n      var _getWindowSizes = getWindowSizes(),\n          height = _getWindowSizes.height,\n          width = _getWindowSizes.width;\n\n      boundaries.top += offsets.top - offsets.marginTop;\n      boundaries.bottom = height + offsets.top;\n      boundaries.left += offsets.left - offsets.marginLeft;\n      boundaries.right = width + offsets.left;\n    } else {\n      // for all the other DOM elements, this one is good\n      boundaries = offsets;\n    }\n  }\n\n  // Add paddings\n  boundaries.left += padding;\n  boundaries.top += padding;\n  boundaries.right -= padding;\n  boundaries.bottom -= padding;\n\n  return boundaries;\n}\n\nfunction getArea(_ref) {\n  var width = _ref.width,\n      height = _ref.height;\n\n  return width * height;\n}\n\n/**\n * Utility used to transform the `auto` placement to the placement with more\n * available space.\n * @method\n * @memberof Popper.Utils\n * @argument {Object} data - The data object generated by update method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction computeAutoPlacement(placement, refRect, popper, reference, boundariesElement) {\n  var padding = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;\n\n  if (placement.indexOf('auto') === -1) {\n    return placement;\n  }\n\n  var boundaries = getBoundaries(popper, reference, padding, boundariesElement);\n\n  var rects = {\n    top: {\n      width: boundaries.width,\n      height: refRect.top - boundaries.top\n    },\n    right: {\n      width: boundaries.right - refRect.right,\n      height: boundaries.height\n    },\n    bottom: {\n      width: boundaries.width,\n      height: boundaries.bottom - refRect.bottom\n    },\n    left: {\n      width: refRect.left - boundaries.left,\n      height: boundaries.height\n    }\n  };\n\n  var sortedAreas = Object.keys(rects).map(function (key) {\n    return _extends({\n      key: key\n    }, rects[key], {\n      area: getArea(rects[key])\n    });\n  }).sort(function (a, b) {\n    return b.area - a.area;\n  });\n\n  var filteredAreas = sortedAreas.filter(function (_ref2) {\n    var width = _ref2.width,\n        height = _ref2.height;\n    return width >= popper.clientWidth && height >= popper.clientHeight;\n  });\n\n  var computedPlacement = filteredAreas.length > 0 ? filteredAreas[0].key : sortedAreas[0].key;\n\n  var variation = placement.split('-')[1];\n\n  return computedPlacement + (variation ? '-' + variation : '');\n}\n\n/**\n * Get offsets to the reference element\n * @method\n * @memberof Popper.Utils\n * @param {Object} state\n * @param {Element} popper - the popper element\n * @param {Element} reference - the reference element (the popper will be relative to this)\n * @param {Element} fixedPosition - is in fixed position mode\n * @returns {Object} An object containing the offsets which will be applied to the popper\n */\nfunction getReferenceOffsets(state, popper, reference) {\n  var fixedPosition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n\n  var commonOffsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, reference);\n  return getOffsetRectRelativeToArbitraryNode(reference, commonOffsetParent, fixedPosition);\n}\n\n/**\n * Get the outer sizes of the given element (offset size + margins)\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @returns {Object} object containing width and height properties\n */\nfunction getOuterSizes(element) {\n  var styles = getComputedStyle(element);\n  var x = parseFloat(styles.marginTop) + parseFloat(styles.marginBottom);\n  var y = parseFloat(styles.marginLeft) + parseFloat(styles.marginRight);\n  var result = {\n    width: element.offsetWidth + y,\n    height: element.offsetHeight + x\n  };\n  return result;\n}\n\n/**\n * Get the opposite placement of the given one\n * @method\n * @memberof Popper.Utils\n * @argument {String} placement\n * @returns {String} flipped placement\n */\nfunction getOppositePlacement(placement) {\n  var hash = { left: 'right', right: 'left', bottom: 'top', top: 'bottom' };\n  return placement.replace(/left|right|bottom|top/g, function (matched) {\n    return hash[matched];\n  });\n}\n\n/**\n * Get offsets to the popper\n * @method\n * @memberof Popper.Utils\n * @param {Object} position - CSS position the Popper will get applied\n * @param {HTMLElement} popper - the popper element\n * @param {Object} referenceOffsets - the reference offsets (the popper will be relative to this)\n * @param {String} placement - one of the valid placement options\n * @returns {Object} popperOffsets - An object containing the offsets which will be applied to the popper\n */\nfunction getPopperOffsets(popper, referenceOffsets, placement) {\n  placement = placement.split('-')[0];\n\n  // Get popper node sizes\n  var popperRect = getOuterSizes(popper);\n\n  // Add position, width and height to our offsets object\n  var popperOffsets = {\n    width: popperRect.width,\n    height: popperRect.height\n  };\n\n  // depending by the popper placement we have to compute its offsets slightly differently\n  var isHoriz = ['right', 'left'].indexOf(placement) !== -1;\n  var mainSide = isHoriz ? 'top' : 'left';\n  var secondarySide = isHoriz ? 'left' : 'top';\n  var measurement = isHoriz ? 'height' : 'width';\n  var secondaryMeasurement = !isHoriz ? 'height' : 'width';\n\n  popperOffsets[mainSide] = referenceOffsets[mainSide] + referenceOffsets[measurement] / 2 - popperRect[measurement] / 2;\n  if (placement === secondarySide) {\n    popperOffsets[secondarySide] = referenceOffsets[secondarySide] - popperRect[secondaryMeasurement];\n  } else {\n    popperOffsets[secondarySide] = referenceOffsets[getOppositePlacement(secondarySide)];\n  }\n\n  return popperOffsets;\n}\n\n/**\n * Mimics the `find` method of Array\n * @method\n * @memberof Popper.Utils\n * @argument {Array} arr\n * @argument prop\n * @argument value\n * @returns index or -1\n */\nfunction find(arr, check) {\n  // use native find if supported\n  if (Array.prototype.find) {\n    return arr.find(check);\n  }\n\n  // use `filter` to obtain the same behavior of `find`\n  return arr.filter(check)[0];\n}\n\n/**\n * Return the index of the matching object\n * @method\n * @memberof Popper.Utils\n * @argument {Array} arr\n * @argument prop\n * @argument value\n * @returns index or -1\n */\nfunction findIndex(arr, prop, value) {\n  // use native findIndex if supported\n  if (Array.prototype.findIndex) {\n    return arr.findIndex(function (cur) {\n      return cur[prop] === value;\n    });\n  }\n\n  // use `find` + `indexOf` if `findIndex` isn't supported\n  var match = find(arr, function (obj) {\n    return obj[prop] === value;\n  });\n  return arr.indexOf(match);\n}\n\n/**\n * Loop trough the list of modifiers and run them in order,\n * each of them will then edit the data object.\n * @method\n * @memberof Popper.Utils\n * @param {dataObject} data\n * @param {Array} modifiers\n * @param {String} ends - Optional modifier name used as stopper\n * @returns {dataObject}\n */\nfunction runModifiers(modifiers, data, ends) {\n  var modifiersToRun = ends === undefined ? modifiers : modifiers.slice(0, findIndex(modifiers, 'name', ends));\n\n  modifiersToRun.forEach(function (modifier) {\n    if (modifier['function']) {\n      // eslint-disable-line dot-notation\n      console.warn('`modifier.function` is deprecated, use `modifier.fn`!');\n    }\n    var fn = modifier['function'] || modifier.fn; // eslint-disable-line dot-notation\n    if (modifier.enabled && isFunction(fn)) {\n      // Add properties to offsets to make them a complete clientRect object\n      // we do this before each modifier to make sure the previous one doesn't\n      // mess with these values\n      data.offsets.popper = getClientRect(data.offsets.popper);\n      data.offsets.reference = getClientRect(data.offsets.reference);\n\n      data = fn(data, modifier);\n    }\n  });\n\n  return data;\n}\n\n/**\n * Updates the position of the popper, computing the new offsets and applying\n * the new style.<br />\n * Prefer `scheduleUpdate` over `update` because of performance reasons.\n * @method\n * @memberof Popper\n */\nfunction update() {\n  // if popper is destroyed, don't perform any further update\n  if (this.state.isDestroyed) {\n    return;\n  }\n\n  var data = {\n    instance: this,\n    styles: {},\n    arrowStyles: {},\n    attributes: {},\n    flipped: false,\n    offsets: {}\n  };\n\n  // compute reference element offsets\n  data.offsets.reference = getReferenceOffsets(this.state, this.popper, this.reference, this.options.positionFixed);\n\n  // compute auto placement, store placement inside the data object,\n  // modifiers will be able to edit `placement` if needed\n  // and refer to originalPlacement to know the original value\n  data.placement = computeAutoPlacement(this.options.placement, data.offsets.reference, this.popper, this.reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding);\n\n  // store the computed placement inside `originalPlacement`\n  data.originalPlacement = data.placement;\n\n  data.positionFixed = this.options.positionFixed;\n\n  // compute the popper offsets\n  data.offsets.popper = getPopperOffsets(this.popper, data.offsets.reference, data.placement);\n\n  data.offsets.popper.position = this.options.positionFixed ? 'fixed' : 'absolute';\n\n  // run the modifiers\n  data = runModifiers(this.modifiers, data);\n\n  // the first `update` will call `onCreate` callback\n  // the other ones will call `onUpdate` callback\n  if (!this.state.isCreated) {\n    this.state.isCreated = true;\n    this.options.onCreate(data);\n  } else {\n    this.options.onUpdate(data);\n  }\n}\n\n/**\n * Helper used to know if the given modifier is enabled.\n * @method\n * @memberof Popper.Utils\n * @returns {Boolean}\n */\nfunction isModifierEnabled(modifiers, modifierName) {\n  return modifiers.some(function (_ref) {\n    var name = _ref.name,\n        enabled = _ref.enabled;\n    return enabled && name === modifierName;\n  });\n}\n\n/**\n * Get the prefixed supported property name\n * @method\n * @memberof Popper.Utils\n * @argument {String} property (camelCase)\n * @returns {String} prefixed property (camelCase or PascalCase, depending on the vendor prefix)\n */\nfunction getSupportedPropertyName(property) {\n  var prefixes = [false, 'ms', 'Webkit', 'Moz', 'O'];\n  var upperProp = property.charAt(0).toUpperCase() + property.slice(1);\n\n  for (var i = 0; i < prefixes.length; i++) {\n    var prefix = prefixes[i];\n    var toCheck = prefix ? '' + prefix + upperProp : property;\n    if (typeof document.body.style[toCheck] !== 'undefined') {\n      return toCheck;\n    }\n  }\n  return null;\n}\n\n/**\n * Destroy the popper\n * @method\n * @memberof Popper\n */\nfunction destroy() {\n  this.state.isDestroyed = true;\n\n  // touch DOM only if `applyStyle` modifier is enabled\n  if (isModifierEnabled(this.modifiers, 'applyStyle')) {\n    this.popper.removeAttribute('x-placement');\n    this.popper.style.position = '';\n    this.popper.style.top = '';\n    this.popper.style.left = '';\n    this.popper.style.right = '';\n    this.popper.style.bottom = '';\n    this.popper.style.willChange = '';\n    this.popper.style[getSupportedPropertyName('transform')] = '';\n  }\n\n  this.disableEventListeners();\n\n  // remove the popper if user explicity asked for the deletion on destroy\n  // do not use `remove` because IE11 doesn't support it\n  if (this.options.removeOnDestroy) {\n    this.popper.parentNode.removeChild(this.popper);\n  }\n  return this;\n}\n\n/**\n * Get the window associated with the element\n * @argument {Element} element\n * @returns {Window}\n */\nfunction getWindow(element) {\n  var ownerDocument = element.ownerDocument;\n  return ownerDocument ? ownerDocument.defaultView : window;\n}\n\nfunction attachToScrollParents(scrollParent, event, callback, scrollParents) {\n  var isBody = scrollParent.nodeName === 'BODY';\n  var target = isBody ? scrollParent.ownerDocument.defaultView : scrollParent;\n  target.addEventListener(event, callback, { passive: true });\n\n  if (!isBody) {\n    attachToScrollParents(getScrollParent(target.parentNode), event, callback, scrollParents);\n  }\n  scrollParents.push(target);\n}\n\n/**\n * Setup needed event listeners used to update the popper position\n * @method\n * @memberof Popper.Utils\n * @private\n */\nfunction setupEventListeners(reference, options, state, updateBound) {\n  // Resize event listener on window\n  state.updateBound = updateBound;\n  getWindow(reference).addEventListener('resize', state.updateBound, { passive: true });\n\n  // Scroll event listener on scroll parents\n  var scrollElement = getScrollParent(reference);\n  attachToScrollParents(scrollElement, 'scroll', state.updateBound, state.scrollParents);\n  state.scrollElement = scrollElement;\n  state.eventsEnabled = true;\n\n  return state;\n}\n\n/**\n * It will add resize/scroll events and start recalculating\n * position of the popper element when they are triggered.\n * @method\n * @memberof Popper\n */\nfunction enableEventListeners() {\n  if (!this.state.eventsEnabled) {\n    this.state = setupEventListeners(this.reference, this.options, this.state, this.scheduleUpdate);\n  }\n}\n\n/**\n * Remove event listeners used to update the popper position\n * @method\n * @memberof Popper.Utils\n * @private\n */\nfunction removeEventListeners(reference, state) {\n  // Remove resize event listener on window\n  getWindow(reference).removeEventListener('resize', state.updateBound);\n\n  // Remove scroll event listener on scroll parents\n  state.scrollParents.forEach(function (target) {\n    target.removeEventListener('scroll', state.updateBound);\n  });\n\n  // Reset state\n  state.updateBound = null;\n  state.scrollParents = [];\n  state.scrollElement = null;\n  state.eventsEnabled = false;\n  return state;\n}\n\n/**\n * It will remove resize/scroll events and won't recalculate popper position\n * when they are triggered. It also won't trigger onUpdate callback anymore,\n * unless you call `update` method manually.\n * @method\n * @memberof Popper\n */\nfunction disableEventListeners() {\n  if (this.state.eventsEnabled) {\n    cancelAnimationFrame(this.scheduleUpdate);\n    this.state = removeEventListeners(this.reference, this.state);\n  }\n}\n\n/**\n * Tells if a given input is a number\n * @method\n * @memberof Popper.Utils\n * @param {*} input to check\n * @return {Boolean}\n */\nfunction isNumeric(n) {\n  return n !== '' && !isNaN(parseFloat(n)) && isFinite(n);\n}\n\n/**\n * Set the style to the given popper\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element - Element to apply the style to\n * @argument {Object} styles\n * Object with a list of properties and values which will be applied to the element\n */\nfunction setStyles(element, styles) {\n  Object.keys(styles).forEach(function (prop) {\n    var unit = '';\n    // add unit if the value is numeric and is one of the following\n    if (['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop) !== -1 && isNumeric(styles[prop])) {\n      unit = 'px';\n    }\n    element.style[prop] = styles[prop] + unit;\n  });\n}\n\n/**\n * Set the attributes to the given popper\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element - Element to apply the attributes to\n * @argument {Object} styles\n * Object with a list of properties and values which will be applied to the element\n */\nfunction setAttributes(element, attributes) {\n  Object.keys(attributes).forEach(function (prop) {\n    var value = attributes[prop];\n    if (value !== false) {\n      element.setAttribute(prop, attributes[prop]);\n    } else {\n      element.removeAttribute(prop);\n    }\n  });\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by `update` method\n * @argument {Object} data.styles - List of style properties - values to apply to popper element\n * @argument {Object} data.attributes - List of attribute properties - values to apply to popper element\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The same data object\n */\nfunction applyStyle(data) {\n  // any property present in `data.styles` will be applied to the popper,\n  // in this way we can make the 3rd party modifiers add custom styles to it\n  // Be aware, modifiers could override the properties defined in the previous\n  // lines of this modifier!\n  setStyles(data.instance.popper, data.styles);\n\n  // any property present in `data.attributes` will be applied to the popper,\n  // they will be set as HTML attributes of the element\n  setAttributes(data.instance.popper, data.attributes);\n\n  // if arrowElement is defined and arrowStyles has some properties\n  if (data.arrowElement && Object.keys(data.arrowStyles).length) {\n    setStyles(data.arrowElement, data.arrowStyles);\n  }\n\n  return data;\n}\n\n/**\n * Set the x-placement attribute before everything else because it could be used\n * to add margins to the popper margins needs to be calculated to get the\n * correct popper offsets.\n * @method\n * @memberof Popper.modifiers\n * @param {HTMLElement} reference - The reference element used to position the popper\n * @param {HTMLElement} popper - The HTML element used as popper\n * @param {Object} options - Popper.js options\n */\nfunction applyStyleOnLoad(reference, popper, options, modifierOptions, state) {\n  // compute reference element offsets\n  var referenceOffsets = getReferenceOffsets(state, popper, reference, options.positionFixed);\n\n  // compute auto placement, store placement inside the data object,\n  // modifiers will be able to edit `placement` if needed\n  // and refer to originalPlacement to know the original value\n  var placement = computeAutoPlacement(options.placement, referenceOffsets, popper, reference, options.modifiers.flip.boundariesElement, options.modifiers.flip.padding);\n\n  popper.setAttribute('x-placement', placement);\n\n  // Apply `position` to popper before anything else because\n  // without the position applied we can't guarantee correct computations\n  setStyles(popper, { position: options.positionFixed ? 'fixed' : 'absolute' });\n\n  return options;\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by `update` method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction computeStyle(data, options) {\n  var x = options.x,\n      y = options.y;\n  var popper = data.offsets.popper;\n\n  // Remove this legacy support in Popper.js v2\n\n  var legacyGpuAccelerationOption = find(data.instance.modifiers, function (modifier) {\n    return modifier.name === 'applyStyle';\n  }).gpuAcceleration;\n  if (legacyGpuAccelerationOption !== undefined) {\n    console.warn('WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!');\n  }\n  var gpuAcceleration = legacyGpuAccelerationOption !== undefined ? legacyGpuAccelerationOption : options.gpuAcceleration;\n\n  var offsetParent = getOffsetParent(data.instance.popper);\n  var offsetParentRect = getBoundingClientRect(offsetParent);\n\n  // Styles\n  var styles = {\n    position: popper.position\n  };\n\n  // Avoid blurry text by using full pixel integers.\n  // For pixel-perfect positioning, top/bottom prefers rounded\n  // values, while left/right prefers floored values.\n  var offsets = {\n    left: Math.floor(popper.left),\n    top: Math.round(popper.top),\n    bottom: Math.round(popper.bottom),\n    right: Math.floor(popper.right)\n  };\n\n  var sideA = x === 'bottom' ? 'top' : 'bottom';\n  var sideB = y === 'right' ? 'left' : 'right';\n\n  // if gpuAcceleration is set to `true` and transform is supported,\n  //  we use `translate3d` to apply the position to the popper we\n  // automatically use the supported prefixed version if needed\n  var prefixedProperty = getSupportedPropertyName('transform');\n\n  // now, let's make a step back and look at this code closely (wtf?)\n  // If the content of the popper grows once it's been positioned, it\n  // may happen that the popper gets misplaced because of the new content\n  // overflowing its reference element\n  // To avoid this problem, we provide two options (x and y), which allow\n  // the consumer to define the offset origin.\n  // If we position a popper on top of a reference element, we can set\n  // `x` to `top` to make the popper grow towards its top instead of\n  // its bottom.\n  var left = void 0,\n      top = void 0;\n  if (sideA === 'bottom') {\n    top = -offsetParentRect.height + offsets.bottom;\n  } else {\n    top = offsets.top;\n  }\n  if (sideB === 'right') {\n    left = -offsetParentRect.width + offsets.right;\n  } else {\n    left = offsets.left;\n  }\n  if (gpuAcceleration && prefixedProperty) {\n    styles[prefixedProperty] = 'translate3d(' + left + 'px, ' + top + 'px, 0)';\n    styles[sideA] = 0;\n    styles[sideB] = 0;\n    styles.willChange = 'transform';\n  } else {\n    // othwerise, we use the standard `top`, `left`, `bottom` and `right` properties\n    var invertTop = sideA === 'bottom' ? -1 : 1;\n    var invertLeft = sideB === 'right' ? -1 : 1;\n    styles[sideA] = top * invertTop;\n    styles[sideB] = left * invertLeft;\n    styles.willChange = sideA + ', ' + sideB;\n  }\n\n  // Attributes\n  var attributes = {\n    'x-placement': data.placement\n  };\n\n  // Update `data` attributes, styles and arrowStyles\n  data.attributes = _extends({}, attributes, data.attributes);\n  data.styles = _extends({}, styles, data.styles);\n  data.arrowStyles = _extends({}, data.offsets.arrow, data.arrowStyles);\n\n  return data;\n}\n\n/**\n * Helper used to know if the given modifier depends from another one.<br />\n * It checks if the needed modifier is listed and enabled.\n * @method\n * @memberof Popper.Utils\n * @param {Array} modifiers - list of modifiers\n * @param {String} requestingName - name of requesting modifier\n * @param {String} requestedName - name of requested modifier\n * @returns {Boolean}\n */\nfunction isModifierRequired(modifiers, requestingName, requestedName) {\n  var requesting = find(modifiers, function (_ref) {\n    var name = _ref.name;\n    return name === requestingName;\n  });\n\n  var isRequired = !!requesting && modifiers.some(function (modifier) {\n    return modifier.name === requestedName && modifier.enabled && modifier.order < requesting.order;\n  });\n\n  if (!isRequired) {\n    var _requesting = '`' + requestingName + '`';\n    var requested = '`' + requestedName + '`';\n    console.warn(requested + ' modifier is required by ' + _requesting + ' modifier in order to work, be sure to include it before ' + _requesting + '!');\n  }\n  return isRequired;\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by update method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction arrow(data, options) {\n  var _data$offsets$arrow;\n\n  // arrow depends on keepTogether in order to work\n  if (!isModifierRequired(data.instance.modifiers, 'arrow', 'keepTogether')) {\n    return data;\n  }\n\n  var arrowElement = options.element;\n\n  // if arrowElement is a string, suppose it's a CSS selector\n  if (typeof arrowElement === 'string') {\n    arrowElement = data.instance.popper.querySelector(arrowElement);\n\n    // if arrowElement is not found, don't run the modifier\n    if (!arrowElement) {\n      return data;\n    }\n  } else {\n    // if the arrowElement isn't a query selector we must check that the\n    // provided DOM node is child of its popper node\n    if (!data.instance.popper.contains(arrowElement)) {\n      console.warn('WARNING: `arrow.element` must be child of its popper element!');\n      return data;\n    }\n  }\n\n  var placement = data.placement.split('-')[0];\n  var _data$offsets = data.offsets,\n      popper = _data$offsets.popper,\n      reference = _data$offsets.reference;\n\n  var isVertical = ['left', 'right'].indexOf(placement) !== -1;\n\n  var len = isVertical ? 'height' : 'width';\n  var sideCapitalized = isVertical ? 'Top' : 'Left';\n  var side = sideCapitalized.toLowerCase();\n  var altSide = isVertical ? 'left' : 'top';\n  var opSide = isVertical ? 'bottom' : 'right';\n  var arrowElementSize = getOuterSizes(arrowElement)[len];\n\n  //\n  // extends keepTogether behavior making sure the popper and its\n  // reference have enough pixels in conjuction\n  //\n\n  // top/left side\n  if (reference[opSide] - arrowElementSize < popper[side]) {\n    data.offsets.popper[side] -= popper[side] - (reference[opSide] - arrowElementSize);\n  }\n  // bottom/right side\n  if (reference[side] + arrowElementSize > popper[opSide]) {\n    data.offsets.popper[side] += reference[side] + arrowElementSize - popper[opSide];\n  }\n  data.offsets.popper = getClientRect(data.offsets.popper);\n\n  // compute center of the popper\n  var center = reference[side] + reference[len] / 2 - arrowElementSize / 2;\n\n  // Compute the sideValue using the updated popper offsets\n  // take popper margin in account because we don't have this info available\n  var css = getStyleComputedProperty(data.instance.popper);\n  var popperMarginSide = parseFloat(css['margin' + sideCapitalized], 10);\n  var popperBorderSide = parseFloat(css['border' + sideCapitalized + 'Width'], 10);\n  var sideValue = center - data.offsets.popper[side] - popperMarginSide - popperBorderSide;\n\n  // prevent arrowElement from being placed not contiguously to its popper\n  sideValue = Math.max(Math.min(popper[len] - arrowElementSize, sideValue), 0);\n\n  data.arrowElement = arrowElement;\n  data.offsets.arrow = (_data$offsets$arrow = {}, defineProperty(_data$offsets$arrow, side, Math.round(sideValue)), defineProperty(_data$offsets$arrow, altSide, ''), _data$offsets$arrow);\n\n  return data;\n}\n\n/**\n * Get the opposite placement variation of the given one\n * @method\n * @memberof Popper.Utils\n * @argument {String} placement variation\n * @returns {String} flipped placement variation\n */\nfunction getOppositeVariation(variation) {\n  if (variation === 'end') {\n    return 'start';\n  } else if (variation === 'start') {\n    return 'end';\n  }\n  return variation;\n}\n\n/**\n * List of accepted placements to use as values of the `placement` option.<br />\n * Valid placements are:\n * - `auto`\n * - `top`\n * - `right`\n * - `bottom`\n * - `left`\n *\n * Each placement can have a variation from this list:\n * - `-start`\n * - `-end`\n *\n * Variations are interpreted easily if you think of them as the left to right\n * written languages. Horizontally (`top` and `bottom`), `start` is left and `end`\n * is right.<br />\n * Vertically (`left` and `right`), `start` is top and `end` is bottom.\n *\n * Some valid examples are:\n * - `top-end` (on top of reference, right aligned)\n * - `right-start` (on right of reference, top aligned)\n * - `bottom` (on bottom, centered)\n * - `auto-right` (on the side with more space available, alignment depends by placement)\n *\n * @static\n * @type {Array}\n * @enum {String}\n * @readonly\n * @method placements\n * @memberof Popper\n */\nvar placements = ['auto-start', 'auto', 'auto-end', 'top-start', 'top', 'top-end', 'right-start', 'right', 'right-end', 'bottom-end', 'bottom', 'bottom-start', 'left-end', 'left', 'left-start'];\n\n// Get rid of `auto` `auto-start` and `auto-end`\nvar validPlacements = placements.slice(3);\n\n/**\n * Given an initial placement, returns all the subsequent placements\n * clockwise (or counter-clockwise).\n *\n * @method\n * @memberof Popper.Utils\n * @argument {String} placement - A valid placement (it accepts variations)\n * @argument {Boolean} counter - Set to true to walk the placements counterclockwise\n * @returns {Array} placements including their variations\n */\nfunction clockwise(placement) {\n  var counter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n  var index = validPlacements.indexOf(placement);\n  var arr = validPlacements.slice(index + 1).concat(validPlacements.slice(0, index));\n  return counter ? arr.reverse() : arr;\n}\n\nvar BEHAVIORS = {\n  FLIP: 'flip',\n  CLOCKWISE: 'clockwise',\n  COUNTERCLOCKWISE: 'counterclockwise'\n};\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by update method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction flip(data, options) {\n  // if `inner` modifier is enabled, we can't use the `flip` modifier\n  if (isModifierEnabled(data.instance.modifiers, 'inner')) {\n    return data;\n  }\n\n  if (data.flipped && data.placement === data.originalPlacement) {\n    // seems like flip is trying to loop, probably there's not enough space on any of the flippable sides\n    return data;\n  }\n\n  var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, options.boundariesElement, data.positionFixed);\n\n  var placement = data.placement.split('-')[0];\n  var placementOpposite = getOppositePlacement(placement);\n  var variation = data.placement.split('-')[1] || '';\n\n  var flipOrder = [];\n\n  switch (options.behavior) {\n    case BEHAVIORS.FLIP:\n      flipOrder = [placement, placementOpposite];\n      break;\n    case BEHAVIORS.CLOCKWISE:\n      flipOrder = clockwise(placement);\n      break;\n    case BEHAVIORS.COUNTERCLOCKWISE:\n      flipOrder = clockwise(placement, true);\n      break;\n    default:\n      flipOrder = options.behavior;\n  }\n\n  flipOrder.forEach(function (step, index) {\n    if (placement !== step || flipOrder.length === index + 1) {\n      return data;\n    }\n\n    placement = data.placement.split('-')[0];\n    placementOpposite = getOppositePlacement(placement);\n\n    var popperOffsets = data.offsets.popper;\n    var refOffsets = data.offsets.reference;\n\n    // using floor because the reference offsets may contain decimals we are not going to consider here\n    var floor = Math.floor;\n    var overlapsRef = placement === 'left' && floor(popperOffsets.right) > floor(refOffsets.left) || placement === 'right' && floor(popperOffsets.left) < floor(refOffsets.right) || placement === 'top' && floor(popperOffsets.bottom) > floor(refOffsets.top) || placement === 'bottom' && floor(popperOffsets.top) < floor(refOffsets.bottom);\n\n    var overflowsLeft = floor(popperOffsets.left) < floor(boundaries.left);\n    var overflowsRight = floor(popperOffsets.right) > floor(boundaries.right);\n    var overflowsTop = floor(popperOffsets.top) < floor(boundaries.top);\n    var overflowsBottom = floor(popperOffsets.bottom) > floor(boundaries.bottom);\n\n    var overflowsBoundaries = placement === 'left' && overflowsLeft || placement === 'right' && overflowsRight || placement === 'top' && overflowsTop || placement === 'bottom' && overflowsBottom;\n\n    // flip the variation if required\n    var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;\n    var flippedVariation = !!options.flipVariations && (isVertical && variation === 'start' && overflowsLeft || isVertical && variation === 'end' && overflowsRight || !isVertical && variation === 'start' && overflowsTop || !isVertical && variation === 'end' && overflowsBottom);\n\n    if (overlapsRef || overflowsBoundaries || flippedVariation) {\n      // this boolean to detect any flip loop\n      data.flipped = true;\n\n      if (overlapsRef || overflowsBoundaries) {\n        placement = flipOrder[index + 1];\n      }\n\n      if (flippedVariation) {\n        variation = getOppositeVariation(variation);\n      }\n\n      data.placement = placement + (variation ? '-' + variation : '');\n\n      // this object contains `position`, we want to preserve it along with\n      // any additional property we may add in the future\n      data.offsets.popper = _extends({}, data.offsets.popper, getPopperOffsets(data.instance.popper, data.offsets.reference, data.placement));\n\n      data = runModifiers(data.instance.modifiers, data, 'flip');\n    }\n  });\n  return data;\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by update method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction keepTogether(data) {\n  var _data$offsets = data.offsets,\n      popper = _data$offsets.popper,\n      reference = _data$offsets.reference;\n\n  var placement = data.placement.split('-')[0];\n  var floor = Math.floor;\n  var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;\n  var side = isVertical ? 'right' : 'bottom';\n  var opSide = isVertical ? 'left' : 'top';\n  var measurement = isVertical ? 'width' : 'height';\n\n  if (popper[side] < floor(reference[opSide])) {\n    data.offsets.popper[opSide] = floor(reference[opSide]) - popper[measurement];\n  }\n  if (popper[opSide] > floor(reference[side])) {\n    data.offsets.popper[opSide] = floor(reference[side]);\n  }\n\n  return data;\n}\n\n/**\n * Converts a string containing value + unit into a px value number\n * @function\n * @memberof {modifiers~offset}\n * @private\n * @argument {String} str - Value + unit string\n * @argument {String} measurement - `height` or `width`\n * @argument {Object} popperOffsets\n * @argument {Object} referenceOffsets\n * @returns {Number|String}\n * Value in pixels, or original string if no values were extracted\n */\nfunction toValue(str, measurement, popperOffsets, referenceOffsets) {\n  // separate value from unit\n  var split = str.match(/((?:\\-|\\+)?\\d*\\.?\\d*)(.*)/);\n  var value = +split[1];\n  var unit = split[2];\n\n  // If it's not a number it's an operator, I guess\n  if (!value) {\n    return str;\n  }\n\n  if (unit.indexOf('%') === 0) {\n    var element = void 0;\n    switch (unit) {\n      case '%p':\n        element = popperOffsets;\n        break;\n      case '%':\n      case '%r':\n      default:\n        element = referenceOffsets;\n    }\n\n    var rect = getClientRect(element);\n    return rect[measurement] / 100 * value;\n  } else if (unit === 'vh' || unit === 'vw') {\n    // if is a vh or vw, we calculate the size based on the viewport\n    var size = void 0;\n    if (unit === 'vh') {\n      size = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);\n    } else {\n      size = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);\n    }\n    return size / 100 * value;\n  } else {\n    // if is an explicit pixel unit, we get rid of the unit and keep the value\n    // if is an implicit unit, it's px, and we return just the value\n    return value;\n  }\n}\n\n/**\n * Parse an `offset` string to extrapolate `x` and `y` numeric offsets.\n * @function\n * @memberof {modifiers~offset}\n * @private\n * @argument {String} offset\n * @argument {Object} popperOffsets\n * @argument {Object} referenceOffsets\n * @argument {String} basePlacement\n * @returns {Array} a two cells array with x and y offsets in numbers\n */\nfunction parseOffset(offset, popperOffsets, referenceOffsets, basePlacement) {\n  var offsets = [0, 0];\n\n  // Use height if placement is left or right and index is 0 otherwise use width\n  // in this way the first offset will use an axis and the second one\n  // will use the other one\n  var useHeight = ['right', 'left'].indexOf(basePlacement) !== -1;\n\n  // Split the offset string to obtain a list of values and operands\n  // The regex addresses values with the plus or minus sign in front (+10, -20, etc)\n  var fragments = offset.split(/(\\+|\\-)/).map(function (frag) {\n    return frag.trim();\n  });\n\n  // Detect if the offset string contains a pair of values or a single one\n  // they could be separated by comma or space\n  var divider = fragments.indexOf(find(fragments, function (frag) {\n    return frag.search(/,|\\s/) !== -1;\n  }));\n\n  if (fragments[divider] && fragments[divider].indexOf(',') === -1) {\n    console.warn('Offsets separated by white space(s) are deprecated, use a comma (,) instead.');\n  }\n\n  // If divider is found, we divide the list of values and operands to divide\n  // them by ofset X and Y.\n  var splitRegex = /\\s*,\\s*|\\s+/;\n  var ops = divider !== -1 ? [fragments.slice(0, divider).concat([fragments[divider].split(splitRegex)[0]]), [fragments[divider].split(splitRegex)[1]].concat(fragments.slice(divider + 1))] : [fragments];\n\n  // Convert the values with units to absolute pixels to allow our computations\n  ops = ops.map(function (op, index) {\n    // Most of the units rely on the orientation of the popper\n    var measurement = (index === 1 ? !useHeight : useHeight) ? 'height' : 'width';\n    var mergeWithPrevious = false;\n    return op\n    // This aggregates any `+` or `-` sign that aren't considered operators\n    // e.g.: 10 + +5 => [10, +, +5]\n    .reduce(function (a, b) {\n      if (a[a.length - 1] === '' && ['+', '-'].indexOf(b) !== -1) {\n        a[a.length - 1] = b;\n        mergeWithPrevious = true;\n        return a;\n      } else if (mergeWithPrevious) {\n        a[a.length - 1] += b;\n        mergeWithPrevious = false;\n        return a;\n      } else {\n        return a.concat(b);\n      }\n    }, [])\n    // Here we convert the string values into number values (in px)\n    .map(function (str) {\n      return toValue(str, measurement, popperOffsets, referenceOffsets);\n    });\n  });\n\n  // Loop trough the offsets arrays and execute the operations\n  ops.forEach(function (op, index) {\n    op.forEach(function (frag, index2) {\n      if (isNumeric(frag)) {\n        offsets[index] += frag * (op[index2 - 1] === '-' ? -1 : 1);\n      }\n    });\n  });\n  return offsets;\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by update method\n * @argument {Object} options - Modifiers configuration and options\n * @argument {Number|String} options.offset=0\n * The offset value as described in the modifier description\n * @returns {Object} The data object, properly modified\n */\nfunction offset(data, _ref) {\n  var offset = _ref.offset;\n  var placement = data.placement,\n      _data$offsets = data.offsets,\n      popper = _data$offsets.popper,\n      reference = _data$offsets.reference;\n\n  var basePlacement = placement.split('-')[0];\n\n  var offsets = void 0;\n  if (isNumeric(+offset)) {\n    offsets = [+offset, 0];\n  } else {\n    offsets = parseOffset(offset, popper, reference, basePlacement);\n  }\n\n  if (basePlacement === 'left') {\n    popper.top += offsets[0];\n    popper.left -= offsets[1];\n  } else if (basePlacement === 'right') {\n    popper.top += offsets[0];\n    popper.left += offsets[1];\n  } else if (basePlacement === 'top') {\n    popper.left += offsets[0];\n    popper.top -= offsets[1];\n  } else if (basePlacement === 'bottom') {\n    popper.left += offsets[0];\n    popper.top += offsets[1];\n  }\n\n  data.popper = popper;\n  return data;\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by `update` method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction preventOverflow(data, options) {\n  var boundariesElement = options.boundariesElement || getOffsetParent(data.instance.popper);\n\n  // If offsetParent is the reference element, we really want to\n  // go one step up and use the next offsetParent as reference to\n  // avoid to make this modifier completely useless and look like broken\n  if (data.instance.reference === boundariesElement) {\n    boundariesElement = getOffsetParent(boundariesElement);\n  }\n\n  // NOTE: DOM access here\n  // resets the popper's position so that the document size can be calculated excluding\n  // the size of the popper element itself\n  var transformProp = getSupportedPropertyName('transform');\n  var popperStyles = data.instance.popper.style; // assignment to help minification\n  var top = popperStyles.top,\n      left = popperStyles.left,\n      transform = popperStyles[transformProp];\n\n  popperStyles.top = '';\n  popperStyles.left = '';\n  popperStyles[transformProp] = '';\n\n  var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, boundariesElement, data.positionFixed);\n\n  // NOTE: DOM access here\n  // restores the original style properties after the offsets have been computed\n  popperStyles.top = top;\n  popperStyles.left = left;\n  popperStyles[transformProp] = transform;\n\n  options.boundaries = boundaries;\n\n  var order = options.priority;\n  var popper = data.offsets.popper;\n\n  var check = {\n    primary: function primary(placement) {\n      var value = popper[placement];\n      if (popper[placement] < boundaries[placement] && !options.escapeWithReference) {\n        value = Math.max(popper[placement], boundaries[placement]);\n      }\n      return defineProperty({}, placement, value);\n    },\n    secondary: function secondary(placement) {\n      var mainSide = placement === 'right' ? 'left' : 'top';\n      var value = popper[mainSide];\n      if (popper[placement] > boundaries[placement] && !options.escapeWithReference) {\n        value = Math.min(popper[mainSide], boundaries[placement] - (placement === 'right' ? popper.width : popper.height));\n      }\n      return defineProperty({}, mainSide, value);\n    }\n  };\n\n  order.forEach(function (placement) {\n    var side = ['left', 'top'].indexOf(placement) !== -1 ? 'primary' : 'secondary';\n    popper = _extends({}, popper, check[side](placement));\n  });\n\n  data.offsets.popper = popper;\n\n  return data;\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by `update` method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction shift(data) {\n  var placement = data.placement;\n  var basePlacement = placement.split('-')[0];\n  var shiftvariation = placement.split('-')[1];\n\n  // if shift shiftvariation is specified, run the modifier\n  if (shiftvariation) {\n    var _data$offsets = data.offsets,\n        reference = _data$offsets.reference,\n        popper = _data$offsets.popper;\n\n    var isVertical = ['bottom', 'top'].indexOf(basePlacement) !== -1;\n    var side = isVertical ? 'left' : 'top';\n    var measurement = isVertical ? 'width' : 'height';\n\n    var shiftOffsets = {\n      start: defineProperty({}, side, reference[side]),\n      end: defineProperty({}, side, reference[side] + reference[measurement] - popper[measurement])\n    };\n\n    data.offsets.popper = _extends({}, popper, shiftOffsets[shiftvariation]);\n  }\n\n  return data;\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by update method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction hide(data) {\n  if (!isModifierRequired(data.instance.modifiers, 'hide', 'preventOverflow')) {\n    return data;\n  }\n\n  var refRect = data.offsets.reference;\n  var bound = find(data.instance.modifiers, function (modifier) {\n    return modifier.name === 'preventOverflow';\n  }).boundaries;\n\n  if (refRect.bottom < bound.top || refRect.left > bound.right || refRect.top > bound.bottom || refRect.right < bound.left) {\n    // Avoid unnecessary DOM access if visibility hasn't changed\n    if (data.hide === true) {\n      return data;\n    }\n\n    data.hide = true;\n    data.attributes['x-out-of-boundaries'] = '';\n  } else {\n    // Avoid unnecessary DOM access if visibility hasn't changed\n    if (data.hide === false) {\n      return data;\n    }\n\n    data.hide = false;\n    data.attributes['x-out-of-boundaries'] = false;\n  }\n\n  return data;\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by `update` method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction inner(data) {\n  var placement = data.placement;\n  var basePlacement = placement.split('-')[0];\n  var _data$offsets = data.offsets,\n      popper = _data$offsets.popper,\n      reference = _data$offsets.reference;\n\n  var isHoriz = ['left', 'right'].indexOf(basePlacement) !== -1;\n\n  var subtractLength = ['top', 'left'].indexOf(basePlacement) === -1;\n\n  popper[isHoriz ? 'left' : 'top'] = reference[basePlacement] - (subtractLength ? popper[isHoriz ? 'width' : 'height'] : 0);\n\n  data.placement = getOppositePlacement(placement);\n  data.offsets.popper = getClientRect(popper);\n\n  return data;\n}\n\n/**\n * Modifier function, each modifier can have a function of this type assigned\n * to its `fn` property.<br />\n * These functions will be called on each update, this means that you must\n * make sure they are performant enough to avoid performance bottlenecks.\n *\n * @function ModifierFn\n * @argument {dataObject} data - The data object generated by `update` method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {dataObject} The data object, properly modified\n */\n\n/**\n * Modifiers are plugins used to alter the behavior of your poppers.<br />\n * Popper.js uses a set of 9 modifiers to provide all the basic functionalities\n * needed by the library.\n *\n * Usually you don't want to override the `order`, `fn` and `onLoad` props.\n * All the other properties are configurations that could be tweaked.\n * @namespace modifiers\n */\nvar modifiers = {\n  /**\n   * Modifier used to shift the popper on the start or end of its reference\n   * element.<br />\n   * It will read the variation of the `placement` property.<br />\n   * It can be one either `-end` or `-start`.\n   * @memberof modifiers\n   * @inner\n   */\n  shift: {\n    /** @prop {number} order=100 - Index used to define the order of execution */\n    order: 100,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: shift\n  },\n\n  /**\n   * The `offset` modifier can shift your popper on both its axis.\n   *\n   * It accepts the following units:\n   * - `px` or unitless, interpreted as pixels\n   * - `%` or `%r`, percentage relative to the length of the reference element\n   * - `%p`, percentage relative to the length of the popper element\n   * - `vw`, CSS viewport width unit\n   * - `vh`, CSS viewport height unit\n   *\n   * For length is intended the main axis relative to the placement of the popper.<br />\n   * This means that if the placement is `top` or `bottom`, the length will be the\n   * `width`. In case of `left` or `right`, it will be the height.\n   *\n   * You can provide a single value (as `Number` or `String`), or a pair of values\n   * as `String` divided by a comma or one (or more) white spaces.<br />\n   * The latter is a deprecated method because it leads to confusion and will be\n   * removed in v2.<br />\n   * Additionally, it accepts additions and subtractions between different units.\n   * Note that multiplications and divisions aren't supported.\n   *\n   * Valid examples are:\n   * ```\n   * 10\n   * '10%'\n   * '10, 10'\n   * '10%, 10'\n   * '10 + 10%'\n   * '10 - 5vh + 3%'\n   * '-10px + 5vh, 5px - 6%'\n   * ```\n   * > **NB**: If you desire to apply offsets to your poppers in a way that may make them overlap\n   * > with their reference element, unfortunately, you will have to disable the `flip` modifier.\n   * > More on this [reading this issue](https://github.com/FezVrasta/popper.js/issues/373)\n   *\n   * @memberof modifiers\n   * @inner\n   */\n  offset: {\n    /** @prop {number} order=200 - Index used to define the order of execution */\n    order: 200,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: offset,\n    /** @prop {Number|String} offset=0\n     * The offset value as described in the modifier description\n     */\n    offset: 0\n  },\n\n  /**\n   * Modifier used to prevent the popper from being positioned outside the boundary.\n   *\n   * An scenario exists where the reference itself is not within the boundaries.<br />\n   * We can say it has \"escaped the boundaries\" — or just \"escaped\".<br />\n   * In this case we need to decide whether the popper should either:\n   *\n   * - detach from the reference and remain \"trapped\" in the boundaries, or\n   * - if it should ignore the boundary and \"escape with its reference\"\n   *\n   * When `escapeWithReference` is set to`true` and reference is completely\n   * outside its boundaries, the popper will overflow (or completely leave)\n   * the boundaries in order to remain attached to the edge of the reference.\n   *\n   * @memberof modifiers\n   * @inner\n   */\n  preventOverflow: {\n    /** @prop {number} order=300 - Index used to define the order of execution */\n    order: 300,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: preventOverflow,\n    /**\n     * @prop {Array} [priority=['left','right','top','bottom']]\n     * Popper will try to prevent overflow following these priorities by default,\n     * then, it could overflow on the left and on top of the `boundariesElement`\n     */\n    priority: ['left', 'right', 'top', 'bottom'],\n    /**\n     * @prop {number} padding=5\n     * Amount of pixel used to define a minimum distance between the boundaries\n     * and the popper this makes sure the popper has always a little padding\n     * between the edges of its container\n     */\n    padding: 5,\n    /**\n     * @prop {String|HTMLElement} boundariesElement='scrollParent'\n     * Boundaries used by the modifier, can be `scrollParent`, `window`,\n     * `viewport` or any DOM element.\n     */\n    boundariesElement: 'scrollParent'\n  },\n\n  /**\n   * Modifier used to make sure the reference and its popper stay near eachothers\n   * without leaving any gap between the two. Expecially useful when the arrow is\n   * enabled and you want to assure it to point to its reference element.\n   * It cares only about the first axis, you can still have poppers with margin\n   * between the popper and its reference element.\n   * @memberof modifiers\n   * @inner\n   */\n  keepTogether: {\n    /** @prop {number} order=400 - Index used to define the order of execution */\n    order: 400,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: keepTogether\n  },\n\n  /**\n   * This modifier is used to move the `arrowElement` of the popper to make\n   * sure it is positioned between the reference element and its popper element.\n   * It will read the outer size of the `arrowElement` node to detect how many\n   * pixels of conjuction are needed.\n   *\n   * It has no effect if no `arrowElement` is provided.\n   * @memberof modifiers\n   * @inner\n   */\n  arrow: {\n    /** @prop {number} order=500 - Index used to define the order of execution */\n    order: 500,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: arrow,\n    /** @prop {String|HTMLElement} element='[x-arrow]' - Selector or node used as arrow */\n    element: '[x-arrow]'\n  },\n\n  /**\n   * Modifier used to flip the popper's placement when it starts to overlap its\n   * reference element.\n   *\n   * Requires the `preventOverflow` modifier before it in order to work.\n   *\n   * **NOTE:** this modifier will interrupt the current update cycle and will\n   * restart it if it detects the need to flip the placement.\n   * @memberof modifiers\n   * @inner\n   */\n  flip: {\n    /** @prop {number} order=600 - Index used to define the order of execution */\n    order: 600,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: flip,\n    /**\n     * @prop {String|Array} behavior='flip'\n     * The behavior used to change the popper's placement. It can be one of\n     * `flip`, `clockwise`, `counterclockwise` or an array with a list of valid\n     * placements (with optional variations).\n     */\n    behavior: 'flip',\n    /**\n     * @prop {number} padding=5\n     * The popper will flip if it hits the edges of the `boundariesElement`\n     */\n    padding: 5,\n    /**\n     * @prop {String|HTMLElement} boundariesElement='viewport'\n     * The element which will define the boundaries of the popper position,\n     * the popper will never be placed outside of the defined boundaries\n     * (except if keepTogether is enabled)\n     */\n    boundariesElement: 'viewport'\n  },\n\n  /**\n   * Modifier used to make the popper flow toward the inner of the reference element.\n   * By default, when this modifier is disabled, the popper will be placed outside\n   * the reference element.\n   * @memberof modifiers\n   * @inner\n   */\n  inner: {\n    /** @prop {number} order=700 - Index used to define the order of execution */\n    order: 700,\n    /** @prop {Boolean} enabled=false - Whether the modifier is enabled or not */\n    enabled: false,\n    /** @prop {ModifierFn} */\n    fn: inner\n  },\n\n  /**\n   * Modifier used to hide the popper when its reference element is outside of the\n   * popper boundaries. It will set a `x-out-of-boundaries` attribute which can\n   * be used to hide with a CSS selector the popper when its reference is\n   * out of boundaries.\n   *\n   * Requires the `preventOverflow` modifier before it in order to work.\n   * @memberof modifiers\n   * @inner\n   */\n  hide: {\n    /** @prop {number} order=800 - Index used to define the order of execution */\n    order: 800,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: hide\n  },\n\n  /**\n   * Computes the style that will be applied to the popper element to gets\n   * properly positioned.\n   *\n   * Note that this modifier will not touch the DOM, it just prepares the styles\n   * so that `applyStyle` modifier can apply it. This separation is useful\n   * in case you need to replace `applyStyle` with a custom implementation.\n   *\n   * This modifier has `850` as `order` value to maintain backward compatibility\n   * with previous versions of Popper.js. Expect the modifiers ordering method\n   * to change in future major versions of the library.\n   *\n   * @memberof modifiers\n   * @inner\n   */\n  computeStyle: {\n    /** @prop {number} order=850 - Index used to define the order of execution */\n    order: 850,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: computeStyle,\n    /**\n     * @prop {Boolean} gpuAcceleration=true\n     * If true, it uses the CSS 3d transformation to position the popper.\n     * Otherwise, it will use the `top` and `left` properties.\n     */\n    gpuAcceleration: true,\n    /**\n     * @prop {string} [x='bottom']\n     * Where to anchor the X axis (`bottom` or `top`). AKA X offset origin.\n     * Change this if your popper should grow in a direction different from `bottom`\n     */\n    x: 'bottom',\n    /**\n     * @prop {string} [x='left']\n     * Where to anchor the Y axis (`left` or `right`). AKA Y offset origin.\n     * Change this if your popper should grow in a direction different from `right`\n     */\n    y: 'right'\n  },\n\n  /**\n   * Applies the computed styles to the popper element.\n   *\n   * All the DOM manipulations are limited to this modifier. This is useful in case\n   * you want to integrate Popper.js inside a framework or view library and you\n   * want to delegate all the DOM manipulations to it.\n   *\n   * Note that if you disable this modifier, you must make sure the popper element\n   * has its position set to `absolute` before Popper.js can do its work!\n   *\n   * Just disable this modifier and define you own to achieve the desired effect.\n   *\n   * @memberof modifiers\n   * @inner\n   */\n  applyStyle: {\n    /** @prop {number} order=900 - Index used to define the order of execution */\n    order: 900,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: applyStyle,\n    /** @prop {Function} */\n    onLoad: applyStyleOnLoad,\n    /**\n     * @deprecated since version 1.10.0, the property moved to `computeStyle` modifier\n     * @prop {Boolean} gpuAcceleration=true\n     * If true, it uses the CSS 3d transformation to position the popper.\n     * Otherwise, it will use the `top` and `left` properties.\n     */\n    gpuAcceleration: undefined\n  }\n};\n\n/**\n * The `dataObject` is an object containing all the informations used by Popper.js\n * this object get passed to modifiers and to the `onCreate` and `onUpdate` callbacks.\n * @name dataObject\n * @property {Object} data.instance The Popper.js instance\n * @property {String} data.placement Placement applied to popper\n * @property {String} data.originalPlacement Placement originally defined on init\n * @property {Boolean} data.flipped True if popper has been flipped by flip modifier\n * @property {Boolean} data.hide True if the reference element is out of boundaries, useful to know when to hide the popper.\n * @property {HTMLElement} data.arrowElement Node used as arrow by arrow modifier\n * @property {Object} data.styles Any CSS property defined here will be applied to the popper, it expects the JavaScript nomenclature (eg. `marginBottom`)\n * @property {Object} data.arrowStyles Any CSS property defined here will be applied to the popper arrow, it expects the JavaScript nomenclature (eg. `marginBottom`)\n * @property {Object} data.boundaries Offsets of the popper boundaries\n * @property {Object} data.offsets The measurements of popper, reference and arrow elements.\n * @property {Object} data.offsets.popper `top`, `left`, `width`, `height` values\n * @property {Object} data.offsets.reference `top`, `left`, `width`, `height` values\n * @property {Object} data.offsets.arrow] `top` and `left` offsets, only one of them will be different from 0\n */\n\n/**\n * Default options provided to Popper.js constructor.<br />\n * These can be overriden using the `options` argument of Popper.js.<br />\n * To override an option, simply pass as 3rd argument an object with the same\n * structure of this object, example:\n * ```\n * new Popper(ref, pop, {\n *   modifiers: {\n *     preventOverflow: { enabled: false }\n *   }\n * })\n * ```\n * @type {Object}\n * @static\n * @memberof Popper\n */\nvar Defaults = {\n  /**\n   * Popper's placement\n   * @prop {Popper.placements} placement='bottom'\n   */\n  placement: 'bottom',\n\n  /**\n   * Set this to true if you want popper to position it self in 'fixed' mode\n   * @prop {Boolean} positionFixed=false\n   */\n  positionFixed: false,\n\n  /**\n   * Whether events (resize, scroll) are initially enabled\n   * @prop {Boolean} eventsEnabled=true\n   */\n  eventsEnabled: true,\n\n  /**\n   * Set to true if you want to automatically remove the popper when\n   * you call the `destroy` method.\n   * @prop {Boolean} removeOnDestroy=false\n   */\n  removeOnDestroy: false,\n\n  /**\n   * Callback called when the popper is created.<br />\n   * By default, is set to no-op.<br />\n   * Access Popper.js instance with `data.instance`.\n   * @prop {onCreate}\n   */\n  onCreate: function onCreate() {},\n\n  /**\n   * Callback called when the popper is updated, this callback is not called\n   * on the initialization/creation of the popper, but only on subsequent\n   * updates.<br />\n   * By default, is set to no-op.<br />\n   * Access Popper.js instance with `data.instance`.\n   * @prop {onUpdate}\n   */\n  onUpdate: function onUpdate() {},\n\n  /**\n   * List of modifiers used to modify the offsets before they are applied to the popper.\n   * They provide most of the functionalities of Popper.js\n   * @prop {modifiers}\n   */\n  modifiers: modifiers\n};\n\n/**\n * @callback onCreate\n * @param {dataObject} data\n */\n\n/**\n * @callback onUpdate\n * @param {dataObject} data\n */\n\n// Utils\n// Methods\nvar Popper = function () {\n  /**\n   * Create a new Popper.js instance\n   * @class Popper\n   * @param {HTMLElement|referenceObject} reference - The reference element used to position the popper\n   * @param {HTMLElement} popper - The HTML element used as popper.\n   * @param {Object} options - Your custom options to override the ones defined in [Defaults](#defaults)\n   * @return {Object} instance - The generated Popper.js instance\n   */\n  function Popper(reference, popper) {\n    var _this = this;\n\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    classCallCheck(this, Popper);\n\n    this.scheduleUpdate = function () {\n      return requestAnimationFrame(_this.update);\n    };\n\n    // make update() debounced, so that it only runs at most once-per-tick\n    this.update = debounce(this.update.bind(this));\n\n    // with {} we create a new object with the options inside it\n    this.options = _extends({}, Popper.Defaults, options);\n\n    // init state\n    this.state = {\n      isDestroyed: false,\n      isCreated: false,\n      scrollParents: []\n    };\n\n    // get reference and popper elements (allow jQuery wrappers)\n    this.reference = reference && reference.jquery ? reference[0] : reference;\n    this.popper = popper && popper.jquery ? popper[0] : popper;\n\n    // Deep merge modifiers options\n    this.options.modifiers = {};\n    Object.keys(_extends({}, Popper.Defaults.modifiers, options.modifiers)).forEach(function (name) {\n      _this.options.modifiers[name] = _extends({}, Popper.Defaults.modifiers[name] || {}, options.modifiers ? options.modifiers[name] : {});\n    });\n\n    // Refactoring modifiers' list (Object => Array)\n    this.modifiers = Object.keys(this.options.modifiers).map(function (name) {\n      return _extends({\n        name: name\n      }, _this.options.modifiers[name]);\n    })\n    // sort the modifiers by order\n    .sort(function (a, b) {\n      return a.order - b.order;\n    });\n\n    // modifiers have the ability to execute arbitrary code when Popper.js get inited\n    // such code is executed in the same order of its modifier\n    // they could add new properties to their options configuration\n    // BE AWARE: don't add options to `options.modifiers.name` but to `modifierOptions`!\n    this.modifiers.forEach(function (modifierOptions) {\n      if (modifierOptions.enabled && isFunction(modifierOptions.onLoad)) {\n        modifierOptions.onLoad(_this.reference, _this.popper, _this.options, modifierOptions, _this.state);\n      }\n    });\n\n    // fire the first update to position the popper in the right place\n    this.update();\n\n    var eventsEnabled = this.options.eventsEnabled;\n    if (eventsEnabled) {\n      // setup event listeners, they will take care of update the position in specific situations\n      this.enableEventListeners();\n    }\n\n    this.state.eventsEnabled = eventsEnabled;\n  }\n\n  // We can't use class properties because they don't get listed in the\n  // class prototype and break stuff like Sinon stubs\n\n\n  createClass(Popper, [{\n    key: 'update',\n    value: function update$$1() {\n      return update.call(this);\n    }\n  }, {\n    key: 'destroy',\n    value: function destroy$$1() {\n      return destroy.call(this);\n    }\n  }, {\n    key: 'enableEventListeners',\n    value: function enableEventListeners$$1() {\n      return enableEventListeners.call(this);\n    }\n  }, {\n    key: 'disableEventListeners',\n    value: function disableEventListeners$$1() {\n      return disableEventListeners.call(this);\n    }\n\n    /**\n     * Schedule an update, it will run on the next UI update available\n     * @method scheduleUpdate\n     * @memberof Popper\n     */\n\n\n    /**\n     * Collection of utilities useful when writing custom modifiers.\n     * Starting from version 1.7, this method is available only if you\n     * include `popper-utils.js` before `popper.js`.\n     *\n     * **DEPRECATION**: This way to access PopperUtils is deprecated\n     * and will be removed in v2! Use the PopperUtils module directly instead.\n     * Due to the high instability of the methods contained in Utils, we can't\n     * guarantee them to follow semver. Use them at your own risk!\n     * @static\n     * @private\n     * @type {Object}\n     * @deprecated since version 1.8\n     * @member Utils\n     * @memberof Popper\n     */\n\n  }]);\n  return Popper;\n}();\n\n/**\n * The `referenceObject` is an object that provides an interface compatible with Popper.js\n * and lets you use it as replacement of a real DOM node.<br />\n * You can use this method to position a popper relatively to a set of coordinates\n * in case you don't have a DOM node to use as reference.\n *\n * ```\n * new Popper(referenceObject, popperNode);\n * ```\n *\n * NB: This feature isn't supported in Internet Explorer 10\n * @name referenceObject\n * @property {Function} data.getBoundingClientRect\n * A function that returns a set of coordinates compatible with the native `getBoundingClientRect` method.\n * @property {number} data.clientWidth\n * An ES6 getter that will return the width of the virtual reference element.\n * @property {number} data.clientHeight\n * An ES6 getter that will return the height of the virtual reference element.\n */\n\n\nPopper.Utils = (typeof window !== 'undefined' ? window : global).PopperUtils;\nPopper.placements = placements;\nPopper.Defaults = Defaults;\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Popper);\n//# sourceMappingURL=popper.js.map\n\n/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(4)))\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports) {\n\nvar g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar __WEBPACK_AMD_DEFINE_RESULT__;/*! Hammer.JS - v2.0.7 - 2016-04-22\n * http://hammerjs.github.io/\n *\n * Copyright (c) 2016 Jorik Tangelder;\n * Licensed under the MIT license */\n(function(window, document, exportName, undefined) {\n  'use strict';\n\nvar VENDOR_PREFIXES = ['', 'webkit', 'Moz', 'MS', 'ms', 'o'];\nvar TEST_ELEMENT = document.createElement('div');\n\nvar TYPE_FUNCTION = 'function';\n\nvar round = Math.round;\nvar abs = Math.abs;\nvar now = Date.now;\n\n/**\n * set a timeout with a given scope\n * @param {Function} fn\n * @param {Number} timeout\n * @param {Object} context\n * @returns {number}\n */\nfunction setTimeoutContext(fn, timeout, context) {\n    return setTimeout(bindFn(fn, context), timeout);\n}\n\n/**\n * if the argument is an array, we want to execute the fn on each entry\n * if it aint an array we don't want to do a thing.\n * this is used by all the methods that accept a single and array argument.\n * @param {*|Array} arg\n * @param {String} fn\n * @param {Object} [context]\n * @returns {Boolean}\n */\nfunction invokeArrayArg(arg, fn, context) {\n    if (Array.isArray(arg)) {\n        each(arg, context[fn], context);\n        return true;\n    }\n    return false;\n}\n\n/**\n * walk objects and arrays\n * @param {Object} obj\n * @param {Function} iterator\n * @param {Object} context\n */\nfunction each(obj, iterator, context) {\n    var i;\n\n    if (!obj) {\n        return;\n    }\n\n    if (obj.forEach) {\n        obj.forEach(iterator, context);\n    } else if (obj.length !== undefined) {\n        i = 0;\n        while (i < obj.length) {\n            iterator.call(context, obj[i], i, obj);\n            i++;\n        }\n    } else {\n        for (i in obj) {\n            obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);\n        }\n    }\n}\n\n/**\n * wrap a method with a deprecation warning and stack trace\n * @param {Function} method\n * @param {String} name\n * @param {String} message\n * @returns {Function} A new function wrapping the supplied method.\n */\nfunction deprecate(method, name, message) {\n    var deprecationMessage = 'DEPRECATED METHOD: ' + name + '\\n' + message + ' AT \\n';\n    return function() {\n        var e = new Error('get-stack-trace');\n        var stack = e && e.stack ? e.stack.replace(/^[^\\(]+?[\\n$]/gm, '')\n            .replace(/^\\s+at\\s+/gm, '')\n            .replace(/^Object.<anonymous>\\s*\\(/gm, '{anonymous}()@') : 'Unknown Stack Trace';\n\n        var log = window.console && (window.console.warn || window.console.log);\n        if (log) {\n            log.call(window.console, deprecationMessage, stack);\n        }\n        return method.apply(this, arguments);\n    };\n}\n\n/**\n * extend object.\n * means that properties in dest will be overwritten by the ones in src.\n * @param {Object} target\n * @param {...Object} objects_to_assign\n * @returns {Object} target\n */\nvar assign;\nif (typeof Object.assign !== 'function') {\n    assign = function assign(target) {\n        if (target === undefined || target === null) {\n            throw new TypeError('Cannot convert undefined or null to object');\n        }\n\n        var output = Object(target);\n        for (var index = 1; index < arguments.length; index++) {\n            var source = arguments[index];\n            if (source !== undefined && source !== null) {\n                for (var nextKey in source) {\n                    if (source.hasOwnProperty(nextKey)) {\n                        output[nextKey] = source[nextKey];\n                    }\n                }\n            }\n        }\n        return output;\n    };\n} else {\n    assign = Object.assign;\n}\n\n/**\n * extend object.\n * means that properties in dest will be overwritten by the ones in src.\n * @param {Object} dest\n * @param {Object} src\n * @param {Boolean} [merge=false]\n * @returns {Object} dest\n */\nvar extend = deprecate(function extend(dest, src, merge) {\n    var keys = Object.keys(src);\n    var i = 0;\n    while (i < keys.length) {\n        if (!merge || (merge && dest[keys[i]] === undefined)) {\n            dest[keys[i]] = src[keys[i]];\n        }\n        i++;\n    }\n    return dest;\n}, 'extend', 'Use `assign`.');\n\n/**\n * merge the values from src in the dest.\n * means that properties that exist in dest will not be overwritten by src\n * @param {Object} dest\n * @param {Object} src\n * @returns {Object} dest\n */\nvar merge = deprecate(function merge(dest, src) {\n    return extend(dest, src, true);\n}, 'merge', 'Use `assign`.');\n\n/**\n * simple class inheritance\n * @param {Function} child\n * @param {Function} base\n * @param {Object} [properties]\n */\nfunction inherit(child, base, properties) {\n    var baseP = base.prototype,\n        childP;\n\n    childP = child.prototype = Object.create(baseP);\n    childP.constructor = child;\n    childP._super = baseP;\n\n    if (properties) {\n        assign(childP, properties);\n    }\n}\n\n/**\n * simple function bind\n * @param {Function} fn\n * @param {Object} context\n * @returns {Function}\n */\nfunction bindFn(fn, context) {\n    return function boundFn() {\n        return fn.apply(context, arguments);\n    };\n}\n\n/**\n * let a boolean value also be a function that must return a boolean\n * this first item in args will be used as the context\n * @param {Boolean|Function} val\n * @param {Array} [args]\n * @returns {Boolean}\n */\nfunction boolOrFn(val, args) {\n    if (typeof val == TYPE_FUNCTION) {\n        return val.apply(args ? args[0] || undefined : undefined, args);\n    }\n    return val;\n}\n\n/**\n * use the val2 when val1 is undefined\n * @param {*} val1\n * @param {*} val2\n * @returns {*}\n */\nfunction ifUndefined(val1, val2) {\n    return (val1 === undefined) ? val2 : val1;\n}\n\n/**\n * addEventListener with multiple events at once\n * @param {EventTarget} target\n * @param {String} types\n * @param {Function} handler\n */\nfunction addEventListeners(target, types, handler) {\n    each(splitStr(types), function(type) {\n        target.addEventListener(type, handler, false);\n    });\n}\n\n/**\n * removeEventListener with multiple events at once\n * @param {EventTarget} target\n * @param {String} types\n * @param {Function} handler\n */\nfunction removeEventListeners(target, types, handler) {\n    each(splitStr(types), function(type) {\n        target.removeEventListener(type, handler, false);\n    });\n}\n\n/**\n * find if a node is in the given parent\n * @method hasParent\n * @param {HTMLElement} node\n * @param {HTMLElement} parent\n * @return {Boolean} found\n */\nfunction hasParent(node, parent) {\n    while (node) {\n        if (node == parent) {\n            return true;\n        }\n        node = node.parentNode;\n    }\n    return false;\n}\n\n/**\n * small indexOf wrapper\n * @param {String} str\n * @param {String} find\n * @returns {Boolean} found\n */\nfunction inStr(str, find) {\n    return str.indexOf(find) > -1;\n}\n\n/**\n * split string on whitespace\n * @param {String} str\n * @returns {Array} words\n */\nfunction splitStr(str) {\n    return str.trim().split(/\\s+/g);\n}\n\n/**\n * find if a array contains the object using indexOf or a simple polyFill\n * @param {Array} src\n * @param {String} find\n * @param {String} [findByKey]\n * @return {Boolean|Number} false when not found, or the index\n */\nfunction inArray(src, find, findByKey) {\n    if (src.indexOf && !findByKey) {\n        return src.indexOf(find);\n    } else {\n        var i = 0;\n        while (i < src.length) {\n            if ((findByKey && src[i][findByKey] == find) || (!findByKey && src[i] === find)) {\n                return i;\n            }\n            i++;\n        }\n        return -1;\n    }\n}\n\n/**\n * convert array-like objects to real arrays\n * @param {Object} obj\n * @returns {Array}\n */\nfunction toArray(obj) {\n    return Array.prototype.slice.call(obj, 0);\n}\n\n/**\n * unique array with objects based on a key (like 'id') or just by the array's value\n * @param {Array} src [{id:1},{id:2},{id:1}]\n * @param {String} [key]\n * @param {Boolean} [sort=False]\n * @returns {Array} [{id:1},{id:2}]\n */\nfunction uniqueArray(src, key, sort) {\n    var results = [];\n    var values = [];\n    var i = 0;\n\n    while (i < src.length) {\n        var val = key ? src[i][key] : src[i];\n        if (inArray(values, val) < 0) {\n            results.push(src[i]);\n        }\n        values[i] = val;\n        i++;\n    }\n\n    if (sort) {\n        if (!key) {\n            results = results.sort();\n        } else {\n            results = results.sort(function sortUniqueArray(a, b) {\n                return a[key] > b[key];\n            });\n        }\n    }\n\n    return results;\n}\n\n/**\n * get the prefixed property\n * @param {Object} obj\n * @param {String} property\n * @returns {String|Undefined} prefixed\n */\nfunction prefixed(obj, property) {\n    var prefix, prop;\n    var camelProp = property[0].toUpperCase() + property.slice(1);\n\n    var i = 0;\n    while (i < VENDOR_PREFIXES.length) {\n        prefix = VENDOR_PREFIXES[i];\n        prop = (prefix) ? prefix + camelProp : property;\n\n        if (prop in obj) {\n            return prop;\n        }\n        i++;\n    }\n    return undefined;\n}\n\n/**\n * get a unique id\n * @returns {number} uniqueId\n */\nvar _uniqueId = 1;\nfunction uniqueId() {\n    return _uniqueId++;\n}\n\n/**\n * get the window object of an element\n * @param {HTMLElement} element\n * @returns {DocumentView|Window}\n */\nfunction getWindowForElement(element) {\n    var doc = element.ownerDocument || element;\n    return (doc.defaultView || doc.parentWindow || window);\n}\n\nvar MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;\n\nvar SUPPORT_TOUCH = ('ontouchstart' in window);\nvar SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;\nvar SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);\n\nvar INPUT_TYPE_TOUCH = 'touch';\nvar INPUT_TYPE_PEN = 'pen';\nvar INPUT_TYPE_MOUSE = 'mouse';\nvar INPUT_TYPE_KINECT = 'kinect';\n\nvar COMPUTE_INTERVAL = 25;\n\nvar INPUT_START = 1;\nvar INPUT_MOVE = 2;\nvar INPUT_END = 4;\nvar INPUT_CANCEL = 8;\n\nvar DIRECTION_NONE = 1;\nvar DIRECTION_LEFT = 2;\nvar DIRECTION_RIGHT = 4;\nvar DIRECTION_UP = 8;\nvar DIRECTION_DOWN = 16;\n\nvar DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;\nvar DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;\nvar DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;\n\nvar PROPS_XY = ['x', 'y'];\nvar PROPS_CLIENT_XY = ['clientX', 'clientY'];\n\n/**\n * create new input type manager\n * @param {Manager} manager\n * @param {Function} callback\n * @returns {Input}\n * @constructor\n */\nfunction Input(manager, callback) {\n    var self = this;\n    this.manager = manager;\n    this.callback = callback;\n    this.element = manager.element;\n    this.target = manager.options.inputTarget;\n\n    // smaller wrapper around the handler, for the scope and the enabled state of the manager,\n    // so when disabled the input events are completely bypassed.\n    this.domHandler = function(ev) {\n        if (boolOrFn(manager.options.enable, [manager])) {\n            self.handler(ev);\n        }\n    };\n\n    this.init();\n\n}\n\nInput.prototype = {\n    /**\n     * should handle the inputEvent data and trigger the callback\n     * @virtual\n     */\n    handler: function() { },\n\n    /**\n     * bind the events\n     */\n    init: function() {\n        this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);\n        this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);\n        this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);\n    },\n\n    /**\n     * unbind the events\n     */\n    destroy: function() {\n        this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);\n        this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);\n        this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);\n    }\n};\n\n/**\n * create new input type manager\n * called by the Manager constructor\n * @param {Hammer} manager\n * @returns {Input}\n */\nfunction createInputInstance(manager) {\n    var Type;\n    var inputClass = manager.options.inputClass;\n\n    if (inputClass) {\n        Type = inputClass;\n    } else if (SUPPORT_POINTER_EVENTS) {\n        Type = PointerEventInput;\n    } else if (SUPPORT_ONLY_TOUCH) {\n        Type = TouchInput;\n    } else if (!SUPPORT_TOUCH) {\n        Type = MouseInput;\n    } else {\n        Type = TouchMouseInput;\n    }\n    return new (Type)(manager, inputHandler);\n}\n\n/**\n * handle input events\n * @param {Manager} manager\n * @param {String} eventType\n * @param {Object} input\n */\nfunction inputHandler(manager, eventType, input) {\n    var pointersLen = input.pointers.length;\n    var changedPointersLen = input.changedPointers.length;\n    var isFirst = (eventType & INPUT_START && (pointersLen - changedPointersLen === 0));\n    var isFinal = (eventType & (INPUT_END | INPUT_CANCEL) && (pointersLen - changedPointersLen === 0));\n\n    input.isFirst = !!isFirst;\n    input.isFinal = !!isFinal;\n\n    if (isFirst) {\n        manager.session = {};\n    }\n\n    // source event is the normalized value of the domEvents\n    // like 'touchstart, mouseup, pointerdown'\n    input.eventType = eventType;\n\n    // compute scale, rotation etc\n    computeInputData(manager, input);\n\n    // emit secret event\n    manager.emit('hammer.input', input);\n\n    manager.recognize(input);\n    manager.session.prevInput = input;\n}\n\n/**\n * extend the data with some usable properties like scale, rotate, velocity etc\n * @param {Object} manager\n * @param {Object} input\n */\nfunction computeInputData(manager, input) {\n    var session = manager.session;\n    var pointers = input.pointers;\n    var pointersLength = pointers.length;\n\n    // store the first input to calculate the distance and direction\n    if (!session.firstInput) {\n        session.firstInput = simpleCloneInputData(input);\n    }\n\n    // to compute scale and rotation we need to store the multiple touches\n    if (pointersLength > 1 && !session.firstMultiple) {\n        session.firstMultiple = simpleCloneInputData(input);\n    } else if (pointersLength === 1) {\n        session.firstMultiple = false;\n    }\n\n    var firstInput = session.firstInput;\n    var firstMultiple = session.firstMultiple;\n    var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;\n\n    var center = input.center = getCenter(pointers);\n    input.timeStamp = now();\n    input.deltaTime = input.timeStamp - firstInput.timeStamp;\n\n    input.angle = getAngle(offsetCenter, center);\n    input.distance = getDistance(offsetCenter, center);\n\n    computeDeltaXY(session, input);\n    input.offsetDirection = getDirection(input.deltaX, input.deltaY);\n\n    var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);\n    input.overallVelocityX = overallVelocity.x;\n    input.overallVelocityY = overallVelocity.y;\n    input.overallVelocity = (abs(overallVelocity.x) > abs(overallVelocity.y)) ? overallVelocity.x : overallVelocity.y;\n\n    input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;\n    input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;\n\n    input.maxPointers = !session.prevInput ? input.pointers.length : ((input.pointers.length >\n        session.prevInput.maxPointers) ? input.pointers.length : session.prevInput.maxPointers);\n\n    computeIntervalInputData(session, input);\n\n    // find the correct target\n    var target = manager.element;\n    if (hasParent(input.srcEvent.target, target)) {\n        target = input.srcEvent.target;\n    }\n    input.target = target;\n}\n\nfunction computeDeltaXY(session, input) {\n    var center = input.center;\n    var offset = session.offsetDelta || {};\n    var prevDelta = session.prevDelta || {};\n    var prevInput = session.prevInput || {};\n\n    if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {\n        prevDelta = session.prevDelta = {\n            x: prevInput.deltaX || 0,\n            y: prevInput.deltaY || 0\n        };\n\n        offset = session.offsetDelta = {\n            x: center.x,\n            y: center.y\n        };\n    }\n\n    input.deltaX = prevDelta.x + (center.x - offset.x);\n    input.deltaY = prevDelta.y + (center.y - offset.y);\n}\n\n/**\n * velocity is calculated every x ms\n * @param {Object} session\n * @param {Object} input\n */\nfunction computeIntervalInputData(session, input) {\n    var last = session.lastInterval || input,\n        deltaTime = input.timeStamp - last.timeStamp,\n        velocity, velocityX, velocityY, direction;\n\n    if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {\n        var deltaX = input.deltaX - last.deltaX;\n        var deltaY = input.deltaY - last.deltaY;\n\n        var v = getVelocity(deltaTime, deltaX, deltaY);\n        velocityX = v.x;\n        velocityY = v.y;\n        velocity = (abs(v.x) > abs(v.y)) ? v.x : v.y;\n        direction = getDirection(deltaX, deltaY);\n\n        session.lastInterval = input;\n    } else {\n        // use latest velocity info if it doesn't overtake a minimum period\n        velocity = last.velocity;\n        velocityX = last.velocityX;\n        velocityY = last.velocityY;\n        direction = last.direction;\n    }\n\n    input.velocity = velocity;\n    input.velocityX = velocityX;\n    input.velocityY = velocityY;\n    input.direction = direction;\n}\n\n/**\n * create a simple clone from the input used for storage of firstInput and firstMultiple\n * @param {Object} input\n * @returns {Object} clonedInputData\n */\nfunction simpleCloneInputData(input) {\n    // make a simple copy of the pointers because we will get a reference if we don't\n    // we only need clientXY for the calculations\n    var pointers = [];\n    var i = 0;\n    while (i < input.pointers.length) {\n        pointers[i] = {\n            clientX: round(input.pointers[i].clientX),\n            clientY: round(input.pointers[i].clientY)\n        };\n        i++;\n    }\n\n    return {\n        timeStamp: now(),\n        pointers: pointers,\n        center: getCenter(pointers),\n        deltaX: input.deltaX,\n        deltaY: input.deltaY\n    };\n}\n\n/**\n * get the center of all the pointers\n * @param {Array} pointers\n * @return {Object} center contains `x` and `y` properties\n */\nfunction getCenter(pointers) {\n    var pointersLength = pointers.length;\n\n    // no need to loop when only one touch\n    if (pointersLength === 1) {\n        return {\n            x: round(pointers[0].clientX),\n            y: round(pointers[0].clientY)\n        };\n    }\n\n    var x = 0, y = 0, i = 0;\n    while (i < pointersLength) {\n        x += pointers[i].clientX;\n        y += pointers[i].clientY;\n        i++;\n    }\n\n    return {\n        x: round(x / pointersLength),\n        y: round(y / pointersLength)\n    };\n}\n\n/**\n * calculate the velocity between two points. unit is in px per ms.\n * @param {Number} deltaTime\n * @param {Number} x\n * @param {Number} y\n * @return {Object} velocity `x` and `y`\n */\nfunction getVelocity(deltaTime, x, y) {\n    return {\n        x: x / deltaTime || 0,\n        y: y / deltaTime || 0\n    };\n}\n\n/**\n * get the direction between two points\n * @param {Number} x\n * @param {Number} y\n * @return {Number} direction\n */\nfunction getDirection(x, y) {\n    if (x === y) {\n        return DIRECTION_NONE;\n    }\n\n    if (abs(x) >= abs(y)) {\n        return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;\n    }\n    return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;\n}\n\n/**\n * calculate the absolute distance between two points\n * @param {Object} p1 {x, y}\n * @param {Object} p2 {x, y}\n * @param {Array} [props] containing x and y keys\n * @return {Number} distance\n */\nfunction getDistance(p1, p2, props) {\n    if (!props) {\n        props = PROPS_XY;\n    }\n    var x = p2[props[0]] - p1[props[0]],\n        y = p2[props[1]] - p1[props[1]];\n\n    return Math.sqrt((x * x) + (y * y));\n}\n\n/**\n * calculate the angle between two coordinates\n * @param {Object} p1\n * @param {Object} p2\n * @param {Array} [props] containing x and y keys\n * @return {Number} angle\n */\nfunction getAngle(p1, p2, props) {\n    if (!props) {\n        props = PROPS_XY;\n    }\n    var x = p2[props[0]] - p1[props[0]],\n        y = p2[props[1]] - p1[props[1]];\n    return Math.atan2(y, x) * 180 / Math.PI;\n}\n\n/**\n * calculate the rotation degrees between two pointersets\n * @param {Array} start array of pointers\n * @param {Array} end array of pointers\n * @return {Number} rotation\n */\nfunction getRotation(start, end) {\n    return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);\n}\n\n/**\n * calculate the scale factor between two pointersets\n * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out\n * @param {Array} start array of pointers\n * @param {Array} end array of pointers\n * @return {Number} scale\n */\nfunction getScale(start, end) {\n    return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);\n}\n\nvar MOUSE_INPUT_MAP = {\n    mousedown: INPUT_START,\n    mousemove: INPUT_MOVE,\n    mouseup: INPUT_END\n};\n\nvar MOUSE_ELEMENT_EVENTS = 'mousedown';\nvar MOUSE_WINDOW_EVENTS = 'mousemove mouseup';\n\n/**\n * Mouse events input\n * @constructor\n * @extends Input\n */\nfunction MouseInput() {\n    this.evEl = MOUSE_ELEMENT_EVENTS;\n    this.evWin = MOUSE_WINDOW_EVENTS;\n\n    this.pressed = false; // mousedown state\n\n    Input.apply(this, arguments);\n}\n\ninherit(MouseInput, Input, {\n    /**\n     * handle mouse events\n     * @param {Object} ev\n     */\n    handler: function MEhandler(ev) {\n        var eventType = MOUSE_INPUT_MAP[ev.type];\n\n        // on start we want to have the left mouse button down\n        if (eventType & INPUT_START && ev.button === 0) {\n            this.pressed = true;\n        }\n\n        if (eventType & INPUT_MOVE && ev.which !== 1) {\n            eventType = INPUT_END;\n        }\n\n        // mouse must be down\n        if (!this.pressed) {\n            return;\n        }\n\n        if (eventType & INPUT_END) {\n            this.pressed = false;\n        }\n\n        this.callback(this.manager, eventType, {\n            pointers: [ev],\n            changedPointers: [ev],\n            pointerType: INPUT_TYPE_MOUSE,\n            srcEvent: ev\n        });\n    }\n});\n\nvar POINTER_INPUT_MAP = {\n    pointerdown: INPUT_START,\n    pointermove: INPUT_MOVE,\n    pointerup: INPUT_END,\n    pointercancel: INPUT_CANCEL,\n    pointerout: INPUT_CANCEL\n};\n\n// in IE10 the pointer types is defined as an enum\nvar IE10_POINTER_TYPE_ENUM = {\n    2: INPUT_TYPE_TOUCH,\n    3: INPUT_TYPE_PEN,\n    4: INPUT_TYPE_MOUSE,\n    5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816\n};\n\nvar POINTER_ELEMENT_EVENTS = 'pointerdown';\nvar POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel';\n\n// IE10 has prefixed support, and case-sensitive\nif (window.MSPointerEvent && !window.PointerEvent) {\n    POINTER_ELEMENT_EVENTS = 'MSPointerDown';\n    POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';\n}\n\n/**\n * Pointer events input\n * @constructor\n * @extends Input\n */\nfunction PointerEventInput() {\n    this.evEl = POINTER_ELEMENT_EVENTS;\n    this.evWin = POINTER_WINDOW_EVENTS;\n\n    Input.apply(this, arguments);\n\n    this.store = (this.manager.session.pointerEvents = []);\n}\n\ninherit(PointerEventInput, Input, {\n    /**\n     * handle mouse events\n     * @param {Object} ev\n     */\n    handler: function PEhandler(ev) {\n        var store = this.store;\n        var removePointer = false;\n\n        var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');\n        var eventType = POINTER_INPUT_MAP[eventTypeNormalized];\n        var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;\n\n        var isTouch = (pointerType == INPUT_TYPE_TOUCH);\n\n        // get index of the event in the store\n        var storeIndex = inArray(store, ev.pointerId, 'pointerId');\n\n        // start and mouse must be down\n        if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {\n            if (storeIndex < 0) {\n                store.push(ev);\n                storeIndex = store.length - 1;\n            }\n        } else if (eventType & (INPUT_END | INPUT_CANCEL)) {\n            removePointer = true;\n        }\n\n        // it not found, so the pointer hasn't been down (so it's probably a hover)\n        if (storeIndex < 0) {\n            return;\n        }\n\n        // update the event in the store\n        store[storeIndex] = ev;\n\n        this.callback(this.manager, eventType, {\n            pointers: store,\n            changedPointers: [ev],\n            pointerType: pointerType,\n            srcEvent: ev\n        });\n\n        if (removePointer) {\n            // remove from the store\n            store.splice(storeIndex, 1);\n        }\n    }\n});\n\nvar SINGLE_TOUCH_INPUT_MAP = {\n    touchstart: INPUT_START,\n    touchmove: INPUT_MOVE,\n    touchend: INPUT_END,\n    touchcancel: INPUT_CANCEL\n};\n\nvar SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';\nvar SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';\n\n/**\n * Touch events input\n * @constructor\n * @extends Input\n */\nfunction SingleTouchInput() {\n    this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;\n    this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;\n    this.started = false;\n\n    Input.apply(this, arguments);\n}\n\ninherit(SingleTouchInput, Input, {\n    handler: function TEhandler(ev) {\n        var type = SINGLE_TOUCH_INPUT_MAP[ev.type];\n\n        // should we handle the touch events?\n        if (type === INPUT_START) {\n            this.started = true;\n        }\n\n        if (!this.started) {\n            return;\n        }\n\n        var touches = normalizeSingleTouches.call(this, ev, type);\n\n        // when done, reset the started state\n        if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {\n            this.started = false;\n        }\n\n        this.callback(this.manager, type, {\n            pointers: touches[0],\n            changedPointers: touches[1],\n            pointerType: INPUT_TYPE_TOUCH,\n            srcEvent: ev\n        });\n    }\n});\n\n/**\n * @this {TouchInput}\n * @param {Object} ev\n * @param {Number} type flag\n * @returns {undefined|Array} [all, changed]\n */\nfunction normalizeSingleTouches(ev, type) {\n    var all = toArray(ev.touches);\n    var changed = toArray(ev.changedTouches);\n\n    if (type & (INPUT_END | INPUT_CANCEL)) {\n        all = uniqueArray(all.concat(changed), 'identifier', true);\n    }\n\n    return [all, changed];\n}\n\nvar TOUCH_INPUT_MAP = {\n    touchstart: INPUT_START,\n    touchmove: INPUT_MOVE,\n    touchend: INPUT_END,\n    touchcancel: INPUT_CANCEL\n};\n\nvar TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';\n\n/**\n * Multi-user touch events input\n * @constructor\n * @extends Input\n */\nfunction TouchInput() {\n    this.evTarget = TOUCH_TARGET_EVENTS;\n    this.targetIds = {};\n\n    Input.apply(this, arguments);\n}\n\ninherit(TouchInput, Input, {\n    handler: function MTEhandler(ev) {\n        var type = TOUCH_INPUT_MAP[ev.type];\n        var touches = getTouches.call(this, ev, type);\n        if (!touches) {\n            return;\n        }\n\n        this.callback(this.manager, type, {\n            pointers: touches[0],\n            changedPointers: touches[1],\n            pointerType: INPUT_TYPE_TOUCH,\n            srcEvent: ev\n        });\n    }\n});\n\n/**\n * @this {TouchInput}\n * @param {Object} ev\n * @param {Number} type flag\n * @returns {undefined|Array} [all, changed]\n */\nfunction getTouches(ev, type) {\n    var allTouches = toArray(ev.touches);\n    var targetIds = this.targetIds;\n\n    // when there is only one touch, the process can be simplified\n    if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {\n        targetIds[allTouches[0].identifier] = true;\n        return [allTouches, allTouches];\n    }\n\n    var i,\n        targetTouches,\n        changedTouches = toArray(ev.changedTouches),\n        changedTargetTouches = [],\n        target = this.target;\n\n    // get target touches from touches\n    targetTouches = allTouches.filter(function(touch) {\n        return hasParent(touch.target, target);\n    });\n\n    // collect touches\n    if (type === INPUT_START) {\n        i = 0;\n        while (i < targetTouches.length) {\n            targetIds[targetTouches[i].identifier] = true;\n            i++;\n        }\n    }\n\n    // filter changed touches to only contain touches that exist in the collected target ids\n    i = 0;\n    while (i < changedTouches.length) {\n        if (targetIds[changedTouches[i].identifier]) {\n            changedTargetTouches.push(changedTouches[i]);\n        }\n\n        // cleanup removed touches\n        if (type & (INPUT_END | INPUT_CANCEL)) {\n            delete targetIds[changedTouches[i].identifier];\n        }\n        i++;\n    }\n\n    if (!changedTargetTouches.length) {\n        return;\n    }\n\n    return [\n        // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'\n        uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true),\n        changedTargetTouches\n    ];\n}\n\n/**\n * Combined touch and mouse input\n *\n * Touch has a higher priority then mouse, and while touching no mouse events are allowed.\n * This because touch devices also emit mouse events while doing a touch.\n *\n * @constructor\n * @extends Input\n */\n\nvar DEDUP_TIMEOUT = 2500;\nvar DEDUP_DISTANCE = 25;\n\nfunction TouchMouseInput() {\n    Input.apply(this, arguments);\n\n    var handler = bindFn(this.handler, this);\n    this.touch = new TouchInput(this.manager, handler);\n    this.mouse = new MouseInput(this.manager, handler);\n\n    this.primaryTouch = null;\n    this.lastTouches = [];\n}\n\ninherit(TouchMouseInput, Input, {\n    /**\n     * handle mouse and touch events\n     * @param {Hammer} manager\n     * @param {String} inputEvent\n     * @param {Object} inputData\n     */\n    handler: function TMEhandler(manager, inputEvent, inputData) {\n        var isTouch = (inputData.pointerType == INPUT_TYPE_TOUCH),\n            isMouse = (inputData.pointerType == INPUT_TYPE_MOUSE);\n\n        if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {\n            return;\n        }\n\n        // when we're in a touch event, record touches to  de-dupe synthetic mouse event\n        if (isTouch) {\n            recordTouches.call(this, inputEvent, inputData);\n        } else if (isMouse && isSyntheticEvent.call(this, inputData)) {\n            return;\n        }\n\n        this.callback(manager, inputEvent, inputData);\n    },\n\n    /**\n     * remove the event listeners\n     */\n    destroy: function destroy() {\n        this.touch.destroy();\n        this.mouse.destroy();\n    }\n});\n\nfunction recordTouches(eventType, eventData) {\n    if (eventType & INPUT_START) {\n        this.primaryTouch = eventData.changedPointers[0].identifier;\n        setLastTouch.call(this, eventData);\n    } else if (eventType & (INPUT_END | INPUT_CANCEL)) {\n        setLastTouch.call(this, eventData);\n    }\n}\n\nfunction setLastTouch(eventData) {\n    var touch = eventData.changedPointers[0];\n\n    if (touch.identifier === this.primaryTouch) {\n        var lastTouch = {x: touch.clientX, y: touch.clientY};\n        this.lastTouches.push(lastTouch);\n        var lts = this.lastTouches;\n        var removeLastTouch = function() {\n            var i = lts.indexOf(lastTouch);\n            if (i > -1) {\n                lts.splice(i, 1);\n            }\n        };\n        setTimeout(removeLastTouch, DEDUP_TIMEOUT);\n    }\n}\n\nfunction isSyntheticEvent(eventData) {\n    var x = eventData.srcEvent.clientX, y = eventData.srcEvent.clientY;\n    for (var i = 0; i < this.lastTouches.length; i++) {\n        var t = this.lastTouches[i];\n        var dx = Math.abs(x - t.x), dy = Math.abs(y - t.y);\n        if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) {\n            return true;\n        }\n    }\n    return false;\n}\n\nvar PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');\nvar NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;\n\n// magical touchAction value\nvar TOUCH_ACTION_COMPUTE = 'compute';\nvar TOUCH_ACTION_AUTO = 'auto';\nvar TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented\nvar TOUCH_ACTION_NONE = 'none';\nvar TOUCH_ACTION_PAN_X = 'pan-x';\nvar TOUCH_ACTION_PAN_Y = 'pan-y';\nvar TOUCH_ACTION_MAP = getTouchActionProps();\n\n/**\n * Touch Action\n * sets the touchAction property or uses the js alternative\n * @param {Manager} manager\n * @param {String} value\n * @constructor\n */\nfunction TouchAction(manager, value) {\n    this.manager = manager;\n    this.set(value);\n}\n\nTouchAction.prototype = {\n    /**\n     * set the touchAction value on the element or enable the polyfill\n     * @param {String} value\n     */\n    set: function(value) {\n        // find out the touch-action by the event handlers\n        if (value == TOUCH_ACTION_COMPUTE) {\n            value = this.compute();\n        }\n\n        if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) {\n            this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;\n        }\n        this.actions = value.toLowerCase().trim();\n    },\n\n    /**\n     * just re-set the touchAction value\n     */\n    update: function() {\n        this.set(this.manager.options.touchAction);\n    },\n\n    /**\n     * compute the value for the touchAction property based on the recognizer's settings\n     * @returns {String} value\n     */\n    compute: function() {\n        var actions = [];\n        each(this.manager.recognizers, function(recognizer) {\n            if (boolOrFn(recognizer.options.enable, [recognizer])) {\n                actions = actions.concat(recognizer.getTouchAction());\n            }\n        });\n        return cleanTouchActions(actions.join(' '));\n    },\n\n    /**\n     * this method is called on each input cycle and provides the preventing of the browser behavior\n     * @param {Object} input\n     */\n    preventDefaults: function(input) {\n        var srcEvent = input.srcEvent;\n        var direction = input.offsetDirection;\n\n        // if the touch action did prevented once this session\n        if (this.manager.session.prevented) {\n            srcEvent.preventDefault();\n            return;\n        }\n\n        var actions = this.actions;\n        var hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];\n        var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];\n        var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];\n\n        if (hasNone) {\n            //do not prevent defaults if this is a tap gesture\n\n            var isTapPointer = input.pointers.length === 1;\n            var isTapMovement = input.distance < 2;\n            var isTapTouchTime = input.deltaTime < 250;\n\n            if (isTapPointer && isTapMovement && isTapTouchTime) {\n                return;\n            }\n        }\n\n        if (hasPanX && hasPanY) {\n            // `pan-x pan-y` means browser handles all scrolling/panning, do not prevent\n            return;\n        }\n\n        if (hasNone ||\n            (hasPanY && direction & DIRECTION_HORIZONTAL) ||\n            (hasPanX && direction & DIRECTION_VERTICAL)) {\n            return this.preventSrc(srcEvent);\n        }\n    },\n\n    /**\n     * call preventDefault to prevent the browser's default behavior (scrolling in most cases)\n     * @param {Object} srcEvent\n     */\n    preventSrc: function(srcEvent) {\n        this.manager.session.prevented = true;\n        srcEvent.preventDefault();\n    }\n};\n\n/**\n * when the touchActions are collected they are not a valid value, so we need to clean things up. *\n * @param {String} actions\n * @returns {*}\n */\nfunction cleanTouchActions(actions) {\n    // none\n    if (inStr(actions, TOUCH_ACTION_NONE)) {\n        return TOUCH_ACTION_NONE;\n    }\n\n    var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);\n    var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);\n\n    // if both pan-x and pan-y are set (different recognizers\n    // for different directions, e.g. horizontal pan but vertical swipe?)\n    // we need none (as otherwise with pan-x pan-y combined none of these\n    // recognizers will work, since the browser would handle all panning\n    if (hasPanX && hasPanY) {\n        return TOUCH_ACTION_NONE;\n    }\n\n    // pan-x OR pan-y\n    if (hasPanX || hasPanY) {\n        return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;\n    }\n\n    // manipulation\n    if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {\n        return TOUCH_ACTION_MANIPULATION;\n    }\n\n    return TOUCH_ACTION_AUTO;\n}\n\nfunction getTouchActionProps() {\n    if (!NATIVE_TOUCH_ACTION) {\n        return false;\n    }\n    var touchMap = {};\n    var cssSupports = window.CSS && window.CSS.supports;\n    ['auto', 'manipulation', 'pan-y', 'pan-x', 'pan-x pan-y', 'none'].forEach(function(val) {\n\n        // If css.supports is not supported but there is native touch-action assume it supports\n        // all values. This is the case for IE 10 and 11.\n        touchMap[val] = cssSupports ? window.CSS.supports('touch-action', val) : true;\n    });\n    return touchMap;\n}\n\n/**\n * Recognizer flow explained; *\n * All recognizers have the initial state of POSSIBLE when a input session starts.\n * The definition of a input session is from the first input until the last input, with all it's movement in it. *\n * Example session for mouse-input: mousedown -> mousemove -> mouseup\n *\n * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed\n * which determines with state it should be.\n *\n * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to\n * POSSIBLE to give it another change on the next cycle.\n *\n *               Possible\n *                  |\n *            +-----+---------------+\n *            |                     |\n *      +-----+-----+               |\n *      |           |               |\n *   Failed      Cancelled          |\n *                          +-------+------+\n *                          |              |\n *                      Recognized       Began\n *                                         |\n *                                      Changed\n *                                         |\n *                                  Ended/Recognized\n */\nvar STATE_POSSIBLE = 1;\nvar STATE_BEGAN = 2;\nvar STATE_CHANGED = 4;\nvar STATE_ENDED = 8;\nvar STATE_RECOGNIZED = STATE_ENDED;\nvar STATE_CANCELLED = 16;\nvar STATE_FAILED = 32;\n\n/**\n * Recognizer\n * Every recognizer needs to extend from this class.\n * @constructor\n * @param {Object} options\n */\nfunction Recognizer(options) {\n    this.options = assign({}, this.defaults, options || {});\n\n    this.id = uniqueId();\n\n    this.manager = null;\n\n    // default is enable true\n    this.options.enable = ifUndefined(this.options.enable, true);\n\n    this.state = STATE_POSSIBLE;\n\n    this.simultaneous = {};\n    this.requireFail = [];\n}\n\nRecognizer.prototype = {\n    /**\n     * @virtual\n     * @type {Object}\n     */\n    defaults: {},\n\n    /**\n     * set options\n     * @param {Object} options\n     * @return {Recognizer}\n     */\n    set: function(options) {\n        assign(this.options, options);\n\n        // also update the touchAction, in case something changed about the directions/enabled state\n        this.manager && this.manager.touchAction.update();\n        return this;\n    },\n\n    /**\n     * recognize simultaneous with an other recognizer.\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n    recognizeWith: function(otherRecognizer) {\n        if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {\n            return this;\n        }\n\n        var simultaneous = this.simultaneous;\n        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n        if (!simultaneous[otherRecognizer.id]) {\n            simultaneous[otherRecognizer.id] = otherRecognizer;\n            otherRecognizer.recognizeWith(this);\n        }\n        return this;\n    },\n\n    /**\n     * drop the simultaneous link. it doesnt remove the link on the other recognizer.\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n    dropRecognizeWith: function(otherRecognizer) {\n        if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {\n            return this;\n        }\n\n        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n        delete this.simultaneous[otherRecognizer.id];\n        return this;\n    },\n\n    /**\n     * recognizer can only run when an other is failing\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n    requireFailure: function(otherRecognizer) {\n        if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {\n            return this;\n        }\n\n        var requireFail = this.requireFail;\n        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n        if (inArray(requireFail, otherRecognizer) === -1) {\n            requireFail.push(otherRecognizer);\n            otherRecognizer.requireFailure(this);\n        }\n        return this;\n    },\n\n    /**\n     * drop the requireFailure link. it does not remove the link on the other recognizer.\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n    dropRequireFailure: function(otherRecognizer) {\n        if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {\n            return this;\n        }\n\n        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n        var index = inArray(this.requireFail, otherRecognizer);\n        if (index > -1) {\n            this.requireFail.splice(index, 1);\n        }\n        return this;\n    },\n\n    /**\n     * has require failures boolean\n     * @returns {boolean}\n     */\n    hasRequireFailures: function() {\n        return this.requireFail.length > 0;\n    },\n\n    /**\n     * if the recognizer can recognize simultaneous with an other recognizer\n     * @param {Recognizer} otherRecognizer\n     * @returns {Boolean}\n     */\n    canRecognizeWith: function(otherRecognizer) {\n        return !!this.simultaneous[otherRecognizer.id];\n    },\n\n    /**\n     * You should use `tryEmit` instead of `emit` directly to check\n     * that all the needed recognizers has failed before emitting.\n     * @param {Object} input\n     */\n    emit: function(input) {\n        var self = this;\n        var state = this.state;\n\n        function emit(event) {\n            self.manager.emit(event, input);\n        }\n\n        // 'panstart' and 'panmove'\n        if (state < STATE_ENDED) {\n            emit(self.options.event + stateStr(state));\n        }\n\n        emit(self.options.event); // simple 'eventName' events\n\n        if (input.additionalEvent) { // additional event(panleft, panright, pinchin, pinchout...)\n            emit(input.additionalEvent);\n        }\n\n        // panend and pancancel\n        if (state >= STATE_ENDED) {\n            emit(self.options.event + stateStr(state));\n        }\n    },\n\n    /**\n     * Check that all the require failure recognizers has failed,\n     * if true, it emits a gesture event,\n     * otherwise, setup the state to FAILED.\n     * @param {Object} input\n     */\n    tryEmit: function(input) {\n        if (this.canEmit()) {\n            return this.emit(input);\n        }\n        // it's failing anyway\n        this.state = STATE_FAILED;\n    },\n\n    /**\n     * can we emit?\n     * @returns {boolean}\n     */\n    canEmit: function() {\n        var i = 0;\n        while (i < this.requireFail.length) {\n            if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {\n                return false;\n            }\n            i++;\n        }\n        return true;\n    },\n\n    /**\n     * update the recognizer\n     * @param {Object} inputData\n     */\n    recognize: function(inputData) {\n        // make a new copy of the inputData\n        // so we can change the inputData without messing up the other recognizers\n        var inputDataClone = assign({}, inputData);\n\n        // is is enabled and allow recognizing?\n        if (!boolOrFn(this.options.enable, [this, inputDataClone])) {\n            this.reset();\n            this.state = STATE_FAILED;\n            return;\n        }\n\n        // reset when we've reached the end\n        if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {\n            this.state = STATE_POSSIBLE;\n        }\n\n        this.state = this.process(inputDataClone);\n\n        // the recognizer has recognized a gesture\n        // so trigger an event\n        if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {\n            this.tryEmit(inputDataClone);\n        }\n    },\n\n    /**\n     * return the state of the recognizer\n     * the actual recognizing happens in this method\n     * @virtual\n     * @param {Object} inputData\n     * @returns {Const} STATE\n     */\n    process: function(inputData) { }, // jshint ignore:line\n\n    /**\n     * return the preferred touch-action\n     * @virtual\n     * @returns {Array}\n     */\n    getTouchAction: function() { },\n\n    /**\n     * called when the gesture isn't allowed to recognize\n     * like when another is being recognized or it is disabled\n     * @virtual\n     */\n    reset: function() { }\n};\n\n/**\n * get a usable string, used as event postfix\n * @param {Const} state\n * @returns {String} state\n */\nfunction stateStr(state) {\n    if (state & STATE_CANCELLED) {\n        return 'cancel';\n    } else if (state & STATE_ENDED) {\n        return 'end';\n    } else if (state & STATE_CHANGED) {\n        return 'move';\n    } else if (state & STATE_BEGAN) {\n        return 'start';\n    }\n    return '';\n}\n\n/**\n * direction cons to string\n * @param {Const} direction\n * @returns {String}\n */\nfunction directionStr(direction) {\n    if (direction == DIRECTION_DOWN) {\n        return 'down';\n    } else if (direction == DIRECTION_UP) {\n        return 'up';\n    } else if (direction == DIRECTION_LEFT) {\n        return 'left';\n    } else if (direction == DIRECTION_RIGHT) {\n        return 'right';\n    }\n    return '';\n}\n\n/**\n * get a recognizer by name if it is bound to a manager\n * @param {Recognizer|String} otherRecognizer\n * @param {Recognizer} recognizer\n * @returns {Recognizer}\n */\nfunction getRecognizerByNameIfManager(otherRecognizer, recognizer) {\n    var manager = recognizer.manager;\n    if (manager) {\n        return manager.get(otherRecognizer);\n    }\n    return otherRecognizer;\n}\n\n/**\n * This recognizer is just used as a base for the simple attribute recognizers.\n * @constructor\n * @extends Recognizer\n */\nfunction AttrRecognizer() {\n    Recognizer.apply(this, arguments);\n}\n\ninherit(AttrRecognizer, Recognizer, {\n    /**\n     * @namespace\n     * @memberof AttrRecognizer\n     */\n    defaults: {\n        /**\n         * @type {Number}\n         * @default 1\n         */\n        pointers: 1\n    },\n\n    /**\n     * Used to check if it the recognizer receives valid input, like input.distance > 10.\n     * @memberof AttrRecognizer\n     * @param {Object} input\n     * @returns {Boolean} recognized\n     */\n    attrTest: function(input) {\n        var optionPointers = this.options.pointers;\n        return optionPointers === 0 || input.pointers.length === optionPointers;\n    },\n\n    /**\n     * Process the input and return the state for the recognizer\n     * @memberof AttrRecognizer\n     * @param {Object} input\n     * @returns {*} State\n     */\n    process: function(input) {\n        var state = this.state;\n        var eventType = input.eventType;\n\n        var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);\n        var isValid = this.attrTest(input);\n\n        // on cancel input and we've recognized before, return STATE_CANCELLED\n        if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {\n            return state | STATE_CANCELLED;\n        } else if (isRecognized || isValid) {\n            if (eventType & INPUT_END) {\n                return state | STATE_ENDED;\n            } else if (!(state & STATE_BEGAN)) {\n                return STATE_BEGAN;\n            }\n            return state | STATE_CHANGED;\n        }\n        return STATE_FAILED;\n    }\n});\n\n/**\n * Pan\n * Recognized when the pointer is down and moved in the allowed direction.\n * @constructor\n * @extends AttrRecognizer\n */\nfunction PanRecognizer() {\n    AttrRecognizer.apply(this, arguments);\n\n    this.pX = null;\n    this.pY = null;\n}\n\ninherit(PanRecognizer, AttrRecognizer, {\n    /**\n     * @namespace\n     * @memberof PanRecognizer\n     */\n    defaults: {\n        event: 'pan',\n        threshold: 10,\n        pointers: 1,\n        direction: DIRECTION_ALL\n    },\n\n    getTouchAction: function() {\n        var direction = this.options.direction;\n        var actions = [];\n        if (direction & DIRECTION_HORIZONTAL) {\n            actions.push(TOUCH_ACTION_PAN_Y);\n        }\n        if (direction & DIRECTION_VERTICAL) {\n            actions.push(TOUCH_ACTION_PAN_X);\n        }\n        return actions;\n    },\n\n    directionTest: function(input) {\n        var options = this.options;\n        var hasMoved = true;\n        var distance = input.distance;\n        var direction = input.direction;\n        var x = input.deltaX;\n        var y = input.deltaY;\n\n        // lock to axis?\n        if (!(direction & options.direction)) {\n            if (options.direction & DIRECTION_HORIZONTAL) {\n                direction = (x === 0) ? DIRECTION_NONE : (x < 0) ? DIRECTION_LEFT : DIRECTION_RIGHT;\n                hasMoved = x != this.pX;\n                distance = Math.abs(input.deltaX);\n            } else {\n                direction = (y === 0) ? DIRECTION_NONE : (y < 0) ? DIRECTION_UP : DIRECTION_DOWN;\n                hasMoved = y != this.pY;\n                distance = Math.abs(input.deltaY);\n            }\n        }\n        input.direction = direction;\n        return hasMoved && distance > options.threshold && direction & options.direction;\n    },\n\n    attrTest: function(input) {\n        return AttrRecognizer.prototype.attrTest.call(this, input) &&\n            (this.state & STATE_BEGAN || (!(this.state & STATE_BEGAN) && this.directionTest(input)));\n    },\n\n    emit: function(input) {\n\n        this.pX = input.deltaX;\n        this.pY = input.deltaY;\n\n        var direction = directionStr(input.direction);\n\n        if (direction) {\n            input.additionalEvent = this.options.event + direction;\n        }\n        this._super.emit.call(this, input);\n    }\n});\n\n/**\n * Pinch\n * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).\n * @constructor\n * @extends AttrRecognizer\n */\nfunction PinchRecognizer() {\n    AttrRecognizer.apply(this, arguments);\n}\n\ninherit(PinchRecognizer, AttrRecognizer, {\n    /**\n     * @namespace\n     * @memberof PinchRecognizer\n     */\n    defaults: {\n        event: 'pinch',\n        threshold: 0,\n        pointers: 2\n    },\n\n    getTouchAction: function() {\n        return [TOUCH_ACTION_NONE];\n    },\n\n    attrTest: function(input) {\n        return this._super.attrTest.call(this, input) &&\n            (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);\n    },\n\n    emit: function(input) {\n        if (input.scale !== 1) {\n            var inOut = input.scale < 1 ? 'in' : 'out';\n            input.additionalEvent = this.options.event + inOut;\n        }\n        this._super.emit.call(this, input);\n    }\n});\n\n/**\n * Press\n * Recognized when the pointer is down for x ms without any movement.\n * @constructor\n * @extends Recognizer\n */\nfunction PressRecognizer() {\n    Recognizer.apply(this, arguments);\n\n    this._timer = null;\n    this._input = null;\n}\n\ninherit(PressRecognizer, Recognizer, {\n    /**\n     * @namespace\n     * @memberof PressRecognizer\n     */\n    defaults: {\n        event: 'press',\n        pointers: 1,\n        time: 251, // minimal time of the pointer to be pressed\n        threshold: 9 // a minimal movement is ok, but keep it low\n    },\n\n    getTouchAction: function() {\n        return [TOUCH_ACTION_AUTO];\n    },\n\n    process: function(input) {\n        var options = this.options;\n        var validPointers = input.pointers.length === options.pointers;\n        var validMovement = input.distance < options.threshold;\n        var validTime = input.deltaTime > options.time;\n\n        this._input = input;\n\n        // we only allow little movement\n        // and we've reached an end event, so a tap is possible\n        if (!validMovement || !validPointers || (input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime)) {\n            this.reset();\n        } else if (input.eventType & INPUT_START) {\n            this.reset();\n            this._timer = setTimeoutContext(function() {\n                this.state = STATE_RECOGNIZED;\n                this.tryEmit();\n            }, options.time, this);\n        } else if (input.eventType & INPUT_END) {\n            return STATE_RECOGNIZED;\n        }\n        return STATE_FAILED;\n    },\n\n    reset: function() {\n        clearTimeout(this._timer);\n    },\n\n    emit: function(input) {\n        if (this.state !== STATE_RECOGNIZED) {\n            return;\n        }\n\n        if (input && (input.eventType & INPUT_END)) {\n            this.manager.emit(this.options.event + 'up', input);\n        } else {\n            this._input.timeStamp = now();\n            this.manager.emit(this.options.event, this._input);\n        }\n    }\n});\n\n/**\n * Rotate\n * Recognized when two or more pointer are moving in a circular motion.\n * @constructor\n * @extends AttrRecognizer\n */\nfunction RotateRecognizer() {\n    AttrRecognizer.apply(this, arguments);\n}\n\ninherit(RotateRecognizer, AttrRecognizer, {\n    /**\n     * @namespace\n     * @memberof RotateRecognizer\n     */\n    defaults: {\n        event: 'rotate',\n        threshold: 0,\n        pointers: 2\n    },\n\n    getTouchAction: function() {\n        return [TOUCH_ACTION_NONE];\n    },\n\n    attrTest: function(input) {\n        return this._super.attrTest.call(this, input) &&\n            (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);\n    }\n});\n\n/**\n * Swipe\n * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.\n * @constructor\n * @extends AttrRecognizer\n */\nfunction SwipeRecognizer() {\n    AttrRecognizer.apply(this, arguments);\n}\n\ninherit(SwipeRecognizer, AttrRecognizer, {\n    /**\n     * @namespace\n     * @memberof SwipeRecognizer\n     */\n    defaults: {\n        event: 'swipe',\n        threshold: 10,\n        velocity: 0.3,\n        direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,\n        pointers: 1\n    },\n\n    getTouchAction: function() {\n        return PanRecognizer.prototype.getTouchAction.call(this);\n    },\n\n    attrTest: function(input) {\n        var direction = this.options.direction;\n        var velocity;\n\n        if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {\n            velocity = input.overallVelocity;\n        } else if (direction & DIRECTION_HORIZONTAL) {\n            velocity = input.overallVelocityX;\n        } else if (direction & DIRECTION_VERTICAL) {\n            velocity = input.overallVelocityY;\n        }\n\n        return this._super.attrTest.call(this, input) &&\n            direction & input.offsetDirection &&\n            input.distance > this.options.threshold &&\n            input.maxPointers == this.options.pointers &&\n            abs(velocity) > this.options.velocity && input.eventType & INPUT_END;\n    },\n\n    emit: function(input) {\n        var direction = directionStr(input.offsetDirection);\n        if (direction) {\n            this.manager.emit(this.options.event + direction, input);\n        }\n\n        this.manager.emit(this.options.event, input);\n    }\n});\n\n/**\n * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur\n * between the given interval and position. The delay option can be used to recognize multi-taps without firing\n * a single tap.\n *\n * The eventData from the emitted event contains the property `tapCount`, which contains the amount of\n * multi-taps being recognized.\n * @constructor\n * @extends Recognizer\n */\nfunction TapRecognizer() {\n    Recognizer.apply(this, arguments);\n\n    // previous time and center,\n    // used for tap counting\n    this.pTime = false;\n    this.pCenter = false;\n\n    this._timer = null;\n    this._input = null;\n    this.count = 0;\n}\n\ninherit(TapRecognizer, Recognizer, {\n    /**\n     * @namespace\n     * @memberof PinchRecognizer\n     */\n    defaults: {\n        event: 'tap',\n        pointers: 1,\n        taps: 1,\n        interval: 300, // max time between the multi-tap taps\n        time: 250, // max time of the pointer to be down (like finger on the screen)\n        threshold: 9, // a minimal movement is ok, but keep it low\n        posThreshold: 10 // a multi-tap can be a bit off the initial position\n    },\n\n    getTouchAction: function() {\n        return [TOUCH_ACTION_MANIPULATION];\n    },\n\n    process: function(input) {\n        var options = this.options;\n\n        var validPointers = input.pointers.length === options.pointers;\n        var validMovement = input.distance < options.threshold;\n        var validTouchTime = input.deltaTime < options.time;\n\n        this.reset();\n\n        if ((input.eventType & INPUT_START) && (this.count === 0)) {\n            return this.failTimeout();\n        }\n\n        // we only allow little movement\n        // and we've reached an end event, so a tap is possible\n        if (validMovement && validTouchTime && validPointers) {\n            if (input.eventType != INPUT_END) {\n                return this.failTimeout();\n            }\n\n            var validInterval = this.pTime ? (input.timeStamp - this.pTime < options.interval) : true;\n            var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;\n\n            this.pTime = input.timeStamp;\n            this.pCenter = input.center;\n\n            if (!validMultiTap || !validInterval) {\n                this.count = 1;\n            } else {\n                this.count += 1;\n            }\n\n            this._input = input;\n\n            // if tap count matches we have recognized it,\n            // else it has began recognizing...\n            var tapCount = this.count % options.taps;\n            if (tapCount === 0) {\n                // no failing requirements, immediately trigger the tap event\n                // or wait as long as the multitap interval to trigger\n                if (!this.hasRequireFailures()) {\n                    return STATE_RECOGNIZED;\n                } else {\n                    this._timer = setTimeoutContext(function() {\n                        this.state = STATE_RECOGNIZED;\n                        this.tryEmit();\n                    }, options.interval, this);\n                    return STATE_BEGAN;\n                }\n            }\n        }\n        return STATE_FAILED;\n    },\n\n    failTimeout: function() {\n        this._timer = setTimeoutContext(function() {\n            this.state = STATE_FAILED;\n        }, this.options.interval, this);\n        return STATE_FAILED;\n    },\n\n    reset: function() {\n        clearTimeout(this._timer);\n    },\n\n    emit: function() {\n        if (this.state == STATE_RECOGNIZED) {\n            this._input.tapCount = this.count;\n            this.manager.emit(this.options.event, this._input);\n        }\n    }\n});\n\n/**\n * Simple way to create a manager with a default set of recognizers.\n * @param {HTMLElement} element\n * @param {Object} [options]\n * @constructor\n */\nfunction Hammer(element, options) {\n    options = options || {};\n    options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);\n    return new Manager(element, options);\n}\n\n/**\n * @const {string}\n */\nHammer.VERSION = '2.0.7';\n\n/**\n * default settings\n * @namespace\n */\nHammer.defaults = {\n    /**\n     * set if DOM events are being triggered.\n     * But this is slower and unused by simple implementations, so disabled by default.\n     * @type {Boolean}\n     * @default false\n     */\n    domEvents: false,\n\n    /**\n     * The value for the touchAction property/fallback.\n     * When set to `compute` it will magically set the correct value based on the added recognizers.\n     * @type {String}\n     * @default compute\n     */\n    touchAction: TOUCH_ACTION_COMPUTE,\n\n    /**\n     * @type {Boolean}\n     * @default true\n     */\n    enable: true,\n\n    /**\n     * EXPERIMENTAL FEATURE -- can be removed/changed\n     * Change the parent input target element.\n     * If Null, then it is being set the to main element.\n     * @type {Null|EventTarget}\n     * @default null\n     */\n    inputTarget: null,\n\n    /**\n     * force an input class\n     * @type {Null|Function}\n     * @default null\n     */\n    inputClass: null,\n\n    /**\n     * Default recognizer setup when calling `Hammer()`\n     * When creating a new Manager these will be skipped.\n     * @type {Array}\n     */\n    preset: [\n        // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]\n        [RotateRecognizer, {enable: false}],\n        [PinchRecognizer, {enable: false}, ['rotate']],\n        [SwipeRecognizer, {direction: DIRECTION_HORIZONTAL}],\n        [PanRecognizer, {direction: DIRECTION_HORIZONTAL}, ['swipe']],\n        [TapRecognizer],\n        [TapRecognizer, {event: 'doubletap', taps: 2}, ['tap']],\n        [PressRecognizer]\n    ],\n\n    /**\n     * Some CSS properties can be used to improve the working of Hammer.\n     * Add them to this method and they will be set when creating a new Manager.\n     * @namespace\n     */\n    cssProps: {\n        /**\n         * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.\n         * @type {String}\n         * @default 'none'\n         */\n        userSelect: 'none',\n\n        /**\n         * Disable the Windows Phone grippers when pressing an element.\n         * @type {String}\n         * @default 'none'\n         */\n        touchSelect: 'none',\n\n        /**\n         * Disables the default callout shown when you touch and hold a touch target.\n         * On iOS, when you touch and hold a touch target such as a link, Safari displays\n         * a callout containing information about the link. This property allows you to disable that callout.\n         * @type {String}\n         * @default 'none'\n         */\n        touchCallout: 'none',\n\n        /**\n         * Specifies whether zooming is enabled. Used by IE10>\n         * @type {String}\n         * @default 'none'\n         */\n        contentZooming: 'none',\n\n        /**\n         * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.\n         * @type {String}\n         * @default 'none'\n         */\n        userDrag: 'none',\n\n        /**\n         * Overrides the highlight color shown when the user taps a link or a JavaScript\n         * clickable element in iOS. This property obeys the alpha value, if specified.\n         * @type {String}\n         * @default 'rgba(0,0,0,0)'\n         */\n        tapHighlightColor: 'rgba(0,0,0,0)'\n    }\n};\n\nvar STOP = 1;\nvar FORCED_STOP = 2;\n\n/**\n * Manager\n * @param {HTMLElement} element\n * @param {Object} [options]\n * @constructor\n */\nfunction Manager(element, options) {\n    this.options = assign({}, Hammer.defaults, options || {});\n\n    this.options.inputTarget = this.options.inputTarget || element;\n\n    this.handlers = {};\n    this.session = {};\n    this.recognizers = [];\n    this.oldCssProps = {};\n\n    this.element = element;\n    this.input = createInputInstance(this);\n    this.touchAction = new TouchAction(this, this.options.touchAction);\n\n    toggleCssProps(this, true);\n\n    each(this.options.recognizers, function(item) {\n        var recognizer = this.add(new (item[0])(item[1]));\n        item[2] && recognizer.recognizeWith(item[2]);\n        item[3] && recognizer.requireFailure(item[3]);\n    }, this);\n}\n\nManager.prototype = {\n    /**\n     * set options\n     * @param {Object} options\n     * @returns {Manager}\n     */\n    set: function(options) {\n        assign(this.options, options);\n\n        // Options that need a little more setup\n        if (options.touchAction) {\n            this.touchAction.update();\n        }\n        if (options.inputTarget) {\n            // Clean up existing event listeners and reinitialize\n            this.input.destroy();\n            this.input.target = options.inputTarget;\n            this.input.init();\n        }\n        return this;\n    },\n\n    /**\n     * stop recognizing for this session.\n     * This session will be discarded, when a new [input]start event is fired.\n     * When forced, the recognizer cycle is stopped immediately.\n     * @param {Boolean} [force]\n     */\n    stop: function(force) {\n        this.session.stopped = force ? FORCED_STOP : STOP;\n    },\n\n    /**\n     * run the recognizers!\n     * called by the inputHandler function on every movement of the pointers (touches)\n     * it walks through all the recognizers and tries to detect the gesture that is being made\n     * @param {Object} inputData\n     */\n    recognize: function(inputData) {\n        var session = this.session;\n        if (session.stopped) {\n            return;\n        }\n\n        // run the touch-action polyfill\n        this.touchAction.preventDefaults(inputData);\n\n        var recognizer;\n        var recognizers = this.recognizers;\n\n        // this holds the recognizer that is being recognized.\n        // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED\n        // if no recognizer is detecting a thing, it is set to `null`\n        var curRecognizer = session.curRecognizer;\n\n        // reset when the last recognizer is recognized\n        // or when we're in a new session\n        if (!curRecognizer || (curRecognizer && curRecognizer.state & STATE_RECOGNIZED)) {\n            curRecognizer = session.curRecognizer = null;\n        }\n\n        var i = 0;\n        while (i < recognizers.length) {\n            recognizer = recognizers[i];\n\n            // find out if we are allowed try to recognize the input for this one.\n            // 1.   allow if the session is NOT forced stopped (see the .stop() method)\n            // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one\n            //      that is being recognized.\n            // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.\n            //      this can be setup with the `recognizeWith()` method on the recognizer.\n            if (session.stopped !== FORCED_STOP && ( // 1\n                    !curRecognizer || recognizer == curRecognizer || // 2\n                    recognizer.canRecognizeWith(curRecognizer))) { // 3\n                recognizer.recognize(inputData);\n            } else {\n                recognizer.reset();\n            }\n\n            // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the\n            // current active recognizer. but only if we don't already have an active recognizer\n            if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {\n                curRecognizer = session.curRecognizer = recognizer;\n            }\n            i++;\n        }\n    },\n\n    /**\n     * get a recognizer by its event name.\n     * @param {Recognizer|String} recognizer\n     * @returns {Recognizer|Null}\n     */\n    get: function(recognizer) {\n        if (recognizer instanceof Recognizer) {\n            return recognizer;\n        }\n\n        var recognizers = this.recognizers;\n        for (var i = 0; i < recognizers.length; i++) {\n            if (recognizers[i].options.event == recognizer) {\n                return recognizers[i];\n            }\n        }\n        return null;\n    },\n\n    /**\n     * add a recognizer to the manager\n     * existing recognizers with the same event name will be removed\n     * @param {Recognizer} recognizer\n     * @returns {Recognizer|Manager}\n     */\n    add: function(recognizer) {\n        if (invokeArrayArg(recognizer, 'add', this)) {\n            return this;\n        }\n\n        // remove existing\n        var existing = this.get(recognizer.options.event);\n        if (existing) {\n            this.remove(existing);\n        }\n\n        this.recognizers.push(recognizer);\n        recognizer.manager = this;\n\n        this.touchAction.update();\n        return recognizer;\n    },\n\n    /**\n     * remove a recognizer by name or instance\n     * @param {Recognizer|String} recognizer\n     * @returns {Manager}\n     */\n    remove: function(recognizer) {\n        if (invokeArrayArg(recognizer, 'remove', this)) {\n            return this;\n        }\n\n        recognizer = this.get(recognizer);\n\n        // let's make sure this recognizer exists\n        if (recognizer) {\n            var recognizers = this.recognizers;\n            var index = inArray(recognizers, recognizer);\n\n            if (index !== -1) {\n                recognizers.splice(index, 1);\n                this.touchAction.update();\n            }\n        }\n\n        return this;\n    },\n\n    /**\n     * bind event\n     * @param {String} events\n     * @param {Function} handler\n     * @returns {EventEmitter} this\n     */\n    on: function(events, handler) {\n        if (events === undefined) {\n            return;\n        }\n        if (handler === undefined) {\n            return;\n        }\n\n        var handlers = this.handlers;\n        each(splitStr(events), function(event) {\n            handlers[event] = handlers[event] || [];\n            handlers[event].push(handler);\n        });\n        return this;\n    },\n\n    /**\n     * unbind event, leave emit blank to remove all handlers\n     * @param {String} events\n     * @param {Function} [handler]\n     * @returns {EventEmitter} this\n     */\n    off: function(events, handler) {\n        if (events === undefined) {\n            return;\n        }\n\n        var handlers = this.handlers;\n        each(splitStr(events), function(event) {\n            if (!handler) {\n                delete handlers[event];\n            } else {\n                handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);\n            }\n        });\n        return this;\n    },\n\n    /**\n     * emit event to the listeners\n     * @param {String} event\n     * @param {Object} data\n     */\n    emit: function(event, data) {\n        // we also want to trigger dom events\n        if (this.options.domEvents) {\n            triggerDomEvent(event, data);\n        }\n\n        // no handlers, so skip it all\n        var handlers = this.handlers[event] && this.handlers[event].slice();\n        if (!handlers || !handlers.length) {\n            return;\n        }\n\n        data.type = event;\n        data.preventDefault = function() {\n            data.srcEvent.preventDefault();\n        };\n\n        var i = 0;\n        while (i < handlers.length) {\n            handlers[i](data);\n            i++;\n        }\n    },\n\n    /**\n     * destroy the manager and unbinds all events\n     * it doesn't unbind dom events, that is the user own responsibility\n     */\n    destroy: function() {\n        this.element && toggleCssProps(this, false);\n\n        this.handlers = {};\n        this.session = {};\n        this.input.destroy();\n        this.element = null;\n    }\n};\n\n/**\n * add/remove the css properties as defined in manager.options.cssProps\n * @param {Manager} manager\n * @param {Boolean} add\n */\nfunction toggleCssProps(manager, add) {\n    var element = manager.element;\n    if (!element.style) {\n        return;\n    }\n    var prop;\n    each(manager.options.cssProps, function(value, name) {\n        prop = prefixed(element.style, name);\n        if (add) {\n            manager.oldCssProps[prop] = element.style[prop];\n            element.style[prop] = value;\n        } else {\n            element.style[prop] = manager.oldCssProps[prop] || '';\n        }\n    });\n    if (!add) {\n        manager.oldCssProps = {};\n    }\n}\n\n/**\n * trigger dom event\n * @param {String} event\n * @param {Object} data\n */\nfunction triggerDomEvent(event, data) {\n    var gestureEvent = document.createEvent('Event');\n    gestureEvent.initEvent(event, true, true);\n    gestureEvent.gesture = data;\n    data.target.dispatchEvent(gestureEvent);\n}\n\nassign(Hammer, {\n    INPUT_START: INPUT_START,\n    INPUT_MOVE: INPUT_MOVE,\n    INPUT_END: INPUT_END,\n    INPUT_CANCEL: INPUT_CANCEL,\n\n    STATE_POSSIBLE: STATE_POSSIBLE,\n    STATE_BEGAN: STATE_BEGAN,\n    STATE_CHANGED: STATE_CHANGED,\n    STATE_ENDED: STATE_ENDED,\n    STATE_RECOGNIZED: STATE_RECOGNIZED,\n    STATE_CANCELLED: STATE_CANCELLED,\n    STATE_FAILED: STATE_FAILED,\n\n    DIRECTION_NONE: DIRECTION_NONE,\n    DIRECTION_LEFT: DIRECTION_LEFT,\n    DIRECTION_RIGHT: DIRECTION_RIGHT,\n    DIRECTION_UP: DIRECTION_UP,\n    DIRECTION_DOWN: DIRECTION_DOWN,\n    DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,\n    DIRECTION_VERTICAL: DIRECTION_VERTICAL,\n    DIRECTION_ALL: DIRECTION_ALL,\n\n    Manager: Manager,\n    Input: Input,\n    TouchAction: TouchAction,\n\n    TouchInput: TouchInput,\n    MouseInput: MouseInput,\n    PointerEventInput: PointerEventInput,\n    TouchMouseInput: TouchMouseInput,\n    SingleTouchInput: SingleTouchInput,\n\n    Recognizer: Recognizer,\n    AttrRecognizer: AttrRecognizer,\n    Tap: TapRecognizer,\n    Pan: PanRecognizer,\n    Swipe: SwipeRecognizer,\n    Pinch: PinchRecognizer,\n    Rotate: RotateRecognizer,\n    Press: PressRecognizer,\n\n    on: addEventListeners,\n    off: removeEventListeners,\n    each: each,\n    merge: merge,\n    extend: extend,\n    assign: assign,\n    inherit: inherit,\n    bindFn: bindFn,\n    prefixed: prefixed\n});\n\n// this prevents errors when Hammer is loaded in the presence of an AMD\n//  style loader but by script tag, not by the loader.\nvar freeGlobal = (typeof window !== 'undefined' ? window : (typeof self !== 'undefined' ? self : {})); // jshint ignore:line\nfreeGlobal.Hammer = Hammer;\n\nif (true) {\n    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {\n        return Hammer;\n    }).call(exports, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n} else if (typeof module != 'undefined' && module.exports) {\n    module.exports = Hammer;\n} else {\n    window[exportName] = Hammer;\n}\n\n})(window, document, 'Hammer');\n\n\n/***/ }),\n/* 6 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n\n// EXTERNAL MODULE: ./app/client/src/scss/app.scss\nvar app = __webpack_require__(7);\nvar app_default = /*#__PURE__*/__webpack_require__.n(app);\n\n// EXTERNAL MODULE: ./node_modules/popper.js/dist/esm/popper.js\nvar popper = __webpack_require__(3);\n\n// EXTERNAL MODULE: ./node_modules/bootstrap/js/dist/util.js\nvar util = __webpack_require__(8);\nvar util_default = /*#__PURE__*/__webpack_require__.n(util);\n\n// EXTERNAL MODULE: ./node_modules/bootstrap/js/dist/alert.js\nvar dist_alert = __webpack_require__(9);\nvar alert_default = /*#__PURE__*/__webpack_require__.n(dist_alert);\n\n// EXTERNAL MODULE: ./node_modules/bootstrap/js/dist/button.js\nvar dist_button = __webpack_require__(10);\nvar button_default = /*#__PURE__*/__webpack_require__.n(dist_button);\n\n// EXTERNAL MODULE: ./node_modules/bootstrap/js/dist/carousel.js\nvar carousel = __webpack_require__(11);\nvar carousel_default = /*#__PURE__*/__webpack_require__.n(carousel);\n\n// EXTERNAL MODULE: ./node_modules/bootstrap/js/dist/collapse.js\nvar collapse = __webpack_require__(12);\nvar collapse_default = /*#__PURE__*/__webpack_require__.n(collapse);\n\n// EXTERNAL MODULE: ./node_modules/bootstrap/js/dist/dropdown.js\nvar dropdown = __webpack_require__(13);\nvar dropdown_default = /*#__PURE__*/__webpack_require__.n(dropdown);\n\n// EXTERNAL MODULE: ./node_modules/bootstrap/js/dist/modal.js\nvar modal = __webpack_require__(14);\nvar modal_default = /*#__PURE__*/__webpack_require__.n(modal);\n\n// EXTERNAL MODULE: ./node_modules/bootstrap/js/dist/tooltip.js\nvar tooltip = __webpack_require__(15);\nvar tooltip_default = /*#__PURE__*/__webpack_require__.n(tooltip);\n\n// EXTERNAL MODULE: ./node_modules/bootstrap/js/dist/popover.js\nvar popover = __webpack_require__(16);\nvar popover_default = /*#__PURE__*/__webpack_require__.n(popover);\n\n// EXTERNAL MODULE: ./node_modules/bootstrap/js/dist/scrollspy.js\nvar scrollspy = __webpack_require__(18);\nvar scrollspy_default = /*#__PURE__*/__webpack_require__.n(scrollspy);\n\n// EXTERNAL MODULE: ./node_modules/bootstrap/js/dist/tab.js\nvar tab = __webpack_require__(19);\nvar tab_default = /*#__PURE__*/__webpack_require__.n(tab);\n\n// EXTERNAL MODULE: ./node_modules/offcanvas-bootstrap/dist/js/bootstrap.offcanvas.js\nvar bootstrap_offcanvas = __webpack_require__(20);\nvar bootstrap_offcanvas_default = /*#__PURE__*/__webpack_require__.n(bootstrap_offcanvas);\n\n// EXTERNAL MODULE: external \"jQuery\"\nvar external__jQuery_ = __webpack_require__(0);\nvar external__jQuery__default = /*#__PURE__*/__webpack_require__.n(external__jQuery_);\n\n// EXTERNAL MODULE: ./node_modules/hammerjs/hammer.js\nvar hammer = __webpack_require__(5);\nvar hammer_default = /*#__PURE__*/__webpack_require__.n(hammer);\n\n// EXTERNAL MODULE: ./node_modules/jquery-hammerjs/jquery.hammer.js\nvar jquery_hammer = __webpack_require__(21);\nvar jquery_hammer_default = /*#__PURE__*/__webpack_require__.n(jquery_hammer);\n\n// EXTERNAL MODULE: ./node_modules/pouchdb/dist/pouchdb.js\nvar pouchdb = __webpack_require__(22);\nvar pouchdb_default = /*#__PURE__*/__webpack_require__.n(pouchdb);\n\n// EXTERNAL MODULE: ./app/client/src/js/_components/routes/index.js\nvar routes = __webpack_require__(23);\n\n// EXTERNAL MODULE: ./app/client/src/js/_events.js\nvar _events = __webpack_require__(2);\nvar _events_default = /*#__PURE__*/__webpack_require__.n(_events);\n\n// CONCATENATED MODULE: ./app/client/src/js/_components/_ui.spinner.js\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n\n\nvar SpinnerUI = function ($) {\n  var SpinnerUI = function () {\n    function SpinnerUI() {\n      _classCallCheck(this, SpinnerUI);\n    }\n\n    _createClass(SpinnerUI, null, [{\n      key: 'show',\n      value: function show(callback) {\n        $('#PageLoading').show(0, callback);\n      }\n    }, {\n      key: 'hide',\n      value: function hide(callback) {\n        $('#PageLoading').hide('slow', callback);\n      }\n    }]);\n\n    return SpinnerUI;\n  }();\n\n  return SpinnerUI;\n}(external__jQuery__default.a);\n\n/* harmony default export */ var _ui_spinner = (SpinnerUI);\n// CONCATENATED MODULE: ./app/client/src/js/_components/_ui.carousel.js\nvar _ui_carousel__createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _ui_carousel__classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n\n\n\n\nvar _ui_carousel_CarouselUI = function ($) {\n    // Constants\n    var NAME = 'CarouselUI';\n\n    var CarouselUI = function () {\n        function CarouselUI() {\n            _ui_carousel__classCallCheck(this, CarouselUI);\n        }\n\n        _ui_carousel__createClass(CarouselUI, null, [{\n            key: 'each',\n\n            // Static methods\n\n            value: function each(callback) {\n                $('.js-carousel').each(function (i, e) {\n                    callback(i, $(e));\n                });\n            }\n        }, {\n            key: 'init',\n            value: function init() {\n                this.dispose();\n\n                this.each(function (i, e) {\n                    var $e = $(e),\n                        id = 'Carousel' + i;\n\n                    $e.attr('id', id);\n                    $e.data('id', i);\n\n                    var $items = $(e).find('.carousel-item'),\n                        count = $items.length;\n                    if (!count) {\n                        return;\n                    }\n\n                    // create carousel-controls\n                    if ($e.data('indicators')) {\n                        var $indicators = $('<ol class=\"carousel-indicators\"></ol>');\n                        $indicators.append('<li data-target=\"#' + id + '\" data-slide-to=\"0\" class=\"active\"></li>');\n                        for (var _i = 1; _i < count; _i++) {\n                            $indicators.append('<li data-target=\"#' + id + '\" data-slide-to=\"' + _i + '\"></li>');\n                        }\n                        $e.prepend($indicators);\n                    }\n\n                    // create arrows\n                    if ($e.data('arrows')) {\n                        $e.prepend('<i class=\"carousel-control-prev\" data-target=\"#' + id + '\" role=\"button\" data-slide=\"prev\"><i class=\"fas fa-chevron-left\" aria-hidden=\"true\"></i><i class=\"sr-only\">Previous</i></i>');\n                        $e.prepend('<i class=\"carousel-control-next\" data-target=\"#' + id + '\" role=\"button\" data-slide=\"next\"><i class=\"fas fa-chevron-right\" aria-hidden=\"true\"></i><i class=\"sr-only\">Next</i></i>');\n                    }\n\n                    // init carousel\n                    $e.carousel();\n\n                    // init touch swipes\n                    $e.hammer().bind('swipeleft', function (event) {\n                        $(event.target).carousel('next');\n                    });\n\n                    $e.hammer().bind('swiperight', function (event) {\n                        $(event.target).carousel('prev');\n                    });\n\n                    $e.hammer().bind('panleft', function (event) {\n                        $(event.target).carousel('next');\n                    });\n\n                    $e.hammer().bind('panright', function (event) {\n                        $(event.target).carousel('prev');\n                    });\n\n                    $e.hammer().bind('tap', function (event) {\n                        $(event.target).carousel('next');\n                    });\n                });\n            }\n        }, {\n            key: 'dispose',\n            value: function dispose() {\n                this.each(function (i, e) {\n                    $(e).carousel('dispose');\n                });\n            }\n        }]);\n\n        return CarouselUI;\n    }();\n\n    $(window).on(_events_default.a.AJAX + ' ' + _events_default.a.LOADED, function () {\n        CarouselUI.init();\n    });\n\n    return CarouselUI;\n}(external__jQuery__default.a);\n\n/* harmony default export */ var _ui_carousel = (_ui_carousel_CarouselUI);\n// CONCATENATED MODULE: ./app/client/src/js/_components/_ui.menu.js\nvar _ui_menu__createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _ui_menu__classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n\n\nvar SlidingMenu = function ($) {\n  // Constants\n  var NAME = 'jsSlidingMenu';\n  var DATA_KEY = NAME;\n\n  var SlidingMenu = function () {\n    // Constructor\n    function SlidingMenu(element) {\n      _ui_menu__classCallCheck(this, SlidingMenu);\n\n      this._element = element;\n      var $element = $(this._element);\n      $element.addClass(NAME + '-active');\n\n      // esc button\n      $(window).on('keyup', function (e) {\n        if (e.which === 27) {\n          $element.find('.is-open[data-toggle=\"offcanvas\"]').click();\n        }\n      });\n    }\n\n    // Public methods\n\n\n    _ui_menu__createClass(SlidingMenu, [{\n      key: 'dispose',\n      value: function dispose() {\n        console.log('Disposing: ' + NAME + ' elements');\n\n        $(this._element).removeClass(NAME + '-active');\n        $.removeData(this._element, DATA_KEY);\n        this._element = null;\n      }\n    }], [{\n      key: '_jQueryInterface',\n      value: function _jQueryInterface() {\n        return this.each(function () {\n          // attach functionality to element\n          var $element = $(this);\n          var data = $element.data(DATA_KEY);\n\n          if (!data) {\n            data = new SlidingMenu(this);\n            $element.data(DATA_KEY, data);\n          }\n        });\n      }\n    }]);\n\n    return SlidingMenu;\n  }();\n\n  // jQuery interface\n\n\n  $.fn[NAME] = SlidingMenu._jQueryInterface;\n  $.fn[NAME].Constructor = SlidingMenu;\n  $.fn[NAME].noConflict = function () {\n    $.fn[NAME] = JQUERY_NO_CONFLICT;\n    return SlidingMenu._jQueryInterface;\n  };\n\n  // auto-apply\n  $('.ui.' + NAME).ready(function () {\n    $('.ui.' + NAME).jsSlidingMenu();\n  });\n\n  return SlidingMenu;\n}(external__jQuery__default.a);\n\n/* harmony default export */ var _ui_menu = (SlidingMenu);\n// CONCATENATED MODULE: ./app/client/src/js/_components/_ui.form.storage.js\nvar _ui_form_storage__createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _ui_form_storage__classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n\n\n\nvar _ui_form_storage_FormStorage = function ($) {\n  // Constants\n  var NAME = 'jsFormStorage';\n  var DATA_KEY = NAME;\n  var STORAGE = window.localStorage;\n\n  var FormStorage = function () {\n    // Constructor\n    function FormStorage(element) {\n      _ui_form_storage__classCallCheck(this, FormStorage);\n\n      this._element = element;\n      var $element = $(this._element);\n      var $elements = $element.find('input,textarea');\n\n      $element.addClass(NAME + '-active');\n\n      // restore form data from localStorage\n      $elements.each(function () {\n        var id = $(this).attr('id');\n        var type = $(this).attr('type');\n        var val = STORAGE.getItem(NAME + id);\n\n        if (id && val && type) {\n          if (type && (type === 'checkbox' || type === 'radio')) {\n            $(this).prop('checked', val);\n          } else {\n            $(this).val(val);\n          }\n        }\n      });\n\n      // store form data into localStorage\n      $elements.change(function () {\n        var id = $(this).attr('id');\n        var type = $(this).attr('type');\n        var val = $(this).val();\n\n        if (type && (type === 'checkbox' || type === 'radio')) {\n          val = !!$(this).is(':checked');\n        }\n\n        if (id && type && type !== 'password') {\n          STORAGE.setItem(NAME + id, val);\n        }\n      });\n\n      $element.submit(function () {\n        $element.data(DATA_KEY).clear();\n      });\n\n      $element.find('button,[type=\"submit\"],[type=\"clear\"]').click(function () {\n        $element.data(DATA_KEY).clear();\n      });\n    }\n\n    // Public methods\n\n\n    _ui_form_storage__createClass(FormStorage, [{\n      key: 'dispose',\n      value: function dispose() {\n        var $element = $(this._element);\n\n        $element.removeClass(NAME + '-active');\n        $.removeData(this._element, DATA_KEY);\n        this._element = null;\n      }\n    }, {\n      key: 'clear',\n      value: function clear() {\n        STORAGE.clear();\n      }\n    }], [{\n      key: '_jQueryInterface',\n      value: function _jQueryInterface() {\n        if (typeof window.localStorage !== 'undefined') {\n          return this.each(function () {\n            // attach functionality to element\n            var $element = $(this);\n            var data = $element.data(DATA_KEY);\n\n            if (!data) {\n              data = new FormStorage(this);\n              $element.data(DATA_KEY, data);\n            }\n          });\n        }\n      }\n    }]);\n\n    return FormStorage;\n  }();\n\n  // jQuery interface\n\n\n  $.fn[NAME] = FormStorage._jQueryInterface;\n  $.fn[NAME].Constructor = FormStorage;\n  $.fn[NAME].noConflict = function () {\n    $.fn[NAME] = JQUERY_NO_CONFLICT;\n    return FormStorage._jQueryInterface;\n  };\n\n  // auto-apply\n  $(window).on(_events_default.a.AJAX + ' ' + _events_default.a.LOADED, function () {\n    $('form').jsFormStorage();\n  });\n\n  return FormStorage;\n}(external__jQuery__default.a);\n\n/* harmony default export */ var _ui_form_storage = (_ui_form_storage_FormStorage);\n// CONCATENATED MODULE: ./app/client/src/js/_components/_ui.ajax.js\n\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _ui_ajax__createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _ui_ajax__classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n\n\n\n\nvar _ui_ajax_AjaxUI = function ($) {\n  // Constants\n  var G = window;\n  var D = document;\n  var $Html = $('html');\n  var $Body = $('body');\n\n  var NAME = 'jsAjaxUI';\n  var DATA_KEY = NAME;\n\n  var AjaxUI = function () {\n    // Constructor\n    function AjaxUI(element) {\n      _ui_ajax__classCallCheck(this, AjaxUI);\n\n      this._element = element;\n      var $element = $(this._element);\n      $element.addClass(NAME + '-active');\n\n      $element.bind('click', function (e) {\n        e.preventDefault();\n\n        var $this = $(this);\n\n        $('.ajax').each(function () {\n          var $this = $(this);\n          $this.removeClass('active');\n          $this.parents('.nav-item').removeClass('active');\n        });\n\n        $this.addClass('loading');\n\n        AjaxUI.load($this.attr('href'), function () {\n          $this.removeClass('loading');\n          $this.parents('.nav-item').addClass('active');\n          $this.addClass('active');\n        });\n      });\n    }\n\n    // Public methods\n\n\n    _ui_ajax__createClass(AjaxUI, [{\n      key: 'dispose',\n      value: function dispose() {\n        var $element = $(this._element);\n\n        $element.removeClass(NAME + '-active');\n        $.removeData(this._element, DATA_KEY);\n        this._element = null;\n      }\n    }], [{\n      key: 'load',\n      value: function load(url, callback) {\n        // show spinner\n        _ui_spinner.show(function () {\n          $Body.removeClass('loaded');\n        });\n\n        // update document location\n        G.MainUI.updateLocation(url);\n\n        var absoluteLocation = G.URLDetails['base'] + G.URLDetails['relative'].substring(1);\n        if (absoluteLocation !== G.location.href) {\n          G.history.pushState({\n            ajax: true,\n            page: absoluteLocation\n          }, document.title, absoluteLocation);\n        }\n\n        $.ajax({\n          sync: false,\n          async: true,\n          url: url,\n          dataType: 'json',\n          method: 'GET',\n          cache: false,\n          error: function error(jqXHR) {\n            console.warn('AJAX request failure: ' + jqXHR.statusText);\n            G.location.href = url;\n\n            // google analytics\n            if (typeof G.ga === 'function') {\n              G.ga('send', 'event', 'error', 'AJAX ERROR', jqXHR.statusText);\n            }\n          },\n          success: function success(data, status, jqXHR) {\n            AjaxUI.process(data, jqXHR, callback);\n\n            // google analytics\n            if (typeof G.ga === 'function') {\n              G.ga('set', {\n                page: G.URLDetails['relative'] + G.URLDetails['hash'],\n                title: jqXHR.getResponseHeader('X-Title')\n              });\n              G.ga('send', 'pageview');\n            }\n          }\n        });\n      }\n    }, {\n      key: 'process',\n      value: function process(data, jqXHR, callback) {\n        var _this = this;\n\n        var css = jqXHR.getResponseHeader('X-Include-CSS').split(',') || [];\n        var js = jqXHR.getResponseHeader('X-Include-JS').split(',') || [];\n\n        // Replace HTML regions\n        if (_typeof(data.regions) === 'object') {\n          for (var key in data.regions) {\n            if (typeof data.regions[key] === 'string') {\n              AjaxUI.replaceRegion(data.regions[key], key);\n            }\n          }\n        }\n\n        // remove already loaded scripts\n        $('link[type=\"text/css\"]').each(function () {\n          var i = css.indexOf($(this).attr('href'));\n          if (i > -1) {\n            css.splice(i, 1);\n          } else if (!$Body.data('unload-blocked')) {\n            console.log('Unloading: ' + $(this).attr('href'));\n            $(this).remove();\n          }\n        });\n\n        $('script[type=\"text/javascript\"]').each(function () {\n          var i = js.indexOf($(this).attr('src'));\n          if (i > -1) {\n            js.splice(i, 1);\n          } else if (!$Body.data('unload-blocked')) {\n            console.log('Unloading: ' + $(this).attr('src'));\n            $(this).remove();\n          }\n        });\n\n        // preload CSS\n        this.preload(css).then(function () {\n          var $head = $('head');\n          css.forEach(function (el) {\n            $head.append('<link rel=\"stylesheet\" type=\"text/css\" href=\"' + el + '\" />');\n          });\n\n          // preload JS\n          _this.preload(js, 'script').then(function () {\n\n            js.forEach(function (el) {\n              $Body.append('<script type=\"text/javascript\" charset=\"UTF-8\" src=\"' + el + '\"></script>');\n            });\n\n            console.log('New page is loaded!');\n\n            // trigger events\n            if (_typeof(data.events) === 'object') {\n              for (var eventName in data.events) {\n                $(D).trigger(eventName, [data.events[eventName]]);\n              }\n            }\n\n            if (typeof callback !== 'undefined') {\n              callback();\n            }\n\n            $(G).trigger(_events_default.a.AJAX);\n          });\n        });\n      }\n    }, {\n      key: 'preload',\n      value: function preload(items) {\n        var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'text';\n        var cache = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n\n        if (!items.length) {\n          return $.Deferred().resolve().promise();\n        }\n\n        var dfds = [];\n        items.forEach(function (url) {\n          var dfd = $.Deferred();\n\n          $.ajax({\n            dataType: type,\n            cache: cache,\n            url: url\n          }).always(function () {\n            dfd.resolve();\n          });\n\n          dfds.push(dfd);\n        });\n\n        // return a master promise object which will resolve when all the deferred objects have resolved\n        return $.when.apply($, dfds);\n      }\n    }, {\n      key: 'replaceRegion',\n      value: function replaceRegion(html, key) {\n        var $region = $('[data-ajax-region=\"' + key + '\"]');\n\n        if ($region.length) {\n          $region.empty().append(html);\n        } else {\n          console.warn('Region returned without class or id!');\n        }\n      }\n    }, {\n      key: '_jQueryInterface',\n      value: function _jQueryInterface() {\n        return this.each(function () {\n          // attach functionality to element\n          var $element = $(this);\n          var data = $element.data(DATA_KEY);\n\n          if (!data) {\n            data = new AjaxUI(this);\n            $element.data(DATA_KEY, data);\n          }\n        });\n      }\n    }]);\n\n    return AjaxUI;\n  }();\n\n  // jQuery interface\n\n\n  $.fn[NAME] = AjaxUI._jQueryInterface;\n  $.fn[NAME].Constructor = AjaxUI;\n  $.fn[NAME].noConflict = function () {\n    $.fn[NAME] = JQUERY_NO_CONFLICT;\n    return AjaxUI._jQueryInterface;\n  };\n\n  // auto-apply\n  $('.ajax').ready(function () {\n    $('.ajax').jsAjaxUI();\n  });\n\n  // AJAX update browser title\n  $(D).on('layoutRefresh', function (e, data) {\n    D.title = data.Title;\n\n    $Html.attr('class', '');\n    if (data.ClassName) {\n      $Html.addClass(data.ClassName);\n    }\n    //data.Link = (data.Link === '/home/') ? '/' : data.Link;\n  });\n\n  // Back/Forward functionality\n  G.onpopstate = function (event) {\n    var $existingLink = $('a[href^=\"' + D.location + '\"]');\n\n    if (event.state !== null && event.state.ajax) {\n      console.log('GOBACK (AJAX state)');\n      AjaxUI.load(event.state.page);\n    } else if ($existingLink.length && $existingLink.hasClass('ajax')) {\n      console.log('GOBACK (AJAX link)');\n      $existingLink.trigger('click');\n    } else {\n      console.log('GOBACK (HTTP)');\n      G.location.href = D.location;\n    }\n  };\n\n  return AjaxUI;\n}(external__jQuery__default.a);\n\n/* harmony default export */ var _ui_ajax = (_ui_ajax_AjaxUI);\n// EXTERNAL MODULE: ./node_modules/smooth-scroll/dist/smooth-scroll.min.js\nvar smooth_scroll_min = __webpack_require__(27);\nvar smooth_scroll_min_default = /*#__PURE__*/__webpack_require__.n(smooth_scroll_min);\n\n// CONCATENATED MODULE: ./app/client/src/js/main.js\n\n\nvar main__createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction main__classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n\n\n\n\n\n// Routie\n\n\n\n\n\n\n\n\n\n\n\n\nvar smoothScroll = smooth_scroll_min_default()();\n\nvar main_MainUI = function ($) {\n    // Constants\n    var W = window;\n    var D = document;\n    var $Body = $('body');\n\n    var NAME = 'MainUI';\n\n    // get browser locale\n    //const Locale = $('html').attr('lang').substring(0, 2);\n\n    var $AlertNotify = $('#AlertNotify');\n    var $SiteWideMessage = $('#SiteWideMessage');\n\n    // get browser window visibility preferences\n    // Opera 12.10, Firefox >=18, Chrome >=31, IE11\n    var HiddenName = 'hidden';\n    var VisibilityChangeEvent = 'visibilitychange';\n\n    // update visibility state\n    D.addEventListener(VisibilityChangeEvent, function () {\n        if (D.visibilityState === HiddenName) {\n            console.log('Tab: hidden');\n            $Body.addClass('is-hidden');\n            $Body.trigger('tabHidden');\n        } else {\n            console.log('Tab: focused');\n            $Body.removeClass('is-hidden');\n            $Body.trigger('tabFocused');\n        }\n    });\n\n    // update online/offline state\n    var updateOnlineStatus = function updateOnlineStatus() {\n        if (!navigator.onLine) {\n            console.log('Tab: offline');\n            $Body.addClass('is-offline');\n            $Body.trigger('offline');\n        } else {\n            console.log('Tab: online');\n            $Body.removeClass('is-offline');\n            $Body.trigger('online');\n        }\n    };\n\n    if (typeof navigator.onLine !== 'undefined') {\n        W.addEventListener('offline', function () {\n            updateOnlineStatus();\n        }, false);\n\n        W.addEventListener('online', function () {\n            updateOnlineStatus();\n        }, false);\n\n        W.addEventListener('load', function () {\n            updateOnlineStatus();\n        });\n    }\n\n    // scrollTo\n    var ScrollTo = function ScrollTo(trigger, selector) {\n        smoothScroll.animateScroll(D.querySelector(selector), trigger, {\n            speed: 500,\n            offset: -20\n            //easing: 'easeInOutCubic',\n            // Callback API\n            //before: function (anchor, toggle) {}, // Callback to run before scroll\n            //`after: function (anchor, toggle) {} // Callback to run after scroll\n        });\n    };\n\n    // session ping\n    setInterval(function () {\n        if ($Body.hasClass('is-offline')) {\n            return;\n        }\n\n        $.ajax({\n            sync: false,\n            async: true,\n            cache: false,\n            url: '/Security/ping',\n            global: false,\n            type: 'POST',\n            complete: function complete(data, datastatus) {\n                if (datastatus !== 'success') {\n                    W.location.reload(false);\n                }\n            }\n        });\n    }, 300000); // 5 min in ms\n\n    W.URLDetails = {\n        'base': $('base').attr('href'),\n        'relative': '/',\n        'hash': ''\n    };\n\n    var MainUI = function () {\n        function MainUI() {\n            main__classCallCheck(this, MainUI);\n        }\n\n        main__createClass(MainUI, null, [{\n            key: 'init',\n\n            // Static methods\n\n            value: function init() {\n                this.dispose();\n\n                console.log('Initializing: ' + NAME);\n\n                // update location details\n                this.updateLocation();\n\n                // mark available offline areas\n                if ('caches' in W) {\n                    $('a.offline').addClass('offline-available');\n                }\n\n                this.loadImages();\n\n                // mark external links\n                $('a.external,a[rel=\"external\"]').attr('target', '_blank');\n\n                // show encoded emails\n                /*$(D).find('.obm').each(function () {\n                  if ($(this).attr('data-val') !== undefined) {\n                    const email = $(this).attr('data-val').split('')\n                      .reverse()\n                      .join('')\n                      .slice(0, -8)\n                      .replace(/[a-zA-Z]/g, (c) => String.fromCharCode((c <= 'Z' ? 90 : 122) >= (c = c.charCodeAt(0) + 13) ? c : c - 26))\n                      .replace('#AT#', '@');\n                    const attr = $(this).attr('data-val-append');\n                    if (attr !== undefined && attr !== false) {\n                      $(this).append(email);\n                    }\n                    if ($(this).find('.sr-only').length > 0) {\n                      $(this).find('.sr-only').append(email);\n                    }\n                    if ($(this).attr('href') !== undefined) {\n                      $(this).attr('href', `mailto:${email}`);\n                    }\n                  }\n                });*/\n                //\n\n                // scroll links\n                $(D).on('click', '.js-scrollTo', function (e) {\n                    e.preventDefault();\n                    ScrollTo(this, $(this).attr('data-target'));\n                });\n\n                // load external fonts\n                if ($('[data-extfont]').length) {\n                    $.getScript('//ajax.googleapis.com/ajax/libs/webfont/1/webfont.js', function () {\n                        var fonts = [];\n                        $('[data-extfont]').each(function (i) {\n                            fonts[i] = $(this).attr('data-extfont');\n                        });\n                        W.WebFont.load({\n                            google: {\n                                families: fonts\n                            }\n                        });\n                    });\n                }\n\n                // hide spinner\n                _ui_spinner.hide(function () {\n                    $Body.addClass('loaded');\n                });\n\n                // fire page printing\n                if (W.URLDetails['hash'].indexOf('printpage') > -1) {\n                    W.print();\n                }\n            }\n        }, {\n            key: 'updateLocation',\n            value: function updateLocation(url) {\n                var location = url || W.location.href;\n                location = location.replace(W.URLDetails['base'], '/');\n                var hash = location.indexOf('#');\n\n                W.URLDetails.relative = location.split('#')[0];\n                W.URLDetails.hash = hash >= 0 ? location.substr(location.indexOf('#')) : '';\n            }\n\n            // show site-wide alert\n\n        }, {\n            key: 'alert',\n            value: function alert(msg, cls) {\n                $SiteWideMessage.fadeOut('fast');\n\n                $SiteWideMessage.html('<div class=\"page-alert\"><div class=\"alert alert-' + cls + '\"><i class=\"close\" data-dismiss=\"alert\">&times;</i>' + msg + '</div></div>');\n                $SiteWideMessage.find('.page-alert').alert();\n\n                $SiteWideMessage.find('.close[data-dismiss=\"alert\"]').click(function () {\n                    $SiteWideMessage.fadeOut('slow', function () {\n                        $SiteWideMessage.find('.page-alert').alert('close');\n                    });\n                });\n\n                $SiteWideMessage.fadeIn('slow');\n\n                if ($AlertNotify.length) {\n                    $AlertNotify[0].play();\n                }\n\n                $(W).trigger('alert-appeared');\n            }\n\n            // hide site-wide alert\n\n        }, {\n            key: 'alertHide',\n            value: function alertHide() {\n                if ($SiteWideMessage.length !== 0) {\n                    $SiteWideMessage.fadeOut('slow', function () {\n                        $SiteWideMessage.find('.alert').alert('close');\n                    });\n                }\n\n                if ($AlertNotify.length && typeof $AlertNotify[0].stop !== 'undefined') {\n                    $AlertNotify[0].stop();\n                }\n\n                $(W).trigger('alert-removed');\n            }\n\n            // load all images\n\n        }, {\n            key: 'loadImages',\n            value: function loadImages() {\n                var $imgs = $Body.find('img');\n                var $imgUrls = [];\n                var $imgLazyUrls = [];\n\n                // collect image details\n                $imgs.each(function () {\n                    var src = $(this).attr('src');\n                    var lazySrc = $(this).data('lazy-src');\n                    if (src.length) {\n                        $imgUrls.push(src);\n                    }\n                    if (lazySrc) {\n                        $imgLazyUrls.push(lazySrc);\n                    }\n                });\n\n                // load defined images\n                _ui_ajax.preload($imgUrls).then(function () {\n                    $(W).trigger('images-loaded');\n\n                    // load lazy images\n                    _ui_ajax.preload($imgLazyUrls).then(function () {\n                        // update lazy img src\n                        $('img[data-lazy-src]').each(function () {\n                            if (!$(this).attr('src')) {\n                                return;\n                            }\n                            $(this).attr('src', $(this).data('lazy-src'));\n                        });\n\n                        console.log('All images are loaded!');\n\n                        $(W).trigger('images-lazy-loaded');\n                    });\n                });\n            }\n        }, {\n            key: 'dispose',\n            value: function dispose() {\n                console.log('Destroying: ' + NAME);\n            }\n        }]);\n\n        return MainUI;\n    }();\n\n    $(W).on(_events_default.a.AJAX + ' ' + _events_default.a.LOADED, function () {\n        MainUI.init();\n    });\n\n    W.MainUI = MainUI;\n\n    return MainUI;\n}(external__jQuery__default.a);\n\n/* harmony default export */ var main = (main_MainUI);\n// CONCATENATED MODULE: ./app/client/src/js/app.js\n\n\n// import Bootstrap\n\n\n\n\n\n\n\n\n\n\n\n\n//\n\n//import Vue from 'vue/dist/vue.esm.js';\n\n// import Bootstrap-Vue\n/*import { Carousel } from 'bootstrap-vue/es/components';\nVue.use(Carousel);*/\n\n\n\n// import your custom UI components\n\n\nfunction importAll(r) {\n    return r.keys().map(r);\n}\n\nvar app_images = importAll(__webpack_require__(28));\nvar fontAwesome = importAll(__webpack_require__(32));\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports) {\n\n// removed by extract-text-webpack-plugin\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function($) {/**\n * --------------------------------------------------------------------------\n * Bootstrap (v4.1.1): util.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n * --------------------------------------------------------------------------\n */\nvar Util = function ($) {\n  /**\n   * ------------------------------------------------------------------------\n   * Private TransitionEnd Helpers\n   * ------------------------------------------------------------------------\n   */\n  var TRANSITION_END = 'transitionend';\n  var MAX_UID = 1000000;\n  var MILLISECONDS_MULTIPLIER = 1000; // Shoutout AngusCroll (https://goo.gl/pxwQGp)\n\n  function toType(obj) {\n    return {}.toString.call(obj).match(/\\s([a-z]+)/i)[1].toLowerCase();\n  }\n\n  function getSpecialTransitionEndEvent() {\n    return {\n      bindType: TRANSITION_END,\n      delegateType: TRANSITION_END,\n      handle: function handle(event) {\n        if ($(event.target).is(this)) {\n          return event.handleObj.handler.apply(this, arguments); // eslint-disable-line prefer-rest-params\n        }\n\n        return undefined; // eslint-disable-line no-undefined\n      }\n    };\n  }\n\n  function transitionEndEmulator(duration) {\n    var _this = this;\n\n    var called = false;\n    $(this).one(Util.TRANSITION_END, function () {\n      called = true;\n    });\n    setTimeout(function () {\n      if (!called) {\n        Util.triggerTransitionEnd(_this);\n      }\n    }, duration);\n    return this;\n  }\n\n  function setTransitionEndSupport() {\n    $.fn.emulateTransitionEnd = transitionEndEmulator;\n    $.event.special[Util.TRANSITION_END] = getSpecialTransitionEndEvent();\n  }\n  /**\n   * --------------------------------------------------------------------------\n   * Public Util Api\n   * --------------------------------------------------------------------------\n   */\n\n\n  var Util = {\n    TRANSITION_END: 'bsTransitionEnd',\n    getUID: function getUID(prefix) {\n      do {\n        // eslint-disable-next-line no-bitwise\n        prefix += ~~(Math.random() * MAX_UID); // \"~~\" acts like a faster Math.floor() here\n      } while (document.getElementById(prefix));\n\n      return prefix;\n    },\n    getSelectorFromElement: function getSelectorFromElement(element) {\n      var selector = element.getAttribute('data-target');\n\n      if (!selector || selector === '#') {\n        selector = element.getAttribute('href') || '';\n      }\n\n      try {\n        var $selector = $(document).find(selector);\n        return $selector.length > 0 ? selector : null;\n      } catch (err) {\n        return null;\n      }\n    },\n    getTransitionDurationFromElement: function getTransitionDurationFromElement(element) {\n      if (!element) {\n        return 0;\n      } // Get transition-duration of the element\n\n\n      var transitionDuration = $(element).css('transition-duration');\n      var floatTransitionDuration = parseFloat(transitionDuration); // Return 0 if element or transition duration is not found\n\n      if (!floatTransitionDuration) {\n        return 0;\n      } // If multiple durations are defined, take the first\n\n\n      transitionDuration = transitionDuration.split(',')[0];\n      return parseFloat(transitionDuration) * MILLISECONDS_MULTIPLIER;\n    },\n    reflow: function reflow(element) {\n      return element.offsetHeight;\n    },\n    triggerTransitionEnd: function triggerTransitionEnd(element) {\n      $(element).trigger(TRANSITION_END);\n    },\n    // TODO: Remove in v5\n    supportsTransitionEnd: function supportsTransitionEnd() {\n      return Boolean(TRANSITION_END);\n    },\n    isElement: function isElement(obj) {\n      return (obj[0] || obj).nodeType;\n    },\n    typeCheckConfig: function typeCheckConfig(componentName, config, configTypes) {\n      for (var property in configTypes) {\n        if (Object.prototype.hasOwnProperty.call(configTypes, property)) {\n          var expectedTypes = configTypes[property];\n          var value = config[property];\n          var valueType = value && Util.isElement(value) ? 'element' : toType(value);\n\n          if (!new RegExp(expectedTypes).test(valueType)) {\n            throw new Error(componentName.toUpperCase() + \": \" + (\"Option \\\"\" + property + \"\\\" provided type \\\"\" + valueType + \"\\\" \") + (\"but expected type \\\"\" + expectedTypes + \"\\\".\"));\n          }\n        }\n      }\n    }\n  };\n  setTransitionEndSupport();\n  return Util;\n}($);\n//# sourceMappingURL=util.js.map\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function($, Util) {function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\n * --------------------------------------------------------------------------\n * Bootstrap (v4.1.1): alert.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n * --------------------------------------------------------------------------\n */\nvar Alert = function ($) {\n  /**\n   * ------------------------------------------------------------------------\n   * Constants\n   * ------------------------------------------------------------------------\n   */\n  var NAME = 'alert';\n  var VERSION = '4.1.1';\n  var DATA_KEY = 'bs.alert';\n  var EVENT_KEY = \".\" + DATA_KEY;\n  var DATA_API_KEY = '.data-api';\n  var JQUERY_NO_CONFLICT = $.fn[NAME];\n  var Selector = {\n    DISMISS: '[data-dismiss=\"alert\"]'\n  };\n  var Event = {\n    CLOSE: \"close\" + EVENT_KEY,\n    CLOSED: \"closed\" + EVENT_KEY,\n    CLICK_DATA_API: \"click\" + EVENT_KEY + DATA_API_KEY\n  };\n  var ClassName = {\n    ALERT: 'alert',\n    FADE: 'fade',\n    SHOW: 'show'\n    /**\n     * ------------------------------------------------------------------------\n     * Class Definition\n     * ------------------------------------------------------------------------\n     */\n\n  };\n\n  var Alert =\n  /*#__PURE__*/\n  function () {\n    function Alert(element) {\n      this._element = element;\n    } // Getters\n\n\n    var _proto = Alert.prototype;\n\n    // Public\n    _proto.close = function close(element) {\n      var rootElement = this._element;\n\n      if (element) {\n        rootElement = this._getRootElement(element);\n      }\n\n      var customEvent = this._triggerCloseEvent(rootElement);\n\n      if (customEvent.isDefaultPrevented()) {\n        return;\n      }\n\n      this._removeElement(rootElement);\n    };\n\n    _proto.dispose = function dispose() {\n      $.removeData(this._element, DATA_KEY);\n      this._element = null;\n    }; // Private\n\n\n    _proto._getRootElement = function _getRootElement(element) {\n      var selector = Util.getSelectorFromElement(element);\n      var parent = false;\n\n      if (selector) {\n        parent = $(selector)[0];\n      }\n\n      if (!parent) {\n        parent = $(element).closest(\".\" + ClassName.ALERT)[0];\n      }\n\n      return parent;\n    };\n\n    _proto._triggerCloseEvent = function _triggerCloseEvent(element) {\n      var closeEvent = $.Event(Event.CLOSE);\n      $(element).trigger(closeEvent);\n      return closeEvent;\n    };\n\n    _proto._removeElement = function _removeElement(element) {\n      var _this = this;\n\n      $(element).removeClass(ClassName.SHOW);\n\n      if (!$(element).hasClass(ClassName.FADE)) {\n        this._destroyElement(element);\n\n        return;\n      }\n\n      var transitionDuration = Util.getTransitionDurationFromElement(element);\n      $(element).one(Util.TRANSITION_END, function (event) {\n        return _this._destroyElement(element, event);\n      }).emulateTransitionEnd(transitionDuration);\n    };\n\n    _proto._destroyElement = function _destroyElement(element) {\n      $(element).detach().trigger(Event.CLOSED).remove();\n    }; // Static\n\n\n    Alert._jQueryInterface = function _jQueryInterface(config) {\n      return this.each(function () {\n        var $element = $(this);\n        var data = $element.data(DATA_KEY);\n\n        if (!data) {\n          data = new Alert(this);\n          $element.data(DATA_KEY, data);\n        }\n\n        if (config === 'close') {\n          data[config](this);\n        }\n      });\n    };\n\n    Alert._handleDismiss = function _handleDismiss(alertInstance) {\n      return function (event) {\n        if (event) {\n          event.preventDefault();\n        }\n\n        alertInstance.close(this);\n      };\n    };\n\n    _createClass(Alert, null, [{\n      key: \"VERSION\",\n      get: function get() {\n        return VERSION;\n      }\n    }]);\n\n    return Alert;\n  }();\n  /**\n   * ------------------------------------------------------------------------\n   * Data Api implementation\n   * ------------------------------------------------------------------------\n   */\n\n\n  $(document).on(Event.CLICK_DATA_API, Selector.DISMISS, Alert._handleDismiss(new Alert()));\n  /**\n   * ------------------------------------------------------------------------\n   * jQuery\n   * ------------------------------------------------------------------------\n   */\n\n  $.fn[NAME] = Alert._jQueryInterface;\n  $.fn[NAME].Constructor = Alert;\n\n  $.fn[NAME].noConflict = function () {\n    $.fn[NAME] = JQUERY_NO_CONFLICT;\n    return Alert._jQueryInterface;\n  };\n\n  return Alert;\n}($);\n//# sourceMappingURL=alert.js.map\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0), __webpack_require__(1)))\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function($) {function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\n * --------------------------------------------------------------------------\n * Bootstrap (v4.1.1): button.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n * --------------------------------------------------------------------------\n */\nvar Button = function ($) {\n  /**\n   * ------------------------------------------------------------------------\n   * Constants\n   * ------------------------------------------------------------------------\n   */\n  var NAME = 'button';\n  var VERSION = '4.1.1';\n  var DATA_KEY = 'bs.button';\n  var EVENT_KEY = \".\" + DATA_KEY;\n  var DATA_API_KEY = '.data-api';\n  var JQUERY_NO_CONFLICT = $.fn[NAME];\n  var ClassName = {\n    ACTIVE: 'active',\n    BUTTON: 'btn',\n    FOCUS: 'focus'\n  };\n  var Selector = {\n    DATA_TOGGLE_CARROT: '[data-toggle^=\"button\"]',\n    DATA_TOGGLE: '[data-toggle=\"buttons\"]',\n    INPUT: 'input',\n    ACTIVE: '.active',\n    BUTTON: '.btn'\n  };\n  var Event = {\n    CLICK_DATA_API: \"click\" + EVENT_KEY + DATA_API_KEY,\n    FOCUS_BLUR_DATA_API: \"focus\" + EVENT_KEY + DATA_API_KEY + \" \" + (\"blur\" + EVENT_KEY + DATA_API_KEY)\n    /**\n     * ------------------------------------------------------------------------\n     * Class Definition\n     * ------------------------------------------------------------------------\n     */\n\n  };\n\n  var Button =\n  /*#__PURE__*/\n  function () {\n    function Button(element) {\n      this._element = element;\n    } // Getters\n\n\n    var _proto = Button.prototype;\n\n    // Public\n    _proto.toggle = function toggle() {\n      var triggerChangeEvent = true;\n      var addAriaPressed = true;\n      var rootElement = $(this._element).closest(Selector.DATA_TOGGLE)[0];\n\n      if (rootElement) {\n        var input = $(this._element).find(Selector.INPUT)[0];\n\n        if (input) {\n          if (input.type === 'radio') {\n            if (input.checked && $(this._element).hasClass(ClassName.ACTIVE)) {\n              triggerChangeEvent = false;\n            } else {\n              var activeElement = $(rootElement).find(Selector.ACTIVE)[0];\n\n              if (activeElement) {\n                $(activeElement).removeClass(ClassName.ACTIVE);\n              }\n            }\n          }\n\n          if (triggerChangeEvent) {\n            if (input.hasAttribute('disabled') || rootElement.hasAttribute('disabled') || input.classList.contains('disabled') || rootElement.classList.contains('disabled')) {\n              return;\n            }\n\n            input.checked = !$(this._element).hasClass(ClassName.ACTIVE);\n            $(input).trigger('change');\n          }\n\n          input.focus();\n          addAriaPressed = false;\n        }\n      }\n\n      if (addAriaPressed) {\n        this._element.setAttribute('aria-pressed', !$(this._element).hasClass(ClassName.ACTIVE));\n      }\n\n      if (triggerChangeEvent) {\n        $(this._element).toggleClass(ClassName.ACTIVE);\n      }\n    };\n\n    _proto.dispose = function dispose() {\n      $.removeData(this._element, DATA_KEY);\n      this._element = null;\n    }; // Static\n\n\n    Button._jQueryInterface = function _jQueryInterface(config) {\n      return this.each(function () {\n        var data = $(this).data(DATA_KEY);\n\n        if (!data) {\n          data = new Button(this);\n          $(this).data(DATA_KEY, data);\n        }\n\n        if (config === 'toggle') {\n          data[config]();\n        }\n      });\n    };\n\n    _createClass(Button, null, [{\n      key: \"VERSION\",\n      get: function get() {\n        return VERSION;\n      }\n    }]);\n\n    return Button;\n  }();\n  /**\n   * ------------------------------------------------------------------------\n   * Data Api implementation\n   * ------------------------------------------------------------------------\n   */\n\n\n  $(document).on(Event.CLICK_DATA_API, Selector.DATA_TOGGLE_CARROT, function (event) {\n    event.preventDefault();\n    var button = event.target;\n\n    if (!$(button).hasClass(ClassName.BUTTON)) {\n      button = $(button).closest(Selector.BUTTON);\n    }\n\n    Button._jQueryInterface.call($(button), 'toggle');\n  }).on(Event.FOCUS_BLUR_DATA_API, Selector.DATA_TOGGLE_CARROT, function (event) {\n    var button = $(event.target).closest(Selector.BUTTON)[0];\n    $(button).toggleClass(ClassName.FOCUS, /^focus(in)?$/.test(event.type));\n  });\n  /**\n   * ------------------------------------------------------------------------\n   * jQuery\n   * ------------------------------------------------------------------------\n   */\n\n  $.fn[NAME] = Button._jQueryInterface;\n  $.fn[NAME].Constructor = Button;\n\n  $.fn[NAME].noConflict = function () {\n    $.fn[NAME] = JQUERY_NO_CONFLICT;\n    return Button._jQueryInterface;\n  };\n\n  return Button;\n}($);\n//# sourceMappingURL=button.js.map\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function($, Util) {function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\n * --------------------------------------------------------------------------\n * Bootstrap (v4.1.1): carousel.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n * --------------------------------------------------------------------------\n */\nvar Carousel = function ($) {\n  /**\n   * ------------------------------------------------------------------------\n   * Constants\n   * ------------------------------------------------------------------------\n   */\n  var NAME = 'carousel';\n  var VERSION = '4.1.1';\n  var DATA_KEY = 'bs.carousel';\n  var EVENT_KEY = \".\" + DATA_KEY;\n  var DATA_API_KEY = '.data-api';\n  var JQUERY_NO_CONFLICT = $.fn[NAME];\n  var ARROW_LEFT_KEYCODE = 37; // KeyboardEvent.which value for left arrow key\n\n  var ARROW_RIGHT_KEYCODE = 39; // KeyboardEvent.which value for right arrow key\n\n  var TOUCHEVENT_COMPAT_WAIT = 500; // Time for mouse compat events to fire after touch\n\n  var Default = {\n    interval: 5000,\n    keyboard: true,\n    slide: false,\n    pause: 'hover',\n    wrap: true\n  };\n  var DefaultType = {\n    interval: '(number|boolean)',\n    keyboard: 'boolean',\n    slide: '(boolean|string)',\n    pause: '(string|boolean)',\n    wrap: 'boolean'\n  };\n  var Direction = {\n    NEXT: 'next',\n    PREV: 'prev',\n    LEFT: 'left',\n    RIGHT: 'right'\n  };\n  var Event = {\n    SLIDE: \"slide\" + EVENT_KEY,\n    SLID: \"slid\" + EVENT_KEY,\n    KEYDOWN: \"keydown\" + EVENT_KEY,\n    MOUSEENTER: \"mouseenter\" + EVENT_KEY,\n    MOUSELEAVE: \"mouseleave\" + EVENT_KEY,\n    TOUCHEND: \"touchend\" + EVENT_KEY,\n    LOAD_DATA_API: \"load\" + EVENT_KEY + DATA_API_KEY,\n    CLICK_DATA_API: \"click\" + EVENT_KEY + DATA_API_KEY\n  };\n  var ClassName = {\n    CAROUSEL: 'carousel',\n    ACTIVE: 'active',\n    SLIDE: 'slide',\n    RIGHT: 'carousel-item-right',\n    LEFT: 'carousel-item-left',\n    NEXT: 'carousel-item-next',\n    PREV: 'carousel-item-prev',\n    ITEM: 'carousel-item'\n  };\n  var Selector = {\n    ACTIVE: '.active',\n    ACTIVE_ITEM: '.active.carousel-item',\n    ITEM: '.carousel-item',\n    NEXT_PREV: '.carousel-item-next, .carousel-item-prev',\n    INDICATORS: '.carousel-indicators',\n    DATA_SLIDE: '[data-slide], [data-slide-to]',\n    DATA_RIDE: '[data-ride=\"carousel\"]'\n    /**\n     * ------------------------------------------------------------------------\n     * Class Definition\n     * ------------------------------------------------------------------------\n     */\n\n  };\n\n  var Carousel =\n  /*#__PURE__*/\n  function () {\n    function Carousel(element, config) {\n      this._items = null;\n      this._interval = null;\n      this._activeElement = null;\n      this._isPaused = false;\n      this._isSliding = false;\n      this.touchTimeout = null;\n      this._config = this._getConfig(config);\n      this._element = $(element)[0];\n      this._indicatorsElement = $(this._element).find(Selector.INDICATORS)[0];\n\n      this._addEventListeners();\n    } // Getters\n\n\n    var _proto = Carousel.prototype;\n\n    // Public\n    _proto.next = function next() {\n      if (!this._isSliding) {\n        this._slide(Direction.NEXT);\n      }\n    };\n\n    _proto.nextWhenVisible = function nextWhenVisible() {\n      // Don't call next when the page isn't visible\n      // or the carousel or its parent isn't visible\n      if (!document.hidden && $(this._element).is(':visible') && $(this._element).css('visibility') !== 'hidden') {\n        this.next();\n      }\n    };\n\n    _proto.prev = function prev() {\n      if (!this._isSliding) {\n        this._slide(Direction.PREV);\n      }\n    };\n\n    _proto.pause = function pause(event) {\n      if (!event) {\n        this._isPaused = true;\n      }\n\n      if ($(this._element).find(Selector.NEXT_PREV)[0]) {\n        Util.triggerTransitionEnd(this._element);\n        this.cycle(true);\n      }\n\n      clearInterval(this._interval);\n      this._interval = null;\n    };\n\n    _proto.cycle = function cycle(event) {\n      if (!event) {\n        this._isPaused = false;\n      }\n\n      if (this._interval) {\n        clearInterval(this._interval);\n        this._interval = null;\n      }\n\n      if (this._config.interval && !this._isPaused) {\n        this._interval = setInterval((document.visibilityState ? this.nextWhenVisible : this.next).bind(this), this._config.interval);\n      }\n    };\n\n    _proto.to = function to(index) {\n      var _this = this;\n\n      this._activeElement = $(this._element).find(Selector.ACTIVE_ITEM)[0];\n\n      var activeIndex = this._getItemIndex(this._activeElement);\n\n      if (index > this._items.length - 1 || index < 0) {\n        return;\n      }\n\n      if (this._isSliding) {\n        $(this._element).one(Event.SLID, function () {\n          return _this.to(index);\n        });\n        return;\n      }\n\n      if (activeIndex === index) {\n        this.pause();\n        this.cycle();\n        return;\n      }\n\n      var direction = index > activeIndex ? Direction.NEXT : Direction.PREV;\n\n      this._slide(direction, this._items[index]);\n    };\n\n    _proto.dispose = function dispose() {\n      $(this._element).off(EVENT_KEY);\n      $.removeData(this._element, DATA_KEY);\n      this._items = null;\n      this._config = null;\n      this._element = null;\n      this._interval = null;\n      this._isPaused = null;\n      this._isSliding = null;\n      this._activeElement = null;\n      this._indicatorsElement = null;\n    }; // Private\n\n\n    _proto._getConfig = function _getConfig(config) {\n      config = _objectSpread({}, Default, config);\n      Util.typeCheckConfig(NAME, config, DefaultType);\n      return config;\n    };\n\n    _proto._addEventListeners = function _addEventListeners() {\n      var _this2 = this;\n\n      if (this._config.keyboard) {\n        $(this._element).on(Event.KEYDOWN, function (event) {\n          return _this2._keydown(event);\n        });\n      }\n\n      if (this._config.pause === 'hover') {\n        $(this._element).on(Event.MOUSEENTER, function (event) {\n          return _this2.pause(event);\n        }).on(Event.MOUSELEAVE, function (event) {\n          return _this2.cycle(event);\n        });\n\n        if ('ontouchstart' in document.documentElement) {\n          // If it's a touch-enabled device, mouseenter/leave are fired as\n          // part of the mouse compatibility events on first tap - the carousel\n          // would stop cycling until user tapped out of it;\n          // here, we listen for touchend, explicitly pause the carousel\n          // (as if it's the second time we tap on it, mouseenter compat event\n          // is NOT fired) and after a timeout (to allow for mouse compatibility\n          // events to fire) we explicitly restart cycling\n          $(this._element).on(Event.TOUCHEND, function () {\n            _this2.pause();\n\n            if (_this2.touchTimeout) {\n              clearTimeout(_this2.touchTimeout);\n            }\n\n            _this2.touchTimeout = setTimeout(function (event) {\n              return _this2.cycle(event);\n            }, TOUCHEVENT_COMPAT_WAIT + _this2._config.interval);\n          });\n        }\n      }\n    };\n\n    _proto._keydown = function _keydown(event) {\n      if (/input|textarea/i.test(event.target.tagName)) {\n        return;\n      }\n\n      switch (event.which) {\n        case ARROW_LEFT_KEYCODE:\n          event.preventDefault();\n          this.prev();\n          break;\n\n        case ARROW_RIGHT_KEYCODE:\n          event.preventDefault();\n          this.next();\n          break;\n\n        default:\n      }\n    };\n\n    _proto._getItemIndex = function _getItemIndex(element) {\n      this._items = $.makeArray($(element).parent().find(Selector.ITEM));\n      return this._items.indexOf(element);\n    };\n\n    _proto._getItemByDirection = function _getItemByDirection(direction, activeElement) {\n      var isNextDirection = direction === Direction.NEXT;\n      var isPrevDirection = direction === Direction.PREV;\n\n      var activeIndex = this._getItemIndex(activeElement);\n\n      var lastItemIndex = this._items.length - 1;\n      var isGoingToWrap = isPrevDirection && activeIndex === 0 || isNextDirection && activeIndex === lastItemIndex;\n\n      if (isGoingToWrap && !this._config.wrap) {\n        return activeElement;\n      }\n\n      var delta = direction === Direction.PREV ? -1 : 1;\n      var itemIndex = (activeIndex + delta) % this._items.length;\n      return itemIndex === -1 ? this._items[this._items.length - 1] : this._items[itemIndex];\n    };\n\n    _proto._triggerSlideEvent = function _triggerSlideEvent(relatedTarget, eventDirectionName) {\n      var targetIndex = this._getItemIndex(relatedTarget);\n\n      var fromIndex = this._getItemIndex($(this._element).find(Selector.ACTIVE_ITEM)[0]);\n\n      var slideEvent = $.Event(Event.SLIDE, {\n        relatedTarget: relatedTarget,\n        direction: eventDirectionName,\n        from: fromIndex,\n        to: targetIndex\n      });\n      $(this._element).trigger(slideEvent);\n      return slideEvent;\n    };\n\n    _proto._setActiveIndicatorElement = function _setActiveIndicatorElement(element) {\n      if (this._indicatorsElement) {\n        $(this._indicatorsElement).find(Selector.ACTIVE).removeClass(ClassName.ACTIVE);\n\n        var nextIndicator = this._indicatorsElement.children[this._getItemIndex(element)];\n\n        if (nextIndicator) {\n          $(nextIndicator).addClass(ClassName.ACTIVE);\n        }\n      }\n    };\n\n    _proto._slide = function _slide(direction, element) {\n      var _this3 = this;\n\n      var activeElement = $(this._element).find(Selector.ACTIVE_ITEM)[0];\n\n      var activeElementIndex = this._getItemIndex(activeElement);\n\n      var nextElement = element || activeElement && this._getItemByDirection(direction, activeElement);\n\n      var nextElementIndex = this._getItemIndex(nextElement);\n\n      var isCycling = Boolean(this._interval);\n      var directionalClassName;\n      var orderClassName;\n      var eventDirectionName;\n\n      if (direction === Direction.NEXT) {\n        directionalClassName = ClassName.LEFT;\n        orderClassName = ClassName.NEXT;\n        eventDirectionName = Direction.LEFT;\n      } else {\n        directionalClassName = ClassName.RIGHT;\n        orderClassName = ClassName.PREV;\n        eventDirectionName = Direction.RIGHT;\n      }\n\n      if (nextElement && $(nextElement).hasClass(ClassName.ACTIVE)) {\n        this._isSliding = false;\n        return;\n      }\n\n      var slideEvent = this._triggerSlideEvent(nextElement, eventDirectionName);\n\n      if (slideEvent.isDefaultPrevented()) {\n        return;\n      }\n\n      if (!activeElement || !nextElement) {\n        // Some weirdness is happening, so we bail\n        return;\n      }\n\n      this._isSliding = true;\n\n      if (isCycling) {\n        this.pause();\n      }\n\n      this._setActiveIndicatorElement(nextElement);\n\n      var slidEvent = $.Event(Event.SLID, {\n        relatedTarget: nextElement,\n        direction: eventDirectionName,\n        from: activeElementIndex,\n        to: nextElementIndex\n      });\n\n      if ($(this._element).hasClass(ClassName.SLIDE)) {\n        $(nextElement).addClass(orderClassName);\n        Util.reflow(nextElement);\n        $(activeElement).addClass(directionalClassName);\n        $(nextElement).addClass(directionalClassName);\n        var transitionDuration = Util.getTransitionDurationFromElement(activeElement);\n        $(activeElement).one(Util.TRANSITION_END, function () {\n          $(nextElement).removeClass(directionalClassName + \" \" + orderClassName).addClass(ClassName.ACTIVE);\n          $(activeElement).removeClass(ClassName.ACTIVE + \" \" + orderClassName + \" \" + directionalClassName);\n          _this3._isSliding = false;\n          setTimeout(function () {\n            return $(_this3._element).trigger(slidEvent);\n          }, 0);\n        }).emulateTransitionEnd(transitionDuration);\n      } else {\n        $(activeElement).removeClass(ClassName.ACTIVE);\n        $(nextElement).addClass(ClassName.ACTIVE);\n        this._isSliding = false;\n        $(this._element).trigger(slidEvent);\n      }\n\n      if (isCycling) {\n        this.cycle();\n      }\n    }; // Static\n\n\n    Carousel._jQueryInterface = function _jQueryInterface(config) {\n      return this.each(function () {\n        var data = $(this).data(DATA_KEY);\n\n        var _config = _objectSpread({}, Default, $(this).data());\n\n        if (typeof config === 'object') {\n          _config = _objectSpread({}, _config, config);\n        }\n\n        var action = typeof config === 'string' ? config : _config.slide;\n\n        if (!data) {\n          data = new Carousel(this, _config);\n          $(this).data(DATA_KEY, data);\n        }\n\n        if (typeof config === 'number') {\n          data.to(config);\n        } else if (typeof action === 'string') {\n          if (typeof data[action] === 'undefined') {\n            throw new TypeError(\"No method named \\\"\" + action + \"\\\"\");\n          }\n\n          data[action]();\n        } else if (_config.interval) {\n          data.pause();\n          data.cycle();\n        }\n      });\n    };\n\n    Carousel._dataApiClickHandler = function _dataApiClickHandler(event) {\n      var selector = Util.getSelectorFromElement(this);\n\n      if (!selector) {\n        return;\n      }\n\n      var target = $(selector)[0];\n\n      if (!target || !$(target).hasClass(ClassName.CAROUSEL)) {\n        return;\n      }\n\n      var config = _objectSpread({}, $(target).data(), $(this).data());\n\n      var slideIndex = this.getAttribute('data-slide-to');\n\n      if (slideIndex) {\n        config.interval = false;\n      }\n\n      Carousel._jQueryInterface.call($(target), config);\n\n      if (slideIndex) {\n        $(target).data(DATA_KEY).to(slideIndex);\n      }\n\n      event.preventDefault();\n    };\n\n    _createClass(Carousel, null, [{\n      key: \"VERSION\",\n      get: function get() {\n        return VERSION;\n      }\n    }, {\n      key: \"Default\",\n      get: function get() {\n        return Default;\n      }\n    }]);\n\n    return Carousel;\n  }();\n  /**\n   * ------------------------------------------------------------------------\n   * Data Api implementation\n   * ------------------------------------------------------------------------\n   */\n\n\n  $(document).on(Event.CLICK_DATA_API, Selector.DATA_SLIDE, Carousel._dataApiClickHandler);\n  $(window).on(Event.LOAD_DATA_API, function () {\n    $(Selector.DATA_RIDE).each(function () {\n      var $carousel = $(this);\n\n      Carousel._jQueryInterface.call($carousel, $carousel.data());\n    });\n  });\n  /**\n   * ------------------------------------------------------------------------\n   * jQuery\n   * ------------------------------------------------------------------------\n   */\n\n  $.fn[NAME] = Carousel._jQueryInterface;\n  $.fn[NAME].Constructor = Carousel;\n\n  $.fn[NAME].noConflict = function () {\n    $.fn[NAME] = JQUERY_NO_CONFLICT;\n    return Carousel._jQueryInterface;\n  };\n\n  return Carousel;\n}($);\n//# sourceMappingURL=carousel.js.map\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0), __webpack_require__(1)))\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function($, Util) {function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\n * --------------------------------------------------------------------------\n * Bootstrap (v4.1.1): collapse.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n * --------------------------------------------------------------------------\n */\nvar Collapse = function ($) {\n  /**\n   * ------------------------------------------------------------------------\n   * Constants\n   * ------------------------------------------------------------------------\n   */\n  var NAME = 'collapse';\n  var VERSION = '4.1.1';\n  var DATA_KEY = 'bs.collapse';\n  var EVENT_KEY = \".\" + DATA_KEY;\n  var DATA_API_KEY = '.data-api';\n  var JQUERY_NO_CONFLICT = $.fn[NAME];\n  var Default = {\n    toggle: true,\n    parent: ''\n  };\n  var DefaultType = {\n    toggle: 'boolean',\n    parent: '(string|element)'\n  };\n  var Event = {\n    SHOW: \"show\" + EVENT_KEY,\n    SHOWN: \"shown\" + EVENT_KEY,\n    HIDE: \"hide\" + EVENT_KEY,\n    HIDDEN: \"hidden\" + EVENT_KEY,\n    CLICK_DATA_API: \"click\" + EVENT_KEY + DATA_API_KEY\n  };\n  var ClassName = {\n    SHOW: 'show',\n    COLLAPSE: 'collapse',\n    COLLAPSING: 'collapsing',\n    COLLAPSED: 'collapsed'\n  };\n  var Dimension = {\n    WIDTH: 'width',\n    HEIGHT: 'height'\n  };\n  var Selector = {\n    ACTIVES: '.show, .collapsing',\n    DATA_TOGGLE: '[data-toggle=\"collapse\"]'\n    /**\n     * ------------------------------------------------------------------------\n     * Class Definition\n     * ------------------------------------------------------------------------\n     */\n\n  };\n\n  var Collapse =\n  /*#__PURE__*/\n  function () {\n    function Collapse(element, config) {\n      this._isTransitioning = false;\n      this._element = element;\n      this._config = this._getConfig(config);\n      this._triggerArray = $.makeArray($(\"[data-toggle=\\\"collapse\\\"][href=\\\"#\" + element.id + \"\\\"],\" + (\"[data-toggle=\\\"collapse\\\"][data-target=\\\"#\" + element.id + \"\\\"]\")));\n      var tabToggles = $(Selector.DATA_TOGGLE);\n\n      for (var i = 0; i < tabToggles.length; i++) {\n        var elem = tabToggles[i];\n        var selector = Util.getSelectorFromElement(elem);\n\n        if (selector !== null && $(selector).filter(element).length > 0) {\n          this._selector = selector;\n\n          this._triggerArray.push(elem);\n        }\n      }\n\n      this._parent = this._config.parent ? this._getParent() : null;\n\n      if (!this._config.parent) {\n        this._addAriaAndCollapsedClass(this._element, this._triggerArray);\n      }\n\n      if (this._config.toggle) {\n        this.toggle();\n      }\n    } // Getters\n\n\n    var _proto = Collapse.prototype;\n\n    // Public\n    _proto.toggle = function toggle() {\n      if ($(this._element).hasClass(ClassName.SHOW)) {\n        this.hide();\n      } else {\n        this.show();\n      }\n    };\n\n    _proto.show = function show() {\n      var _this = this;\n\n      if (this._isTransitioning || $(this._element).hasClass(ClassName.SHOW)) {\n        return;\n      }\n\n      var actives;\n      var activesData;\n\n      if (this._parent) {\n        actives = $.makeArray($(this._parent).find(Selector.ACTIVES).filter(\"[data-parent=\\\"\" + this._config.parent + \"\\\"]\"));\n\n        if (actives.length === 0) {\n          actives = null;\n        }\n      }\n\n      if (actives) {\n        activesData = $(actives).not(this._selector).data(DATA_KEY);\n\n        if (activesData && activesData._isTransitioning) {\n          return;\n        }\n      }\n\n      var startEvent = $.Event(Event.SHOW);\n      $(this._element).trigger(startEvent);\n\n      if (startEvent.isDefaultPrevented()) {\n        return;\n      }\n\n      if (actives) {\n        Collapse._jQueryInterface.call($(actives).not(this._selector), 'hide');\n\n        if (!activesData) {\n          $(actives).data(DATA_KEY, null);\n        }\n      }\n\n      var dimension = this._getDimension();\n\n      $(this._element).removeClass(ClassName.COLLAPSE).addClass(ClassName.COLLAPSING);\n      this._element.style[dimension] = 0;\n\n      if (this._triggerArray.length > 0) {\n        $(this._triggerArray).removeClass(ClassName.COLLAPSED).attr('aria-expanded', true);\n      }\n\n      this.setTransitioning(true);\n\n      var complete = function complete() {\n        $(_this._element).removeClass(ClassName.COLLAPSING).addClass(ClassName.COLLAPSE).addClass(ClassName.SHOW);\n        _this._element.style[dimension] = '';\n\n        _this.setTransitioning(false);\n\n        $(_this._element).trigger(Event.SHOWN);\n      };\n\n      var capitalizedDimension = dimension[0].toUpperCase() + dimension.slice(1);\n      var scrollSize = \"scroll\" + capitalizedDimension;\n      var transitionDuration = Util.getTransitionDurationFromElement(this._element);\n      $(this._element).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);\n      this._element.style[dimension] = this._element[scrollSize] + \"px\";\n    };\n\n    _proto.hide = function hide() {\n      var _this2 = this;\n\n      if (this._isTransitioning || !$(this._element).hasClass(ClassName.SHOW)) {\n        return;\n      }\n\n      var startEvent = $.Event(Event.HIDE);\n      $(this._element).trigger(startEvent);\n\n      if (startEvent.isDefaultPrevented()) {\n        return;\n      }\n\n      var dimension = this._getDimension();\n\n      this._element.style[dimension] = this._element.getBoundingClientRect()[dimension] + \"px\";\n      Util.reflow(this._element);\n      $(this._element).addClass(ClassName.COLLAPSING).removeClass(ClassName.COLLAPSE).removeClass(ClassName.SHOW);\n\n      if (this._triggerArray.length > 0) {\n        for (var i = 0; i < this._triggerArray.length; i++) {\n          var trigger = this._triggerArray[i];\n          var selector = Util.getSelectorFromElement(trigger);\n\n          if (selector !== null) {\n            var $elem = $(selector);\n\n            if (!$elem.hasClass(ClassName.SHOW)) {\n              $(trigger).addClass(ClassName.COLLAPSED).attr('aria-expanded', false);\n            }\n          }\n        }\n      }\n\n      this.setTransitioning(true);\n\n      var complete = function complete() {\n        _this2.setTransitioning(false);\n\n        $(_this2._element).removeClass(ClassName.COLLAPSING).addClass(ClassName.COLLAPSE).trigger(Event.HIDDEN);\n      };\n\n      this._element.style[dimension] = '';\n      var transitionDuration = Util.getTransitionDurationFromElement(this._element);\n      $(this._element).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);\n    };\n\n    _proto.setTransitioning = function setTransitioning(isTransitioning) {\n      this._isTransitioning = isTransitioning;\n    };\n\n    _proto.dispose = function dispose() {\n      $.removeData(this._element, DATA_KEY);\n      this._config = null;\n      this._parent = null;\n      this._element = null;\n      this._triggerArray = null;\n      this._isTransitioning = null;\n    }; // Private\n\n\n    _proto._getConfig = function _getConfig(config) {\n      config = _objectSpread({}, Default, config);\n      config.toggle = Boolean(config.toggle); // Coerce string values\n\n      Util.typeCheckConfig(NAME, config, DefaultType);\n      return config;\n    };\n\n    _proto._getDimension = function _getDimension() {\n      var hasWidth = $(this._element).hasClass(Dimension.WIDTH);\n      return hasWidth ? Dimension.WIDTH : Dimension.HEIGHT;\n    };\n\n    _proto._getParent = function _getParent() {\n      var _this3 = this;\n\n      var parent = null;\n\n      if (Util.isElement(this._config.parent)) {\n        parent = this._config.parent; // It's a jQuery object\n\n        if (typeof this._config.parent.jquery !== 'undefined') {\n          parent = this._config.parent[0];\n        }\n      } else {\n        parent = $(this._config.parent)[0];\n      }\n\n      var selector = \"[data-toggle=\\\"collapse\\\"][data-parent=\\\"\" + this._config.parent + \"\\\"]\";\n      $(parent).find(selector).each(function (i, element) {\n        _this3._addAriaAndCollapsedClass(Collapse._getTargetFromElement(element), [element]);\n      });\n      return parent;\n    };\n\n    _proto._addAriaAndCollapsedClass = function _addAriaAndCollapsedClass(element, triggerArray) {\n      if (element) {\n        var isOpen = $(element).hasClass(ClassName.SHOW);\n\n        if (triggerArray.length > 0) {\n          $(triggerArray).toggleClass(ClassName.COLLAPSED, !isOpen).attr('aria-expanded', isOpen);\n        }\n      }\n    }; // Static\n\n\n    Collapse._getTargetFromElement = function _getTargetFromElement(element) {\n      var selector = Util.getSelectorFromElement(element);\n      return selector ? $(selector)[0] : null;\n    };\n\n    Collapse._jQueryInterface = function _jQueryInterface(config) {\n      return this.each(function () {\n        var $this = $(this);\n        var data = $this.data(DATA_KEY);\n\n        var _config = _objectSpread({}, Default, $this.data(), typeof config === 'object' && config ? config : {});\n\n        if (!data && _config.toggle && /show|hide/.test(config)) {\n          _config.toggle = false;\n        }\n\n        if (!data) {\n          data = new Collapse(this, _config);\n          $this.data(DATA_KEY, data);\n        }\n\n        if (typeof config === 'string') {\n          if (typeof data[config] === 'undefined') {\n            throw new TypeError(\"No method named \\\"\" + config + \"\\\"\");\n          }\n\n          data[config]();\n        }\n      });\n    };\n\n    _createClass(Collapse, null, [{\n      key: \"VERSION\",\n      get: function get() {\n        return VERSION;\n      }\n    }, {\n      key: \"Default\",\n      get: function get() {\n        return Default;\n      }\n    }]);\n\n    return Collapse;\n  }();\n  /**\n   * ------------------------------------------------------------------------\n   * Data Api implementation\n   * ------------------------------------------------------------------------\n   */\n\n\n  $(document).on(Event.CLICK_DATA_API, Selector.DATA_TOGGLE, function (event) {\n    // preventDefault only for <a> elements (which change the URL) not inside the collapsible element\n    if (event.currentTarget.tagName === 'A') {\n      event.preventDefault();\n    }\n\n    var $trigger = $(this);\n    var selector = Util.getSelectorFromElement(this);\n    $(selector).each(function () {\n      var $target = $(this);\n      var data = $target.data(DATA_KEY);\n      var config = data ? 'toggle' : $trigger.data();\n\n      Collapse._jQueryInterface.call($target, config);\n    });\n  });\n  /**\n   * ------------------------------------------------------------------------\n   * jQuery\n   * ------------------------------------------------------------------------\n   */\n\n  $.fn[NAME] = Collapse._jQueryInterface;\n  $.fn[NAME].Constructor = Collapse;\n\n  $.fn[NAME].noConflict = function () {\n    $.fn[NAME] = JQUERY_NO_CONFLICT;\n    return Collapse._jQueryInterface;\n  };\n\n  return Collapse;\n}($);\n//# sourceMappingURL=collapse.js.map\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0), __webpack_require__(1)))\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function($, Popper, Util) {function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\n * --------------------------------------------------------------------------\n * Bootstrap (v4.1.1): dropdown.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n * --------------------------------------------------------------------------\n */\nvar Dropdown = function ($) {\n  /**\n   * ------------------------------------------------------------------------\n   * Constants\n   * ------------------------------------------------------------------------\n   */\n  var NAME = 'dropdown';\n  var VERSION = '4.1.1';\n  var DATA_KEY = 'bs.dropdown';\n  var EVENT_KEY = \".\" + DATA_KEY;\n  var DATA_API_KEY = '.data-api';\n  var JQUERY_NO_CONFLICT = $.fn[NAME];\n  var ESCAPE_KEYCODE = 27; // KeyboardEvent.which value for Escape (Esc) key\n\n  var SPACE_KEYCODE = 32; // KeyboardEvent.which value for space key\n\n  var TAB_KEYCODE = 9; // KeyboardEvent.which value for tab key\n\n  var ARROW_UP_KEYCODE = 38; // KeyboardEvent.which value for up arrow key\n\n  var ARROW_DOWN_KEYCODE = 40; // KeyboardEvent.which value for down arrow key\n\n  var RIGHT_MOUSE_BUTTON_WHICH = 3; // MouseEvent.which value for the right button (assuming a right-handed mouse)\n\n  var REGEXP_KEYDOWN = new RegExp(ARROW_UP_KEYCODE + \"|\" + ARROW_DOWN_KEYCODE + \"|\" + ESCAPE_KEYCODE);\n  var Event = {\n    HIDE: \"hide\" + EVENT_KEY,\n    HIDDEN: \"hidden\" + EVENT_KEY,\n    SHOW: \"show\" + EVENT_KEY,\n    SHOWN: \"shown\" + EVENT_KEY,\n    CLICK: \"click\" + EVENT_KEY,\n    CLICK_DATA_API: \"click\" + EVENT_KEY + DATA_API_KEY,\n    KEYDOWN_DATA_API: \"keydown\" + EVENT_KEY + DATA_API_KEY,\n    KEYUP_DATA_API: \"keyup\" + EVENT_KEY + DATA_API_KEY\n  };\n  var ClassName = {\n    DISABLED: 'disabled',\n    SHOW: 'show',\n    DROPUP: 'dropup',\n    DROPRIGHT: 'dropright',\n    DROPLEFT: 'dropleft',\n    MENURIGHT: 'dropdown-menu-right',\n    MENULEFT: 'dropdown-menu-left',\n    POSITION_STATIC: 'position-static'\n  };\n  var Selector = {\n    DATA_TOGGLE: '[data-toggle=\"dropdown\"]',\n    FORM_CHILD: '.dropdown form',\n    MENU: '.dropdown-menu',\n    NAVBAR_NAV: '.navbar-nav',\n    VISIBLE_ITEMS: '.dropdown-menu .dropdown-item:not(.disabled):not(:disabled)'\n  };\n  var AttachmentMap = {\n    TOP: 'top-start',\n    TOPEND: 'top-end',\n    BOTTOM: 'bottom-start',\n    BOTTOMEND: 'bottom-end',\n    RIGHT: 'right-start',\n    RIGHTEND: 'right-end',\n    LEFT: 'left-start',\n    LEFTEND: 'left-end'\n  };\n  var Default = {\n    offset: 0,\n    flip: true,\n    boundary: 'scrollParent',\n    reference: 'toggle',\n    display: 'dynamic'\n  };\n  var DefaultType = {\n    offset: '(number|string|function)',\n    flip: 'boolean',\n    boundary: '(string|element)',\n    reference: '(string|element)',\n    display: 'string'\n    /**\n     * ------------------------------------------------------------------------\n     * Class Definition\n     * ------------------------------------------------------------------------\n     */\n\n  };\n\n  var Dropdown =\n  /*#__PURE__*/\n  function () {\n    function Dropdown(element, config) {\n      this._element = element;\n      this._popper = null;\n      this._config = this._getConfig(config);\n      this._menu = this._getMenuElement();\n      this._inNavbar = this._detectNavbar();\n\n      this._addEventListeners();\n    } // Getters\n\n\n    var _proto = Dropdown.prototype;\n\n    // Public\n    _proto.toggle = function toggle() {\n      if (this._element.disabled || $(this._element).hasClass(ClassName.DISABLED)) {\n        return;\n      }\n\n      var parent = Dropdown._getParentFromElement(this._element);\n\n      var isActive = $(this._menu).hasClass(ClassName.SHOW);\n\n      Dropdown._clearMenus();\n\n      if (isActive) {\n        return;\n      }\n\n      var relatedTarget = {\n        relatedTarget: this._element\n      };\n      var showEvent = $.Event(Event.SHOW, relatedTarget);\n      $(parent).trigger(showEvent);\n\n      if (showEvent.isDefaultPrevented()) {\n        return;\n      } // Disable totally Popper.js for Dropdown in Navbar\n\n\n      if (!this._inNavbar) {\n        /**\n         * Check for Popper dependency\n         * Popper - https://popper.js.org\n         */\n        if (typeof Popper === 'undefined') {\n          throw new TypeError('Bootstrap dropdown require Popper.js (https://popper.js.org)');\n        }\n\n        var referenceElement = this._element;\n\n        if (this._config.reference === 'parent') {\n          referenceElement = parent;\n        } else if (Util.isElement(this._config.reference)) {\n          referenceElement = this._config.reference; // Check if it's jQuery element\n\n          if (typeof this._config.reference.jquery !== 'undefined') {\n            referenceElement = this._config.reference[0];\n          }\n        } // If boundary is not `scrollParent`, then set position to `static`\n        // to allow the menu to \"escape\" the scroll parent's boundaries\n        // https://github.com/twbs/bootstrap/issues/24251\n\n\n        if (this._config.boundary !== 'scrollParent') {\n          $(parent).addClass(ClassName.POSITION_STATIC);\n        }\n\n        this._popper = new Popper(referenceElement, this._menu, this._getPopperConfig());\n      } // If this is a touch-enabled device we add extra\n      // empty mouseover listeners to the body's immediate children;\n      // only needed because of broken event delegation on iOS\n      // https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html\n\n\n      if ('ontouchstart' in document.documentElement && $(parent).closest(Selector.NAVBAR_NAV).length === 0) {\n        $(document.body).children().on('mouseover', null, $.noop);\n      }\n\n      this._element.focus();\n\n      this._element.setAttribute('aria-expanded', true);\n\n      $(this._menu).toggleClass(ClassName.SHOW);\n      $(parent).toggleClass(ClassName.SHOW).trigger($.Event(Event.SHOWN, relatedTarget));\n    };\n\n    _proto.dispose = function dispose() {\n      $.removeData(this._element, DATA_KEY);\n      $(this._element).off(EVENT_KEY);\n      this._element = null;\n      this._menu = null;\n\n      if (this._popper !== null) {\n        this._popper.destroy();\n\n        this._popper = null;\n      }\n    };\n\n    _proto.update = function update() {\n      this._inNavbar = this._detectNavbar();\n\n      if (this._popper !== null) {\n        this._popper.scheduleUpdate();\n      }\n    }; // Private\n\n\n    _proto._addEventListeners = function _addEventListeners() {\n      var _this = this;\n\n      $(this._element).on(Event.CLICK, function (event) {\n        event.preventDefault();\n        event.stopPropagation();\n\n        _this.toggle();\n      });\n    };\n\n    _proto._getConfig = function _getConfig(config) {\n      config = _objectSpread({}, this.constructor.Default, $(this._element).data(), config);\n      Util.typeCheckConfig(NAME, config, this.constructor.DefaultType);\n      return config;\n    };\n\n    _proto._getMenuElement = function _getMenuElement() {\n      if (!this._menu) {\n        var parent = Dropdown._getParentFromElement(this._element);\n\n        this._menu = $(parent).find(Selector.MENU)[0];\n      }\n\n      return this._menu;\n    };\n\n    _proto._getPlacement = function _getPlacement() {\n      var $parentDropdown = $(this._element).parent();\n      var placement = AttachmentMap.BOTTOM; // Handle dropup\n\n      if ($parentDropdown.hasClass(ClassName.DROPUP)) {\n        placement = AttachmentMap.TOP;\n\n        if ($(this._menu).hasClass(ClassName.MENURIGHT)) {\n          placement = AttachmentMap.TOPEND;\n        }\n      } else if ($parentDropdown.hasClass(ClassName.DROPRIGHT)) {\n        placement = AttachmentMap.RIGHT;\n      } else if ($parentDropdown.hasClass(ClassName.DROPLEFT)) {\n        placement = AttachmentMap.LEFT;\n      } else if ($(this._menu).hasClass(ClassName.MENURIGHT)) {\n        placement = AttachmentMap.BOTTOMEND;\n      }\n\n      return placement;\n    };\n\n    _proto._detectNavbar = function _detectNavbar() {\n      return $(this._element).closest('.navbar').length > 0;\n    };\n\n    _proto._getPopperConfig = function _getPopperConfig() {\n      var _this2 = this;\n\n      var offsetConf = {};\n\n      if (typeof this._config.offset === 'function') {\n        offsetConf.fn = function (data) {\n          data.offsets = _objectSpread({}, data.offsets, _this2._config.offset(data.offsets) || {});\n          return data;\n        };\n      } else {\n        offsetConf.offset = this._config.offset;\n      }\n\n      var popperConfig = {\n        placement: this._getPlacement(),\n        modifiers: {\n          offset: offsetConf,\n          flip: {\n            enabled: this._config.flip\n          },\n          preventOverflow: {\n            boundariesElement: this._config.boundary\n          }\n        } // Disable Popper.js if we have a static display\n\n      };\n\n      if (this._config.display === 'static') {\n        popperConfig.modifiers.applyStyle = {\n          enabled: false\n        };\n      }\n\n      return popperConfig;\n    }; // Static\n\n\n    Dropdown._jQueryInterface = function _jQueryInterface(config) {\n      return this.each(function () {\n        var data = $(this).data(DATA_KEY);\n\n        var _config = typeof config === 'object' ? config : null;\n\n        if (!data) {\n          data = new Dropdown(this, _config);\n          $(this).data(DATA_KEY, data);\n        }\n\n        if (typeof config === 'string') {\n          if (typeof data[config] === 'undefined') {\n            throw new TypeError(\"No method named \\\"\" + config + \"\\\"\");\n          }\n\n          data[config]();\n        }\n      });\n    };\n\n    Dropdown._clearMenus = function _clearMenus(event) {\n      if (event && (event.which === RIGHT_MOUSE_BUTTON_WHICH || event.type === 'keyup' && event.which !== TAB_KEYCODE)) {\n        return;\n      }\n\n      var toggles = $.makeArray($(Selector.DATA_TOGGLE));\n\n      for (var i = 0; i < toggles.length; i++) {\n        var parent = Dropdown._getParentFromElement(toggles[i]);\n\n        var context = $(toggles[i]).data(DATA_KEY);\n        var relatedTarget = {\n          relatedTarget: toggles[i]\n        };\n\n        if (!context) {\n          continue;\n        }\n\n        var dropdownMenu = context._menu;\n\n        if (!$(parent).hasClass(ClassName.SHOW)) {\n          continue;\n        }\n\n        if (event && (event.type === 'click' && /input|textarea/i.test(event.target.tagName) || event.type === 'keyup' && event.which === TAB_KEYCODE) && $.contains(parent, event.target)) {\n          continue;\n        }\n\n        var hideEvent = $.Event(Event.HIDE, relatedTarget);\n        $(parent).trigger(hideEvent);\n\n        if (hideEvent.isDefaultPrevented()) {\n          continue;\n        } // If this is a touch-enabled device we remove the extra\n        // empty mouseover listeners we added for iOS support\n\n\n        if ('ontouchstart' in document.documentElement) {\n          $(document.body).children().off('mouseover', null, $.noop);\n        }\n\n        toggles[i].setAttribute('aria-expanded', 'false');\n        $(dropdownMenu).removeClass(ClassName.SHOW);\n        $(parent).removeClass(ClassName.SHOW).trigger($.Event(Event.HIDDEN, relatedTarget));\n      }\n    };\n\n    Dropdown._getParentFromElement = function _getParentFromElement(element) {\n      var parent;\n      var selector = Util.getSelectorFromElement(element);\n\n      if (selector) {\n        parent = $(selector)[0];\n      }\n\n      return parent || element.parentNode;\n    }; // eslint-disable-next-line complexity\n\n\n    Dropdown._dataApiKeydownHandler = function _dataApiKeydownHandler(event) {\n      // If not input/textarea:\n      //  - And not a key in REGEXP_KEYDOWN => not a dropdown command\n      // If input/textarea:\n      //  - If space key => not a dropdown command\n      //  - If key is other than escape\n      //    - If key is not up or down => not a dropdown command\n      //    - If trigger inside the menu => not a dropdown command\n      if (/input|textarea/i.test(event.target.tagName) ? event.which === SPACE_KEYCODE || event.which !== ESCAPE_KEYCODE && (event.which !== ARROW_DOWN_KEYCODE && event.which !== ARROW_UP_KEYCODE || $(event.target).closest(Selector.MENU).length) : !REGEXP_KEYDOWN.test(event.which)) {\n        return;\n      }\n\n      event.preventDefault();\n      event.stopPropagation();\n\n      if (this.disabled || $(this).hasClass(ClassName.DISABLED)) {\n        return;\n      }\n\n      var parent = Dropdown._getParentFromElement(this);\n\n      var isActive = $(parent).hasClass(ClassName.SHOW);\n\n      if (!isActive && (event.which !== ESCAPE_KEYCODE || event.which !== SPACE_KEYCODE) || isActive && (event.which === ESCAPE_KEYCODE || event.which === SPACE_KEYCODE)) {\n        if (event.which === ESCAPE_KEYCODE) {\n          var toggle = $(parent).find(Selector.DATA_TOGGLE)[0];\n          $(toggle).trigger('focus');\n        }\n\n        $(this).trigger('click');\n        return;\n      }\n\n      var items = $(parent).find(Selector.VISIBLE_ITEMS).get();\n\n      if (items.length === 0) {\n        return;\n      }\n\n      var index = items.indexOf(event.target);\n\n      if (event.which === ARROW_UP_KEYCODE && index > 0) {\n        // Up\n        index--;\n      }\n\n      if (event.which === ARROW_DOWN_KEYCODE && index < items.length - 1) {\n        // Down\n        index++;\n      }\n\n      if (index < 0) {\n        index = 0;\n      }\n\n      items[index].focus();\n    };\n\n    _createClass(Dropdown, null, [{\n      key: \"VERSION\",\n      get: function get() {\n        return VERSION;\n      }\n    }, {\n      key: \"Default\",\n      get: function get() {\n        return Default;\n      }\n    }, {\n      key: \"DefaultType\",\n      get: function get() {\n        return DefaultType;\n      }\n    }]);\n\n    return Dropdown;\n  }();\n  /**\n   * ------------------------------------------------------------------------\n   * Data Api implementation\n   * ------------------------------------------------------------------------\n   */\n\n\n  $(document).on(Event.KEYDOWN_DATA_API, Selector.DATA_TOGGLE, Dropdown._dataApiKeydownHandler).on(Event.KEYDOWN_DATA_API, Selector.MENU, Dropdown._dataApiKeydownHandler).on(Event.CLICK_DATA_API + \" \" + Event.KEYUP_DATA_API, Dropdown._clearMenus).on(Event.CLICK_DATA_API, Selector.DATA_TOGGLE, function (event) {\n    event.preventDefault();\n    event.stopPropagation();\n\n    Dropdown._jQueryInterface.call($(this), 'toggle');\n  }).on(Event.CLICK_DATA_API, Selector.FORM_CHILD, function (e) {\n    e.stopPropagation();\n  });\n  /**\n   * ------------------------------------------------------------------------\n   * jQuery\n   * ------------------------------------------------------------------------\n   */\n\n  $.fn[NAME] = Dropdown._jQueryInterface;\n  $.fn[NAME].Constructor = Dropdown;\n\n  $.fn[NAME].noConflict = function () {\n    $.fn[NAME] = JQUERY_NO_CONFLICT;\n    return Dropdown._jQueryInterface;\n  };\n\n  return Dropdown;\n}($, Popper);\n//# sourceMappingURL=dropdown.js.map\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0), __webpack_require__(3)[\"default\"], __webpack_require__(1)))\n\n/***/ }),\n/* 14 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function($, Util) {function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\n * --------------------------------------------------------------------------\n * Bootstrap (v4.1.1): modal.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n * --------------------------------------------------------------------------\n */\nvar Modal = function ($) {\n  /**\n   * ------------------------------------------------------------------------\n   * Constants\n   * ------------------------------------------------------------------------\n   */\n  var NAME = 'modal';\n  var VERSION = '4.1.1';\n  var DATA_KEY = 'bs.modal';\n  var EVENT_KEY = \".\" + DATA_KEY;\n  var DATA_API_KEY = '.data-api';\n  var JQUERY_NO_CONFLICT = $.fn[NAME];\n  var ESCAPE_KEYCODE = 27; // KeyboardEvent.which value for Escape (Esc) key\n\n  var Default = {\n    backdrop: true,\n    keyboard: true,\n    focus: true,\n    show: true\n  };\n  var DefaultType = {\n    backdrop: '(boolean|string)',\n    keyboard: 'boolean',\n    focus: 'boolean',\n    show: 'boolean'\n  };\n  var Event = {\n    HIDE: \"hide\" + EVENT_KEY,\n    HIDDEN: \"hidden\" + EVENT_KEY,\n    SHOW: \"show\" + EVENT_KEY,\n    SHOWN: \"shown\" + EVENT_KEY,\n    FOCUSIN: \"focusin\" + EVENT_KEY,\n    RESIZE: \"resize\" + EVENT_KEY,\n    CLICK_DISMISS: \"click.dismiss\" + EVENT_KEY,\n    KEYDOWN_DISMISS: \"keydown.dismiss\" + EVENT_KEY,\n    MOUSEUP_DISMISS: \"mouseup.dismiss\" + EVENT_KEY,\n    MOUSEDOWN_DISMISS: \"mousedown.dismiss\" + EVENT_KEY,\n    CLICK_DATA_API: \"click\" + EVENT_KEY + DATA_API_KEY\n  };\n  var ClassName = {\n    SCROLLBAR_MEASURER: 'modal-scrollbar-measure',\n    BACKDROP: 'modal-backdrop',\n    OPEN: 'modal-open',\n    FADE: 'fade',\n    SHOW: 'show'\n  };\n  var Selector = {\n    DIALOG: '.modal-dialog',\n    DATA_TOGGLE: '[data-toggle=\"modal\"]',\n    DATA_DISMISS: '[data-dismiss=\"modal\"]',\n    FIXED_CONTENT: '.fixed-top, .fixed-bottom, .is-fixed, .sticky-top',\n    STICKY_CONTENT: '.sticky-top',\n    NAVBAR_TOGGLER: '.navbar-toggler'\n    /**\n     * ------------------------------------------------------------------------\n     * Class Definition\n     * ------------------------------------------------------------------------\n     */\n\n  };\n\n  var Modal =\n  /*#__PURE__*/\n  function () {\n    function Modal(element, config) {\n      this._config = this._getConfig(config);\n      this._element = element;\n      this._dialog = $(element).find(Selector.DIALOG)[0];\n      this._backdrop = null;\n      this._isShown = false;\n      this._isBodyOverflowing = false;\n      this._ignoreBackdropClick = false;\n      this._scrollbarWidth = 0;\n    } // Getters\n\n\n    var _proto = Modal.prototype;\n\n    // Public\n    _proto.toggle = function toggle(relatedTarget) {\n      return this._isShown ? this.hide() : this.show(relatedTarget);\n    };\n\n    _proto.show = function show(relatedTarget) {\n      var _this = this;\n\n      if (this._isTransitioning || this._isShown) {\n        return;\n      }\n\n      if ($(this._element).hasClass(ClassName.FADE)) {\n        this._isTransitioning = true;\n      }\n\n      var showEvent = $.Event(Event.SHOW, {\n        relatedTarget: relatedTarget\n      });\n      $(this._element).trigger(showEvent);\n\n      if (this._isShown || showEvent.isDefaultPrevented()) {\n        return;\n      }\n\n      this._isShown = true;\n\n      this._checkScrollbar();\n\n      this._setScrollbar();\n\n      this._adjustDialog();\n\n      $(document.body).addClass(ClassName.OPEN);\n\n      this._setEscapeEvent();\n\n      this._setResizeEvent();\n\n      $(this._element).on(Event.CLICK_DISMISS, Selector.DATA_DISMISS, function (event) {\n        return _this.hide(event);\n      });\n      $(this._dialog).on(Event.MOUSEDOWN_DISMISS, function () {\n        $(_this._element).one(Event.MOUSEUP_DISMISS, function (event) {\n          if ($(event.target).is(_this._element)) {\n            _this._ignoreBackdropClick = true;\n          }\n        });\n      });\n\n      this._showBackdrop(function () {\n        return _this._showElement(relatedTarget);\n      });\n    };\n\n    _proto.hide = function hide(event) {\n      var _this2 = this;\n\n      if (event) {\n        event.preventDefault();\n      }\n\n      if (this._isTransitioning || !this._isShown) {\n        return;\n      }\n\n      var hideEvent = $.Event(Event.HIDE);\n      $(this._element).trigger(hideEvent);\n\n      if (!this._isShown || hideEvent.isDefaultPrevented()) {\n        return;\n      }\n\n      this._isShown = false;\n      var transition = $(this._element).hasClass(ClassName.FADE);\n\n      if (transition) {\n        this._isTransitioning = true;\n      }\n\n      this._setEscapeEvent();\n\n      this._setResizeEvent();\n\n      $(document).off(Event.FOCUSIN);\n      $(this._element).removeClass(ClassName.SHOW);\n      $(this._element).off(Event.CLICK_DISMISS);\n      $(this._dialog).off(Event.MOUSEDOWN_DISMISS);\n\n      if (transition) {\n        var transitionDuration = Util.getTransitionDurationFromElement(this._element);\n        $(this._element).one(Util.TRANSITION_END, function (event) {\n          return _this2._hideModal(event);\n        }).emulateTransitionEnd(transitionDuration);\n      } else {\n        this._hideModal();\n      }\n    };\n\n    _proto.dispose = function dispose() {\n      $.removeData(this._element, DATA_KEY);\n      $(window, document, this._element, this._backdrop).off(EVENT_KEY);\n      this._config = null;\n      this._element = null;\n      this._dialog = null;\n      this._backdrop = null;\n      this._isShown = null;\n      this._isBodyOverflowing = null;\n      this._ignoreBackdropClick = null;\n      this._scrollbarWidth = null;\n    };\n\n    _proto.handleUpdate = function handleUpdate() {\n      this._adjustDialog();\n    }; // Private\n\n\n    _proto._getConfig = function _getConfig(config) {\n      config = _objectSpread({}, Default, config);\n      Util.typeCheckConfig(NAME, config, DefaultType);\n      return config;\n    };\n\n    _proto._showElement = function _showElement(relatedTarget) {\n      var _this3 = this;\n\n      var transition = $(this._element).hasClass(ClassName.FADE);\n\n      if (!this._element.parentNode || this._element.parentNode.nodeType !== Node.ELEMENT_NODE) {\n        // Don't move modal's DOM position\n        document.body.appendChild(this._element);\n      }\n\n      this._element.style.display = 'block';\n\n      this._element.removeAttribute('aria-hidden');\n\n      this._element.scrollTop = 0;\n\n      if (transition) {\n        Util.reflow(this._element);\n      }\n\n      $(this._element).addClass(ClassName.SHOW);\n\n      if (this._config.focus) {\n        this._enforceFocus();\n      }\n\n      var shownEvent = $.Event(Event.SHOWN, {\n        relatedTarget: relatedTarget\n      });\n\n      var transitionComplete = function transitionComplete() {\n        if (_this3._config.focus) {\n          _this3._element.focus();\n        }\n\n        _this3._isTransitioning = false;\n        $(_this3._element).trigger(shownEvent);\n      };\n\n      if (transition) {\n        var transitionDuration = Util.getTransitionDurationFromElement(this._element);\n        $(this._dialog).one(Util.TRANSITION_END, transitionComplete).emulateTransitionEnd(transitionDuration);\n      } else {\n        transitionComplete();\n      }\n    };\n\n    _proto._enforceFocus = function _enforceFocus() {\n      var _this4 = this;\n\n      $(document).off(Event.FOCUSIN) // Guard against infinite focus loop\n      .on(Event.FOCUSIN, function (event) {\n        if (document !== event.target && _this4._element !== event.target && $(_this4._element).has(event.target).length === 0) {\n          _this4._element.focus();\n        }\n      });\n    };\n\n    _proto._setEscapeEvent = function _setEscapeEvent() {\n      var _this5 = this;\n\n      if (this._isShown && this._config.keyboard) {\n        $(this._element).on(Event.KEYDOWN_DISMISS, function (event) {\n          if (event.which === ESCAPE_KEYCODE) {\n            event.preventDefault();\n\n            _this5.hide();\n          }\n        });\n      } else if (!this._isShown) {\n        $(this._element).off(Event.KEYDOWN_DISMISS);\n      }\n    };\n\n    _proto._setResizeEvent = function _setResizeEvent() {\n      var _this6 = this;\n\n      if (this._isShown) {\n        $(window).on(Event.RESIZE, function (event) {\n          return _this6.handleUpdate(event);\n        });\n      } else {\n        $(window).off(Event.RESIZE);\n      }\n    };\n\n    _proto._hideModal = function _hideModal() {\n      var _this7 = this;\n\n      this._element.style.display = 'none';\n\n      this._element.setAttribute('aria-hidden', true);\n\n      this._isTransitioning = false;\n\n      this._showBackdrop(function () {\n        $(document.body).removeClass(ClassName.OPEN);\n\n        _this7._resetAdjustments();\n\n        _this7._resetScrollbar();\n\n        $(_this7._element).trigger(Event.HIDDEN);\n      });\n    };\n\n    _proto._removeBackdrop = function _removeBackdrop() {\n      if (this._backdrop) {\n        $(this._backdrop).remove();\n        this._backdrop = null;\n      }\n    };\n\n    _proto._showBackdrop = function _showBackdrop(callback) {\n      var _this8 = this;\n\n      var animate = $(this._element).hasClass(ClassName.FADE) ? ClassName.FADE : '';\n\n      if (this._isShown && this._config.backdrop) {\n        this._backdrop = document.createElement('div');\n        this._backdrop.className = ClassName.BACKDROP;\n\n        if (animate) {\n          $(this._backdrop).addClass(animate);\n        }\n\n        $(this._backdrop).appendTo(document.body);\n        $(this._element).on(Event.CLICK_DISMISS, function (event) {\n          if (_this8._ignoreBackdropClick) {\n            _this8._ignoreBackdropClick = false;\n            return;\n          }\n\n          if (event.target !== event.currentTarget) {\n            return;\n          }\n\n          if (_this8._config.backdrop === 'static') {\n            _this8._element.focus();\n          } else {\n            _this8.hide();\n          }\n        });\n\n        if (animate) {\n          Util.reflow(this._backdrop);\n        }\n\n        $(this._backdrop).addClass(ClassName.SHOW);\n\n        if (!callback) {\n          return;\n        }\n\n        if (!animate) {\n          callback();\n          return;\n        }\n\n        var backdropTransitionDuration = Util.getTransitionDurationFromElement(this._backdrop);\n        $(this._backdrop).one(Util.TRANSITION_END, callback).emulateTransitionEnd(backdropTransitionDuration);\n      } else if (!this._isShown && this._backdrop) {\n        $(this._backdrop).removeClass(ClassName.SHOW);\n\n        var callbackRemove = function callbackRemove() {\n          _this8._removeBackdrop();\n\n          if (callback) {\n            callback();\n          }\n        };\n\n        if ($(this._element).hasClass(ClassName.FADE)) {\n          var _backdropTransitionDuration = Util.getTransitionDurationFromElement(this._backdrop);\n\n          $(this._backdrop).one(Util.TRANSITION_END, callbackRemove).emulateTransitionEnd(_backdropTransitionDuration);\n        } else {\n          callbackRemove();\n        }\n      } else if (callback) {\n        callback();\n      }\n    }; // ----------------------------------------------------------------------\n    // the following methods are used to handle overflowing modals\n    // todo (fat): these should probably be refactored out of modal.js\n    // ----------------------------------------------------------------------\n\n\n    _proto._adjustDialog = function _adjustDialog() {\n      var isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;\n\n      if (!this._isBodyOverflowing && isModalOverflowing) {\n        this._element.style.paddingLeft = this._scrollbarWidth + \"px\";\n      }\n\n      if (this._isBodyOverflowing && !isModalOverflowing) {\n        this._element.style.paddingRight = this._scrollbarWidth + \"px\";\n      }\n    };\n\n    _proto._resetAdjustments = function _resetAdjustments() {\n      this._element.style.paddingLeft = '';\n      this._element.style.paddingRight = '';\n    };\n\n    _proto._checkScrollbar = function _checkScrollbar() {\n      var rect = document.body.getBoundingClientRect();\n      this._isBodyOverflowing = rect.left + rect.right < window.innerWidth;\n      this._scrollbarWidth = this._getScrollbarWidth();\n    };\n\n    _proto._setScrollbar = function _setScrollbar() {\n      var _this9 = this;\n\n      if (this._isBodyOverflowing) {\n        // Note: DOMNode.style.paddingRight returns the actual value or '' if not set\n        //   while $(DOMNode).css('padding-right') returns the calculated value or 0 if not set\n        // Adjust fixed content padding\n        $(Selector.FIXED_CONTENT).each(function (index, element) {\n          var actualPadding = $(element)[0].style.paddingRight;\n          var calculatedPadding = $(element).css('padding-right');\n          $(element).data('padding-right', actualPadding).css('padding-right', parseFloat(calculatedPadding) + _this9._scrollbarWidth + \"px\");\n        }); // Adjust sticky content margin\n\n        $(Selector.STICKY_CONTENT).each(function (index, element) {\n          var actualMargin = $(element)[0].style.marginRight;\n          var calculatedMargin = $(element).css('margin-right');\n          $(element).data('margin-right', actualMargin).css('margin-right', parseFloat(calculatedMargin) - _this9._scrollbarWidth + \"px\");\n        }); // Adjust navbar-toggler margin\n\n        $(Selector.NAVBAR_TOGGLER).each(function (index, element) {\n          var actualMargin = $(element)[0].style.marginRight;\n          var calculatedMargin = $(element).css('margin-right');\n          $(element).data('margin-right', actualMargin).css('margin-right', parseFloat(calculatedMargin) + _this9._scrollbarWidth + \"px\");\n        }); // Adjust body padding\n\n        var actualPadding = document.body.style.paddingRight;\n        var calculatedPadding = $(document.body).css('padding-right');\n        $(document.body).data('padding-right', actualPadding).css('padding-right', parseFloat(calculatedPadding) + this._scrollbarWidth + \"px\");\n      }\n    };\n\n    _proto._resetScrollbar = function _resetScrollbar() {\n      // Restore fixed content padding\n      $(Selector.FIXED_CONTENT).each(function (index, element) {\n        var padding = $(element).data('padding-right');\n\n        if (typeof padding !== 'undefined') {\n          $(element).css('padding-right', padding).removeData('padding-right');\n        }\n      }); // Restore sticky content and navbar-toggler margin\n\n      $(Selector.STICKY_CONTENT + \", \" + Selector.NAVBAR_TOGGLER).each(function (index, element) {\n        var margin = $(element).data('margin-right');\n\n        if (typeof margin !== 'undefined') {\n          $(element).css('margin-right', margin).removeData('margin-right');\n        }\n      }); // Restore body padding\n\n      var padding = $(document.body).data('padding-right');\n\n      if (typeof padding !== 'undefined') {\n        $(document.body).css('padding-right', padding).removeData('padding-right');\n      }\n    };\n\n    _proto._getScrollbarWidth = function _getScrollbarWidth() {\n      // thx d.walsh\n      var scrollDiv = document.createElement('div');\n      scrollDiv.className = ClassName.SCROLLBAR_MEASURER;\n      document.body.appendChild(scrollDiv);\n      var scrollbarWidth = scrollDiv.getBoundingClientRect().width - scrollDiv.clientWidth;\n      document.body.removeChild(scrollDiv);\n      return scrollbarWidth;\n    }; // Static\n\n\n    Modal._jQueryInterface = function _jQueryInterface(config, relatedTarget) {\n      return this.each(function () {\n        var data = $(this).data(DATA_KEY);\n\n        var _config = _objectSpread({}, Default, $(this).data(), typeof config === 'object' && config ? config : {});\n\n        if (!data) {\n          data = new Modal(this, _config);\n          $(this).data(DATA_KEY, data);\n        }\n\n        if (typeof config === 'string') {\n          if (typeof data[config] === 'undefined') {\n            throw new TypeError(\"No method named \\\"\" + config + \"\\\"\");\n          }\n\n          data[config](relatedTarget);\n        } else if (_config.show) {\n          data.show(relatedTarget);\n        }\n      });\n    };\n\n    _createClass(Modal, null, [{\n      key: \"VERSION\",\n      get: function get() {\n        return VERSION;\n      }\n    }, {\n      key: \"Default\",\n      get: function get() {\n        return Default;\n      }\n    }]);\n\n    return Modal;\n  }();\n  /**\n   * ------------------------------------------------------------------------\n   * Data Api implementation\n   * ------------------------------------------------------------------------\n   */\n\n\n  $(document).on(Event.CLICK_DATA_API, Selector.DATA_TOGGLE, function (event) {\n    var _this10 = this;\n\n    var target;\n    var selector = Util.getSelectorFromElement(this);\n\n    if (selector) {\n      target = $(selector)[0];\n    }\n\n    var config = $(target).data(DATA_KEY) ? 'toggle' : _objectSpread({}, $(target).data(), $(this).data());\n\n    if (this.tagName === 'A' || this.tagName === 'AREA') {\n      event.preventDefault();\n    }\n\n    var $target = $(target).one(Event.SHOW, function (showEvent) {\n      if (showEvent.isDefaultPrevented()) {\n        // Only register focus restorer if modal will actually get shown\n        return;\n      }\n\n      $target.one(Event.HIDDEN, function () {\n        if ($(_this10).is(':visible')) {\n          _this10.focus();\n        }\n      });\n    });\n\n    Modal._jQueryInterface.call($(target), config, this);\n  });\n  /**\n   * ------------------------------------------------------------------------\n   * jQuery\n   * ------------------------------------------------------------------------\n   */\n\n  $.fn[NAME] = Modal._jQueryInterface;\n  $.fn[NAME].Constructor = Modal;\n\n  $.fn[NAME].noConflict = function () {\n    $.fn[NAME] = JQUERY_NO_CONFLICT;\n    return Modal._jQueryInterface;\n  };\n\n  return Modal;\n}($);\n//# sourceMappingURL=modal.js.map\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0), __webpack_require__(1)))\n\n/***/ }),\n/* 15 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function($, Popper, Util) {function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\n * --------------------------------------------------------------------------\n * Bootstrap (v4.1.1): tooltip.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n * --------------------------------------------------------------------------\n */\nvar Tooltip = function ($) {\n  /**\n   * ------------------------------------------------------------------------\n   * Constants\n   * ------------------------------------------------------------------------\n   */\n  var NAME = 'tooltip';\n  var VERSION = '4.1.1';\n  var DATA_KEY = 'bs.tooltip';\n  var EVENT_KEY = \".\" + DATA_KEY;\n  var JQUERY_NO_CONFLICT = $.fn[NAME];\n  var CLASS_PREFIX = 'bs-tooltip';\n  var BSCLS_PREFIX_REGEX = new RegExp(\"(^|\\\\s)\" + CLASS_PREFIX + \"\\\\S+\", 'g');\n  var DefaultType = {\n    animation: 'boolean',\n    template: 'string',\n    title: '(string|element|function)',\n    trigger: 'string',\n    delay: '(number|object)',\n    html: 'boolean',\n    selector: '(string|boolean)',\n    placement: '(string|function)',\n    offset: '(number|string)',\n    container: '(string|element|boolean)',\n    fallbackPlacement: '(string|array)',\n    boundary: '(string|element)'\n  };\n  var AttachmentMap = {\n    AUTO: 'auto',\n    TOP: 'top',\n    RIGHT: 'right',\n    BOTTOM: 'bottom',\n    LEFT: 'left'\n  };\n  var Default = {\n    animation: true,\n    template: '<div class=\"tooltip\" role=\"tooltip\">' + '<div class=\"arrow\"></div>' + '<div class=\"tooltip-inner\"></div></div>',\n    trigger: 'hover focus',\n    title: '',\n    delay: 0,\n    html: false,\n    selector: false,\n    placement: 'top',\n    offset: 0,\n    container: false,\n    fallbackPlacement: 'flip',\n    boundary: 'scrollParent'\n  };\n  var HoverState = {\n    SHOW: 'show',\n    OUT: 'out'\n  };\n  var Event = {\n    HIDE: \"hide\" + EVENT_KEY,\n    HIDDEN: \"hidden\" + EVENT_KEY,\n    SHOW: \"show\" + EVENT_KEY,\n    SHOWN: \"shown\" + EVENT_KEY,\n    INSERTED: \"inserted\" + EVENT_KEY,\n    CLICK: \"click\" + EVENT_KEY,\n    FOCUSIN: \"focusin\" + EVENT_KEY,\n    FOCUSOUT: \"focusout\" + EVENT_KEY,\n    MOUSEENTER: \"mouseenter\" + EVENT_KEY,\n    MOUSELEAVE: \"mouseleave\" + EVENT_KEY\n  };\n  var ClassName = {\n    FADE: 'fade',\n    SHOW: 'show'\n  };\n  var Selector = {\n    TOOLTIP: '.tooltip',\n    TOOLTIP_INNER: '.tooltip-inner',\n    ARROW: '.arrow'\n  };\n  var Trigger = {\n    HOVER: 'hover',\n    FOCUS: 'focus',\n    CLICK: 'click',\n    MANUAL: 'manual'\n    /**\n     * ------------------------------------------------------------------------\n     * Class Definition\n     * ------------------------------------------------------------------------\n     */\n\n  };\n\n  var Tooltip =\n  /*#__PURE__*/\n  function () {\n    function Tooltip(element, config) {\n      /**\n       * Check for Popper dependency\n       * Popper - https://popper.js.org\n       */\n      if (typeof Popper === 'undefined') {\n        throw new TypeError('Bootstrap tooltips require Popper.js (https://popper.js.org)');\n      } // private\n\n\n      this._isEnabled = true;\n      this._timeout = 0;\n      this._hoverState = '';\n      this._activeTrigger = {};\n      this._popper = null; // Protected\n\n      this.element = element;\n      this.config = this._getConfig(config);\n      this.tip = null;\n\n      this._setListeners();\n    } // Getters\n\n\n    var _proto = Tooltip.prototype;\n\n    // Public\n    _proto.enable = function enable() {\n      this._isEnabled = true;\n    };\n\n    _proto.disable = function disable() {\n      this._isEnabled = false;\n    };\n\n    _proto.toggleEnabled = function toggleEnabled() {\n      this._isEnabled = !this._isEnabled;\n    };\n\n    _proto.toggle = function toggle(event) {\n      if (!this._isEnabled) {\n        return;\n      }\n\n      if (event) {\n        var dataKey = this.constructor.DATA_KEY;\n        var context = $(event.currentTarget).data(dataKey);\n\n        if (!context) {\n          context = new this.constructor(event.currentTarget, this._getDelegateConfig());\n          $(event.currentTarget).data(dataKey, context);\n        }\n\n        context._activeTrigger.click = !context._activeTrigger.click;\n\n        if (context._isWithActiveTrigger()) {\n          context._enter(null, context);\n        } else {\n          context._leave(null, context);\n        }\n      } else {\n        if ($(this.getTipElement()).hasClass(ClassName.SHOW)) {\n          this._leave(null, this);\n\n          return;\n        }\n\n        this._enter(null, this);\n      }\n    };\n\n    _proto.dispose = function dispose() {\n      clearTimeout(this._timeout);\n      $.removeData(this.element, this.constructor.DATA_KEY);\n      $(this.element).off(this.constructor.EVENT_KEY);\n      $(this.element).closest('.modal').off('hide.bs.modal');\n\n      if (this.tip) {\n        $(this.tip).remove();\n      }\n\n      this._isEnabled = null;\n      this._timeout = null;\n      this._hoverState = null;\n      this._activeTrigger = null;\n\n      if (this._popper !== null) {\n        this._popper.destroy();\n      }\n\n      this._popper = null;\n      this.element = null;\n      this.config = null;\n      this.tip = null;\n    };\n\n    _proto.show = function show() {\n      var _this = this;\n\n      if ($(this.element).css('display') === 'none') {\n        throw new Error('Please use show on visible elements');\n      }\n\n      var showEvent = $.Event(this.constructor.Event.SHOW);\n\n      if (this.isWithContent() && this._isEnabled) {\n        $(this.element).trigger(showEvent);\n        var isInTheDom = $.contains(this.element.ownerDocument.documentElement, this.element);\n\n        if (showEvent.isDefaultPrevented() || !isInTheDom) {\n          return;\n        }\n\n        var tip = this.getTipElement();\n        var tipId = Util.getUID(this.constructor.NAME);\n        tip.setAttribute('id', tipId);\n        this.element.setAttribute('aria-describedby', tipId);\n        this.setContent();\n\n        if (this.config.animation) {\n          $(tip).addClass(ClassName.FADE);\n        }\n\n        var placement = typeof this.config.placement === 'function' ? this.config.placement.call(this, tip, this.element) : this.config.placement;\n\n        var attachment = this._getAttachment(placement);\n\n        this.addAttachmentClass(attachment);\n        var container = this.config.container === false ? document.body : $(this.config.container);\n        $(tip).data(this.constructor.DATA_KEY, this);\n\n        if (!$.contains(this.element.ownerDocument.documentElement, this.tip)) {\n          $(tip).appendTo(container);\n        }\n\n        $(this.element).trigger(this.constructor.Event.INSERTED);\n        this._popper = new Popper(this.element, tip, {\n          placement: attachment,\n          modifiers: {\n            offset: {\n              offset: this.config.offset\n            },\n            flip: {\n              behavior: this.config.fallbackPlacement\n            },\n            arrow: {\n              element: Selector.ARROW\n            },\n            preventOverflow: {\n              boundariesElement: this.config.boundary\n            }\n          },\n          onCreate: function onCreate(data) {\n            if (data.originalPlacement !== data.placement) {\n              _this._handlePopperPlacementChange(data);\n            }\n          },\n          onUpdate: function onUpdate(data) {\n            _this._handlePopperPlacementChange(data);\n          }\n        });\n        $(tip).addClass(ClassName.SHOW); // If this is a touch-enabled device we add extra\n        // empty mouseover listeners to the body's immediate children;\n        // only needed because of broken event delegation on iOS\n        // https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html\n\n        if ('ontouchstart' in document.documentElement) {\n          $(document.body).children().on('mouseover', null, $.noop);\n        }\n\n        var complete = function complete() {\n          if (_this.config.animation) {\n            _this._fixTransition();\n          }\n\n          var prevHoverState = _this._hoverState;\n          _this._hoverState = null;\n          $(_this.element).trigger(_this.constructor.Event.SHOWN);\n\n          if (prevHoverState === HoverState.OUT) {\n            _this._leave(null, _this);\n          }\n        };\n\n        if ($(this.tip).hasClass(ClassName.FADE)) {\n          var transitionDuration = Util.getTransitionDurationFromElement(this.tip);\n          $(this.tip).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);\n        } else {\n          complete();\n        }\n      }\n    };\n\n    _proto.hide = function hide(callback) {\n      var _this2 = this;\n\n      var tip = this.getTipElement();\n      var hideEvent = $.Event(this.constructor.Event.HIDE);\n\n      var complete = function complete() {\n        if (_this2._hoverState !== HoverState.SHOW && tip.parentNode) {\n          tip.parentNode.removeChild(tip);\n        }\n\n        _this2._cleanTipClass();\n\n        _this2.element.removeAttribute('aria-describedby');\n\n        $(_this2.element).trigger(_this2.constructor.Event.HIDDEN);\n\n        if (_this2._popper !== null) {\n          _this2._popper.destroy();\n        }\n\n        if (callback) {\n          callback();\n        }\n      };\n\n      $(this.element).trigger(hideEvent);\n\n      if (hideEvent.isDefaultPrevented()) {\n        return;\n      }\n\n      $(tip).removeClass(ClassName.SHOW); // If this is a touch-enabled device we remove the extra\n      // empty mouseover listeners we added for iOS support\n\n      if ('ontouchstart' in document.documentElement) {\n        $(document.body).children().off('mouseover', null, $.noop);\n      }\n\n      this._activeTrigger[Trigger.CLICK] = false;\n      this._activeTrigger[Trigger.FOCUS] = false;\n      this._activeTrigger[Trigger.HOVER] = false;\n\n      if ($(this.tip).hasClass(ClassName.FADE)) {\n        var transitionDuration = Util.getTransitionDurationFromElement(tip);\n        $(tip).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);\n      } else {\n        complete();\n      }\n\n      this._hoverState = '';\n    };\n\n    _proto.update = function update() {\n      if (this._popper !== null) {\n        this._popper.scheduleUpdate();\n      }\n    }; // Protected\n\n\n    _proto.isWithContent = function isWithContent() {\n      return Boolean(this.getTitle());\n    };\n\n    _proto.addAttachmentClass = function addAttachmentClass(attachment) {\n      $(this.getTipElement()).addClass(CLASS_PREFIX + \"-\" + attachment);\n    };\n\n    _proto.getTipElement = function getTipElement() {\n      this.tip = this.tip || $(this.config.template)[0];\n      return this.tip;\n    };\n\n    _proto.setContent = function setContent() {\n      var $tip = $(this.getTipElement());\n      this.setElementContent($tip.find(Selector.TOOLTIP_INNER), this.getTitle());\n      $tip.removeClass(ClassName.FADE + \" \" + ClassName.SHOW);\n    };\n\n    _proto.setElementContent = function setElementContent($element, content) {\n      var html = this.config.html;\n\n      if (typeof content === 'object' && (content.nodeType || content.jquery)) {\n        // Content is a DOM node or a jQuery\n        if (html) {\n          if (!$(content).parent().is($element)) {\n            $element.empty().append(content);\n          }\n        } else {\n          $element.text($(content).text());\n        }\n      } else {\n        $element[html ? 'html' : 'text'](content);\n      }\n    };\n\n    _proto.getTitle = function getTitle() {\n      var title = this.element.getAttribute('data-original-title');\n\n      if (!title) {\n        title = typeof this.config.title === 'function' ? this.config.title.call(this.element) : this.config.title;\n      }\n\n      return title;\n    }; // Private\n\n\n    _proto._getAttachment = function _getAttachment(placement) {\n      return AttachmentMap[placement.toUpperCase()];\n    };\n\n    _proto._setListeners = function _setListeners() {\n      var _this3 = this;\n\n      var triggers = this.config.trigger.split(' ');\n      triggers.forEach(function (trigger) {\n        if (trigger === 'click') {\n          $(_this3.element).on(_this3.constructor.Event.CLICK, _this3.config.selector, function (event) {\n            return _this3.toggle(event);\n          });\n        } else if (trigger !== Trigger.MANUAL) {\n          var eventIn = trigger === Trigger.HOVER ? _this3.constructor.Event.MOUSEENTER : _this3.constructor.Event.FOCUSIN;\n          var eventOut = trigger === Trigger.HOVER ? _this3.constructor.Event.MOUSELEAVE : _this3.constructor.Event.FOCUSOUT;\n          $(_this3.element).on(eventIn, _this3.config.selector, function (event) {\n            return _this3._enter(event);\n          }).on(eventOut, _this3.config.selector, function (event) {\n            return _this3._leave(event);\n          });\n        }\n\n        $(_this3.element).closest('.modal').on('hide.bs.modal', function () {\n          return _this3.hide();\n        });\n      });\n\n      if (this.config.selector) {\n        this.config = _objectSpread({}, this.config, {\n          trigger: 'manual',\n          selector: ''\n        });\n      } else {\n        this._fixTitle();\n      }\n    };\n\n    _proto._fixTitle = function _fixTitle() {\n      var titleType = typeof this.element.getAttribute('data-original-title');\n\n      if (this.element.getAttribute('title') || titleType !== 'string') {\n        this.element.setAttribute('data-original-title', this.element.getAttribute('title') || '');\n        this.element.setAttribute('title', '');\n      }\n    };\n\n    _proto._enter = function _enter(event, context) {\n      var dataKey = this.constructor.DATA_KEY;\n      context = context || $(event.currentTarget).data(dataKey);\n\n      if (!context) {\n        context = new this.constructor(event.currentTarget, this._getDelegateConfig());\n        $(event.currentTarget).data(dataKey, context);\n      }\n\n      if (event) {\n        context._activeTrigger[event.type === 'focusin' ? Trigger.FOCUS : Trigger.HOVER] = true;\n      }\n\n      if ($(context.getTipElement()).hasClass(ClassName.SHOW) || context._hoverState === HoverState.SHOW) {\n        context._hoverState = HoverState.SHOW;\n        return;\n      }\n\n      clearTimeout(context._timeout);\n      context._hoverState = HoverState.SHOW;\n\n      if (!context.config.delay || !context.config.delay.show) {\n        context.show();\n        return;\n      }\n\n      context._timeout = setTimeout(function () {\n        if (context._hoverState === HoverState.SHOW) {\n          context.show();\n        }\n      }, context.config.delay.show);\n    };\n\n    _proto._leave = function _leave(event, context) {\n      var dataKey = this.constructor.DATA_KEY;\n      context = context || $(event.currentTarget).data(dataKey);\n\n      if (!context) {\n        context = new this.constructor(event.currentTarget, this._getDelegateConfig());\n        $(event.currentTarget).data(dataKey, context);\n      }\n\n      if (event) {\n        context._activeTrigger[event.type === 'focusout' ? Trigger.FOCUS : Trigger.HOVER] = false;\n      }\n\n      if (context._isWithActiveTrigger()) {\n        return;\n      }\n\n      clearTimeout(context._timeout);\n      context._hoverState = HoverState.OUT;\n\n      if (!context.config.delay || !context.config.delay.hide) {\n        context.hide();\n        return;\n      }\n\n      context._timeout = setTimeout(function () {\n        if (context._hoverState === HoverState.OUT) {\n          context.hide();\n        }\n      }, context.config.delay.hide);\n    };\n\n    _proto._isWithActiveTrigger = function _isWithActiveTrigger() {\n      for (var trigger in this._activeTrigger) {\n        if (this._activeTrigger[trigger]) {\n          return true;\n        }\n      }\n\n      return false;\n    };\n\n    _proto._getConfig = function _getConfig(config) {\n      config = _objectSpread({}, this.constructor.Default, $(this.element).data(), typeof config === 'object' && config ? config : {});\n\n      if (typeof config.delay === 'number') {\n        config.delay = {\n          show: config.delay,\n          hide: config.delay\n        };\n      }\n\n      if (typeof config.title === 'number') {\n        config.title = config.title.toString();\n      }\n\n      if (typeof config.content === 'number') {\n        config.content = config.content.toString();\n      }\n\n      Util.typeCheckConfig(NAME, config, this.constructor.DefaultType);\n      return config;\n    };\n\n    _proto._getDelegateConfig = function _getDelegateConfig() {\n      var config = {};\n\n      if (this.config) {\n        for (var key in this.config) {\n          if (this.constructor.Default[key] !== this.config[key]) {\n            config[key] = this.config[key];\n          }\n        }\n      }\n\n      return config;\n    };\n\n    _proto._cleanTipClass = function _cleanTipClass() {\n      var $tip = $(this.getTipElement());\n      var tabClass = $tip.attr('class').match(BSCLS_PREFIX_REGEX);\n\n      if (tabClass !== null && tabClass.length > 0) {\n        $tip.removeClass(tabClass.join(''));\n      }\n    };\n\n    _proto._handlePopperPlacementChange = function _handlePopperPlacementChange(data) {\n      this._cleanTipClass();\n\n      this.addAttachmentClass(this._getAttachment(data.placement));\n    };\n\n    _proto._fixTransition = function _fixTransition() {\n      var tip = this.getTipElement();\n      var initConfigAnimation = this.config.animation;\n\n      if (tip.getAttribute('x-placement') !== null) {\n        return;\n      }\n\n      $(tip).removeClass(ClassName.FADE);\n      this.config.animation = false;\n      this.hide();\n      this.show();\n      this.config.animation = initConfigAnimation;\n    }; // Static\n\n\n    Tooltip._jQueryInterface = function _jQueryInterface(config) {\n      return this.each(function () {\n        var data = $(this).data(DATA_KEY);\n\n        var _config = typeof config === 'object' && config;\n\n        if (!data && /dispose|hide/.test(config)) {\n          return;\n        }\n\n        if (!data) {\n          data = new Tooltip(this, _config);\n          $(this).data(DATA_KEY, data);\n        }\n\n        if (typeof config === 'string') {\n          if (typeof data[config] === 'undefined') {\n            throw new TypeError(\"No method named \\\"\" + config + \"\\\"\");\n          }\n\n          data[config]();\n        }\n      });\n    };\n\n    _createClass(Tooltip, null, [{\n      key: \"VERSION\",\n      get: function get() {\n        return VERSION;\n      }\n    }, {\n      key: \"Default\",\n      get: function get() {\n        return Default;\n      }\n    }, {\n      key: \"NAME\",\n      get: function get() {\n        return NAME;\n      }\n    }, {\n      key: \"DATA_KEY\",\n      get: function get() {\n        return DATA_KEY;\n      }\n    }, {\n      key: \"Event\",\n      get: function get() {\n        return Event;\n      }\n    }, {\n      key: \"EVENT_KEY\",\n      get: function get() {\n        return EVENT_KEY;\n      }\n    }, {\n      key: \"DefaultType\",\n      get: function get() {\n        return DefaultType;\n      }\n    }]);\n\n    return Tooltip;\n  }();\n  /**\n   * ------------------------------------------------------------------------\n   * jQuery\n   * ------------------------------------------------------------------------\n   */\n\n\n  $.fn[NAME] = Tooltip._jQueryInterface;\n  $.fn[NAME].Constructor = Tooltip;\n\n  $.fn[NAME].noConflict = function () {\n    $.fn[NAME] = JQUERY_NO_CONFLICT;\n    return Tooltip._jQueryInterface;\n  };\n\n  return Tooltip;\n}($, Popper);\n//# sourceMappingURL=tooltip.js.map\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0), __webpack_require__(3)[\"default\"], __webpack_require__(1)))\n\n/***/ }),\n/* 16 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function($, Tooltip) {function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/**\n * --------------------------------------------------------------------------\n * Bootstrap (v4.1.1): popover.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n * --------------------------------------------------------------------------\n */\nvar Popover = function ($) {\n  /**\n   * ------------------------------------------------------------------------\n   * Constants\n   * ------------------------------------------------------------------------\n   */\n  var NAME = 'popover';\n  var VERSION = '4.1.1';\n  var DATA_KEY = 'bs.popover';\n  var EVENT_KEY = \".\" + DATA_KEY;\n  var JQUERY_NO_CONFLICT = $.fn[NAME];\n  var CLASS_PREFIX = 'bs-popover';\n  var BSCLS_PREFIX_REGEX = new RegExp(\"(^|\\\\s)\" + CLASS_PREFIX + \"\\\\S+\", 'g');\n\n  var Default = _objectSpread({}, Tooltip.Default, {\n    placement: 'right',\n    trigger: 'click',\n    content: '',\n    template: '<div class=\"popover\" role=\"tooltip\">' + '<div class=\"arrow\"></div>' + '<h3 class=\"popover-header\"></h3>' + '<div class=\"popover-body\"></div></div>'\n  });\n\n  var DefaultType = _objectSpread({}, Tooltip.DefaultType, {\n    content: '(string|element|function)'\n  });\n\n  var ClassName = {\n    FADE: 'fade',\n    SHOW: 'show'\n  };\n  var Selector = {\n    TITLE: '.popover-header',\n    CONTENT: '.popover-body'\n  };\n  var Event = {\n    HIDE: \"hide\" + EVENT_KEY,\n    HIDDEN: \"hidden\" + EVENT_KEY,\n    SHOW: \"show\" + EVENT_KEY,\n    SHOWN: \"shown\" + EVENT_KEY,\n    INSERTED: \"inserted\" + EVENT_KEY,\n    CLICK: \"click\" + EVENT_KEY,\n    FOCUSIN: \"focusin\" + EVENT_KEY,\n    FOCUSOUT: \"focusout\" + EVENT_KEY,\n    MOUSEENTER: \"mouseenter\" + EVENT_KEY,\n    MOUSELEAVE: \"mouseleave\" + EVENT_KEY\n    /**\n     * ------------------------------------------------------------------------\n     * Class Definition\n     * ------------------------------------------------------------------------\n     */\n\n  };\n\n  var Popover =\n  /*#__PURE__*/\n  function (_Tooltip) {\n    _inheritsLoose(Popover, _Tooltip);\n\n    function Popover() {\n      return _Tooltip.apply(this, arguments) || this;\n    }\n\n    var _proto = Popover.prototype;\n\n    // Overrides\n    _proto.isWithContent = function isWithContent() {\n      return this.getTitle() || this._getContent();\n    };\n\n    _proto.addAttachmentClass = function addAttachmentClass(attachment) {\n      $(this.getTipElement()).addClass(CLASS_PREFIX + \"-\" + attachment);\n    };\n\n    _proto.getTipElement = function getTipElement() {\n      this.tip = this.tip || $(this.config.template)[0];\n      return this.tip;\n    };\n\n    _proto.setContent = function setContent() {\n      var $tip = $(this.getTipElement()); // We use append for html objects to maintain js events\n\n      this.setElementContent($tip.find(Selector.TITLE), this.getTitle());\n\n      var content = this._getContent();\n\n      if (typeof content === 'function') {\n        content = content.call(this.element);\n      }\n\n      this.setElementContent($tip.find(Selector.CONTENT), content);\n      $tip.removeClass(ClassName.FADE + \" \" + ClassName.SHOW);\n    }; // Private\n\n\n    _proto._getContent = function _getContent() {\n      return this.element.getAttribute('data-content') || this.config.content;\n    };\n\n    _proto._cleanTipClass = function _cleanTipClass() {\n      var $tip = $(this.getTipElement());\n      var tabClass = $tip.attr('class').match(BSCLS_PREFIX_REGEX);\n\n      if (tabClass !== null && tabClass.length > 0) {\n        $tip.removeClass(tabClass.join(''));\n      }\n    }; // Static\n\n\n    Popover._jQueryInterface = function _jQueryInterface(config) {\n      return this.each(function () {\n        var data = $(this).data(DATA_KEY);\n\n        var _config = typeof config === 'object' ? config : null;\n\n        if (!data && /destroy|hide/.test(config)) {\n          return;\n        }\n\n        if (!data) {\n          data = new Popover(this, _config);\n          $(this).data(DATA_KEY, data);\n        }\n\n        if (typeof config === 'string') {\n          if (typeof data[config] === 'undefined') {\n            throw new TypeError(\"No method named \\\"\" + config + \"\\\"\");\n          }\n\n          data[config]();\n        }\n      });\n    };\n\n    _createClass(Popover, null, [{\n      key: \"VERSION\",\n      // Getters\n      get: function get() {\n        return VERSION;\n      }\n    }, {\n      key: \"Default\",\n      get: function get() {\n        return Default;\n      }\n    }, {\n      key: \"NAME\",\n      get: function get() {\n        return NAME;\n      }\n    }, {\n      key: \"DATA_KEY\",\n      get: function get() {\n        return DATA_KEY;\n      }\n    }, {\n      key: \"Event\",\n      get: function get() {\n        return Event;\n      }\n    }, {\n      key: \"EVENT_KEY\",\n      get: function get() {\n        return EVENT_KEY;\n      }\n    }, {\n      key: \"DefaultType\",\n      get: function get() {\n        return DefaultType;\n      }\n    }]);\n\n    return Popover;\n  }(Tooltip);\n  /**\n   * ------------------------------------------------------------------------\n   * jQuery\n   * ------------------------------------------------------------------------\n   */\n\n\n  $.fn[NAME] = Popover._jQueryInterface;\n  $.fn[NAME].Constructor = Popover;\n\n  $.fn[NAME].noConflict = function () {\n    $.fn[NAME] = JQUERY_NO_CONFLICT;\n    return Popover._jQueryInterface;\n  };\n\n  return Popover;\n}($);\n//# sourceMappingURL=popover.js.map\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0), __webpack_require__(17)))\n\n/***/ }),\n/* 17 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function($, Popper, Util) {function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\n * --------------------------------------------------------------------------\n * Bootstrap (v4.1.1): tooltip.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n * --------------------------------------------------------------------------\n */\nvar Tooltip = function ($) {\n  /**\n   * ------------------------------------------------------------------------\n   * Constants\n   * ------------------------------------------------------------------------\n   */\n  var NAME = 'tooltip';\n  var VERSION = '4.1.1';\n  var DATA_KEY = 'bs.tooltip';\n  var EVENT_KEY = \".\" + DATA_KEY;\n  var JQUERY_NO_CONFLICT = $.fn[NAME];\n  var CLASS_PREFIX = 'bs-tooltip';\n  var BSCLS_PREFIX_REGEX = new RegExp(\"(^|\\\\s)\" + CLASS_PREFIX + \"\\\\S+\", 'g');\n  var DefaultType = {\n    animation: 'boolean',\n    template: 'string',\n    title: '(string|element|function)',\n    trigger: 'string',\n    delay: '(number|object)',\n    html: 'boolean',\n    selector: '(string|boolean)',\n    placement: '(string|function)',\n    offset: '(number|string)',\n    container: '(string|element|boolean)',\n    fallbackPlacement: '(string|array)',\n    boundary: '(string|element)'\n  };\n  var AttachmentMap = {\n    AUTO: 'auto',\n    TOP: 'top',\n    RIGHT: 'right',\n    BOTTOM: 'bottom',\n    LEFT: 'left'\n  };\n  var Default = {\n    animation: true,\n    template: '<div class=\"tooltip\" role=\"tooltip\">' + '<div class=\"arrow\"></div>' + '<div class=\"tooltip-inner\"></div></div>',\n    trigger: 'hover focus',\n    title: '',\n    delay: 0,\n    html: false,\n    selector: false,\n    placement: 'top',\n    offset: 0,\n    container: false,\n    fallbackPlacement: 'flip',\n    boundary: 'scrollParent'\n  };\n  var HoverState = {\n    SHOW: 'show',\n    OUT: 'out'\n  };\n  var Event = {\n    HIDE: \"hide\" + EVENT_KEY,\n    HIDDEN: \"hidden\" + EVENT_KEY,\n    SHOW: \"show\" + EVENT_KEY,\n    SHOWN: \"shown\" + EVENT_KEY,\n    INSERTED: \"inserted\" + EVENT_KEY,\n    CLICK: \"click\" + EVENT_KEY,\n    FOCUSIN: \"focusin\" + EVENT_KEY,\n    FOCUSOUT: \"focusout\" + EVENT_KEY,\n    MOUSEENTER: \"mouseenter\" + EVENT_KEY,\n    MOUSELEAVE: \"mouseleave\" + EVENT_KEY\n  };\n  var ClassName = {\n    FADE: 'fade',\n    SHOW: 'show'\n  };\n  var Selector = {\n    TOOLTIP: '.tooltip',\n    TOOLTIP_INNER: '.tooltip-inner',\n    ARROW: '.arrow'\n  };\n  var Trigger = {\n    HOVER: 'hover',\n    FOCUS: 'focus',\n    CLICK: 'click',\n    MANUAL: 'manual'\n    /**\n     * ------------------------------------------------------------------------\n     * Class Definition\n     * ------------------------------------------------------------------------\n     */\n\n  };\n\n  var Tooltip =\n  /*#__PURE__*/\n  function () {\n    function Tooltip(element, config) {\n      /**\n       * Check for Popper dependency\n       * Popper - https://popper.js.org\n       */\n      if (typeof Popper === 'undefined') {\n        throw new TypeError('Bootstrap tooltips require Popper.js (https://popper.js.org)');\n      } // private\n\n\n      this._isEnabled = true;\n      this._timeout = 0;\n      this._hoverState = '';\n      this._activeTrigger = {};\n      this._popper = null; // Protected\n\n      this.element = element;\n      this.config = this._getConfig(config);\n      this.tip = null;\n\n      this._setListeners();\n    } // Getters\n\n\n    var _proto = Tooltip.prototype;\n\n    // Public\n    _proto.enable = function enable() {\n      this._isEnabled = true;\n    };\n\n    _proto.disable = function disable() {\n      this._isEnabled = false;\n    };\n\n    _proto.toggleEnabled = function toggleEnabled() {\n      this._isEnabled = !this._isEnabled;\n    };\n\n    _proto.toggle = function toggle(event) {\n      if (!this._isEnabled) {\n        return;\n      }\n\n      if (event) {\n        var dataKey = this.constructor.DATA_KEY;\n        var context = $(event.currentTarget).data(dataKey);\n\n        if (!context) {\n          context = new this.constructor(event.currentTarget, this._getDelegateConfig());\n          $(event.currentTarget).data(dataKey, context);\n        }\n\n        context._activeTrigger.click = !context._activeTrigger.click;\n\n        if (context._isWithActiveTrigger()) {\n          context._enter(null, context);\n        } else {\n          context._leave(null, context);\n        }\n      } else {\n        if ($(this.getTipElement()).hasClass(ClassName.SHOW)) {\n          this._leave(null, this);\n\n          return;\n        }\n\n        this._enter(null, this);\n      }\n    };\n\n    _proto.dispose = function dispose() {\n      clearTimeout(this._timeout);\n      $.removeData(this.element, this.constructor.DATA_KEY);\n      $(this.element).off(this.constructor.EVENT_KEY);\n      $(this.element).closest('.modal').off('hide.bs.modal');\n\n      if (this.tip) {\n        $(this.tip).remove();\n      }\n\n      this._isEnabled = null;\n      this._timeout = null;\n      this._hoverState = null;\n      this._activeTrigger = null;\n\n      if (this._popper !== null) {\n        this._popper.destroy();\n      }\n\n      this._popper = null;\n      this.element = null;\n      this.config = null;\n      this.tip = null;\n    };\n\n    _proto.show = function show() {\n      var _this = this;\n\n      if ($(this.element).css('display') === 'none') {\n        throw new Error('Please use show on visible elements');\n      }\n\n      var showEvent = $.Event(this.constructor.Event.SHOW);\n\n      if (this.isWithContent() && this._isEnabled) {\n        $(this.element).trigger(showEvent);\n        var isInTheDom = $.contains(this.element.ownerDocument.documentElement, this.element);\n\n        if (showEvent.isDefaultPrevented() || !isInTheDom) {\n          return;\n        }\n\n        var tip = this.getTipElement();\n        var tipId = Util.getUID(this.constructor.NAME);\n        tip.setAttribute('id', tipId);\n        this.element.setAttribute('aria-describedby', tipId);\n        this.setContent();\n\n        if (this.config.animation) {\n          $(tip).addClass(ClassName.FADE);\n        }\n\n        var placement = typeof this.config.placement === 'function' ? this.config.placement.call(this, tip, this.element) : this.config.placement;\n\n        var attachment = this._getAttachment(placement);\n\n        this.addAttachmentClass(attachment);\n        var container = this.config.container === false ? document.body : $(this.config.container);\n        $(tip).data(this.constructor.DATA_KEY, this);\n\n        if (!$.contains(this.element.ownerDocument.documentElement, this.tip)) {\n          $(tip).appendTo(container);\n        }\n\n        $(this.element).trigger(this.constructor.Event.INSERTED);\n        this._popper = new Popper(this.element, tip, {\n          placement: attachment,\n          modifiers: {\n            offset: {\n              offset: this.config.offset\n            },\n            flip: {\n              behavior: this.config.fallbackPlacement\n            },\n            arrow: {\n              element: Selector.ARROW\n            },\n            preventOverflow: {\n              boundariesElement: this.config.boundary\n            }\n          },\n          onCreate: function onCreate(data) {\n            if (data.originalPlacement !== data.placement) {\n              _this._handlePopperPlacementChange(data);\n            }\n          },\n          onUpdate: function onUpdate(data) {\n            _this._handlePopperPlacementChange(data);\n          }\n        });\n        $(tip).addClass(ClassName.SHOW); // If this is a touch-enabled device we add extra\n        // empty mouseover listeners to the body's immediate children;\n        // only needed because of broken event delegation on iOS\n        // https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html\n\n        if ('ontouchstart' in document.documentElement) {\n          $(document.body).children().on('mouseover', null, $.noop);\n        }\n\n        var complete = function complete() {\n          if (_this.config.animation) {\n            _this._fixTransition();\n          }\n\n          var prevHoverState = _this._hoverState;\n          _this._hoverState = null;\n          $(_this.element).trigger(_this.constructor.Event.SHOWN);\n\n          if (prevHoverState === HoverState.OUT) {\n            _this._leave(null, _this);\n          }\n        };\n\n        if ($(this.tip).hasClass(ClassName.FADE)) {\n          var transitionDuration = Util.getTransitionDurationFromElement(this.tip);\n          $(this.tip).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);\n        } else {\n          complete();\n        }\n      }\n    };\n\n    _proto.hide = function hide(callback) {\n      var _this2 = this;\n\n      var tip = this.getTipElement();\n      var hideEvent = $.Event(this.constructor.Event.HIDE);\n\n      var complete = function complete() {\n        if (_this2._hoverState !== HoverState.SHOW && tip.parentNode) {\n          tip.parentNode.removeChild(tip);\n        }\n\n        _this2._cleanTipClass();\n\n        _this2.element.removeAttribute('aria-describedby');\n\n        $(_this2.element).trigger(_this2.constructor.Event.HIDDEN);\n\n        if (_this2._popper !== null) {\n          _this2._popper.destroy();\n        }\n\n        if (callback) {\n          callback();\n        }\n      };\n\n      $(this.element).trigger(hideEvent);\n\n      if (hideEvent.isDefaultPrevented()) {\n        return;\n      }\n\n      $(tip).removeClass(ClassName.SHOW); // If this is a touch-enabled device we remove the extra\n      // empty mouseover listeners we added for iOS support\n\n      if ('ontouchstart' in document.documentElement) {\n        $(document.body).children().off('mouseover', null, $.noop);\n      }\n\n      this._activeTrigger[Trigger.CLICK] = false;\n      this._activeTrigger[Trigger.FOCUS] = false;\n      this._activeTrigger[Trigger.HOVER] = false;\n\n      if ($(this.tip).hasClass(ClassName.FADE)) {\n        var transitionDuration = Util.getTransitionDurationFromElement(tip);\n        $(tip).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);\n      } else {\n        complete();\n      }\n\n      this._hoverState = '';\n    };\n\n    _proto.update = function update() {\n      if (this._popper !== null) {\n        this._popper.scheduleUpdate();\n      }\n    }; // Protected\n\n\n    _proto.isWithContent = function isWithContent() {\n      return Boolean(this.getTitle());\n    };\n\n    _proto.addAttachmentClass = function addAttachmentClass(attachment) {\n      $(this.getTipElement()).addClass(CLASS_PREFIX + \"-\" + attachment);\n    };\n\n    _proto.getTipElement = function getTipElement() {\n      this.tip = this.tip || $(this.config.template)[0];\n      return this.tip;\n    };\n\n    _proto.setContent = function setContent() {\n      var $tip = $(this.getTipElement());\n      this.setElementContent($tip.find(Selector.TOOLTIP_INNER), this.getTitle());\n      $tip.removeClass(ClassName.FADE + \" \" + ClassName.SHOW);\n    };\n\n    _proto.setElementContent = function setElementContent($element, content) {\n      var html = this.config.html;\n\n      if (typeof content === 'object' && (content.nodeType || content.jquery)) {\n        // Content is a DOM node or a jQuery\n        if (html) {\n          if (!$(content).parent().is($element)) {\n            $element.empty().append(content);\n          }\n        } else {\n          $element.text($(content).text());\n        }\n      } else {\n        $element[html ? 'html' : 'text'](content);\n      }\n    };\n\n    _proto.getTitle = function getTitle() {\n      var title = this.element.getAttribute('data-original-title');\n\n      if (!title) {\n        title = typeof this.config.title === 'function' ? this.config.title.call(this.element) : this.config.title;\n      }\n\n      return title;\n    }; // Private\n\n\n    _proto._getAttachment = function _getAttachment(placement) {\n      return AttachmentMap[placement.toUpperCase()];\n    };\n\n    _proto._setListeners = function _setListeners() {\n      var _this3 = this;\n\n      var triggers = this.config.trigger.split(' ');\n      triggers.forEach(function (trigger) {\n        if (trigger === 'click') {\n          $(_this3.element).on(_this3.constructor.Event.CLICK, _this3.config.selector, function (event) {\n            return _this3.toggle(event);\n          });\n        } else if (trigger !== Trigger.MANUAL) {\n          var eventIn = trigger === Trigger.HOVER ? _this3.constructor.Event.MOUSEENTER : _this3.constructor.Event.FOCUSIN;\n          var eventOut = trigger === Trigger.HOVER ? _this3.constructor.Event.MOUSELEAVE : _this3.constructor.Event.FOCUSOUT;\n          $(_this3.element).on(eventIn, _this3.config.selector, function (event) {\n            return _this3._enter(event);\n          }).on(eventOut, _this3.config.selector, function (event) {\n            return _this3._leave(event);\n          });\n        }\n\n        $(_this3.element).closest('.modal').on('hide.bs.modal', function () {\n          return _this3.hide();\n        });\n      });\n\n      if (this.config.selector) {\n        this.config = _objectSpread({}, this.config, {\n          trigger: 'manual',\n          selector: ''\n        });\n      } else {\n        this._fixTitle();\n      }\n    };\n\n    _proto._fixTitle = function _fixTitle() {\n      var titleType = typeof this.element.getAttribute('data-original-title');\n\n      if (this.element.getAttribute('title') || titleType !== 'string') {\n        this.element.setAttribute('data-original-title', this.element.getAttribute('title') || '');\n        this.element.setAttribute('title', '');\n      }\n    };\n\n    _proto._enter = function _enter(event, context) {\n      var dataKey = this.constructor.DATA_KEY;\n      context = context || $(event.currentTarget).data(dataKey);\n\n      if (!context) {\n        context = new this.constructor(event.currentTarget, this._getDelegateConfig());\n        $(event.currentTarget).data(dataKey, context);\n      }\n\n      if (event) {\n        context._activeTrigger[event.type === 'focusin' ? Trigger.FOCUS : Trigger.HOVER] = true;\n      }\n\n      if ($(context.getTipElement()).hasClass(ClassName.SHOW) || context._hoverState === HoverState.SHOW) {\n        context._hoverState = HoverState.SHOW;\n        return;\n      }\n\n      clearTimeout(context._timeout);\n      context._hoverState = HoverState.SHOW;\n\n      if (!context.config.delay || !context.config.delay.show) {\n        context.show();\n        return;\n      }\n\n      context._timeout = setTimeout(function () {\n        if (context._hoverState === HoverState.SHOW) {\n          context.show();\n        }\n      }, context.config.delay.show);\n    };\n\n    _proto._leave = function _leave(event, context) {\n      var dataKey = this.constructor.DATA_KEY;\n      context = context || $(event.currentTarget).data(dataKey);\n\n      if (!context) {\n        context = new this.constructor(event.currentTarget, this._getDelegateConfig());\n        $(event.currentTarget).data(dataKey, context);\n      }\n\n      if (event) {\n        context._activeTrigger[event.type === 'focusout' ? Trigger.FOCUS : Trigger.HOVER] = false;\n      }\n\n      if (context._isWithActiveTrigger()) {\n        return;\n      }\n\n      clearTimeout(context._timeout);\n      context._hoverState = HoverState.OUT;\n\n      if (!context.config.delay || !context.config.delay.hide) {\n        context.hide();\n        return;\n      }\n\n      context._timeout = setTimeout(function () {\n        if (context._hoverState === HoverState.OUT) {\n          context.hide();\n        }\n      }, context.config.delay.hide);\n    };\n\n    _proto._isWithActiveTrigger = function _isWithActiveTrigger() {\n      for (var trigger in this._activeTrigger) {\n        if (this._activeTrigger[trigger]) {\n          return true;\n        }\n      }\n\n      return false;\n    };\n\n    _proto._getConfig = function _getConfig(config) {\n      config = _objectSpread({}, this.constructor.Default, $(this.element).data(), typeof config === 'object' && config ? config : {});\n\n      if (typeof config.delay === 'number') {\n        config.delay = {\n          show: config.delay,\n          hide: config.delay\n        };\n      }\n\n      if (typeof config.title === 'number') {\n        config.title = config.title.toString();\n      }\n\n      if (typeof config.content === 'number') {\n        config.content = config.content.toString();\n      }\n\n      Util.typeCheckConfig(NAME, config, this.constructor.DefaultType);\n      return config;\n    };\n\n    _proto._getDelegateConfig = function _getDelegateConfig() {\n      var config = {};\n\n      if (this.config) {\n        for (var key in this.config) {\n          if (this.constructor.Default[key] !== this.config[key]) {\n            config[key] = this.config[key];\n          }\n        }\n      }\n\n      return config;\n    };\n\n    _proto._cleanTipClass = function _cleanTipClass() {\n      var $tip = $(this.getTipElement());\n      var tabClass = $tip.attr('class').match(BSCLS_PREFIX_REGEX);\n\n      if (tabClass !== null && tabClass.length > 0) {\n        $tip.removeClass(tabClass.join(''));\n      }\n    };\n\n    _proto._handlePopperPlacementChange = function _handlePopperPlacementChange(data) {\n      this._cleanTipClass();\n\n      this.addAttachmentClass(this._getAttachment(data.placement));\n    };\n\n    _proto._fixTransition = function _fixTransition() {\n      var tip = this.getTipElement();\n      var initConfigAnimation = this.config.animation;\n\n      if (tip.getAttribute('x-placement') !== null) {\n        return;\n      }\n\n      $(tip).removeClass(ClassName.FADE);\n      this.config.animation = false;\n      this.hide();\n      this.show();\n      this.config.animation = initConfigAnimation;\n    }; // Static\n\n\n    Tooltip._jQueryInterface = function _jQueryInterface(config) {\n      return this.each(function () {\n        var data = $(this).data(DATA_KEY);\n\n        var _config = typeof config === 'object' && config;\n\n        if (!data && /dispose|hide/.test(config)) {\n          return;\n        }\n\n        if (!data) {\n          data = new Tooltip(this, _config);\n          $(this).data(DATA_KEY, data);\n        }\n\n        if (typeof config === 'string') {\n          if (typeof data[config] === 'undefined') {\n            throw new TypeError(\"No method named \\\"\" + config + \"\\\"\");\n          }\n\n          data[config]();\n        }\n      });\n    };\n\n    _createClass(Tooltip, null, [{\n      key: \"VERSION\",\n      get: function get() {\n        return VERSION;\n      }\n    }, {\n      key: \"Default\",\n      get: function get() {\n        return Default;\n      }\n    }, {\n      key: \"NAME\",\n      get: function get() {\n        return NAME;\n      }\n    }, {\n      key: \"DATA_KEY\",\n      get: function get() {\n        return DATA_KEY;\n      }\n    }, {\n      key: \"Event\",\n      get: function get() {\n        return Event;\n      }\n    }, {\n      key: \"EVENT_KEY\",\n      get: function get() {\n        return EVENT_KEY;\n      }\n    }, {\n      key: \"DefaultType\",\n      get: function get() {\n        return DefaultType;\n      }\n    }]);\n\n    return Tooltip;\n  }();\n  /**\n   * ------------------------------------------------------------------------\n   * jQuery\n   * ------------------------------------------------------------------------\n   */\n\n\n  $.fn[NAME] = Tooltip._jQueryInterface;\n  $.fn[NAME].Constructor = Tooltip;\n\n  $.fn[NAME].noConflict = function () {\n    $.fn[NAME] = JQUERY_NO_CONFLICT;\n    return Tooltip._jQueryInterface;\n  };\n\n  return Tooltip;\n}($, Popper);\n//# sourceMappingURL=tooltip.js.map\n\n/*** EXPORTS FROM exports-loader ***/\nmodule.exports = Tooltip;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0), __webpack_require__(3)[\"default\"], __webpack_require__(1)))\n\n/***/ }),\n/* 18 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function($, Util) {function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\n * --------------------------------------------------------------------------\n * Bootstrap (v4.1.1): scrollspy.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n * --------------------------------------------------------------------------\n */\nvar ScrollSpy = function ($) {\n  /**\n   * ------------------------------------------------------------------------\n   * Constants\n   * ------------------------------------------------------------------------\n   */\n  var NAME = 'scrollspy';\n  var VERSION = '4.1.1';\n  var DATA_KEY = 'bs.scrollspy';\n  var EVENT_KEY = \".\" + DATA_KEY;\n  var DATA_API_KEY = '.data-api';\n  var JQUERY_NO_CONFLICT = $.fn[NAME];\n  var Default = {\n    offset: 10,\n    method: 'auto',\n    target: ''\n  };\n  var DefaultType = {\n    offset: 'number',\n    method: 'string',\n    target: '(string|element)'\n  };\n  var Event = {\n    ACTIVATE: \"activate\" + EVENT_KEY,\n    SCROLL: \"scroll\" + EVENT_KEY,\n    LOAD_DATA_API: \"load\" + EVENT_KEY + DATA_API_KEY\n  };\n  var ClassName = {\n    DROPDOWN_ITEM: 'dropdown-item',\n    DROPDOWN_MENU: 'dropdown-menu',\n    ACTIVE: 'active'\n  };\n  var Selector = {\n    DATA_SPY: '[data-spy=\"scroll\"]',\n    ACTIVE: '.active',\n    NAV_LIST_GROUP: '.nav, .list-group',\n    NAV_LINKS: '.nav-link',\n    NAV_ITEMS: '.nav-item',\n    LIST_ITEMS: '.list-group-item',\n    DROPDOWN: '.dropdown',\n    DROPDOWN_ITEMS: '.dropdown-item',\n    DROPDOWN_TOGGLE: '.dropdown-toggle'\n  };\n  var OffsetMethod = {\n    OFFSET: 'offset',\n    POSITION: 'position'\n    /**\n     * ------------------------------------------------------------------------\n     * Class Definition\n     * ------------------------------------------------------------------------\n     */\n\n  };\n\n  var ScrollSpy =\n  /*#__PURE__*/\n  function () {\n    function ScrollSpy(element, config) {\n      var _this = this;\n\n      this._element = element;\n      this._scrollElement = element.tagName === 'BODY' ? window : element;\n      this._config = this._getConfig(config);\n      this._selector = this._config.target + \" \" + Selector.NAV_LINKS + \",\" + (this._config.target + \" \" + Selector.LIST_ITEMS + \",\") + (this._config.target + \" \" + Selector.DROPDOWN_ITEMS);\n      this._offsets = [];\n      this._targets = [];\n      this._activeTarget = null;\n      this._scrollHeight = 0;\n      $(this._scrollElement).on(Event.SCROLL, function (event) {\n        return _this._process(event);\n      });\n      this.refresh();\n\n      this._process();\n    } // Getters\n\n\n    var _proto = ScrollSpy.prototype;\n\n    // Public\n    _proto.refresh = function refresh() {\n      var _this2 = this;\n\n      var autoMethod = this._scrollElement === this._scrollElement.window ? OffsetMethod.OFFSET : OffsetMethod.POSITION;\n      var offsetMethod = this._config.method === 'auto' ? autoMethod : this._config.method;\n      var offsetBase = offsetMethod === OffsetMethod.POSITION ? this._getScrollTop() : 0;\n      this._offsets = [];\n      this._targets = [];\n      this._scrollHeight = this._getScrollHeight();\n      var targets = $.makeArray($(this._selector));\n      targets.map(function (element) {\n        var target;\n        var targetSelector = Util.getSelectorFromElement(element);\n\n        if (targetSelector) {\n          target = $(targetSelector)[0];\n        }\n\n        if (target) {\n          var targetBCR = target.getBoundingClientRect();\n\n          if (targetBCR.width || targetBCR.height) {\n            // TODO (fat): remove sketch reliance on jQuery position/offset\n            return [$(target)[offsetMethod]().top + offsetBase, targetSelector];\n          }\n        }\n\n        return null;\n      }).filter(function (item) {\n        return item;\n      }).sort(function (a, b) {\n        return a[0] - b[0];\n      }).forEach(function (item) {\n        _this2._offsets.push(item[0]);\n\n        _this2._targets.push(item[1]);\n      });\n    };\n\n    _proto.dispose = function dispose() {\n      $.removeData(this._element, DATA_KEY);\n      $(this._scrollElement).off(EVENT_KEY);\n      this._element = null;\n      this._scrollElement = null;\n      this._config = null;\n      this._selector = null;\n      this._offsets = null;\n      this._targets = null;\n      this._activeTarget = null;\n      this._scrollHeight = null;\n    }; // Private\n\n\n    _proto._getConfig = function _getConfig(config) {\n      config = _objectSpread({}, Default, typeof config === 'object' && config ? config : {});\n\n      if (typeof config.target !== 'string') {\n        var id = $(config.target).attr('id');\n\n        if (!id) {\n          id = Util.getUID(NAME);\n          $(config.target).attr('id', id);\n        }\n\n        config.target = \"#\" + id;\n      }\n\n      Util.typeCheckConfig(NAME, config, DefaultType);\n      return config;\n    };\n\n    _proto._getScrollTop = function _getScrollTop() {\n      return this._scrollElement === window ? this._scrollElement.pageYOffset : this._scrollElement.scrollTop;\n    };\n\n    _proto._getScrollHeight = function _getScrollHeight() {\n      return this._scrollElement.scrollHeight || Math.max(document.body.scrollHeight, document.documentElement.scrollHeight);\n    };\n\n    _proto._getOffsetHeight = function _getOffsetHeight() {\n      return this._scrollElement === window ? window.innerHeight : this._scrollElement.getBoundingClientRect().height;\n    };\n\n    _proto._process = function _process() {\n      var scrollTop = this._getScrollTop() + this._config.offset;\n\n      var scrollHeight = this._getScrollHeight();\n\n      var maxScroll = this._config.offset + scrollHeight - this._getOffsetHeight();\n\n      if (this._scrollHeight !== scrollHeight) {\n        this.refresh();\n      }\n\n      if (scrollTop >= maxScroll) {\n        var target = this._targets[this._targets.length - 1];\n\n        if (this._activeTarget !== target) {\n          this._activate(target);\n        }\n\n        return;\n      }\n\n      if (this._activeTarget && scrollTop < this._offsets[0] && this._offsets[0] > 0) {\n        this._activeTarget = null;\n\n        this._clear();\n\n        return;\n      }\n\n      for (var i = this._offsets.length; i--;) {\n        var isActiveTarget = this._activeTarget !== this._targets[i] && scrollTop >= this._offsets[i] && (typeof this._offsets[i + 1] === 'undefined' || scrollTop < this._offsets[i + 1]);\n\n        if (isActiveTarget) {\n          this._activate(this._targets[i]);\n        }\n      }\n    };\n\n    _proto._activate = function _activate(target) {\n      this._activeTarget = target;\n\n      this._clear();\n\n      var queries = this._selector.split(','); // eslint-disable-next-line arrow-body-style\n\n\n      queries = queries.map(function (selector) {\n        return selector + \"[data-target=\\\"\" + target + \"\\\"],\" + (selector + \"[href=\\\"\" + target + \"\\\"]\");\n      });\n      var $link = $(queries.join(','));\n\n      if ($link.hasClass(ClassName.DROPDOWN_ITEM)) {\n        $link.closest(Selector.DROPDOWN).find(Selector.DROPDOWN_TOGGLE).addClass(ClassName.ACTIVE);\n        $link.addClass(ClassName.ACTIVE);\n      } else {\n        // Set triggered link as active\n        $link.addClass(ClassName.ACTIVE); // Set triggered links parents as active\n        // With both <ul> and <nav> markup a parent is the previous sibling of any nav ancestor\n\n        $link.parents(Selector.NAV_LIST_GROUP).prev(Selector.NAV_LINKS + \", \" + Selector.LIST_ITEMS).addClass(ClassName.ACTIVE); // Handle special case when .nav-link is inside .nav-item\n\n        $link.parents(Selector.NAV_LIST_GROUP).prev(Selector.NAV_ITEMS).children(Selector.NAV_LINKS).addClass(ClassName.ACTIVE);\n      }\n\n      $(this._scrollElement).trigger(Event.ACTIVATE, {\n        relatedTarget: target\n      });\n    };\n\n    _proto._clear = function _clear() {\n      $(this._selector).filter(Selector.ACTIVE).removeClass(ClassName.ACTIVE);\n    }; // Static\n\n\n    ScrollSpy._jQueryInterface = function _jQueryInterface(config) {\n      return this.each(function () {\n        var data = $(this).data(DATA_KEY);\n\n        var _config = typeof config === 'object' && config;\n\n        if (!data) {\n          data = new ScrollSpy(this, _config);\n          $(this).data(DATA_KEY, data);\n        }\n\n        if (typeof config === 'string') {\n          if (typeof data[config] === 'undefined') {\n            throw new TypeError(\"No method named \\\"\" + config + \"\\\"\");\n          }\n\n          data[config]();\n        }\n      });\n    };\n\n    _createClass(ScrollSpy, null, [{\n      key: \"VERSION\",\n      get: function get() {\n        return VERSION;\n      }\n    }, {\n      key: \"Default\",\n      get: function get() {\n        return Default;\n      }\n    }]);\n\n    return ScrollSpy;\n  }();\n  /**\n   * ------------------------------------------------------------------------\n   * Data Api implementation\n   * ------------------------------------------------------------------------\n   */\n\n\n  $(window).on(Event.LOAD_DATA_API, function () {\n    var scrollSpys = $.makeArray($(Selector.DATA_SPY));\n\n    for (var i = scrollSpys.length; i--;) {\n      var $spy = $(scrollSpys[i]);\n\n      ScrollSpy._jQueryInterface.call($spy, $spy.data());\n    }\n  });\n  /**\n   * ------------------------------------------------------------------------\n   * jQuery\n   * ------------------------------------------------------------------------\n   */\n\n  $.fn[NAME] = ScrollSpy._jQueryInterface;\n  $.fn[NAME].Constructor = ScrollSpy;\n\n  $.fn[NAME].noConflict = function () {\n    $.fn[NAME] = JQUERY_NO_CONFLICT;\n    return ScrollSpy._jQueryInterface;\n  };\n\n  return ScrollSpy;\n}($);\n//# sourceMappingURL=scrollspy.js.map\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0), __webpack_require__(1)))\n\n/***/ }),\n/* 19 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function($, Util) {function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\n * --------------------------------------------------------------------------\n * Bootstrap (v4.1.1): tab.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n * --------------------------------------------------------------------------\n */\nvar Tab = function ($) {\n  /**\n   * ------------------------------------------------------------------------\n   * Constants\n   * ------------------------------------------------------------------------\n   */\n  var NAME = 'tab';\n  var VERSION = '4.1.1';\n  var DATA_KEY = 'bs.tab';\n  var EVENT_KEY = \".\" + DATA_KEY;\n  var DATA_API_KEY = '.data-api';\n  var JQUERY_NO_CONFLICT = $.fn[NAME];\n  var Event = {\n    HIDE: \"hide\" + EVENT_KEY,\n    HIDDEN: \"hidden\" + EVENT_KEY,\n    SHOW: \"show\" + EVENT_KEY,\n    SHOWN: \"shown\" + EVENT_KEY,\n    CLICK_DATA_API: \"click\" + EVENT_KEY + DATA_API_KEY\n  };\n  var ClassName = {\n    DROPDOWN_MENU: 'dropdown-menu',\n    ACTIVE: 'active',\n    DISABLED: 'disabled',\n    FADE: 'fade',\n    SHOW: 'show'\n  };\n  var Selector = {\n    DROPDOWN: '.dropdown',\n    NAV_LIST_GROUP: '.nav, .list-group',\n    ACTIVE: '.active',\n    ACTIVE_UL: '> li > .active',\n    DATA_TOGGLE: '[data-toggle=\"tab\"], [data-toggle=\"pill\"], [data-toggle=\"list\"]',\n    DROPDOWN_TOGGLE: '.dropdown-toggle',\n    DROPDOWN_ACTIVE_CHILD: '> .dropdown-menu .active'\n    /**\n     * ------------------------------------------------------------------------\n     * Class Definition\n     * ------------------------------------------------------------------------\n     */\n\n  };\n\n  var Tab =\n  /*#__PURE__*/\n  function () {\n    function Tab(element) {\n      this._element = element;\n    } // Getters\n\n\n    var _proto = Tab.prototype;\n\n    // Public\n    _proto.show = function show() {\n      var _this = this;\n\n      if (this._element.parentNode && this._element.parentNode.nodeType === Node.ELEMENT_NODE && $(this._element).hasClass(ClassName.ACTIVE) || $(this._element).hasClass(ClassName.DISABLED)) {\n        return;\n      }\n\n      var target;\n      var previous;\n      var listElement = $(this._element).closest(Selector.NAV_LIST_GROUP)[0];\n      var selector = Util.getSelectorFromElement(this._element);\n\n      if (listElement) {\n        var itemSelector = listElement.nodeName === 'UL' ? Selector.ACTIVE_UL : Selector.ACTIVE;\n        previous = $.makeArray($(listElement).find(itemSelector));\n        previous = previous[previous.length - 1];\n      }\n\n      var hideEvent = $.Event(Event.HIDE, {\n        relatedTarget: this._element\n      });\n      var showEvent = $.Event(Event.SHOW, {\n        relatedTarget: previous\n      });\n\n      if (previous) {\n        $(previous).trigger(hideEvent);\n      }\n\n      $(this._element).trigger(showEvent);\n\n      if (showEvent.isDefaultPrevented() || hideEvent.isDefaultPrevented()) {\n        return;\n      }\n\n      if (selector) {\n        target = $(selector)[0];\n      }\n\n      this._activate(this._element, listElement);\n\n      var complete = function complete() {\n        var hiddenEvent = $.Event(Event.HIDDEN, {\n          relatedTarget: _this._element\n        });\n        var shownEvent = $.Event(Event.SHOWN, {\n          relatedTarget: previous\n        });\n        $(previous).trigger(hiddenEvent);\n        $(_this._element).trigger(shownEvent);\n      };\n\n      if (target) {\n        this._activate(target, target.parentNode, complete);\n      } else {\n        complete();\n      }\n    };\n\n    _proto.dispose = function dispose() {\n      $.removeData(this._element, DATA_KEY);\n      this._element = null;\n    }; // Private\n\n\n    _proto._activate = function _activate(element, container, callback) {\n      var _this2 = this;\n\n      var activeElements;\n\n      if (container.nodeName === 'UL') {\n        activeElements = $(container).find(Selector.ACTIVE_UL);\n      } else {\n        activeElements = $(container).children(Selector.ACTIVE);\n      }\n\n      var active = activeElements[0];\n      var isTransitioning = callback && active && $(active).hasClass(ClassName.FADE);\n\n      var complete = function complete() {\n        return _this2._transitionComplete(element, active, callback);\n      };\n\n      if (active && isTransitioning) {\n        var transitionDuration = Util.getTransitionDurationFromElement(active);\n        $(active).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);\n      } else {\n        complete();\n      }\n    };\n\n    _proto._transitionComplete = function _transitionComplete(element, active, callback) {\n      if (active) {\n        $(active).removeClass(ClassName.SHOW + \" \" + ClassName.ACTIVE);\n        var dropdownChild = $(active.parentNode).find(Selector.DROPDOWN_ACTIVE_CHILD)[0];\n\n        if (dropdownChild) {\n          $(dropdownChild).removeClass(ClassName.ACTIVE);\n        }\n\n        if (active.getAttribute('role') === 'tab') {\n          active.setAttribute('aria-selected', false);\n        }\n      }\n\n      $(element).addClass(ClassName.ACTIVE);\n\n      if (element.getAttribute('role') === 'tab') {\n        element.setAttribute('aria-selected', true);\n      }\n\n      Util.reflow(element);\n      $(element).addClass(ClassName.SHOW);\n\n      if (element.parentNode && $(element.parentNode).hasClass(ClassName.DROPDOWN_MENU)) {\n        var dropdownElement = $(element).closest(Selector.DROPDOWN)[0];\n\n        if (dropdownElement) {\n          $(dropdownElement).find(Selector.DROPDOWN_TOGGLE).addClass(ClassName.ACTIVE);\n        }\n\n        element.setAttribute('aria-expanded', true);\n      }\n\n      if (callback) {\n        callback();\n      }\n    }; // Static\n\n\n    Tab._jQueryInterface = function _jQueryInterface(config) {\n      return this.each(function () {\n        var $this = $(this);\n        var data = $this.data(DATA_KEY);\n\n        if (!data) {\n          data = new Tab(this);\n          $this.data(DATA_KEY, data);\n        }\n\n        if (typeof config === 'string') {\n          if (typeof data[config] === 'undefined') {\n            throw new TypeError(\"No method named \\\"\" + config + \"\\\"\");\n          }\n\n          data[config]();\n        }\n      });\n    };\n\n    _createClass(Tab, null, [{\n      key: \"VERSION\",\n      get: function get() {\n        return VERSION;\n      }\n    }]);\n\n    return Tab;\n  }();\n  /**\n   * ------------------------------------------------------------------------\n   * Data Api implementation\n   * ------------------------------------------------------------------------\n   */\n\n\n  $(document).on(Event.CLICK_DATA_API, Selector.DATA_TOGGLE, function (event) {\n    event.preventDefault();\n\n    Tab._jQueryInterface.call($(this), 'show');\n  });\n  /**\n   * ------------------------------------------------------------------------\n   * jQuery\n   * ------------------------------------------------------------------------\n   */\n\n  $.fn[NAME] = Tab._jQueryInterface;\n  $.fn[NAME].Constructor = Tab;\n\n  $.fn[NAME].noConflict = function () {\n    $.fn[NAME] = JQUERY_NO_CONFLICT;\n    return Tab._jQueryInterface;\n  };\n\n  return Tab;\n}($);\n//# sourceMappingURL=tab.js.map\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0), __webpack_require__(1)))\n\n/***/ }),\n/* 20 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(__webpack_provided_window_dot_jQuery) {(function() {\n  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };\n\n  (function($, window) {\n    var Offcanvas, OffcanvasDropdown, OffcanvasTouch;\n    OffcanvasDropdown = (function() {\n      function OffcanvasDropdown(element) {\n        this.element = element;\n        this._clickEvent = __bind(this._clickEvent, this);\n        this.element = $(this.element);\n        this.nav = this.element.closest(\".nav\");\n        this.dropdown = this.element.parent().find(\".dropdown-menu\");\n        this.element.on('click', this._clickEvent);\n        this.nav.closest('.navbar-offcanvas').on('click', (function(_this) {\n          return function() {\n            if (_this.dropdown.is('.shown')) {\n              return _this.dropdown.removeClass('shown').closest('.open').removeClass('open');\n            }\n          };\n        })(this));\n      }\n\n      OffcanvasDropdown.prototype._clickEvent = function(e) {\n        if (!this.dropdown.hasClass('shown')) {\n          e.preventDefault();\n        }\n        e.stopPropagation();\n        $('.dropdown-toggle').not(this.element).closest('.open').removeClass('open').find('.dropdown-menu').removeClass('shown');\n        this.dropdown.toggleClass(\"shown\");\n        return this.element.parent().toggleClass('open');\n      };\n\n      return OffcanvasDropdown;\n\n    })();\n    OffcanvasTouch = (function() {\n      function OffcanvasTouch(button, element, location, offcanvas) {\n        this.button = button;\n        this.element = element;\n        this.location = location;\n        this.offcanvas = offcanvas;\n        this._getFade = __bind(this._getFade, this);\n        this._getCss = __bind(this._getCss, this);\n        this._touchEnd = __bind(this._touchEnd, this);\n        this._touchMove = __bind(this._touchMove, this);\n        this._touchStart = __bind(this._touchStart, this);\n        this.endThreshold = 130;\n        this.startThreshold = this.element.hasClass('navbar-offcanvas-right') ? $(\"body\").outerWidth() - 60 : 20;\n        this.maxStartThreshold = this.element.hasClass('navbar-offcanvas-right') ? $(\"body\").outerWidth() - 20 : 60;\n        this.currentX = 0;\n        this.fade = this.element.hasClass('navbar-offcanvas-fade') ? true : false;\n        $(document).on(\"touchstart\", this._touchStart);\n        $(document).on(\"touchmove\", this._touchMove);\n        $(document).on(\"touchend\", this._touchEnd);\n      }\n\n      OffcanvasTouch.prototype._touchStart = function(e) {\n        this.startX = e.originalEvent.touches[0].pageX;\n        if (this.element.is('.in')) {\n          return this.element.height($(window).outerHeight());\n        }\n      };\n\n      OffcanvasTouch.prototype._touchMove = function(e) {\n        var x;\n        if ($(e.target).parents('.navbar-offcanvas').length > 0) {\n          return true;\n        }\n        if (this.startX > this.startThreshold && this.startX < this.maxStartThreshold) {\n          e.preventDefault();\n          x = e.originalEvent.touches[0].pageX - this.startX;\n          x = this.element.hasClass('navbar-offcanvas-right') ? -x : x;\n          if (Math.abs(x) < this.element.outerWidth()) {\n            this.element.css(this._getCss(x));\n            return this.element.css(this._getFade(x));\n          }\n        } else if (this.element.hasClass('in')) {\n          e.preventDefault();\n          x = e.originalEvent.touches[0].pageX + (this.currentX - this.startX);\n          x = this.element.hasClass('navbar-offcanvas-right') ? -x : x;\n          if (Math.abs(x) < this.element.outerWidth()) {\n            this.element.css(this._getCss(x));\n            return this.element.css(this._getFade(x));\n          }\n        }\n      };\n\n      OffcanvasTouch.prototype._touchEnd = function(e) {\n        var end, sendEvents, x;\n        if ($(e.target).parents('.navbar-offcanvas').length > 0) {\n          return true;\n        }\n        sendEvents = false;\n        x = e.originalEvent.changedTouches[0].pageX;\n        if (Math.abs(x) === this.startX) {\n          return;\n        }\n        end = this.element.hasClass('navbar-offcanvas-right') ? Math.abs(x) > (this.endThreshold + 50) : x < (this.endThreshold + 50);\n        if (this.element.hasClass('in') && end) {\n          this.currentX = 0;\n          this.element.removeClass('in').css(this._clearCss());\n          this.button.removeClass('is-open');\n          sendEvents = true;\n        } else if (Math.abs(x - this.startX) > this.endThreshold && this.startX > this.startThreshold && this.startX < this.maxStartThreshold) {\n          this.currentX = this.element.hasClass('navbar-offcanvas-right') ? -this.element.outerWidth() : this.element.outerWidth();\n          this.element.toggleClass('in').css(this._clearCss());\n          this.button.toggleClass('is-open');\n          sendEvents = true;\n        } else {\n          this.element.css(this._clearCss());\n        }\n        return this.offcanvas.bodyOverflow(sendEvents);\n      };\n\n      OffcanvasTouch.prototype._getCss = function(x) {\n        x = this.element.hasClass('navbar-offcanvas-right') ? -x : x;\n        return {\n          \"-webkit-transform\": \"translate3d(\" + x + \"px, 0px, 0px)\",\n          \"-webkit-transition-duration\": \"0s\",\n          \"-moz-transform\": \"translate3d(\" + x + \"px, 0px, 0px)\",\n          \"-moz-transition\": \"0s\",\n          \"-o-transform\": \"translate3d(\" + x + \"px, 0px, 0px)\",\n          \"-o-transition\": \"0s\",\n          \"transform\": \"translate3d(\" + x + \"px, 0px, 0px)\",\n          \"transition\": \"0s\"\n        };\n      };\n\n      OffcanvasTouch.prototype._getFade = function(x) {\n        if (this.fade) {\n          return {\n            \"opacity\": x / this.element.outerWidth()\n          };\n        } else {\n          return {};\n        }\n      };\n\n      OffcanvasTouch.prototype._clearCss = function() {\n        return {\n          \"-webkit-transform\": \"\",\n          \"-webkit-transition-duration\": \"\",\n          \"-moz-transform\": \"\",\n          \"-moz-transition\": \"\",\n          \"-o-transform\": \"\",\n          \"-o-transition\": \"\",\n          \"transform\": \"\",\n          \"transition\": \"\",\n          \"opacity\": \"\"\n        };\n      };\n\n      return OffcanvasTouch;\n\n    })();\n    window.Offcanvas = Offcanvas = (function() {\n      function Offcanvas(element) {\n        var t, target;\n        this.element = element;\n        this.bodyOverflow = __bind(this.bodyOverflow, this);\n        this._sendEventsAfter = __bind(this._sendEventsAfter, this);\n        this._sendEventsBefore = __bind(this._sendEventsBefore, this);\n        this._documentClicked = __bind(this._documentClicked, this);\n        this._close = __bind(this._close, this);\n        this._open = __bind(this._open, this);\n        this._clicked = __bind(this._clicked, this);\n        this._navbarHeight = __bind(this._navbarHeight, this);\n        target = this.element.attr('data-target') ? this.element.attr('data-target') : false;\n        if (target) {\n          this.target = $(target);\n          if (this.target.length && !this.target.hasClass('js-offcanvas-done')) {\n            this.element.addClass('js-offcanvas-has-events');\n            this.location = this.target.hasClass(\"navbar-offcanvas-right\") ? \"right\" : \"left\";\n            this.target.addClass(this._transformSupported() ? \"offcanvas-transform js-offcanvas-done\" : \"offcanvas-position js-offcanvas-done\");\n            this.target.data('offcanvas', this);\n            this.element.on(\"click\", this._clicked);\n            this.target.on('transitionend', (function(_this) {\n              return function() {\n                if (_this.target.is(':not(.in)')) {\n                  return _this.target.height('');\n                }\n              };\n            })(this));\n            $(document).on(\"click\", this._documentClicked);\n            if (this.target.hasClass('navbar-offcanvas-touch')) {\n              t = new OffcanvasTouch(this.element, this.target, this.location, this);\n            }\n            this.target.find(\".dropdown-toggle\").each(function() {\n              var d;\n              return d = new OffcanvasDropdown(this);\n            });\n            this.target.on('offcanvas.toggle', (function(_this) {\n              return function(e) {\n                return _this._clicked(e);\n              };\n            })(this));\n            this.target.on('offcanvas.close', (function(_this) {\n              return function(e) {\n                return _this._close(e);\n              };\n            })(this));\n            this.target.on('offcanvas.open', (function(_this) {\n              return function(e) {\n                return _this._open(e);\n              };\n            })(this));\n          }\n        } else {\n          console.warn('Offcanvas: `data-target` attribute must be present.');\n        }\n      }\n\n      Offcanvas.prototype._navbarHeight = function() {\n        if (this.target.is('.in')) {\n          return this.target.height($(window).outerHeight());\n        }\n      };\n\n      Offcanvas.prototype._clicked = function(e) {\n        e.preventDefault();\n        this._sendEventsBefore();\n        $(\".navbar-offcanvas\").not(this.target).trigger('offcanvas.close');\n        this.target.toggleClass('in');\n        this.element.toggleClass('is-open');\n        this._navbarHeight();\n        return this.bodyOverflow();\n      };\n\n      Offcanvas.prototype._open = function(e) {\n        e.preventDefault();\n        if (this.target.is('.in')) {\n          return;\n        }\n        this._sendEventsBefore();\n        this.target.addClass('in');\n        this.element.addClass('is-open');\n        this._navbarHeight();\n        return this.bodyOverflow();\n      };\n\n      Offcanvas.prototype._close = function(e) {\n        e.preventDefault();\n        if (this.target.is(':not(.in)')) {\n          return;\n        }\n        this._sendEventsBefore();\n        this.target.removeClass('in');\n        this.element.removeClass('is-open');\n        this._navbarHeight();\n        return this.bodyOverflow();\n      };\n\n      Offcanvas.prototype._documentClicked = function(e) {\n        var clickedEl;\n        clickedEl = $(e.target);\n        if (!clickedEl.hasClass('offcanvas-toggle') && clickedEl.parents('.offcanvas-toggle').length === 0 && clickedEl.parents('.navbar-offcanvas').length === 0 && !clickedEl.hasClass('navbar-offcanvas')) {\n          if (this.target.hasClass('in')) {\n            e.preventDefault();\n            this._sendEventsBefore();\n            this.target.removeClass('in');\n            this.element.removeClass('is-open');\n            this._navbarHeight();\n            return this.bodyOverflow();\n          }\n        }\n      };\n\n      Offcanvas.prototype._sendEventsBefore = function() {\n        if (this.target.hasClass('in')) {\n          return this.target.trigger('hide.bs.offcanvas');\n        } else {\n          return this.target.trigger('show.bs.offcanvas');\n        }\n      };\n\n      Offcanvas.prototype._sendEventsAfter = function() {\n        if (this.target.hasClass('in')) {\n          return this.target.trigger('shown.bs.offcanvas');\n        } else {\n          return this.target.trigger('hidden.bs.offcanvas');\n        }\n      };\n\n      Offcanvas.prototype.bodyOverflow = function(events) {\n        if (events == null) {\n          events = true;\n        }\n        if (this.target.is('.in')) {\n          $('body').addClass('offcanvas-stop-scrolling');\n        } else {\n          $('body').removeClass('offcanvas-stop-scrolling');\n        }\n        if (events) {\n          return this._sendEventsAfter();\n        }\n      };\n\n      Offcanvas.prototype._transformSupported = function() {\n        var asSupport, el, regex, translate3D;\n        el = document.createElement('div');\n        translate3D = \"translate3d(0px, 0px, 0px)\";\n        regex = /translate3d\\(0px, 0px, 0px\\)/g;\n        el.style.cssText = \"-webkit-transform: \" + translate3D + \"; -moz-transform: \" + translate3D + \"; -o-transform: \" + translate3D + \"; transform: \" + translate3D;\n        asSupport = el.style.cssText.match(regex);\n        return asSupport.length != null;\n      };\n\n      return Offcanvas;\n\n    })();\n    $.fn.bsOffcanvas = function() {\n      return this.each(function() {\n        return new Offcanvas($(this));\n      });\n    };\n    return $(function() {\n      $('[data-toggle=\"offcanvas\"]').each(function() {\n        return $(this).bsOffcanvas();\n      });\n      $(window).on('resize', function() {\n        $('.navbar-offcanvas.in').each(function() {\n          return $(this).height('').removeClass('in');\n        });\n        $('.offcanvas-toggle').removeClass('is-open');\n        return $('body').removeClass('offcanvas-stop-scrolling');\n      });\n      return $('.offcanvas-toggle').each(function() {\n        return $(this).on('click', function(e) {\n          var el, selector;\n          if (!$(this).hasClass('js-offcanvas-has-events')) {\n            selector = $(this).attr('data-target');\n            el = $(selector);\n            if (el) {\n              el.height('');\n              el.removeClass('in');\n              return $('body').css({\n                overflow: '',\n                position: ''\n              });\n            }\n          }\n        });\n      });\n    });\n  })(__webpack_provided_window_dot_jQuery, window);\n\n}).call(this);\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))\n\n/***/ }),\n/* 21 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(factory) {\r\n    if (true) {\r\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0), __webpack_require__(5)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n    } else if (typeof exports === 'object') {\r\n        factory(require('jquery'), require('hammerjs'));\r\n    } else {\r\n        factory(jQuery, Hammer);\r\n    }\r\n}(function($, Hammer) {\r\n    function hammerify(el, options) {\r\n        var $el = $(el);\r\n        if(!$el.data(\"hammer\")) {\r\n            $el.data(\"hammer\", new Hammer($el[0], options));\r\n        }\r\n    }\r\n\r\n    $.fn.hammer = function(options) {\r\n        return this.each(function() {\r\n            hammerify(this, options);\r\n        });\r\n    };\r\n\r\n    // extend the emit method to also trigger jQuery events\r\n    Hammer.Manager.prototype.emit = (function(originalEmit) {\r\n        return function(type, data) {\r\n            originalEmit.call(this, type, data);\r\n            $(this.element).trigger({\r\n                type: type,\r\n                gesture: data\r\n            });\r\n        };\r\n    })(Hammer.Manager.prototype.emit);\r\n}));\r\n\n\n/***/ }),\n/* 22 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(global) {var require;var require;// PouchDB 6.4.3\n// \n// (c) 2012-2018 Dale Harvey and the PouchDB team\n// PouchDB may be freely distributed under the Apache license, version 2.0.\n// For all details and documentation:\n// http://pouchdb.com\n(function(f){if(true){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.PouchDB = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return require(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){\n'use strict';\n\nmodule.exports = argsArray;\n\nfunction argsArray(fun) {\n  return function () {\n    var len = arguments.length;\n    if (len) {\n      var args = [];\n      var i = -1;\n      while (++i < len) {\n        args[i] = arguments[i];\n      }\n      return fun.call(this, args);\n    } else {\n      return fun.call(this, []);\n    }\n  };\n}\n},{}],2:[function(_dereq_,module,exports){\n(function (process){\n/**\n * This is the web browser implementation of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = _dereq_(3);\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = 'undefined' != typeof chrome\n               && 'undefined' != typeof chrome.storage\n                  ? chrome.storage.local\n                  : localstorage();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n  '#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC',\n  '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF',\n  '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC',\n  '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF',\n  '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC',\n  '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033',\n  '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366',\n  '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933',\n  '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC',\n  '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF',\n  '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\nfunction useColors() {\n  // NB: In an Electron preload script, document will be defined but not fully\n  // initialized. Since we know we're in Chrome, we'll just detect this case\n  // explicitly\n  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {\n    return true;\n  }\n\n  // Internet Explorer and Edge do not support colors.\n  if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n    return false;\n  }\n\n  // is webkit? http://stackoverflow.com/a/16459606/376773\n  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n  return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n    // is firebug? http://stackoverflow.com/a/398120/376773\n    (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n    // is firefox >= v31?\n    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||\n    // double check webkit in userAgent just in case we are in a worker\n    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nexports.formatters.j = function(v) {\n  try {\n    return JSON.stringify(v);\n  } catch (err) {\n    return '[UnexpectedJSONParseError]: ' + err.message;\n  }\n};\n\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n  var useColors = this.useColors;\n\n  args[0] = (useColors ? '%c' : '')\n    + this.namespace\n    + (useColors ? ' %c' : ' ')\n    + args[0]\n    + (useColors ? '%c ' : ' ')\n    + '+' + exports.humanize(this.diff);\n\n  if (!useColors) return;\n\n  var c = 'color: ' + this.color;\n  args.splice(1, 0, c, 'color: inherit')\n\n  // the final \"%c\" is somewhat tricky, because there could be other\n  // arguments passed either before or after the %c, so we need to\n  // figure out the correct index to insert the CSS into\n  var index = 0;\n  var lastC = 0;\n  args[0].replace(/%[a-zA-Z%]/g, function(match) {\n    if ('%%' === match) return;\n    index++;\n    if ('%c' === match) {\n      // we only are interested in the *last* %c\n      // (the user may have provided their own)\n      lastC = index;\n    }\n  });\n\n  args.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.log()` when available.\n * No-op when `console.log` is not a \"function\".\n *\n * @api public\n */\n\nfunction log() {\n  // this hackery is required for IE8/9, where\n  // the `console.log` function doesn't have 'apply'\n  return 'object' === typeof console\n    && console.log\n    && Function.prototype.apply.call(console.log, console, arguments);\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\nfunction save(namespaces) {\n  try {\n    if (null == namespaces) {\n      exports.storage.removeItem('debug');\n    } else {\n      exports.storage.debug = namespaces;\n    }\n  } catch(e) {}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n  var r;\n  try {\n    r = exports.storage.debug;\n  } catch(e) {}\n\n  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n  if (!r && typeof process !== 'undefined' && 'env' in process) {\n    r = process.env.DEBUG;\n  }\n\n  return r;\n}\n\n/**\n * Enable namespaces listed in `localStorage.debug` initially.\n */\n\nexports.enable(load());\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n  try {\n    return window.localStorage;\n  } catch (e) {}\n}\n\n}).call(this,_dereq_(9))\n},{\"3\":3,\"9\":9}],3:[function(_dereq_,module,exports){\n\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = createDebug.debug = createDebug['default'] = createDebug;\nexports.coerce = coerce;\nexports.disable = disable;\nexports.enable = enable;\nexports.enabled = enabled;\nexports.humanize = _dereq_(8);\n\n/**\n * Active `debug` instances.\n */\nexports.instances = [];\n\n/**\n * The currently active debug mode names, and names to skip.\n */\n\nexports.names = [];\nexports.skips = [];\n\n/**\n * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n *\n * Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n */\n\nexports.formatters = {};\n\n/**\n * Select a color.\n * @param {String} namespace\n * @return {Number}\n * @api private\n */\n\nfunction selectColor(namespace) {\n  var hash = 0, i;\n\n  for (i in namespace) {\n    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);\n    hash |= 0; // Convert to 32bit integer\n  }\n\n  return exports.colors[Math.abs(hash) % exports.colors.length];\n}\n\n/**\n * Create a debugger with the given `namespace`.\n *\n * @param {String} namespace\n * @return {Function}\n * @api public\n */\n\nfunction createDebug(namespace) {\n\n  var prevTime;\n\n  function debug() {\n    // disabled?\n    if (!debug.enabled) return;\n\n    var self = debug;\n\n    // set `diff` timestamp\n    var curr = +new Date();\n    var ms = curr - (prevTime || curr);\n    self.diff = ms;\n    self.prev = prevTime;\n    self.curr = curr;\n    prevTime = curr;\n\n    // turn the `arguments` into a proper Array\n    var args = new Array(arguments.length);\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i];\n    }\n\n    args[0] = exports.coerce(args[0]);\n\n    if ('string' !== typeof args[0]) {\n      // anything else let's inspect with %O\n      args.unshift('%O');\n    }\n\n    // apply any `formatters` transformations\n    var index = 0;\n    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {\n      // if we encounter an escaped % then don't increase the array index\n      if (match === '%%') return match;\n      index++;\n      var formatter = exports.formatters[format];\n      if ('function' === typeof formatter) {\n        var val = args[index];\n        match = formatter.call(self, val);\n\n        // now we need to remove `args[index]` since it's inlined in the `format`\n        args.splice(index, 1);\n        index--;\n      }\n      return match;\n    });\n\n    // apply env-specific formatting (colors, etc.)\n    exports.formatArgs.call(self, args);\n\n    var logFn = debug.log || exports.log || console.log.bind(console);\n    logFn.apply(self, args);\n  }\n\n  debug.namespace = namespace;\n  debug.enabled = exports.enabled(namespace);\n  debug.useColors = exports.useColors();\n  debug.color = selectColor(namespace);\n  debug.destroy = destroy;\n\n  // env-specific initialization logic for debug instances\n  if ('function' === typeof exports.init) {\n    exports.init(debug);\n  }\n\n  exports.instances.push(debug);\n\n  return debug;\n}\n\nfunction destroy () {\n  var index = exports.instances.indexOf(this);\n  if (index !== -1) {\n    exports.instances.splice(index, 1);\n    return true;\n  } else {\n    return false;\n  }\n}\n\n/**\n * Enables a debug mode by namespaces. This can include modes\n * separated by a colon and wildcards.\n *\n * @param {String} namespaces\n * @api public\n */\n\nfunction enable(namespaces) {\n  exports.save(namespaces);\n\n  exports.names = [];\n  exports.skips = [];\n\n  var i;\n  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n  var len = split.length;\n\n  for (i = 0; i < len; i++) {\n    if (!split[i]) continue; // ignore empty strings\n    namespaces = split[i].replace(/\\*/g, '.*?');\n    if (namespaces[0] === '-') {\n      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n    } else {\n      exports.names.push(new RegExp('^' + namespaces + '$'));\n    }\n  }\n\n  for (i = 0; i < exports.instances.length; i++) {\n    var instance = exports.instances[i];\n    instance.enabled = exports.enabled(instance.namespace);\n  }\n}\n\n/**\n * Disable debug output.\n *\n * @api public\n */\n\nfunction disable() {\n  exports.enable('');\n}\n\n/**\n * Returns true if the given mode name is enabled, false otherwise.\n *\n * @param {String} name\n * @return {Boolean}\n * @api public\n */\n\nfunction enabled(name) {\n  if (name[name.length - 1] === '*') {\n    return true;\n  }\n  var i, len;\n  for (i = 0, len = exports.skips.length; i < len; i++) {\n    if (exports.skips[i].test(name)) {\n      return false;\n    }\n  }\n  for (i = 0, len = exports.names.length; i < len; i++) {\n    if (exports.names[i].test(name)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Coerce `val`.\n *\n * @param {Mixed} val\n * @return {Mixed}\n * @api private\n */\n\nfunction coerce(val) {\n  if (val instanceof Error) return val.stack || val.message;\n  return val;\n}\n\n},{\"8\":8}],4:[function(_dereq_,module,exports){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nfunction EventEmitter() {\n  this._events = this._events || {};\n  this._maxListeners = this._maxListeners || undefined;\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nEventEmitter.defaultMaxListeners = 10;\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!isNumber(n) || n < 0 || isNaN(n))\n    throw TypeError('n must be a positive number');\n  this._maxListeners = n;\n  return this;\n};\n\nEventEmitter.prototype.emit = function(type) {\n  var er, handler, len, args, i, listeners;\n\n  if (!this._events)\n    this._events = {};\n\n  // If there is no 'error' event listener then throw.\n  if (type === 'error') {\n    if (!this._events.error ||\n        (isObject(this._events.error) && !this._events.error.length)) {\n      er = arguments[1];\n      if (er instanceof Error) {\n        throw er; // Unhandled 'error' event\n      } else {\n        // At least give some kind of context to the user\n        var err = new Error('Uncaught, unspecified \"error\" event. (' + er + ')');\n        err.context = er;\n        throw err;\n      }\n    }\n  }\n\n  handler = this._events[type];\n\n  if (isUndefined(handler))\n    return false;\n\n  if (isFunction(handler)) {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        args = Array.prototype.slice.call(arguments, 1);\n        handler.apply(this, args);\n    }\n  } else if (isObject(handler)) {\n    args = Array.prototype.slice.call(arguments, 1);\n    listeners = handler.slice();\n    len = listeners.length;\n    for (i = 0; i < len; i++)\n      listeners[i].apply(this, args);\n  }\n\n  return true;\n};\n\nEventEmitter.prototype.addListener = function(type, listener) {\n  var m;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events)\n    this._events = {};\n\n  // To avoid recursion in the case that type === \"newListener\"! Before\n  // adding it to the listeners, first emit \"newListener\".\n  if (this._events.newListener)\n    this.emit('newListener', type,\n              isFunction(listener.listener) ?\n              listener.listener : listener);\n\n  if (!this._events[type])\n    // Optimize the case of one listener. Don't need the extra array object.\n    this._events[type] = listener;\n  else if (isObject(this._events[type]))\n    // If we've already got an array, just append.\n    this._events[type].push(listener);\n  else\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n\n  // Check for listener leak\n  if (isObject(this._events[type]) && !this._events[type].warned) {\n    if (!isUndefined(this._maxListeners)) {\n      m = this._maxListeners;\n    } else {\n      m = EventEmitter.defaultMaxListeners;\n    }\n\n    if (m && m > 0 && this._events[type].length > m) {\n      this._events[type].warned = true;\n      console.error('(node) warning: possible EventEmitter memory ' +\n                    'leak detected. %d listeners added. ' +\n                    'Use emitter.setMaxListeners() to increase limit.',\n                    this._events[type].length);\n      if (typeof console.trace === 'function') {\n        // not supported in IE 10\n        console.trace();\n      }\n    }\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  var fired = false;\n\n  function g() {\n    this.removeListener(type, g);\n\n    if (!fired) {\n      fired = true;\n      listener.apply(this, arguments);\n    }\n  }\n\n  g.listener = listener;\n  this.on(type, g);\n\n  return this;\n};\n\n// emits a 'removeListener' event iff the listener was removed\nEventEmitter.prototype.removeListener = function(type, listener) {\n  var list, position, length, i;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events || !this._events[type])\n    return this;\n\n  list = this._events[type];\n  length = list.length;\n  position = -1;\n\n  if (list === listener ||\n      (isFunction(list.listener) && list.listener === listener)) {\n    delete this._events[type];\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n\n  } else if (isObject(list)) {\n    for (i = length; i-- > 0;) {\n      if (list[i] === listener ||\n          (list[i].listener && list[i].listener === listener)) {\n        position = i;\n        break;\n      }\n    }\n\n    if (position < 0)\n      return this;\n\n    if (list.length === 1) {\n      list.length = 0;\n      delete this._events[type];\n    } else {\n      list.splice(position, 1);\n    }\n\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  var key, listeners;\n\n  if (!this._events)\n    return this;\n\n  // not listening for removeListener, no need to emit\n  if (!this._events.removeListener) {\n    if (arguments.length === 0)\n      this._events = {};\n    else if (this._events[type])\n      delete this._events[type];\n    return this;\n  }\n\n  // emit removeListener for all listeners on all events\n  if (arguments.length === 0) {\n    for (key in this._events) {\n      if (key === 'removeListener') continue;\n      this.removeAllListeners(key);\n    }\n    this.removeAllListeners('removeListener');\n    this._events = {};\n    return this;\n  }\n\n  listeners = this._events[type];\n\n  if (isFunction(listeners)) {\n    this.removeListener(type, listeners);\n  } else if (listeners) {\n    // LIFO order\n    while (listeners.length)\n      this.removeListener(type, listeners[listeners.length - 1]);\n  }\n  delete this._events[type];\n\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  var ret;\n  if (!this._events || !this._events[type])\n    ret = [];\n  else if (isFunction(this._events[type]))\n    ret = [this._events[type]];\n  else\n    ret = this._events[type].slice();\n  return ret;\n};\n\nEventEmitter.prototype.listenerCount = function(type) {\n  if (this._events) {\n    var evlistener = this._events[type];\n\n    if (isFunction(evlistener))\n      return 1;\n    else if (evlistener)\n      return evlistener.length;\n  }\n  return 0;\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  return emitter.listenerCount(type);\n};\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\n\n},{}],5:[function(_dereq_,module,exports){\n(function (global){\n'use strict';\nvar Mutation = global.MutationObserver || global.WebKitMutationObserver;\n\nvar scheduleDrain;\n\n{\n  if (Mutation) {\n    var called = 0;\n    var observer = new Mutation(nextTick);\n    var element = global.document.createTextNode('');\n    observer.observe(element, {\n      characterData: true\n    });\n    scheduleDrain = function () {\n      element.data = (called = ++called % 2);\n    };\n  } else if (!global.setImmediate && typeof global.MessageChannel !== 'undefined') {\n    var channel = new global.MessageChannel();\n    channel.port1.onmessage = nextTick;\n    scheduleDrain = function () {\n      channel.port2.postMessage(0);\n    };\n  } else if ('document' in global && 'onreadystatechange' in global.document.createElement('script')) {\n    scheduleDrain = function () {\n\n      // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n      // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n      var scriptEl = global.document.createElement('script');\n      scriptEl.onreadystatechange = function () {\n        nextTick();\n\n        scriptEl.onreadystatechange = null;\n        scriptEl.parentNode.removeChild(scriptEl);\n        scriptEl = null;\n      };\n      global.document.documentElement.appendChild(scriptEl);\n    };\n  } else {\n    scheduleDrain = function () {\n      setTimeout(nextTick, 0);\n    };\n  }\n}\n\nvar draining;\nvar queue = [];\n//named nextTick for less confusing stack traces\nfunction nextTick() {\n  draining = true;\n  var i, oldQueue;\n  var len = queue.length;\n  while (len) {\n    oldQueue = queue;\n    queue = [];\n    i = -1;\n    while (++i < len) {\n      oldQueue[i]();\n    }\n    len = queue.length;\n  }\n  draining = false;\n}\n\nmodule.exports = immediate;\nfunction immediate(task) {\n  if (queue.push(task) === 1 && !draining) {\n    scheduleDrain();\n  }\n}\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{}],6:[function(_dereq_,module,exports){\nif (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    var TempCtor = function () {}\n    TempCtor.prototype = superCtor.prototype\n    ctor.prototype = new TempCtor()\n    ctor.prototype.constructor = ctor\n  }\n}\n\n},{}],7:[function(_dereq_,module,exports){\n'use strict';\nvar immediate = _dereq_(5);\n\n/* istanbul ignore next */\nfunction INTERNAL() {}\n\nvar handlers = {};\n\nvar REJECTED = ['REJECTED'];\nvar FULFILLED = ['FULFILLED'];\nvar PENDING = ['PENDING'];\n\nmodule.exports = Promise;\n\nfunction Promise(resolver) {\n  if (typeof resolver !== 'function') {\n    throw new TypeError('resolver must be a function');\n  }\n  this.state = PENDING;\n  this.queue = [];\n  this.outcome = void 0;\n  if (resolver !== INTERNAL) {\n    safelyResolveThenable(this, resolver);\n  }\n}\n\nPromise.prototype[\"catch\"] = function (onRejected) {\n  return this.then(null, onRejected);\n};\nPromise.prototype.then = function (onFulfilled, onRejected) {\n  if (typeof onFulfilled !== 'function' && this.state === FULFILLED ||\n    typeof onRejected !== 'function' && this.state === REJECTED) {\n    return this;\n  }\n  var promise = new this.constructor(INTERNAL);\n  if (this.state !== PENDING) {\n    var resolver = this.state === FULFILLED ? onFulfilled : onRejected;\n    unwrap(promise, resolver, this.outcome);\n  } else {\n    this.queue.push(new QueueItem(promise, onFulfilled, onRejected));\n  }\n\n  return promise;\n};\nfunction QueueItem(promise, onFulfilled, onRejected) {\n  this.promise = promise;\n  if (typeof onFulfilled === 'function') {\n    this.onFulfilled = onFulfilled;\n    this.callFulfilled = this.otherCallFulfilled;\n  }\n  if (typeof onRejected === 'function') {\n    this.onRejected = onRejected;\n    this.callRejected = this.otherCallRejected;\n  }\n}\nQueueItem.prototype.callFulfilled = function (value) {\n  handlers.resolve(this.promise, value);\n};\nQueueItem.prototype.otherCallFulfilled = function (value) {\n  unwrap(this.promise, this.onFulfilled, value);\n};\nQueueItem.prototype.callRejected = function (value) {\n  handlers.reject(this.promise, value);\n};\nQueueItem.prototype.otherCallRejected = function (value) {\n  unwrap(this.promise, this.onRejected, value);\n};\n\nfunction unwrap(promise, func, value) {\n  immediate(function () {\n    var returnValue;\n    try {\n      returnValue = func(value);\n    } catch (e) {\n      return handlers.reject(promise, e);\n    }\n    if (returnValue === promise) {\n      handlers.reject(promise, new TypeError('Cannot resolve promise with itself'));\n    } else {\n      handlers.resolve(promise, returnValue);\n    }\n  });\n}\n\nhandlers.resolve = function (self, value) {\n  var result = tryCatch(getThen, value);\n  if (result.status === 'error') {\n    return handlers.reject(self, result.value);\n  }\n  var thenable = result.value;\n\n  if (thenable) {\n    safelyResolveThenable(self, thenable);\n  } else {\n    self.state = FULFILLED;\n    self.outcome = value;\n    var i = -1;\n    var len = self.queue.length;\n    while (++i < len) {\n      self.queue[i].callFulfilled(value);\n    }\n  }\n  return self;\n};\nhandlers.reject = function (self, error) {\n  self.state = REJECTED;\n  self.outcome = error;\n  var i = -1;\n  var len = self.queue.length;\n  while (++i < len) {\n    self.queue[i].callRejected(error);\n  }\n  return self;\n};\n\nfunction getThen(obj) {\n  // Make sure we only access the accessor once as required by the spec\n  var then = obj && obj.then;\n  if (obj && (typeof obj === 'object' || typeof obj === 'function') && typeof then === 'function') {\n    return function appyThen() {\n      then.apply(obj, arguments);\n    };\n  }\n}\n\nfunction safelyResolveThenable(self, thenable) {\n  // Either fulfill, reject or reject with error\n  var called = false;\n  function onError(value) {\n    if (called) {\n      return;\n    }\n    called = true;\n    handlers.reject(self, value);\n  }\n\n  function onSuccess(value) {\n    if (called) {\n      return;\n    }\n    called = true;\n    handlers.resolve(self, value);\n  }\n\n  function tryToUnwrap() {\n    thenable(onSuccess, onError);\n  }\n\n  var result = tryCatch(tryToUnwrap);\n  if (result.status === 'error') {\n    onError(result.value);\n  }\n}\n\nfunction tryCatch(func, value) {\n  var out = {};\n  try {\n    out.value = func(value);\n    out.status = 'success';\n  } catch (e) {\n    out.status = 'error';\n    out.value = e;\n  }\n  return out;\n}\n\nPromise.resolve = resolve;\nfunction resolve(value) {\n  if (value instanceof this) {\n    return value;\n  }\n  return handlers.resolve(new this(INTERNAL), value);\n}\n\nPromise.reject = reject;\nfunction reject(reason) {\n  var promise = new this(INTERNAL);\n  return handlers.reject(promise, reason);\n}\n\nPromise.all = all;\nfunction all(iterable) {\n  var self = this;\n  if (Object.prototype.toString.call(iterable) !== '[object Array]') {\n    return this.reject(new TypeError('must be an array'));\n  }\n\n  var len = iterable.length;\n  var called = false;\n  if (!len) {\n    return this.resolve([]);\n  }\n\n  var values = new Array(len);\n  var resolved = 0;\n  var i = -1;\n  var promise = new this(INTERNAL);\n\n  while (++i < len) {\n    allResolver(iterable[i], i);\n  }\n  return promise;\n  function allResolver(value, i) {\n    self.resolve(value).then(resolveFromAll, function (error) {\n      if (!called) {\n        called = true;\n        handlers.reject(promise, error);\n      }\n    });\n    function resolveFromAll(outValue) {\n      values[i] = outValue;\n      if (++resolved === len && !called) {\n        called = true;\n        handlers.resolve(promise, values);\n      }\n    }\n  }\n}\n\nPromise.race = race;\nfunction race(iterable) {\n  var self = this;\n  if (Object.prototype.toString.call(iterable) !== '[object Array]') {\n    return this.reject(new TypeError('must be an array'));\n  }\n\n  var len = iterable.length;\n  var called = false;\n  if (!len) {\n    return this.resolve([]);\n  }\n\n  var i = -1;\n  var promise = new this(INTERNAL);\n\n  while (++i < len) {\n    resolver(iterable[i]);\n  }\n  return promise;\n  function resolver(value) {\n    self.resolve(value).then(function (response) {\n      if (!called) {\n        called = true;\n        handlers.resolve(promise, response);\n      }\n    }, function (error) {\n      if (!called) {\n        called = true;\n        handlers.reject(promise, error);\n      }\n    });\n  }\n}\n\n},{\"5\":5}],8:[function(_dereq_,module,exports){\n/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isNaN(val) === false) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^((?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  if (ms >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (ms >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (ms >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (ms >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  return plural(ms, d, 'day') ||\n    plural(ms, h, 'hour') ||\n    plural(ms, m, 'minute') ||\n    plural(ms, s, 'second') ||\n    ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, n, name) {\n  if (ms < n) {\n    return;\n  }\n  if (ms < n * 1.5) {\n    return Math.floor(ms / n) + ' ' + name;\n  }\n  return Math.ceil(ms / n) + ' ' + name + 's';\n}\n\n},{}],9:[function(_dereq_,module,exports){\n// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n},{}],10:[function(_dereq_,module,exports){\n(function (factory) {\n    if (typeof exports === 'object') {\n        // Node/CommonJS\n        module.exports = factory();\n    } else if (typeof define === 'function' && define.amd) {\n        // AMD\n        define(factory);\n    } else {\n        // Browser globals (with support for web workers)\n        var glob;\n\n        try {\n            glob = window;\n        } catch (e) {\n            glob = self;\n        }\n\n        glob.SparkMD5 = factory();\n    }\n}(function (undefined) {\n\n    'use strict';\n\n    /*\n     * Fastest md5 implementation around (JKM md5).\n     * Credits: Joseph Myers\n     *\n     * @see http://www.myersdaily.org/joseph/javascript/md5-text.html\n     * @see http://jsperf.com/md5-shootout/7\n     */\n\n    /* this function is much faster,\n      so if possible we use it. Some IEs\n      are the only ones I know of that\n      need the idiotic second function,\n      generated by an if clause.  */\n    var add32 = function (a, b) {\n        return (a + b) & 0xFFFFFFFF;\n    },\n        hex_chr = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'];\n\n\n    function cmn(q, a, b, x, s, t) {\n        a = add32(add32(a, q), add32(x, t));\n        return add32((a << s) | (a >>> (32 - s)), b);\n    }\n\n    function md5cycle(x, k) {\n        var a = x[0],\n            b = x[1],\n            c = x[2],\n            d = x[3];\n\n        a += (b & c | ~b & d) + k[0] - 680876936 | 0;\n        a  = (a << 7 | a >>> 25) + b | 0;\n        d += (a & b | ~a & c) + k[1] - 389564586 | 0;\n        d  = (d << 12 | d >>> 20) + a | 0;\n        c += (d & a | ~d & b) + k[2] + 606105819 | 0;\n        c  = (c << 17 | c >>> 15) + d | 0;\n        b += (c & d | ~c & a) + k[3] - 1044525330 | 0;\n        b  = (b << 22 | b >>> 10) + c | 0;\n        a += (b & c | ~b & d) + k[4] - 176418897 | 0;\n        a  = (a << 7 | a >>> 25) + b | 0;\n        d += (a & b | ~a & c) + k[5] + 1200080426 | 0;\n        d  = (d << 12 | d >>> 20) + a | 0;\n        c += (d & a | ~d & b) + k[6] - 1473231341 | 0;\n        c  = (c << 17 | c >>> 15) + d | 0;\n        b += (c & d | ~c & a) + k[7] - 45705983 | 0;\n        b  = (b << 22 | b >>> 10) + c | 0;\n        a += (b & c | ~b & d) + k[8] + 1770035416 | 0;\n        a  = (a << 7 | a >>> 25) + b | 0;\n        d += (a & b | ~a & c) + k[9] - 1958414417 | 0;\n        d  = (d << 12 | d >>> 20) + a | 0;\n        c += (d & a | ~d & b) + k[10] - 42063 | 0;\n        c  = (c << 17 | c >>> 15) + d | 0;\n        b += (c & d | ~c & a) + k[11] - 1990404162 | 0;\n        b  = (b << 22 | b >>> 10) + c | 0;\n        a += (b & c | ~b & d) + k[12] + 1804603682 | 0;\n        a  = (a << 7 | a >>> 25) + b | 0;\n        d += (a & b | ~a & c) + k[13] - 40341101 | 0;\n        d  = (d << 12 | d >>> 20) + a | 0;\n        c += (d & a | ~d & b) + k[14] - 1502002290 | 0;\n        c  = (c << 17 | c >>> 15) + d | 0;\n        b += (c & d | ~c & a) + k[15] + 1236535329 | 0;\n        b  = (b << 22 | b >>> 10) + c | 0;\n\n        a += (b & d | c & ~d) + k[1] - 165796510 | 0;\n        a  = (a << 5 | a >>> 27) + b | 0;\n        d += (a & c | b & ~c) + k[6] - 1069501632 | 0;\n        d  = (d << 9 | d >>> 23) + a | 0;\n        c += (d & b | a & ~b) + k[11] + 643717713 | 0;\n        c  = (c << 14 | c >>> 18) + d | 0;\n        b += (c & a | d & ~a) + k[0] - 373897302 | 0;\n        b  = (b << 20 | b >>> 12) + c | 0;\n        a += (b & d | c & ~d) + k[5] - 701558691 | 0;\n        a  = (a << 5 | a >>> 27) + b | 0;\n        d += (a & c | b & ~c) + k[10] + 38016083 | 0;\n        d  = (d << 9 | d >>> 23) + a | 0;\n        c += (d & b | a & ~b) + k[15] - 660478335 | 0;\n        c  = (c << 14 | c >>> 18) + d | 0;\n        b += (c & a | d & ~a) + k[4] - 405537848 | 0;\n        b  = (b << 20 | b >>> 12) + c | 0;\n        a += (b & d | c & ~d) + k[9] + 568446438 | 0;\n        a  = (a << 5 | a >>> 27) + b | 0;\n        d += (a & c | b & ~c) + k[14] - 1019803690 | 0;\n        d  = (d << 9 | d >>> 23) + a | 0;\n        c += (d & b | a & ~b) + k[3] - 187363961 | 0;\n        c  = (c << 14 | c >>> 18) + d | 0;\n        b += (c & a | d & ~a) + k[8] + 1163531501 | 0;\n        b  = (b << 20 | b >>> 12) + c | 0;\n        a += (b & d | c & ~d) + k[13] - 1444681467 | 0;\n        a  = (a << 5 | a >>> 27) + b | 0;\n        d += (a & c | b & ~c) + k[2] - 51403784 | 0;\n        d  = (d << 9 | d >>> 23) + a | 0;\n        c += (d & b | a & ~b) + k[7] + 1735328473 | 0;\n        c  = (c << 14 | c >>> 18) + d | 0;\n        b += (c & a | d & ~a) + k[12] - 1926607734 | 0;\n        b  = (b << 20 | b >>> 12) + c | 0;\n\n        a += (b ^ c ^ d) + k[5] - 378558 | 0;\n        a  = (a << 4 | a >>> 28) + b | 0;\n        d += (a ^ b ^ c) + k[8] - 2022574463 | 0;\n        d  = (d << 11 | d >>> 21) + a | 0;\n        c += (d ^ a ^ b) + k[11] + 1839030562 | 0;\n        c  = (c << 16 | c >>> 16) + d | 0;\n        b += (c ^ d ^ a) + k[14] - 35309556 | 0;\n        b  = (b << 23 | b >>> 9) + c | 0;\n        a += (b ^ c ^ d) + k[1] - 1530992060 | 0;\n        a  = (a << 4 | a >>> 28) + b | 0;\n        d += (a ^ b ^ c) + k[4] + 1272893353 | 0;\n        d  = (d << 11 | d >>> 21) + a | 0;\n        c += (d ^ a ^ b) + k[7] - 155497632 | 0;\n        c  = (c << 16 | c >>> 16) + d | 0;\n        b += (c ^ d ^ a) + k[10] - 1094730640 | 0;\n        b  = (b << 23 | b >>> 9) + c | 0;\n        a += (b ^ c ^ d) + k[13] + 681279174 | 0;\n        a  = (a << 4 | a >>> 28) + b | 0;\n        d += (a ^ b ^ c) + k[0] - 358537222 | 0;\n        d  = (d << 11 | d >>> 21) + a | 0;\n        c += (d ^ a ^ b) + k[3] - 722521979 | 0;\n        c  = (c << 16 | c >>> 16) + d | 0;\n        b += (c ^ d ^ a) + k[6] + 76029189 | 0;\n        b  = (b << 23 | b >>> 9) + c | 0;\n        a += (b ^ c ^ d) + k[9] - 640364487 | 0;\n        a  = (a << 4 | a >>> 28) + b | 0;\n        d += (a ^ b ^ c) + k[12] - 421815835 | 0;\n        d  = (d << 11 | d >>> 21) + a | 0;\n        c += (d ^ a ^ b) + k[15] + 530742520 | 0;\n        c  = (c << 16 | c >>> 16) + d | 0;\n        b += (c ^ d ^ a) + k[2] - 995338651 | 0;\n        b  = (b << 23 | b >>> 9) + c | 0;\n\n        a += (c ^ (b | ~d)) + k[0] - 198630844 | 0;\n        a  = (a << 6 | a >>> 26) + b | 0;\n        d += (b ^ (a | ~c)) + k[7] + 1126891415 | 0;\n        d  = (d << 10 | d >>> 22) + a | 0;\n        c += (a ^ (d | ~b)) + k[14] - 1416354905 | 0;\n        c  = (c << 15 | c >>> 17) + d | 0;\n        b += (d ^ (c | ~a)) + k[5] - 57434055 | 0;\n        b  = (b << 21 |b >>> 11) + c | 0;\n        a += (c ^ (b | ~d)) + k[12] + 1700485571 | 0;\n        a  = (a << 6 | a >>> 26) + b | 0;\n        d += (b ^ (a | ~c)) + k[3] - 1894986606 | 0;\n        d  = (d << 10 | d >>> 22) + a | 0;\n        c += (a ^ (d | ~b)) + k[10] - 1051523 | 0;\n        c  = (c << 15 | c >>> 17) + d | 0;\n        b += (d ^ (c | ~a)) + k[1] - 2054922799 | 0;\n        b  = (b << 21 |b >>> 11) + c | 0;\n        a += (c ^ (b | ~d)) + k[8] + 1873313359 | 0;\n        a  = (a << 6 | a >>> 26) + b | 0;\n        d += (b ^ (a | ~c)) + k[15] - 30611744 | 0;\n        d  = (d << 10 | d >>> 22) + a | 0;\n        c += (a ^ (d | ~b)) + k[6] - 1560198380 | 0;\n        c  = (c << 15 | c >>> 17) + d | 0;\n        b += (d ^ (c | ~a)) + k[13] + 1309151649 | 0;\n        b  = (b << 21 |b >>> 11) + c | 0;\n        a += (c ^ (b | ~d)) + k[4] - 145523070 | 0;\n        a  = (a << 6 | a >>> 26) + b | 0;\n        d += (b ^ (a | ~c)) + k[11] - 1120210379 | 0;\n        d  = (d << 10 | d >>> 22) + a | 0;\n        c += (a ^ (d | ~b)) + k[2] + 718787259 | 0;\n        c  = (c << 15 | c >>> 17) + d | 0;\n        b += (d ^ (c | ~a)) + k[9] - 343485551 | 0;\n        b  = (b << 21 | b >>> 11) + c | 0;\n\n        x[0] = a + x[0] | 0;\n        x[1] = b + x[1] | 0;\n        x[2] = c + x[2] | 0;\n        x[3] = d + x[3] | 0;\n    }\n\n    function md5blk(s) {\n        var md5blks = [],\n            i; /* Andy King said do it this way. */\n\n        for (i = 0; i < 64; i += 4) {\n            md5blks[i >> 2] = s.charCodeAt(i) + (s.charCodeAt(i + 1) << 8) + (s.charCodeAt(i + 2) << 16) + (s.charCodeAt(i + 3) << 24);\n        }\n        return md5blks;\n    }\n\n    function md5blk_array(a) {\n        var md5blks = [],\n            i; /* Andy King said do it this way. */\n\n        for (i = 0; i < 64; i += 4) {\n            md5blks[i >> 2] = a[i] + (a[i + 1] << 8) + (a[i + 2] << 16) + (a[i + 3] << 24);\n        }\n        return md5blks;\n    }\n\n    function md51(s) {\n        var n = s.length,\n            state = [1732584193, -271733879, -1732584194, 271733878],\n            i,\n            length,\n            tail,\n            tmp,\n            lo,\n            hi;\n\n        for (i = 64; i <= n; i += 64) {\n            md5cycle(state, md5blk(s.substring(i - 64, i)));\n        }\n        s = s.substring(i - 64);\n        length = s.length;\n        tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n        for (i = 0; i < length; i += 1) {\n            tail[i >> 2] |= s.charCodeAt(i) << ((i % 4) << 3);\n        }\n        tail[i >> 2] |= 0x80 << ((i % 4) << 3);\n        if (i > 55) {\n            md5cycle(state, tail);\n            for (i = 0; i < 16; i += 1) {\n                tail[i] = 0;\n            }\n        }\n\n        // Beware that the final length might not fit in 32 bits so we take care of that\n        tmp = n * 8;\n        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);\n        lo = parseInt(tmp[2], 16);\n        hi = parseInt(tmp[1], 16) || 0;\n\n        tail[14] = lo;\n        tail[15] = hi;\n\n        md5cycle(state, tail);\n        return state;\n    }\n\n    function md51_array(a) {\n        var n = a.length,\n            state = [1732584193, -271733879, -1732584194, 271733878],\n            i,\n            length,\n            tail,\n            tmp,\n            lo,\n            hi;\n\n        for (i = 64; i <= n; i += 64) {\n            md5cycle(state, md5blk_array(a.subarray(i - 64, i)));\n        }\n\n        // Not sure if it is a bug, however IE10 will always produce a sub array of length 1\n        // containing the last element of the parent array if the sub array specified starts\n        // beyond the length of the parent array - weird.\n        // https://connect.microsoft.com/IE/feedback/details/771452/typed-array-subarray-issue\n        a = (i - 64) < n ? a.subarray(i - 64) : new Uint8Array(0);\n\n        length = a.length;\n        tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n        for (i = 0; i < length; i += 1) {\n            tail[i >> 2] |= a[i] << ((i % 4) << 3);\n        }\n\n        tail[i >> 2] |= 0x80 << ((i % 4) << 3);\n        if (i > 55) {\n            md5cycle(state, tail);\n            for (i = 0; i < 16; i += 1) {\n                tail[i] = 0;\n            }\n        }\n\n        // Beware that the final length might not fit in 32 bits so we take care of that\n        tmp = n * 8;\n        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);\n        lo = parseInt(tmp[2], 16);\n        hi = parseInt(tmp[1], 16) || 0;\n\n        tail[14] = lo;\n        tail[15] = hi;\n\n        md5cycle(state, tail);\n\n        return state;\n    }\n\n    function rhex(n) {\n        var s = '',\n            j;\n        for (j = 0; j < 4; j += 1) {\n            s += hex_chr[(n >> (j * 8 + 4)) & 0x0F] + hex_chr[(n >> (j * 8)) & 0x0F];\n        }\n        return s;\n    }\n\n    function hex(x) {\n        var i;\n        for (i = 0; i < x.length; i += 1) {\n            x[i] = rhex(x[i]);\n        }\n        return x.join('');\n    }\n\n    // In some cases the fast add32 function cannot be used..\n    if (hex(md51('hello')) !== '5d41402abc4b2a76b9719d911017c592') {\n        add32 = function (x, y) {\n            var lsw = (x & 0xFFFF) + (y & 0xFFFF),\n                msw = (x >> 16) + (y >> 16) + (lsw >> 16);\n            return (msw << 16) | (lsw & 0xFFFF);\n        };\n    }\n\n    // ---------------------------------------------------\n\n    /**\n     * ArrayBuffer slice polyfill.\n     *\n     * @see https://github.com/ttaubert/node-arraybuffer-slice\n     */\n\n    if (typeof ArrayBuffer !== 'undefined' && !ArrayBuffer.prototype.slice) {\n        (function () {\n            function clamp(val, length) {\n                val = (val | 0) || 0;\n\n                if (val < 0) {\n                    return Math.max(val + length, 0);\n                }\n\n                return Math.min(val, length);\n            }\n\n            ArrayBuffer.prototype.slice = function (from, to) {\n                var length = this.byteLength,\n                    begin = clamp(from, length),\n                    end = length,\n                    num,\n                    target,\n                    targetArray,\n                    sourceArray;\n\n                if (to !== undefined) {\n                    end = clamp(to, length);\n                }\n\n                if (begin > end) {\n                    return new ArrayBuffer(0);\n                }\n\n                num = end - begin;\n                target = new ArrayBuffer(num);\n                targetArray = new Uint8Array(target);\n\n                sourceArray = new Uint8Array(this, begin, num);\n                targetArray.set(sourceArray);\n\n                return target;\n            };\n        })();\n    }\n\n    // ---------------------------------------------------\n\n    /**\n     * Helpers.\n     */\n\n    function toUtf8(str) {\n        if (/[\\u0080-\\uFFFF]/.test(str)) {\n            str = unescape(encodeURIComponent(str));\n        }\n\n        return str;\n    }\n\n    function utf8Str2ArrayBuffer(str, returnUInt8Array) {\n        var length = str.length,\n           buff = new ArrayBuffer(length),\n           arr = new Uint8Array(buff),\n           i;\n\n        for (i = 0; i < length; i += 1) {\n            arr[i] = str.charCodeAt(i);\n        }\n\n        return returnUInt8Array ? arr : buff;\n    }\n\n    function arrayBuffer2Utf8Str(buff) {\n        return String.fromCharCode.apply(null, new Uint8Array(buff));\n    }\n\n    function concatenateArrayBuffers(first, second, returnUInt8Array) {\n        var result = new Uint8Array(first.byteLength + second.byteLength);\n\n        result.set(new Uint8Array(first));\n        result.set(new Uint8Array(second), first.byteLength);\n\n        return returnUInt8Array ? result : result.buffer;\n    }\n\n    function hexToBinaryString(hex) {\n        var bytes = [],\n            length = hex.length,\n            x;\n\n        for (x = 0; x < length - 1; x += 2) {\n            bytes.push(parseInt(hex.substr(x, 2), 16));\n        }\n\n        return String.fromCharCode.apply(String, bytes);\n    }\n\n    // ---------------------------------------------------\n\n    /**\n     * SparkMD5 OOP implementation.\n     *\n     * Use this class to perform an incremental md5, otherwise use the\n     * static methods instead.\n     */\n\n    function SparkMD5() {\n        // call reset to init the instance\n        this.reset();\n    }\n\n    /**\n     * Appends a string.\n     * A conversion will be applied if an utf8 string is detected.\n     *\n     * @param {String} str The string to be appended\n     *\n     * @return {SparkMD5} The instance itself\n     */\n    SparkMD5.prototype.append = function (str) {\n        // Converts the string to utf8 bytes if necessary\n        // Then append as binary\n        this.appendBinary(toUtf8(str));\n\n        return this;\n    };\n\n    /**\n     * Appends a binary string.\n     *\n     * @param {String} contents The binary string to be appended\n     *\n     * @return {SparkMD5} The instance itself\n     */\n    SparkMD5.prototype.appendBinary = function (contents) {\n        this._buff += contents;\n        this._length += contents.length;\n\n        var length = this._buff.length,\n            i;\n\n        for (i = 64; i <= length; i += 64) {\n            md5cycle(this._hash, md5blk(this._buff.substring(i - 64, i)));\n        }\n\n        this._buff = this._buff.substring(i - 64);\n\n        return this;\n    };\n\n    /**\n     * Finishes the incremental computation, reseting the internal state and\n     * returning the result.\n     *\n     * @param {Boolean} raw True to get the raw string, false to get the hex string\n     *\n     * @return {String} The result\n     */\n    SparkMD5.prototype.end = function (raw) {\n        var buff = this._buff,\n            length = buff.length,\n            i,\n            tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n            ret;\n\n        for (i = 0; i < length; i += 1) {\n            tail[i >> 2] |= buff.charCodeAt(i) << ((i % 4) << 3);\n        }\n\n        this._finish(tail, length);\n        ret = hex(this._hash);\n\n        if (raw) {\n            ret = hexToBinaryString(ret);\n        }\n\n        this.reset();\n\n        return ret;\n    };\n\n    /**\n     * Resets the internal state of the computation.\n     *\n     * @return {SparkMD5} The instance itself\n     */\n    SparkMD5.prototype.reset = function () {\n        this._buff = '';\n        this._length = 0;\n        this._hash = [1732584193, -271733879, -1732584194, 271733878];\n\n        return this;\n    };\n\n    /**\n     * Gets the internal state of the computation.\n     *\n     * @return {Object} The state\n     */\n    SparkMD5.prototype.getState = function () {\n        return {\n            buff: this._buff,\n            length: this._length,\n            hash: this._hash\n        };\n    };\n\n    /**\n     * Gets the internal state of the computation.\n     *\n     * @param {Object} state The state\n     *\n     * @return {SparkMD5} The instance itself\n     */\n    SparkMD5.prototype.setState = function (state) {\n        this._buff = state.buff;\n        this._length = state.length;\n        this._hash = state.hash;\n\n        return this;\n    };\n\n    /**\n     * Releases memory used by the incremental buffer and other additional\n     * resources. If you plan to use the instance again, use reset instead.\n     */\n    SparkMD5.prototype.destroy = function () {\n        delete this._hash;\n        delete this._buff;\n        delete this._length;\n    };\n\n    /**\n     * Finish the final calculation based on the tail.\n     *\n     * @param {Array}  tail   The tail (will be modified)\n     * @param {Number} length The length of the remaining buffer\n     */\n    SparkMD5.prototype._finish = function (tail, length) {\n        var i = length,\n            tmp,\n            lo,\n            hi;\n\n        tail[i >> 2] |= 0x80 << ((i % 4) << 3);\n        if (i > 55) {\n            md5cycle(this._hash, tail);\n            for (i = 0; i < 16; i += 1) {\n                tail[i] = 0;\n            }\n        }\n\n        // Do the final computation based on the tail and length\n        // Beware that the final length may not fit in 32 bits so we take care of that\n        tmp = this._length * 8;\n        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);\n        lo = parseInt(tmp[2], 16);\n        hi = parseInt(tmp[1], 16) || 0;\n\n        tail[14] = lo;\n        tail[15] = hi;\n        md5cycle(this._hash, tail);\n    };\n\n    /**\n     * Performs the md5 hash on a string.\n     * A conversion will be applied if utf8 string is detected.\n     *\n     * @param {String}  str The string\n     * @param {Boolean} raw True to get the raw string, false to get the hex string\n     *\n     * @return {String} The result\n     */\n    SparkMD5.hash = function (str, raw) {\n        // Converts the string to utf8 bytes if necessary\n        // Then compute it using the binary function\n        return SparkMD5.hashBinary(toUtf8(str), raw);\n    };\n\n    /**\n     * Performs the md5 hash on a binary string.\n     *\n     * @param {String}  content The binary string\n     * @param {Boolean} raw     True to get the raw string, false to get the hex string\n     *\n     * @return {String} The result\n     */\n    SparkMD5.hashBinary = function (content, raw) {\n        var hash = md51(content),\n            ret = hex(hash);\n\n        return raw ? hexToBinaryString(ret) : ret;\n    };\n\n    // ---------------------------------------------------\n\n    /**\n     * SparkMD5 OOP implementation for array buffers.\n     *\n     * Use this class to perform an incremental md5 ONLY for array buffers.\n     */\n    SparkMD5.ArrayBuffer = function () {\n        // call reset to init the instance\n        this.reset();\n    };\n\n    /**\n     * Appends an array buffer.\n     *\n     * @param {ArrayBuffer} arr The array to be appended\n     *\n     * @return {SparkMD5.ArrayBuffer} The instance itself\n     */\n    SparkMD5.ArrayBuffer.prototype.append = function (arr) {\n        var buff = concatenateArrayBuffers(this._buff.buffer, arr, true),\n            length = buff.length,\n            i;\n\n        this._length += arr.byteLength;\n\n        for (i = 64; i <= length; i += 64) {\n            md5cycle(this._hash, md5blk_array(buff.subarray(i - 64, i)));\n        }\n\n        this._buff = (i - 64) < length ? new Uint8Array(buff.buffer.slice(i - 64)) : new Uint8Array(0);\n\n        return this;\n    };\n\n    /**\n     * Finishes the incremental computation, reseting the internal state and\n     * returning the result.\n     *\n     * @param {Boolean} raw True to get the raw string, false to get the hex string\n     *\n     * @return {String} The result\n     */\n    SparkMD5.ArrayBuffer.prototype.end = function (raw) {\n        var buff = this._buff,\n            length = buff.length,\n            tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n            i,\n            ret;\n\n        for (i = 0; i < length; i += 1) {\n            tail[i >> 2] |= buff[i] << ((i % 4) << 3);\n        }\n\n        this._finish(tail, length);\n        ret = hex(this._hash);\n\n        if (raw) {\n            ret = hexToBinaryString(ret);\n        }\n\n        this.reset();\n\n        return ret;\n    };\n\n    /**\n     * Resets the internal state of the computation.\n     *\n     * @return {SparkMD5.ArrayBuffer} The instance itself\n     */\n    SparkMD5.ArrayBuffer.prototype.reset = function () {\n        this._buff = new Uint8Array(0);\n        this._length = 0;\n        this._hash = [1732584193, -271733879, -1732584194, 271733878];\n\n        return this;\n    };\n\n    /**\n     * Gets the internal state of the computation.\n     *\n     * @return {Object} The state\n     */\n    SparkMD5.ArrayBuffer.prototype.getState = function () {\n        var state = SparkMD5.prototype.getState.call(this);\n\n        // Convert buffer to a string\n        state.buff = arrayBuffer2Utf8Str(state.buff);\n\n        return state;\n    };\n\n    /**\n     * Gets the internal state of the computation.\n     *\n     * @param {Object} state The state\n     *\n     * @return {SparkMD5.ArrayBuffer} The instance itself\n     */\n    SparkMD5.ArrayBuffer.prototype.setState = function (state) {\n        // Convert string to buffer\n        state.buff = utf8Str2ArrayBuffer(state.buff, true);\n\n        return SparkMD5.prototype.setState.call(this, state);\n    };\n\n    SparkMD5.ArrayBuffer.prototype.destroy = SparkMD5.prototype.destroy;\n\n    SparkMD5.ArrayBuffer.prototype._finish = SparkMD5.prototype._finish;\n\n    /**\n     * Performs the md5 hash on an array buffer.\n     *\n     * @param {ArrayBuffer} arr The array buffer\n     * @param {Boolean}     raw True to get the raw string, false to get the hex one\n     *\n     * @return {String} The result\n     */\n    SparkMD5.ArrayBuffer.hash = function (arr, raw) {\n        var hash = md51_array(new Uint8Array(arr)),\n            ret = hex(hash);\n\n        return raw ? hexToBinaryString(ret) : ret;\n    };\n\n    return SparkMD5;\n}));\n\n},{}],11:[function(_dereq_,module,exports){\nvar v1 = _dereq_(14);\nvar v4 = _dereq_(15);\n\nvar uuid = v4;\nuuid.v1 = v1;\nuuid.v4 = v4;\n\nmodule.exports = uuid;\n\n},{\"14\":14,\"15\":15}],12:[function(_dereq_,module,exports){\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\nvar byteToHex = [];\nfor (var i = 0; i < 256; ++i) {\n  byteToHex[i] = (i + 0x100).toString(16).substr(1);\n}\n\nfunction bytesToUuid(buf, offset) {\n  var i = offset || 0;\n  var bth = byteToHex;\n  return bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]];\n}\n\nmodule.exports = bytesToUuid;\n\n},{}],13:[function(_dereq_,module,exports){\n// Unique ID creation requires a high quality random # generator.  In the\n// browser this is a little complicated due to unknown quality of Math.random()\n// and inconsistent support for the `crypto` API.  We do the best we can via\n// feature-detection\n\n// getRandomValues needs to be invoked in a context where \"this\" is a Crypto implementation.\nvar getRandomValues = (typeof(crypto) != 'undefined' && crypto.getRandomValues.bind(crypto)) ||\n                      (typeof(msCrypto) != 'undefined' && msCrypto.getRandomValues.bind(msCrypto));\nif (getRandomValues) {\n  // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto\n  var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef\n\n  module.exports = function whatwgRNG() {\n    getRandomValues(rnds8);\n    return rnds8;\n  };\n} else {\n  // Math.random()-based (RNG)\n  //\n  // If all else fails, use Math.random().  It's fast, but is of unspecified\n  // quality.\n  var rnds = new Array(16);\n\n  module.exports = function mathRNG() {\n    for (var i = 0, r; i < 16; i++) {\n      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;\n      rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;\n    }\n\n    return rnds;\n  };\n}\n\n},{}],14:[function(_dereq_,module,exports){\nvar rng = _dereq_(13);\nvar bytesToUuid = _dereq_(12);\n\n// **`v1()` - Generate time-based UUID**\n//\n// Inspired by https://github.com/LiosK/UUID.js\n// and http://docs.python.org/library/uuid.html\n\nvar _nodeId;\nvar _clockseq;\n\n// Previous uuid creation time\nvar _lastMSecs = 0;\nvar _lastNSecs = 0;\n\n// See https://github.com/broofa/node-uuid for API details\nfunction v1(options, buf, offset) {\n  var i = buf && offset || 0;\n  var b = buf || [];\n\n  options = options || {};\n  var node = options.node || _nodeId;\n  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;\n\n  // node and clockseq need to be initialized to random values if they're not\n  // specified.  We do this lazily to minimize issues related to insufficient\n  // system entropy.  See #189\n  if (node == null || clockseq == null) {\n    var seedBytes = rng();\n    if (node == null) {\n      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)\n      node = _nodeId = [\n        seedBytes[0] | 0x01,\n        seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]\n      ];\n    }\n    if (clockseq == null) {\n      // Per 4.2.2, randomize (14 bit) clockseq\n      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;\n    }\n  }\n\n  // UUID timestamps are 100 nano-second units since the Gregorian epoch,\n  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so\n  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'\n  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.\n  var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime();\n\n  // Per 4.2.1.2, use count of uuid's generated during the current clock\n  // cycle to simulate higher resolution clock\n  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;\n\n  // Time since last uuid creation (in msecs)\n  var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;\n\n  // Per 4.2.1.2, Bump clockseq on clock regression\n  if (dt < 0 && options.clockseq === undefined) {\n    clockseq = clockseq + 1 & 0x3fff;\n  }\n\n  // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new\n  // time interval\n  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {\n    nsecs = 0;\n  }\n\n  // Per 4.2.1.2 Throw error if too many uuids are requested\n  if (nsecs >= 10000) {\n    throw new Error('uuid.v1(): Can\\'t create more than 10M uuids/sec');\n  }\n\n  _lastMSecs = msecs;\n  _lastNSecs = nsecs;\n  _clockseq = clockseq;\n\n  // Per 4.1.4 - Convert from unix epoch to Gregorian epoch\n  msecs += 12219292800000;\n\n  // `time_low`\n  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;\n  b[i++] = tl >>> 24 & 0xff;\n  b[i++] = tl >>> 16 & 0xff;\n  b[i++] = tl >>> 8 & 0xff;\n  b[i++] = tl & 0xff;\n\n  // `time_mid`\n  var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;\n  b[i++] = tmh >>> 8 & 0xff;\n  b[i++] = tmh & 0xff;\n\n  // `time_high_and_version`\n  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version\n  b[i++] = tmh >>> 16 & 0xff;\n\n  // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)\n  b[i++] = clockseq >>> 8 | 0x80;\n\n  // `clock_seq_low`\n  b[i++] = clockseq & 0xff;\n\n  // `node`\n  for (var n = 0; n < 6; ++n) {\n    b[i + n] = node[n];\n  }\n\n  return buf ? buf : bytesToUuid(b);\n}\n\nmodule.exports = v1;\n\n},{\"12\":12,\"13\":13}],15:[function(_dereq_,module,exports){\nvar rng = _dereq_(13);\nvar bytesToUuid = _dereq_(12);\n\nfunction v4(options, buf, offset) {\n  var i = buf && offset || 0;\n\n  if (typeof(options) == 'string') {\n    buf = options === 'binary' ? new Array(16) : null;\n    options = null;\n  }\n  options = options || {};\n\n  var rnds = options.random || (options.rng || rng)();\n\n  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n  rnds[6] = (rnds[6] & 0x0f) | 0x40;\n  rnds[8] = (rnds[8] & 0x3f) | 0x80;\n\n  // Copy bytes to buffer, if provided\n  if (buf) {\n    for (var ii = 0; ii < 16; ++ii) {\n      buf[i + ii] = rnds[ii];\n    }\n  }\n\n  return buf || bytesToUuid(rnds);\n}\n\nmodule.exports = v4;\n\n},{\"12\":12,\"13\":13}],16:[function(_dereq_,module,exports){\n'use strict';\n\n/**\n * Stringify/parse functions that don't operate\n * recursively, so they avoid call stack exceeded\n * errors.\n */\nexports.stringify = function stringify(input) {\n  var queue = [];\n  queue.push({obj: input});\n\n  var res = '';\n  var next, obj, prefix, val, i, arrayPrefix, keys, k, key, value, objPrefix;\n  while ((next = queue.pop())) {\n    obj = next.obj;\n    prefix = next.prefix || '';\n    val = next.val || '';\n    res += prefix;\n    if (val) {\n      res += val;\n    } else if (typeof obj !== 'object') {\n      res += typeof obj === 'undefined' ? null : JSON.stringify(obj);\n    } else if (obj === null) {\n      res += 'null';\n    } else if (Array.isArray(obj)) {\n      queue.push({val: ']'});\n      for (i = obj.length - 1; i >= 0; i--) {\n        arrayPrefix = i === 0 ? '' : ',';\n        queue.push({obj: obj[i], prefix: arrayPrefix});\n      }\n      queue.push({val: '['});\n    } else { // object\n      keys = [];\n      for (k in obj) {\n        if (obj.hasOwnProperty(k)) {\n          keys.push(k);\n        }\n      }\n      queue.push({val: '}'});\n      for (i = keys.length - 1; i >= 0; i--) {\n        key = keys[i];\n        value = obj[key];\n        objPrefix = (i > 0 ? ',' : '');\n        objPrefix += JSON.stringify(key) + ':';\n        queue.push({obj: value, prefix: objPrefix});\n      }\n      queue.push({val: '{'});\n    }\n  }\n  return res;\n};\n\n// Convenience function for the parse function.\n// This pop function is basically copied from\n// pouchCollate.parseIndexableString\nfunction pop(obj, stack, metaStack) {\n  var lastMetaElement = metaStack[metaStack.length - 1];\n  if (obj === lastMetaElement.element) {\n    // popping a meta-element, e.g. an object whose value is another object\n    metaStack.pop();\n    lastMetaElement = metaStack[metaStack.length - 1];\n  }\n  var element = lastMetaElement.element;\n  var lastElementIndex = lastMetaElement.index;\n  if (Array.isArray(element)) {\n    element.push(obj);\n  } else if (lastElementIndex === stack.length - 2) { // obj with key+value\n    var key = stack.pop();\n    element[key] = obj;\n  } else {\n    stack.push(obj); // obj with key only\n  }\n}\n\nexports.parse = function (str) {\n  var stack = [];\n  var metaStack = []; // stack for arrays and objects\n  var i = 0;\n  var collationIndex,parsedNum,numChar;\n  var parsedString,lastCh,numConsecutiveSlashes,ch;\n  var arrayElement, objElement;\n  while (true) {\n    collationIndex = str[i++];\n    if (collationIndex === '}' ||\n        collationIndex === ']' ||\n        typeof collationIndex === 'undefined') {\n      if (stack.length === 1) {\n        return stack.pop();\n      } else {\n        pop(stack.pop(), stack, metaStack);\n        continue;\n      }\n    }\n    switch (collationIndex) {\n      case ' ':\n      case '\\t':\n      case '\\n':\n      case ':':\n      case ',':\n        break;\n      case 'n':\n        i += 3; // 'ull'\n        pop(null, stack, metaStack);\n        break;\n      case 't':\n        i += 3; // 'rue'\n        pop(true, stack, metaStack);\n        break;\n      case 'f':\n        i += 4; // 'alse'\n        pop(false, stack, metaStack);\n        break;\n      case '0':\n      case '1':\n      case '2':\n      case '3':\n      case '4':\n      case '5':\n      case '6':\n      case '7':\n      case '8':\n      case '9':\n      case '-':\n        parsedNum = '';\n        i--;\n        while (true) {\n          numChar = str[i++];\n          if (/[\\d\\.\\-e\\+]/.test(numChar)) {\n            parsedNum += numChar;\n          } else {\n            i--;\n            break;\n          }\n        }\n        pop(parseFloat(parsedNum), stack, metaStack);\n        break;\n      case '\"':\n        parsedString = '';\n        lastCh = void 0;\n        numConsecutiveSlashes = 0;\n        while (true) {\n          ch = str[i++];\n          if (ch !== '\"' || (lastCh === '\\\\' &&\n              numConsecutiveSlashes % 2 === 1)) {\n            parsedString += ch;\n            lastCh = ch;\n            if (lastCh === '\\\\') {\n              numConsecutiveSlashes++;\n            } else {\n              numConsecutiveSlashes = 0;\n            }\n          } else {\n            break;\n          }\n        }\n        pop(JSON.parse('\"' + parsedString + '\"'), stack, metaStack);\n        break;\n      case '[':\n        arrayElement = { element: [], index: stack.length };\n        stack.push(arrayElement.element);\n        metaStack.push(arrayElement);\n        break;\n      case '{':\n        objElement = { element: {}, index: stack.length };\n        stack.push(objElement.element);\n        metaStack.push(objElement);\n        break;\n      default:\n        throw new Error(\n          'unexpectedly reached end of input: ' + collationIndex);\n    }\n  }\n};\n\n},{}],17:[function(_dereq_,module,exports){\n(function (global){\n'use strict';\n\nfunction _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }\n\nvar lie = _interopDefault(_dereq_(7));\nvar getArguments = _interopDefault(_dereq_(1));\nvar nextTick = _interopDefault(_dereq_(5));\nvar events = _dereq_(4);\nvar inherits = _interopDefault(_dereq_(6));\nvar uuidV4 = _interopDefault(_dereq_(11));\nvar debug = _interopDefault(_dereq_(2));\nvar Md5 = _interopDefault(_dereq_(10));\nvar vuvuzela = _interopDefault(_dereq_(16));\n\n/* istanbul ignore next */\nvar PouchPromise = typeof Promise === 'function' ? Promise : lie;\n\nfunction isBinaryObject(object) {\n  return (typeof ArrayBuffer !== 'undefined' && object instanceof ArrayBuffer) ||\n    (typeof Blob !== 'undefined' && object instanceof Blob);\n}\n\nfunction cloneArrayBuffer(buff) {\n  if (typeof buff.slice === 'function') {\n    return buff.slice(0);\n  }\n  // IE10-11 slice() polyfill\n  var target = new ArrayBuffer(buff.byteLength);\n  var targetArray = new Uint8Array(target);\n  var sourceArray = new Uint8Array(buff);\n  targetArray.set(sourceArray);\n  return target;\n}\n\nfunction cloneBinaryObject(object) {\n  if (object instanceof ArrayBuffer) {\n    return cloneArrayBuffer(object);\n  }\n  var size = object.size;\n  var type = object.type;\n  // Blob\n  if (typeof object.slice === 'function') {\n    return object.slice(0, size, type);\n  }\n  // PhantomJS slice() replacement\n  return object.webkitSlice(0, size, type);\n}\n\n// most of this is borrowed from lodash.isPlainObject:\n// https://github.com/fis-components/lodash.isplainobject/\n// blob/29c358140a74f252aeb08c9eb28bef86f2217d4a/index.js\n\nvar funcToString = Function.prototype.toString;\nvar objectCtorString = funcToString.call(Object);\n\nfunction isPlainObject(value) {\n  var proto = Object.getPrototypeOf(value);\n  /* istanbul ignore if */\n  if (proto === null) { // not sure when this happens, but I guess it can\n    return true;\n  }\n  var Ctor = proto.constructor;\n  return (typeof Ctor == 'function' &&\n    Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString);\n}\n\nfunction clone(object) {\n  var newObject;\n  var i;\n  var len;\n\n  if (!object || typeof object !== 'object') {\n    return object;\n  }\n\n  if (Array.isArray(object)) {\n    newObject = [];\n    for (i = 0, len = object.length; i < len; i++) {\n      newObject[i] = clone(object[i]);\n    }\n    return newObject;\n  }\n\n  // special case: to avoid inconsistencies between IndexedDB\n  // and other backends, we automatically stringify Dates\n  if (object instanceof Date) {\n    return object.toISOString();\n  }\n\n  if (isBinaryObject(object)) {\n    return cloneBinaryObject(object);\n  }\n\n  if (!isPlainObject(object)) {\n    return object; // don't clone objects like Workers\n  }\n\n  newObject = {};\n  for (i in object) {\n    /* istanbul ignore else */\n    if (Object.prototype.hasOwnProperty.call(object, i)) {\n      var value = clone(object[i]);\n      if (typeof value !== 'undefined') {\n        newObject[i] = value;\n      }\n    }\n  }\n  return newObject;\n}\n\nfunction once(fun) {\n  var called = false;\n  return getArguments(function (args) {\n    /* istanbul ignore if */\n    if (called) {\n      // this is a smoke test and should never actually happen\n      throw new Error('once called more than once');\n    } else {\n      called = true;\n      fun.apply(this, args);\n    }\n  });\n}\n\nfunction toPromise(func) {\n  //create the function we will be returning\n  return getArguments(function (args) {\n    // Clone arguments\n    args = clone(args);\n    var self = this;\n    // if the last argument is a function, assume its a callback\n    var usedCB = (typeof args[args.length - 1] === 'function') ? args.pop() : false;\n    var promise = new PouchPromise(function (fulfill, reject) {\n      var resp;\n      try {\n        var callback = once(function (err, mesg) {\n          if (err) {\n            reject(err);\n          } else {\n            fulfill(mesg);\n          }\n        });\n        // create a callback for this invocation\n        // apply the function in the orig context\n        args.push(callback);\n        resp = func.apply(self, args);\n        if (resp && typeof resp.then === 'function') {\n          fulfill(resp);\n        }\n      } catch (e) {\n        reject(e);\n      }\n    });\n    // if there is a callback, call it back\n    if (usedCB) {\n      promise.then(function (result) {\n        usedCB(null, result);\n      }, usedCB);\n    }\n    return promise;\n  });\n}\n\nfunction logApiCall(self, name, args) {\n  /* istanbul ignore if */\n  if (self.constructor.listeners('debug').length) {\n    var logArgs = ['api', self.name, name];\n    for (var i = 0; i < args.length - 1; i++) {\n      logArgs.push(args[i]);\n    }\n    self.constructor.emit('debug', logArgs);\n\n    // override the callback itself to log the response\n    var origCallback = args[args.length - 1];\n    args[args.length - 1] = function (err, res) {\n      var responseArgs = ['api', self.name, name];\n      responseArgs = responseArgs.concat(\n        err ? ['error', err] : ['success', res]\n      );\n      self.constructor.emit('debug', responseArgs);\n      origCallback(err, res);\n    };\n  }\n}\n\nfunction adapterFun(name, callback) {\n  return toPromise(getArguments(function (args) {\n    if (this._closed) {\n      return PouchPromise.reject(new Error('database is closed'));\n    }\n    if (this._destroyed) {\n      return PouchPromise.reject(new Error('database is destroyed'));\n    }\n    var self = this;\n    logApiCall(self, name, args);\n    if (!this.taskqueue.isReady) {\n      return new PouchPromise(function (fulfill, reject) {\n        self.taskqueue.addTask(function (failed) {\n          if (failed) {\n            reject(failed);\n          } else {\n            fulfill(self[name].apply(self, args));\n          }\n        });\n      });\n    }\n    return callback.apply(this, args);\n  }));\n}\n\nfunction mangle(key) {\n  return '$' + key;\n}\nfunction unmangle(key) {\n  return key.substring(1);\n}\nfunction Map$1() {\n  this._store = {};\n}\nMap$1.prototype.get = function (key) {\n  var mangled = mangle(key);\n  return this._store[mangled];\n};\nMap$1.prototype.set = function (key, value) {\n  var mangled = mangle(key);\n  this._store[mangled] = value;\n  return true;\n};\nMap$1.prototype.has = function (key) {\n  var mangled = mangle(key);\n  return mangled in this._store;\n};\nMap$1.prototype[\"delete\"] = function (key) {\n  var mangled = mangle(key);\n  var res = mangled in this._store;\n  delete this._store[mangled];\n  return res;\n};\nMap$1.prototype.forEach = function (cb) {\n  var keys = Object.keys(this._store);\n  for (var i = 0, len = keys.length; i < len; i++) {\n    var key = keys[i];\n    var value = this._store[key];\n    key = unmangle(key);\n    cb(value, key);\n  }\n};\nObject.defineProperty(Map$1.prototype, 'size', {\n  get: function () {\n    return Object.keys(this._store).length;\n  }\n});\n\nfunction Set$1(array) {\n  this._store = new Map$1();\n\n  // init with an array\n  if (array && Array.isArray(array)) {\n    for (var i = 0, len = array.length; i < len; i++) {\n      this.add(array[i]);\n    }\n  }\n}\nSet$1.prototype.add = function (key) {\n  return this._store.set(key, true);\n};\nSet$1.prototype.has = function (key) {\n  return this._store.has(key);\n};\nSet$1.prototype.forEach = function (cb) {\n  this._store.forEach(function (value, key) {\n    cb(key);\n  });\n};\nObject.defineProperty(Set$1.prototype, 'size', {\n  get: function () {\n    return this._store.size;\n  }\n});\n\n/* global Map,Set,Symbol */\n// Based on https://kangax.github.io/compat-table/es6/ we can sniff out\n// incomplete Map/Set implementations which would otherwise cause our tests to fail.\n// Notably they fail in IE11 and iOS 8.4, which this prevents.\nfunction supportsMapAndSet() {\n  if (typeof Symbol === 'undefined' || typeof Map === 'undefined' || typeof Set === 'undefined') {\n    return false;\n  }\n  var prop = Object.getOwnPropertyDescriptor(Map, Symbol.species);\n  return prop && 'get' in prop && Map[Symbol.species] === Map;\n}\n\n// based on https://github.com/montagejs/collections\n/* global Map,Set */\n\nvar ExportedSet;\nvar ExportedMap;\n\n{\n  if (supportsMapAndSet()) { // prefer built-in Map/Set\n    ExportedSet = Set;\n    ExportedMap = Map;\n  } else { // fall back to our polyfill\n    ExportedSet = Set$1;\n    ExportedMap = Map$1;\n  }\n}\n\n// like underscore/lodash _.pick()\nfunction pick(obj, arr) {\n  var res = {};\n  for (var i = 0, len = arr.length; i < len; i++) {\n    var prop = arr[i];\n    if (prop in obj) {\n      res[prop] = obj[prop];\n    }\n  }\n  return res;\n}\n\n// Most browsers throttle concurrent requests at 6, so it's silly\n// to shim _bulk_get by trying to launch potentially hundreds of requests\n// and then letting the majority time out. We can handle this ourselves.\nvar MAX_NUM_CONCURRENT_REQUESTS = 6;\n\nfunction identityFunction(x) {\n  return x;\n}\n\nfunction formatResultForOpenRevsGet(result) {\n  return [{\n    ok: result\n  }];\n}\n\n// shim for P/CouchDB adapters that don't directly implement _bulk_get\nfunction bulkGet(db, opts, callback) {\n  var requests = opts.docs;\n\n  // consolidate into one request per doc if possible\n  var requestsById = new ExportedMap();\n  requests.forEach(function (request) {\n    if (requestsById.has(request.id)) {\n      requestsById.get(request.id).push(request);\n    } else {\n      requestsById.set(request.id, [request]);\n    }\n  });\n\n  var numDocs = requestsById.size;\n  var numDone = 0;\n  var perDocResults = new Array(numDocs);\n\n  function collapseResultsAndFinish() {\n    var results = [];\n    perDocResults.forEach(function (res) {\n      res.docs.forEach(function (info) {\n        results.push({\n          id: res.id,\n          docs: [info]\n        });\n      });\n    });\n    callback(null, {results: results});\n  }\n\n  function checkDone() {\n    if (++numDone === numDocs) {\n      collapseResultsAndFinish();\n    }\n  }\n\n  function gotResult(docIndex, id, docs) {\n    perDocResults[docIndex] = {id: id, docs: docs};\n    checkDone();\n  }\n\n  var allRequests = [];\n  requestsById.forEach(function (value, key) {\n    allRequests.push(key);\n  });\n\n  var i = 0;\n\n  function nextBatch() {\n\n    if (i >= allRequests.length) {\n      return;\n    }\n\n    var upTo = Math.min(i + MAX_NUM_CONCURRENT_REQUESTS, allRequests.length);\n    var batch = allRequests.slice(i, upTo);\n    processBatch(batch, i);\n    i += batch.length;\n  }\n\n  function processBatch(batch, offset) {\n    batch.forEach(function (docId, j) {\n      var docIdx = offset + j;\n      var docRequests = requestsById.get(docId);\n\n      // just use the first request as the \"template\"\n      // TODO: The _bulk_get API allows for more subtle use cases than this,\n      // but for now it is unlikely that there will be a mix of different\n      // \"atts_since\" or \"attachments\" in the same request, since it's just\n      // replicate.js that is using this for the moment.\n      // Also, atts_since is aspirational, since we don't support it yet.\n      var docOpts = pick(docRequests[0], ['atts_since', 'attachments']);\n      docOpts.open_revs = docRequests.map(function (request) {\n        // rev is optional, open_revs disallowed\n        return request.rev;\n      });\n\n      // remove falsey / undefined revisions\n      docOpts.open_revs = docOpts.open_revs.filter(identityFunction);\n\n      var formatResult = identityFunction;\n\n      if (docOpts.open_revs.length === 0) {\n        delete docOpts.open_revs;\n\n        // when fetching only the \"winning\" leaf,\n        // transform the result so it looks like an open_revs\n        // request\n        formatResult = formatResultForOpenRevsGet;\n      }\n\n      // globally-supplied options\n      ['revs', 'attachments', 'binary', 'ajax', 'latest'].forEach(function (param) {\n        if (param in opts) {\n          docOpts[param] = opts[param];\n        }\n      });\n      db.get(docId, docOpts, function (err, res) {\n        var result;\n        /* istanbul ignore if */\n        if (err) {\n          result = [{error: err}];\n        } else {\n          result = formatResult(res);\n        }\n        gotResult(docIdx, docId, result);\n        nextBatch();\n      });\n    });\n  }\n\n  nextBatch();\n\n}\n\nfunction isChromeApp() {\n  return (typeof chrome !== \"undefined\" &&\n    typeof chrome.storage !== \"undefined\" &&\n    typeof chrome.storage.local !== \"undefined\");\n}\n\nvar hasLocal;\n\nif (isChromeApp()) {\n  hasLocal = false;\n} else {\n  try {\n    localStorage.setItem('_pouch_check_localstorage', 1);\n    hasLocal = !!localStorage.getItem('_pouch_check_localstorage');\n  } catch (e) {\n    hasLocal = false;\n  }\n}\n\nfunction hasLocalStorage() {\n  return hasLocal;\n}\n\n// Custom nextTick() shim for browsers. In node, this will just be process.nextTick(). We\n// avoid using process.nextTick() directly because the polyfill is very large and we don't\n// need all of it (see: https://github.com/defunctzombie/node-process).\n// \"immediate\" 3.0.8 is used by lie, and it's a smaller version of the latest \"immediate\"\n// package, so it's the one we use.\n// When we use nextTick() in our codebase, we only care about not releasing Zalgo\n// (see: http://blog.izs.me/post/59142742143/designing-apis-for-asynchrony).\n// Microtask vs macrotask doesn't matter to us. So we're free to use the fastest\n// (least latency) option, which is \"immediate\" due to use of microtasks.\n// All of our nextTicks are isolated to this one function so we can easily swap out one\n// implementation for another.\n\ninherits(Changes, events.EventEmitter);\n\n/* istanbul ignore next */\nfunction attachBrowserEvents(self) {\n  if (isChromeApp()) {\n    chrome.storage.onChanged.addListener(function (e) {\n      // make sure it's event addressed to us\n      if (e.db_name != null) {\n        //object only has oldValue, newValue members\n        self.emit(e.dbName.newValue);\n      }\n    });\n  } else if (hasLocalStorage()) {\n    if (typeof addEventListener !== 'undefined') {\n      addEventListener(\"storage\", function (e) {\n        self.emit(e.key);\n      });\n    } else { // old IE\n      window.attachEvent(\"storage\", function (e) {\n        self.emit(e.key);\n      });\n    }\n  }\n}\n\nfunction Changes() {\n  events.EventEmitter.call(this);\n  this._listeners = {};\n\n  attachBrowserEvents(this);\n}\nChanges.prototype.addListener = function (dbName, id, db, opts) {\n  /* istanbul ignore if */\n  if (this._listeners[id]) {\n    return;\n  }\n  var self = this;\n  var inprogress = false;\n  function eventFunction() {\n    /* istanbul ignore if */\n    if (!self._listeners[id]) {\n      return;\n    }\n    if (inprogress) {\n      inprogress = 'waiting';\n      return;\n    }\n    inprogress = true;\n    var changesOpts = pick(opts, [\n      'style', 'include_docs', 'attachments', 'conflicts', 'filter',\n      'doc_ids', 'view', 'since', 'query_params', 'binary'\n    ]);\n\n    /* istanbul ignore next */\n    function onError() {\n      inprogress = false;\n    }\n\n    db.changes(changesOpts).on('change', function (c) {\n      if (c.seq > opts.since && !opts.cancelled) {\n        opts.since = c.seq;\n        opts.onChange(c);\n      }\n    }).on('complete', function () {\n      if (inprogress === 'waiting') {\n        nextTick(eventFunction);\n      }\n      inprogress = false;\n    }).on('error', onError);\n  }\n  this._listeners[id] = eventFunction;\n  this.on(dbName, eventFunction);\n};\n\nChanges.prototype.removeListener = function (dbName, id) {\n  /* istanbul ignore if */\n  if (!(id in this._listeners)) {\n    return;\n  }\n  events.EventEmitter.prototype.removeListener.call(this, dbName,\n    this._listeners[id]);\n  delete this._listeners[id];\n};\n\n\n/* istanbul ignore next */\nChanges.prototype.notifyLocalWindows = function (dbName) {\n  //do a useless change on a storage thing\n  //in order to get other windows's listeners to activate\n  if (isChromeApp()) {\n    chrome.storage.local.set({dbName: dbName});\n  } else if (hasLocalStorage()) {\n    localStorage[dbName] = (localStorage[dbName] === \"a\") ? \"b\" : \"a\";\n  }\n};\n\nChanges.prototype.notify = function (dbName) {\n  this.emit(dbName);\n  this.notifyLocalWindows(dbName);\n};\n\nfunction guardedConsole(method) {\n  /* istanbul ignore else */\n  if (typeof console !== 'undefined' && typeof console[method] === 'function') {\n    var args = Array.prototype.slice.call(arguments, 1);\n    console[method].apply(console, args);\n  }\n}\n\nfunction randomNumber(min, max) {\n  var maxTimeout = 600000; // Hard-coded default of 10 minutes\n  min = parseInt(min, 10) || 0;\n  max = parseInt(max, 10);\n  if (max !== max || max <= min) {\n    max = (min || 1) << 1; //doubling\n  } else {\n    max = max + 1;\n  }\n  // In order to not exceed maxTimeout, pick a random value between half of maxTimeout and maxTimeout\n  if (max > maxTimeout) {\n    min = maxTimeout >> 1; // divide by two\n    max = maxTimeout;\n  }\n  var ratio = Math.random();\n  var range = max - min;\n\n  return ~~(range * ratio + min); // ~~ coerces to an int, but fast.\n}\n\nfunction defaultBackOff(min) {\n  var max = 0;\n  if (!min) {\n    max = 2000;\n  }\n  return randomNumber(min, max);\n}\n\n// designed to give info to browser users, who are disturbed\n// when they see http errors in the console\nfunction explainError(status, str) {\n  guardedConsole('info', 'The above ' + status + ' is totally normal. ' + str);\n}\n\nvar assign;\n{\n  if (typeof Object.assign === 'function') {\n    assign = Object.assign;\n  } else {\n    // lite Object.assign polyfill based on\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\n    assign = function (target) {\n      var to = Object(target);\n\n      for (var index = 1; index < arguments.length; index++) {\n        var nextSource = arguments[index];\n\n        if (nextSource != null) { // Skip over if undefined or null\n          for (var nextKey in nextSource) {\n            // Avoid bugs when hasOwnProperty is shadowed\n            if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {\n              to[nextKey] = nextSource[nextKey];\n            }\n          }\n        }\n      }\n      return to;\n    };\n  }\n}\n\nvar $inject_Object_assign = assign;\n\ninherits(PouchError, Error);\n\nfunction PouchError(status, error, reason) {\n  Error.call(this, reason);\n  this.status = status;\n  this.name = error;\n  this.message = reason;\n  this.error = true;\n}\n\nPouchError.prototype.toString = function () {\n  return JSON.stringify({\n    status: this.status,\n    name: this.name,\n    message: this.message,\n    reason: this.reason\n  });\n};\n\nvar UNAUTHORIZED = new PouchError(401, 'unauthorized', \"Name or password is incorrect.\");\nvar MISSING_BULK_DOCS = new PouchError(400, 'bad_request', \"Missing JSON list of 'docs'\");\nvar MISSING_DOC = new PouchError(404, 'not_found', 'missing');\nvar REV_CONFLICT = new PouchError(409, 'conflict', 'Document update conflict');\nvar INVALID_ID = new PouchError(400, 'bad_request', '_id field must contain a string');\nvar MISSING_ID = new PouchError(412, 'missing_id', '_id is required for puts');\nvar RESERVED_ID = new PouchError(400, 'bad_request', 'Only reserved document ids may start with underscore.');\nvar NOT_OPEN = new PouchError(412, 'precondition_failed', 'Database not open');\nvar UNKNOWN_ERROR = new PouchError(500, 'unknown_error', 'Database encountered an unknown error');\nvar BAD_ARG = new PouchError(500, 'badarg', 'Some query argument is invalid');\nvar INVALID_REQUEST = new PouchError(400, 'invalid_request', 'Request was invalid');\nvar QUERY_PARSE_ERROR = new PouchError(400, 'query_parse_error', 'Some query parameter is invalid');\nvar DOC_VALIDATION = new PouchError(500, 'doc_validation', 'Bad special document member');\nvar BAD_REQUEST = new PouchError(400, 'bad_request', 'Something wrong with the request');\nvar NOT_AN_OBJECT = new PouchError(400, 'bad_request', 'Document must be a JSON object');\nvar DB_MISSING = new PouchError(404, 'not_found', 'Database not found');\nvar IDB_ERROR = new PouchError(500, 'indexed_db_went_bad', 'unknown');\nvar WSQ_ERROR = new PouchError(500, 'web_sql_went_bad', 'unknown');\nvar LDB_ERROR = new PouchError(500, 'levelDB_went_went_bad', 'unknown');\nvar FORBIDDEN = new PouchError(403, 'forbidden', 'Forbidden by design doc validate_doc_update function');\nvar INVALID_REV = new PouchError(400, 'bad_request', 'Invalid rev format');\nvar FILE_EXISTS = new PouchError(412, 'file_exists', 'The database could not be created, the file already exists.');\nvar MISSING_STUB = new PouchError(412, 'missing_stub', 'A pre-existing attachment stub wasn\\'t found');\nvar INVALID_URL = new PouchError(413, 'invalid_url', 'Provided URL is invalid');\n\nfunction createError(error, reason) {\n  function CustomPouchError(reason) {\n    // inherit error properties from our parent error manually\n    // so as to allow proper JSON parsing.\n    /* jshint ignore:start */\n    for (var p in error) {\n      if (typeof error[p] !== 'function') {\n        this[p] = error[p];\n      }\n    }\n    /* jshint ignore:end */\n    if (reason !== undefined) {\n      this.reason = reason;\n    }\n  }\n  CustomPouchError.prototype = PouchError.prototype;\n  return new CustomPouchError(reason);\n}\n\nfunction generateErrorFromResponse(err) {\n\n  if (typeof err !== 'object') {\n    var data = err;\n    err = UNKNOWN_ERROR;\n    err.data = data;\n  }\n\n  if ('error' in err && err.error === 'conflict') {\n    err.name = 'conflict';\n    err.status = 409;\n  }\n\n  if (!('name' in err)) {\n    err.name = err.error || 'unknown';\n  }\n\n  if (!('status' in err)) {\n    err.status = 500;\n  }\n\n  if (!('message' in err)) {\n    err.message = err.message || err.reason;\n  }\n\n  return err;\n}\n\nfunction tryFilter(filter, doc, req) {\n  try {\n    return !filter(doc, req);\n  } catch (err) {\n    var msg = 'Filter function threw: ' + err.toString();\n    return createError(BAD_REQUEST, msg);\n  }\n}\n\nfunction filterChange(opts) {\n  var req = {};\n  var hasFilter = opts.filter && typeof opts.filter === 'function';\n  req.query = opts.query_params;\n\n  return function filter(change) {\n    if (!change.doc) {\n      // CSG sends events on the changes feed that don't have documents,\n      // this hack makes a whole lot of existing code robust.\n      change.doc = {};\n    }\n\n    var filterReturn = hasFilter && tryFilter(opts.filter, change.doc, req);\n\n    if (typeof filterReturn === 'object') {\n      return filterReturn;\n    }\n\n    if (filterReturn) {\n      return false;\n    }\n\n    if (!opts.include_docs) {\n      delete change.doc;\n    } else if (!opts.attachments) {\n      for (var att in change.doc._attachments) {\n        /* istanbul ignore else */\n        if (change.doc._attachments.hasOwnProperty(att)) {\n          change.doc._attachments[att].stub = true;\n        }\n      }\n    }\n    return true;\n  };\n}\n\nfunction flatten(arrs) {\n  var res = [];\n  for (var i = 0, len = arrs.length; i < len; i++) {\n    res = res.concat(arrs[i]);\n  }\n  return res;\n}\n\n// shim for Function.prototype.name,\n// for browsers that don't support it like IE\n\n/* istanbul ignore next */\n\n// Determine id an ID is valid\n//   - invalid IDs begin with an underescore that does not begin '_design' or\n//     '_local'\n//   - any other string value is a valid id\n// Returns the specific error object for each case\nfunction invalidIdError(id) {\n  var err;\n  if (!id) {\n    err = createError(MISSING_ID);\n  } else if (typeof id !== 'string') {\n    err = createError(INVALID_ID);\n  } else if (/^_/.test(id) && !(/^_(design|local)/).test(id)) {\n    err = createError(RESERVED_ID);\n  }\n  if (err) {\n    throw err;\n  }\n}\n\n// Checks if a PouchDB object is \"remote\" or not. This is\n// designed to opt-in to certain optimizations, such as\n// avoiding checks for \"dependentDbs\" and other things that\n// we know only apply to local databases. In general, \"remote\"\n// should be true for the http adapter, and for third-party\n// adapters with similar expensive boundaries to cross for\n// every API call, such as socket-pouch and worker-pouch.\n// Previously, this was handled via db.type() === 'http'\n// which is now deprecated.\n\nfunction isRemote(db) {\n  if (typeof db._remote === 'boolean') {\n    return db._remote;\n  }\n  /* istanbul ignore next */\n  if (typeof db.type === 'function') {\n    guardedConsole('warn',\n      'db.type() is deprecated and will be removed in ' +\n      'a future version of PouchDB');\n    return db.type() === 'http';\n  }\n  /* istanbul ignore next */\n  return false;\n}\n\nfunction listenerCount(ee, type) {\n  return 'listenerCount' in ee ? ee.listenerCount(type) :\n                                 events.EventEmitter.listenerCount(ee, type);\n}\n\nfunction parseDesignDocFunctionName(s) {\n  if (!s) {\n    return null;\n  }\n  var parts = s.split('/');\n  if (parts.length === 2) {\n    return parts;\n  }\n  if (parts.length === 1) {\n    return [s, s];\n  }\n  return null;\n}\n\nfunction normalizeDesignDocFunctionName(s) {\n  var normalized = parseDesignDocFunctionName(s);\n  return normalized ? normalized.join('/') : null;\n}\n\n// originally parseUri 1.2.2, now patched by us\n// (c) Steven Levithan <stevenlevithan.com>\n// MIT License\nvar keys = [\"source\", \"protocol\", \"authority\", \"userInfo\", \"user\", \"password\",\n    \"host\", \"port\", \"relative\", \"path\", \"directory\", \"file\", \"query\", \"anchor\"];\nvar qName =\"queryKey\";\nvar qParser = /(?:^|&)([^&=]*)=?([^&]*)/g;\n\n// use the \"loose\" parser\n/* eslint maxlen: 0, no-useless-escape: 0 */\nvar parser = /^(?:(?![^:@]+:[^:@\\/]*@)([^:\\/?#.]+):)?(?:\\/\\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/;\n\nfunction parseUri(str) {\n  var m = parser.exec(str);\n  var uri = {};\n  var i = 14;\n\n  while (i--) {\n    var key = keys[i];\n    var value = m[i] || \"\";\n    var encoded = ['user', 'password'].indexOf(key) !== -1;\n    uri[key] = encoded ? decodeURIComponent(value) : value;\n  }\n\n  uri[qName] = {};\n  uri[keys[12]].replace(qParser, function ($0, $1, $2) {\n    if ($1) {\n      uri[qName][$1] = $2;\n    }\n  });\n\n  return uri;\n}\n\n// Based on https://github.com/alexdavid/scope-eval v0.0.3\n// (source: https://unpkg.com/scope-eval@0.0.3/scope_eval.js)\n// This is basically just a wrapper around new Function()\n\nfunction scopeEval(source, scope) {\n  var keys = [];\n  var values = [];\n  for (var key in scope) {\n    if (scope.hasOwnProperty(key)) {\n      keys.push(key);\n      values.push(scope[key]);\n    }\n  }\n  keys.push(source);\n  return Function.apply(null, keys).apply(null, values);\n}\n\n// this is essentially the \"update sugar\" function from daleharvey/pouchdb#1388\n// the diffFun tells us what delta to apply to the doc.  it either returns\n// the doc, or false if it doesn't need to do an update after all\nfunction upsert(db, docId, diffFun) {\n  return new PouchPromise(function (fulfill, reject) {\n    db.get(docId, function (err, doc) {\n      if (err) {\n        /* istanbul ignore next */\n        if (err.status !== 404) {\n          return reject(err);\n        }\n        doc = {};\n      }\n\n      // the user might change the _rev, so save it for posterity\n      var docRev = doc._rev;\n      var newDoc = diffFun(doc);\n\n      if (!newDoc) {\n        // if the diffFun returns falsy, we short-circuit as\n        // an optimization\n        return fulfill({updated: false, rev: docRev});\n      }\n\n      // users aren't allowed to modify these values,\n      // so reset them here\n      newDoc._id = docId;\n      newDoc._rev = docRev;\n      fulfill(tryAndPut(db, newDoc, diffFun));\n    });\n  });\n}\n\nfunction tryAndPut(db, doc, diffFun) {\n  return db.put(doc).then(function (res) {\n    return {\n      updated: true,\n      rev: res.rev\n    };\n  }, function (err) {\n    /* istanbul ignore next */\n    if (err.status !== 409) {\n      throw err;\n    }\n    return upsert(db, doc._id, diffFun);\n  });\n}\n\nfunction rev() {\n  return uuidV4.v4().replace(/-/g, '').toLowerCase();\n}\n\nvar uuid = uuidV4.v4;\n\n// We fetch all leafs of the revision tree, and sort them based on tree length\n// and whether they were deleted, undeleted documents with the longest revision\n// tree (most edits) win\n// The final sort algorithm is slightly documented in a sidebar here:\n// http://guide.couchdb.org/draft/conflicts.html\nfunction winningRev(metadata) {\n  var winningId;\n  var winningPos;\n  var winningDeleted;\n  var toVisit = metadata.rev_tree.slice();\n  var node;\n  while ((node = toVisit.pop())) {\n    var tree = node.ids;\n    var branches = tree[2];\n    var pos = node.pos;\n    if (branches.length) { // non-leaf\n      for (var i = 0, len = branches.length; i < len; i++) {\n        toVisit.push({pos: pos + 1, ids: branches[i]});\n      }\n      continue;\n    }\n    var deleted = !!tree[1].deleted;\n    var id = tree[0];\n    // sort by deleted, then pos, then id\n    if (!winningId || (winningDeleted !== deleted ? winningDeleted :\n        winningPos !== pos ? winningPos < pos : winningId < id)) {\n      winningId = id;\n      winningPos = pos;\n      winningDeleted = deleted;\n    }\n  }\n\n  return winningPos + '-' + winningId;\n}\n\n// Pretty much all below can be combined into a higher order function to\n// traverse revisions\n// The return value from the callback will be passed as context to all\n// children of that node\nfunction traverseRevTree(revs, callback) {\n  var toVisit = revs.slice();\n\n  var node;\n  while ((node = toVisit.pop())) {\n    var pos = node.pos;\n    var tree = node.ids;\n    var branches = tree[2];\n    var newCtx =\n      callback(branches.length === 0, pos, tree[0], node.ctx, tree[1]);\n    for (var i = 0, len = branches.length; i < len; i++) {\n      toVisit.push({pos: pos + 1, ids: branches[i], ctx: newCtx});\n    }\n  }\n}\n\nfunction sortByPos(a, b) {\n  return a.pos - b.pos;\n}\n\nfunction collectLeaves(revs) {\n  var leaves = [];\n  traverseRevTree(revs, function (isLeaf, pos, id, acc, opts) {\n    if (isLeaf) {\n      leaves.push({rev: pos + \"-\" + id, pos: pos, opts: opts});\n    }\n  });\n  leaves.sort(sortByPos).reverse();\n  for (var i = 0, len = leaves.length; i < len; i++) {\n    delete leaves[i].pos;\n  }\n  return leaves;\n}\n\n// returns revs of all conflicts that is leaves such that\n// 1. are not deleted and\n// 2. are different than winning revision\nfunction collectConflicts(metadata) {\n  var win = winningRev(metadata);\n  var leaves = collectLeaves(metadata.rev_tree);\n  var conflicts = [];\n  for (var i = 0, len = leaves.length; i < len; i++) {\n    var leaf = leaves[i];\n    if (leaf.rev !== win && !leaf.opts.deleted) {\n      conflicts.push(leaf.rev);\n    }\n  }\n  return conflicts;\n}\n\n// compact a tree by marking its non-leafs as missing,\n// and return a list of revs to delete\nfunction compactTree(metadata) {\n  var revs = [];\n  traverseRevTree(metadata.rev_tree, function (isLeaf, pos,\n                                               revHash, ctx, opts) {\n    if (opts.status === 'available' && !isLeaf) {\n      revs.push(pos + '-' + revHash);\n      opts.status = 'missing';\n    }\n  });\n  return revs;\n}\n\n// build up a list of all the paths to the leafs in this revision tree\nfunction rootToLeaf(revs) {\n  var paths = [];\n  var toVisit = revs.slice();\n  var node;\n  while ((node = toVisit.pop())) {\n    var pos = node.pos;\n    var tree = node.ids;\n    var id = tree[0];\n    var opts = tree[1];\n    var branches = tree[2];\n    var isLeaf = branches.length === 0;\n\n    var history = node.history ? node.history.slice() : [];\n    history.push({id: id, opts: opts});\n    if (isLeaf) {\n      paths.push({pos: (pos + 1 - history.length), ids: history});\n    }\n    for (var i = 0, len = branches.length; i < len; i++) {\n      toVisit.push({pos: pos + 1, ids: branches[i], history: history});\n    }\n  }\n  return paths.reverse();\n}\n\n// for a better overview of what this is doing, read:\n// https://github.com/apache/couchdb-couch/blob/master/src/couch_key_tree.erl\n//\n// But for a quick intro, CouchDB uses a revision tree to store a documents\n// history, A -> B -> C, when a document has conflicts, that is a branch in the\n// tree, A -> (B1 | B2 -> C), We store these as a nested array in the format\n//\n// KeyTree = [Path ... ]\n// Path = {pos: position_from_root, ids: Tree}\n// Tree = [Key, Opts, [Tree, ...]], in particular single node: [Key, []]\n\nfunction sortByPos$1(a, b) {\n  return a.pos - b.pos;\n}\n\n// classic binary search\nfunction binarySearch(arr, item, comparator) {\n  var low = 0;\n  var high = arr.length;\n  var mid;\n  while (low < high) {\n    mid = (low + high) >>> 1;\n    if (comparator(arr[mid], item) < 0) {\n      low = mid + 1;\n    } else {\n      high = mid;\n    }\n  }\n  return low;\n}\n\n// assuming the arr is sorted, insert the item in the proper place\nfunction insertSorted(arr, item, comparator) {\n  var idx = binarySearch(arr, item, comparator);\n  arr.splice(idx, 0, item);\n}\n\n// Turn a path as a flat array into a tree with a single branch.\n// If any should be stemmed from the beginning of the array, that's passed\n// in as the second argument\nfunction pathToTree(path, numStemmed) {\n  var root;\n  var leaf;\n  for (var i = numStemmed, len = path.length; i < len; i++) {\n    var node = path[i];\n    var currentLeaf = [node.id, node.opts, []];\n    if (leaf) {\n      leaf[2].push(currentLeaf);\n      leaf = currentLeaf;\n    } else {\n      root = leaf = currentLeaf;\n    }\n  }\n  return root;\n}\n\n// compare the IDs of two trees\nfunction compareTree(a, b) {\n  return a[0] < b[0] ? -1 : 1;\n}\n\n// Merge two trees together\n// The roots of tree1 and tree2 must be the same revision\nfunction mergeTree(in_tree1, in_tree2) {\n  var queue = [{tree1: in_tree1, tree2: in_tree2}];\n  var conflicts = false;\n  while (queue.length > 0) {\n    var item = queue.pop();\n    var tree1 = item.tree1;\n    var tree2 = item.tree2;\n\n    if (tree1[1].status || tree2[1].status) {\n      tree1[1].status =\n        (tree1[1].status ===  'available' ||\n        tree2[1].status === 'available') ? 'available' : 'missing';\n    }\n\n    for (var i = 0; i < tree2[2].length; i++) {\n      if (!tree1[2][0]) {\n        conflicts = 'new_leaf';\n        tree1[2][0] = tree2[2][i];\n        continue;\n      }\n\n      var merged = false;\n      for (var j = 0; j < tree1[2].length; j++) {\n        if (tree1[2][j][0] === tree2[2][i][0]) {\n          queue.push({tree1: tree1[2][j], tree2: tree2[2][i]});\n          merged = true;\n        }\n      }\n      if (!merged) {\n        conflicts = 'new_branch';\n        insertSorted(tree1[2], tree2[2][i], compareTree);\n      }\n    }\n  }\n  return {conflicts: conflicts, tree: in_tree1};\n}\n\nfunction doMerge(tree, path, dontExpand) {\n  var restree = [];\n  var conflicts = false;\n  var merged = false;\n  var res;\n\n  if (!tree.length) {\n    return {tree: [path], conflicts: 'new_leaf'};\n  }\n\n  for (var i = 0, len = tree.length; i < len; i++) {\n    var branch = tree[i];\n    if (branch.pos === path.pos && branch.ids[0] === path.ids[0]) {\n      // Paths start at the same position and have the same root, so they need\n      // merged\n      res = mergeTree(branch.ids, path.ids);\n      restree.push({pos: branch.pos, ids: res.tree});\n      conflicts = conflicts || res.conflicts;\n      merged = true;\n    } else if (dontExpand !== true) {\n      // The paths start at a different position, take the earliest path and\n      // traverse up until it as at the same point from root as the path we\n      // want to merge.  If the keys match we return the longer path with the\n      // other merged After stemming we dont want to expand the trees\n\n      var t1 = branch.pos < path.pos ? branch : path;\n      var t2 = branch.pos < path.pos ? path : branch;\n      var diff = t2.pos - t1.pos;\n\n      var candidateParents = [];\n\n      var trees = [];\n      trees.push({ids: t1.ids, diff: diff, parent: null, parentIdx: null});\n      while (trees.length > 0) {\n        var item = trees.pop();\n        if (item.diff === 0) {\n          if (item.ids[0] === t2.ids[0]) {\n            candidateParents.push(item);\n          }\n          continue;\n        }\n        var elements = item.ids[2];\n        for (var j = 0, elementsLen = elements.length; j < elementsLen; j++) {\n          trees.push({\n            ids: elements[j],\n            diff: item.diff - 1,\n            parent: item.ids,\n            parentIdx: j\n          });\n        }\n      }\n\n      var el = candidateParents[0];\n\n      if (!el) {\n        restree.push(branch);\n      } else {\n        res = mergeTree(el.ids, t2.ids);\n        el.parent[2][el.parentIdx] = res.tree;\n        restree.push({pos: t1.pos, ids: t1.ids});\n        conflicts = conflicts || res.conflicts;\n        merged = true;\n      }\n    } else {\n      restree.push(branch);\n    }\n  }\n\n  // We didnt find\n  if (!merged) {\n    restree.push(path);\n  }\n\n  restree.sort(sortByPos$1);\n\n  return {\n    tree: restree,\n    conflicts: conflicts || 'internal_node'\n  };\n}\n\n// To ensure we dont grow the revision tree infinitely, we stem old revisions\nfunction stem(tree, depth) {\n  // First we break out the tree into a complete list of root to leaf paths\n  var paths = rootToLeaf(tree);\n  var stemmedRevs;\n\n  var result;\n  for (var i = 0, len = paths.length; i < len; i++) {\n    // Then for each path, we cut off the start of the path based on the\n    // `depth` to stem to, and generate a new set of flat trees\n    var path = paths[i];\n    var stemmed = path.ids;\n    var node;\n    if (stemmed.length > depth) {\n      // only do the stemming work if we actually need to stem\n      if (!stemmedRevs) {\n        stemmedRevs = {}; // avoid allocating this object unnecessarily\n      }\n      var numStemmed = stemmed.length - depth;\n      node = {\n        pos: path.pos + numStemmed,\n        ids: pathToTree(stemmed, numStemmed)\n      };\n\n      for (var s = 0; s < numStemmed; s++) {\n        var rev = (path.pos + s) + '-' + stemmed[s].id;\n        stemmedRevs[rev] = true;\n      }\n    } else { // no need to actually stem\n      node = {\n        pos: path.pos,\n        ids: pathToTree(stemmed, 0)\n      };\n    }\n\n    // Then we remerge all those flat trees together, ensuring that we dont\n    // connect trees that would go beyond the depth limit\n    if (result) {\n      result = doMerge(result, node, true).tree;\n    } else {\n      result = [node];\n    }\n  }\n\n  // this is memory-heavy per Chrome profiler, avoid unless we actually stemmed\n  if (stemmedRevs) {\n    traverseRevTree(result, function (isLeaf, pos, revHash) {\n      // some revisions may have been removed in a branch but not in another\n      delete stemmedRevs[pos + '-' + revHash];\n    });\n  }\n\n  return {\n    tree: result,\n    revs: stemmedRevs ? Object.keys(stemmedRevs) : []\n  };\n}\n\nfunction merge(tree, path, depth) {\n  var newTree = doMerge(tree, path);\n  var stemmed = stem(newTree.tree, depth);\n  return {\n    tree: stemmed.tree,\n    stemmedRevs: stemmed.revs,\n    conflicts: newTree.conflicts\n  };\n}\n\n// return true if a rev exists in the rev tree, false otherwise\nfunction revExists(revs, rev) {\n  var toVisit = revs.slice();\n  var splitRev = rev.split('-');\n  var targetPos = parseInt(splitRev[0], 10);\n  var targetId = splitRev[1];\n\n  var node;\n  while ((node = toVisit.pop())) {\n    if (node.pos === targetPos && node.ids[0] === targetId) {\n      return true;\n    }\n    var branches = node.ids[2];\n    for (var i = 0, len = branches.length; i < len; i++) {\n      toVisit.push({pos: node.pos + 1, ids: branches[i]});\n    }\n  }\n  return false;\n}\n\nfunction getTrees(node) {\n  return node.ids;\n}\n\n// check if a specific revision of a doc has been deleted\n//  - metadata: the metadata object from the doc store\n//  - rev: (optional) the revision to check. defaults to winning revision\nfunction isDeleted(metadata, rev) {\n  if (!rev) {\n    rev = winningRev(metadata);\n  }\n  var id = rev.substring(rev.indexOf('-') + 1);\n  var toVisit = metadata.rev_tree.map(getTrees);\n\n  var tree;\n  while ((tree = toVisit.pop())) {\n    if (tree[0] === id) {\n      return !!tree[1].deleted;\n    }\n    toVisit = toVisit.concat(tree[2]);\n  }\n}\n\nfunction isLocalId(id) {\n  return (/^_local/).test(id);\n}\n\n// returns the current leaf node for a given revision\nfunction latest(rev, metadata) {\n  var toVisit = metadata.rev_tree.slice();\n  var node;\n  while ((node = toVisit.pop())) {\n    var pos = node.pos;\n    var tree = node.ids;\n    var id = tree[0];\n    var opts = tree[1];\n    var branches = tree[2];\n    var isLeaf = branches.length === 0;\n\n    var history = node.history ? node.history.slice() : [];\n    history.push({id: id, pos: pos, opts: opts});\n\n    if (isLeaf) {\n      for (var i = 0, len = history.length; i < len; i++) {\n        var historyNode = history[i];\n        var historyRev = historyNode.pos + '-' + historyNode.id;\n\n        if (historyRev === rev) {\n          // return the rev of this leaf\n          return pos + '-' + id;\n        }\n      }\n    }\n\n    for (var j = 0, l = branches.length; j < l; j++) {\n      toVisit.push({pos: pos + 1, ids: branches[j], history: history});\n    }\n  }\n\n  /* istanbul ignore next */\n  throw new Error('Unable to resolve latest revision for id ' + metadata.id + ', rev ' + rev);\n}\n\ninherits(Changes$2, events.EventEmitter);\n\nfunction tryCatchInChangeListener(self, change, pending, lastSeq) {\n  // isolate try/catches to avoid V8 deoptimizations\n  try {\n    self.emit('change', change, pending, lastSeq);\n  } catch (e) {\n    guardedConsole('error', 'Error in .on(\"change\", function):', e);\n  }\n}\n\nfunction Changes$2(db, opts, callback) {\n  events.EventEmitter.call(this);\n  var self = this;\n  this.db = db;\n  opts = opts ? clone(opts) : {};\n  var complete = opts.complete = once(function (err, resp) {\n    if (err) {\n      if (listenerCount(self, 'error') > 0) {\n        self.emit('error', err);\n      }\n    } else {\n      self.emit('complete', resp);\n    }\n    self.removeAllListeners();\n    db.removeListener('destroyed', onDestroy);\n  });\n  if (callback) {\n    self.on('complete', function (resp) {\n      callback(null, resp);\n    });\n    self.on('error', callback);\n  }\n  function onDestroy() {\n    self.cancel();\n  }\n  db.once('destroyed', onDestroy);\n\n  opts.onChange = function (change, pending, lastSeq) {\n    /* istanbul ignore if */\n    if (self.isCancelled) {\n      return;\n    }\n    tryCatchInChangeListener(self, change, pending, lastSeq);\n  };\n\n  var promise = new PouchPromise(function (fulfill, reject) {\n    opts.complete = function (err, res) {\n      if (err) {\n        reject(err);\n      } else {\n        fulfill(res);\n      }\n    };\n  });\n  self.once('cancel', function () {\n    db.removeListener('destroyed', onDestroy);\n    opts.complete(null, {status: 'cancelled'});\n  });\n  this.then = promise.then.bind(promise);\n  this['catch'] = promise['catch'].bind(promise);\n  this.then(function (result) {\n    complete(null, result);\n  }, complete);\n\n\n\n  if (!db.taskqueue.isReady) {\n    db.taskqueue.addTask(function (failed) {\n      if (failed) {\n        opts.complete(failed);\n      } else if (self.isCancelled) {\n        self.emit('cancel');\n      } else {\n        self.validateChanges(opts);\n      }\n    });\n  } else {\n    self.validateChanges(opts);\n  }\n}\nChanges$2.prototype.cancel = function () {\n  this.isCancelled = true;\n  if (this.db.taskqueue.isReady) {\n    this.emit('cancel');\n  }\n};\nfunction processChange(doc, metadata, opts) {\n  var changeList = [{rev: doc._rev}];\n  if (opts.style === 'all_docs') {\n    changeList = collectLeaves(metadata.rev_tree)\n    .map(function (x) { return {rev: x.rev}; });\n  }\n  var change = {\n    id: metadata.id,\n    changes: changeList,\n    doc: doc\n  };\n\n  if (isDeleted(metadata, doc._rev)) {\n    change.deleted = true;\n  }\n  if (opts.conflicts) {\n    change.doc._conflicts = collectConflicts(metadata);\n    if (!change.doc._conflicts.length) {\n      delete change.doc._conflicts;\n    }\n  }\n  return change;\n}\n\nChanges$2.prototype.validateChanges = function (opts) {\n  var callback = opts.complete;\n  var self = this;\n\n  /* istanbul ignore else */\n  if (PouchDB._changesFilterPlugin) {\n    PouchDB._changesFilterPlugin.validate(opts, function (err) {\n      if (err) {\n        return callback(err);\n      }\n      self.doChanges(opts);\n    });\n  } else {\n    self.doChanges(opts);\n  }\n};\n\nChanges$2.prototype.doChanges = function (opts) {\n  var self = this;\n  var callback = opts.complete;\n\n  opts = clone(opts);\n  if ('live' in opts && !('continuous' in opts)) {\n    opts.continuous = opts.live;\n  }\n  opts.processChange = processChange;\n\n  if (opts.since === 'latest') {\n    opts.since = 'now';\n  }\n  if (!opts.since) {\n    opts.since = 0;\n  }\n  if (opts.since === 'now') {\n    this.db.info().then(function (info) {\n      /* istanbul ignore if */\n      if (self.isCancelled) {\n        callback(null, {status: 'cancelled'});\n        return;\n      }\n      opts.since = info.update_seq;\n      self.doChanges(opts);\n    }, callback);\n    return;\n  }\n\n  /* istanbul ignore else */\n  if (PouchDB._changesFilterPlugin) {\n    PouchDB._changesFilterPlugin.normalize(opts);\n    if (PouchDB._changesFilterPlugin.shouldFilter(this, opts)) {\n      return PouchDB._changesFilterPlugin.filter(this, opts);\n    }\n  } else {\n    ['doc_ids', 'filter', 'selector', 'view'].forEach(function (key) {\n      if (key in opts) {\n        guardedConsole('warn',\n          'The \"' + key + '\" option was passed in to changes/replicate, ' +\n          'but pouchdb-changes-filter plugin is not installed, so it ' +\n          'was ignored. Please install the plugin to enable filtering.'\n        );\n      }\n    });\n  }\n\n  if (!('descending' in opts)) {\n    opts.descending = false;\n  }\n\n  // 0 and 1 should return 1 document\n  opts.limit = opts.limit === 0 ? 1 : opts.limit;\n  opts.complete = callback;\n  var newPromise = this.db._changes(opts);\n  /* istanbul ignore else */\n  if (newPromise && typeof newPromise.cancel === 'function') {\n    var cancel = self.cancel;\n    self.cancel = getArguments(function (args) {\n      newPromise.cancel();\n      cancel.apply(this, args);\n    });\n  }\n};\n\n/*\n * A generic pouch adapter\n */\n\nfunction compare(left, right) {\n  return left < right ? -1 : left > right ? 1 : 0;\n}\n\n// Wrapper for functions that call the bulkdocs api with a single doc,\n// if the first result is an error, return an error\nfunction yankError(callback, docId) {\n  return function (err, results) {\n    if (err || (results[0] && results[0].error)) {\n      err = err || results[0];\n      err.docId = docId;\n      callback(err);\n    } else {\n      callback(null, results.length ? results[0]  : results);\n    }\n  };\n}\n\n// clean docs given to us by the user\nfunction cleanDocs(docs) {\n  for (var i = 0; i < docs.length; i++) {\n    var doc = docs[i];\n    if (doc._deleted) {\n      delete doc._attachments; // ignore atts for deleted docs\n    } else if (doc._attachments) {\n      // filter out extraneous keys from _attachments\n      var atts = Object.keys(doc._attachments);\n      for (var j = 0; j < atts.length; j++) {\n        var att = atts[j];\n        doc._attachments[att] = pick(doc._attachments[att],\n          ['data', 'digest', 'content_type', 'length', 'revpos', 'stub']);\n      }\n    }\n  }\n}\n\n// compare two docs, first by _id then by _rev\nfunction compareByIdThenRev(a, b) {\n  var idCompare = compare(a._id, b._id);\n  if (idCompare !== 0) {\n    return idCompare;\n  }\n  var aStart = a._revisions ? a._revisions.start : 0;\n  var bStart = b._revisions ? b._revisions.start : 0;\n  return compare(aStart, bStart);\n}\n\n// for every node in a revision tree computes its distance from the closest\n// leaf\nfunction computeHeight(revs) {\n  var height = {};\n  var edges = [];\n  traverseRevTree(revs, function (isLeaf, pos, id, prnt) {\n    var rev$$1 = pos + \"-\" + id;\n    if (isLeaf) {\n      height[rev$$1] = 0;\n    }\n    if (prnt !== undefined) {\n      edges.push({from: prnt, to: rev$$1});\n    }\n    return rev$$1;\n  });\n\n  edges.reverse();\n  edges.forEach(function (edge) {\n    if (height[edge.from] === undefined) {\n      height[edge.from] = 1 + height[edge.to];\n    } else {\n      height[edge.from] = Math.min(height[edge.from], 1 + height[edge.to]);\n    }\n  });\n  return height;\n}\n\nfunction allDocsKeysParse(opts) {\n  var keys =  ('limit' in opts) ?\n    opts.keys.slice(opts.skip, opts.limit + opts.skip) :\n    (opts.skip > 0) ? opts.keys.slice(opts.skip) : opts.keys;\n  opts.keys = keys;\n  opts.skip = 0;\n  delete opts.limit;\n  if (opts.descending) {\n    keys.reverse();\n    opts.descending = false;\n  }\n}\n\n// all compaction is done in a queue, to avoid attaching\n// too many listeners at once\nfunction doNextCompaction(self) {\n  var task = self._compactionQueue[0];\n  var opts = task.opts;\n  var callback = task.callback;\n  self.get('_local/compaction')[\"catch\"](function () {\n    return false;\n  }).then(function (doc) {\n    if (doc && doc.last_seq) {\n      opts.last_seq = doc.last_seq;\n    }\n    self._compact(opts, function (err, res) {\n      /* istanbul ignore if */\n      if (err) {\n        callback(err);\n      } else {\n        callback(null, res);\n      }\n      nextTick(function () {\n        self._compactionQueue.shift();\n        if (self._compactionQueue.length) {\n          doNextCompaction(self);\n        }\n      });\n    });\n  });\n}\n\nfunction attachmentNameError(name) {\n  if (name.charAt(0) === '_') {\n    return name + ' is not a valid attachment name, attachment ' +\n      'names cannot start with \\'_\\'';\n  }\n  return false;\n}\n\ninherits(AbstractPouchDB, events.EventEmitter);\n\nfunction AbstractPouchDB() {\n  events.EventEmitter.call(this);\n}\n\nAbstractPouchDB.prototype.post =\n  adapterFun('post', function (doc, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  if (typeof doc !== 'object' || Array.isArray(doc)) {\n    return callback(createError(NOT_AN_OBJECT));\n  }\n  this.bulkDocs({docs: [doc]}, opts, yankError(callback, doc._id));\n});\n\nAbstractPouchDB.prototype.put = adapterFun('put', function (doc, opts, cb) {\n  if (typeof opts === 'function') {\n    cb = opts;\n    opts = {};\n  }\n  if (typeof doc !== 'object' || Array.isArray(doc)) {\n    return cb(createError(NOT_AN_OBJECT));\n  }\n  invalidIdError(doc._id);\n  if (isLocalId(doc._id) && typeof this._putLocal === 'function') {\n    if (doc._deleted) {\n      return this._removeLocal(doc, cb);\n    } else {\n      return this._putLocal(doc, cb);\n    }\n  }\n  var self = this;\n  if (opts.force && doc._rev) {\n    transformForceOptionToNewEditsOption();\n    putDoc(function (err) {\n      var result = err ? null : {ok: true, id: doc._id, rev: doc._rev};\n      cb(err, result);\n    });\n  } else {\n    putDoc(cb);\n  }\n\n  function transformForceOptionToNewEditsOption() {\n    var parts = doc._rev.split('-');\n    var oldRevId = parts[1];\n    var oldRevNum = parseInt(parts[0], 10);\n\n    var newRevNum = oldRevNum + 1;\n    var newRevId = rev();\n\n    doc._revisions = {\n      start: newRevNum,\n      ids: [newRevId, oldRevId]\n    };\n    doc._rev = newRevNum + '-' + newRevId;\n    opts.new_edits = false;\n  }\n  function putDoc(next) {\n    if (typeof self._put === 'function' && opts.new_edits !== false) {\n      self._put(doc, opts, next);\n    } else {\n      self.bulkDocs({docs: [doc]}, opts, yankError(next, doc._id));\n    }\n  }\n});\n\nAbstractPouchDB.prototype.putAttachment =\n  adapterFun('putAttachment', function (docId, attachmentId, rev$$1,\n                                              blob, type) {\n  var api = this;\n  if (typeof type === 'function') {\n    type = blob;\n    blob = rev$$1;\n    rev$$1 = null;\n  }\n  // Lets fix in https://github.com/pouchdb/pouchdb/issues/3267\n  /* istanbul ignore if */\n  if (typeof type === 'undefined') {\n    type = blob;\n    blob = rev$$1;\n    rev$$1 = null;\n  }\n  if (!type) {\n    guardedConsole('warn', 'Attachment', attachmentId, 'on document', docId, 'is missing content_type');\n  }\n\n  function createAttachment(doc) {\n    var prevrevpos = '_rev' in doc ? parseInt(doc._rev, 10) : 0;\n    doc._attachments = doc._attachments || {};\n    doc._attachments[attachmentId] = {\n      content_type: type,\n      data: blob,\n      revpos: ++prevrevpos\n    };\n    return api.put(doc);\n  }\n\n  return api.get(docId).then(function (doc) {\n    if (doc._rev !== rev$$1) {\n      throw createError(REV_CONFLICT);\n    }\n\n    return createAttachment(doc);\n  }, function (err) {\n     // create new doc\n    /* istanbul ignore else */\n    if (err.reason === MISSING_DOC.message) {\n      return createAttachment({_id: docId});\n    } else {\n      throw err;\n    }\n  });\n});\n\nAbstractPouchDB.prototype.removeAttachment =\n  adapterFun('removeAttachment', function (docId, attachmentId, rev$$1,\n                                                 callback) {\n  var self = this;\n  self.get(docId, function (err, obj) {\n    /* istanbul ignore if */\n    if (err) {\n      callback(err);\n      return;\n    }\n    if (obj._rev !== rev$$1) {\n      callback(createError(REV_CONFLICT));\n      return;\n    }\n    /* istanbul ignore if */\n    if (!obj._attachments) {\n      return callback();\n    }\n    delete obj._attachments[attachmentId];\n    if (Object.keys(obj._attachments).length === 0) {\n      delete obj._attachments;\n    }\n    self.put(obj, callback);\n  });\n});\n\nAbstractPouchDB.prototype.remove =\n  adapterFun('remove', function (docOrId, optsOrRev, opts, callback) {\n  var doc;\n  if (typeof optsOrRev === 'string') {\n    // id, rev, opts, callback style\n    doc = {\n      _id: docOrId,\n      _rev: optsOrRev\n    };\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n  } else {\n    // doc, opts, callback style\n    doc = docOrId;\n    if (typeof optsOrRev === 'function') {\n      callback = optsOrRev;\n      opts = {};\n    } else {\n      callback = opts;\n      opts = optsOrRev;\n    }\n  }\n  opts = opts || {};\n  opts.was_delete = true;\n  var newDoc = {_id: doc._id, _rev: (doc._rev || opts.rev)};\n  newDoc._deleted = true;\n  if (isLocalId(newDoc._id) && typeof this._removeLocal === 'function') {\n    return this._removeLocal(doc, callback);\n  }\n  this.bulkDocs({docs: [newDoc]}, opts, yankError(callback, newDoc._id));\n});\n\nAbstractPouchDB.prototype.revsDiff =\n  adapterFun('revsDiff', function (req, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  var ids = Object.keys(req);\n\n  if (!ids.length) {\n    return callback(null, {});\n  }\n\n  var count = 0;\n  var missing = new ExportedMap();\n\n  function addToMissing(id, revId) {\n    if (!missing.has(id)) {\n      missing.set(id, {missing: []});\n    }\n    missing.get(id).missing.push(revId);\n  }\n\n  function processDoc(id, rev_tree) {\n    // Is this fast enough? Maybe we should switch to a set simulated by a map\n    var missingForId = req[id].slice(0);\n    traverseRevTree(rev_tree, function (isLeaf, pos, revHash, ctx,\n      opts) {\n        var rev$$1 = pos + '-' + revHash;\n        var idx = missingForId.indexOf(rev$$1);\n        if (idx === -1) {\n          return;\n        }\n\n        missingForId.splice(idx, 1);\n        /* istanbul ignore if */\n        if (opts.status !== 'available') {\n          addToMissing(id, rev$$1);\n        }\n      });\n\n    // Traversing the tree is synchronous, so now `missingForId` contains\n    // revisions that were not found in the tree\n    missingForId.forEach(function (rev$$1) {\n      addToMissing(id, rev$$1);\n    });\n  }\n\n  ids.map(function (id) {\n    this._getRevisionTree(id, function (err, rev_tree) {\n      if (err && err.status === 404 && err.message === 'missing') {\n        missing.set(id, {missing: req[id]});\n      } else if (err) {\n        /* istanbul ignore next */\n        return callback(err);\n      } else {\n        processDoc(id, rev_tree);\n      }\n\n      if (++count === ids.length) {\n        // convert LazyMap to object\n        var missingObj = {};\n        missing.forEach(function (value, key) {\n          missingObj[key] = value;\n        });\n        return callback(null, missingObj);\n      }\n    });\n  }, this);\n});\n\n// _bulk_get API for faster replication, as described in\n// https://github.com/apache/couchdb-chttpd/pull/33\n// At the \"abstract\" level, it will just run multiple get()s in\n// parallel, because this isn't much of a performance cost\n// for local databases (except the cost of multiple transactions, which is\n// small). The http adapter overrides this in order\n// to do a more efficient single HTTP request.\nAbstractPouchDB.prototype.bulkGet =\n  adapterFun('bulkGet', function (opts, callback) {\n  bulkGet(this, opts, callback);\n});\n\n// compact one document and fire callback\n// by compacting we mean removing all revisions which\n// are further from the leaf in revision tree than max_height\nAbstractPouchDB.prototype.compactDocument =\n  adapterFun('compactDocument', function (docId, maxHeight, callback) {\n  var self = this;\n  this._getRevisionTree(docId, function (err, revTree) {\n    /* istanbul ignore if */\n    if (err) {\n      return callback(err);\n    }\n    var height = computeHeight(revTree);\n    var candidates = [];\n    var revs = [];\n    Object.keys(height).forEach(function (rev$$1) {\n      if (height[rev$$1] > maxHeight) {\n        candidates.push(rev$$1);\n      }\n    });\n\n    traverseRevTree(revTree, function (isLeaf, pos, revHash, ctx, opts) {\n      var rev$$1 = pos + '-' + revHash;\n      if (opts.status === 'available' && candidates.indexOf(rev$$1) !== -1) {\n        revs.push(rev$$1);\n      }\n    });\n    self._doCompaction(docId, revs, callback);\n  });\n});\n\n// compact the whole database using single document\n// compaction\nAbstractPouchDB.prototype.compact =\n  adapterFun('compact', function (opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n\n  var self = this;\n  opts = opts || {};\n\n  self._compactionQueue = self._compactionQueue || [];\n  self._compactionQueue.push({opts: opts, callback: callback});\n  if (self._compactionQueue.length === 1) {\n    doNextCompaction(self);\n  }\n});\nAbstractPouchDB.prototype._compact = function (opts, callback) {\n  var self = this;\n  var changesOpts = {\n    return_docs: false,\n    last_seq: opts.last_seq || 0\n  };\n  var promises = [];\n\n  function onChange(row) {\n    promises.push(self.compactDocument(row.id, 0));\n  }\n  function onComplete(resp) {\n    var lastSeq = resp.last_seq;\n    PouchPromise.all(promises).then(function () {\n      return upsert(self, '_local/compaction', function deltaFunc(doc) {\n        if (!doc.last_seq || doc.last_seq < lastSeq) {\n          doc.last_seq = lastSeq;\n          return doc;\n        }\n        return false; // somebody else got here first, don't update\n      });\n    }).then(function () {\n      callback(null, {ok: true});\n    })[\"catch\"](callback);\n  }\n  self.changes(changesOpts)\n    .on('change', onChange)\n    .on('complete', onComplete)\n    .on('error', callback);\n};\n\n/* Begin api wrappers. Specific functionality to storage belongs in the\n   _[method] */\nAbstractPouchDB.prototype.get = adapterFun('get', function (id, opts, cb) {\n  if (typeof opts === 'function') {\n    cb = opts;\n    opts = {};\n  }\n  if (typeof id !== 'string') {\n    return cb(createError(INVALID_ID));\n  }\n  if (isLocalId(id) && typeof this._getLocal === 'function') {\n    return this._getLocal(id, cb);\n  }\n  var leaves = [], self = this;\n\n  function finishOpenRevs() {\n    var result = [];\n    var count = leaves.length;\n    /* istanbul ignore if */\n    if (!count) {\n      return cb(null, result);\n    }\n\n    // order with open_revs is unspecified\n    leaves.forEach(function (leaf) {\n      self.get(id, {\n        rev: leaf,\n        revs: opts.revs,\n        latest: opts.latest,\n        attachments: opts.attachments,\n        binary: opts.binary\n      }, function (err, doc) {\n        if (!err) {\n          // using latest=true can produce duplicates\n          var existing;\n          for (var i = 0, l = result.length; i < l; i++) {\n            if (result[i].ok && result[i].ok._rev === doc._rev) {\n              existing = true;\n              break;\n            }\n          }\n          if (!existing) {\n            result.push({ok: doc});\n          }\n        } else {\n          result.push({missing: leaf});\n        }\n        count--;\n        if (!count) {\n          cb(null, result);\n        }\n      });\n    });\n  }\n\n  if (opts.open_revs) {\n    if (opts.open_revs === \"all\") {\n      this._getRevisionTree(id, function (err, rev_tree) {\n        if (err) {\n          return cb(err);\n        }\n        leaves = collectLeaves(rev_tree).map(function (leaf) {\n          return leaf.rev;\n        });\n        finishOpenRevs();\n      });\n    } else {\n      if (Array.isArray(opts.open_revs)) {\n        leaves = opts.open_revs;\n        for (var i = 0; i < leaves.length; i++) {\n          var l = leaves[i];\n          // looks like it's the only thing couchdb checks\n          if (!(typeof (l) === \"string\" && /^\\d+-/.test(l))) {\n            return cb(createError(INVALID_REV));\n          }\n        }\n        finishOpenRevs();\n      } else {\n        return cb(createError(UNKNOWN_ERROR, 'function_clause'));\n      }\n    }\n    return; // open_revs does not like other options\n  }\n\n  return this._get(id, opts, function (err, result) {\n    if (err) {\n      err.docId = id;\n      return cb(err);\n    }\n\n    var doc = result.doc;\n    var metadata = result.metadata;\n    var ctx = result.ctx;\n\n    if (opts.conflicts) {\n      var conflicts = collectConflicts(metadata);\n      if (conflicts.length) {\n        doc._conflicts = conflicts;\n      }\n    }\n\n    if (isDeleted(metadata, doc._rev)) {\n      doc._deleted = true;\n    }\n\n    if (opts.revs || opts.revs_info) {\n      var splittedRev = doc._rev.split('-');\n      var revNo       = parseInt(splittedRev[0], 10);\n      var revHash     = splittedRev[1];\n\n      var paths = rootToLeaf(metadata.rev_tree);\n      var path = null;\n\n      for (var i = 0; i < paths.length; i++) {\n        var currentPath = paths[i];\n        var hashIndex = currentPath.ids.map(function (x) { return x.id; })\n          .indexOf(revHash);\n        var hashFoundAtRevPos = hashIndex === (revNo - 1);\n\n        if (hashFoundAtRevPos || (!path && hashIndex !== -1)) {\n          path = currentPath;\n        }\n      }\n\n      var indexOfRev = path.ids.map(function (x) { return x.id; })\n        .indexOf(doc._rev.split('-')[1]) + 1;\n      var howMany = path.ids.length - indexOfRev;\n      path.ids.splice(indexOfRev, howMany);\n      path.ids.reverse();\n\n      if (opts.revs) {\n        doc._revisions = {\n          start: (path.pos + path.ids.length) - 1,\n          ids: path.ids.map(function (rev$$1) {\n            return rev$$1.id;\n          })\n        };\n      }\n      if (opts.revs_info) {\n        var pos =  path.pos + path.ids.length;\n        doc._revs_info = path.ids.map(function (rev$$1) {\n          pos--;\n          return {\n            rev: pos + '-' + rev$$1.id,\n            status: rev$$1.opts.status\n          };\n        });\n      }\n    }\n\n    if (opts.attachments && doc._attachments) {\n      var attachments = doc._attachments;\n      var count = Object.keys(attachments).length;\n      if (count === 0) {\n        return cb(null, doc);\n      }\n      Object.keys(attachments).forEach(function (key) {\n        this._getAttachment(doc._id, key, attachments[key], {\n          // Previously the revision handling was done in adapter.js\n          // getAttachment, however since idb-next doesnt we need to\n          // pass the rev through\n          rev: doc._rev,\n          binary: opts.binary,\n          ctx: ctx\n        }, function (err, data) {\n          var att = doc._attachments[key];\n          att.data = data;\n          delete att.stub;\n          delete att.length;\n          if (!--count) {\n            cb(null, doc);\n          }\n        });\n      }, self);\n    } else {\n      if (doc._attachments) {\n        for (var key in doc._attachments) {\n          /* istanbul ignore else */\n          if (doc._attachments.hasOwnProperty(key)) {\n            doc._attachments[key].stub = true;\n          }\n        }\n      }\n      cb(null, doc);\n    }\n  });\n});\n\n// TODO: I dont like this, it forces an extra read for every\n// attachment read and enforces a confusing api between\n// adapter.js and the adapter implementation\nAbstractPouchDB.prototype.getAttachment =\n  adapterFun('getAttachment', function (docId, attachmentId, opts, callback) {\n  var self = this;\n  if (opts instanceof Function) {\n    callback = opts;\n    opts = {};\n  }\n  this._get(docId, opts, function (err, res) {\n    if (err) {\n      return callback(err);\n    }\n    if (res.doc._attachments && res.doc._attachments[attachmentId]) {\n      opts.ctx = res.ctx;\n      opts.binary = true;\n      self._getAttachment(docId, attachmentId,\n                          res.doc._attachments[attachmentId], opts, callback);\n    } else {\n      return callback(createError(MISSING_DOC));\n    }\n  });\n});\n\nAbstractPouchDB.prototype.allDocs =\n  adapterFun('allDocs', function (opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  opts.skip = typeof opts.skip !== 'undefined' ? opts.skip : 0;\n  if (opts.start_key) {\n    opts.startkey = opts.start_key;\n  }\n  if (opts.end_key) {\n    opts.endkey = opts.end_key;\n  }\n  if ('keys' in opts) {\n    if (!Array.isArray(opts.keys)) {\n      return callback(new TypeError('options.keys must be an array'));\n    }\n    var incompatibleOpt =\n      ['startkey', 'endkey', 'key'].filter(function (incompatibleOpt) {\n      return incompatibleOpt in opts;\n    })[0];\n    if (incompatibleOpt) {\n      callback(createError(QUERY_PARSE_ERROR,\n        'Query parameter `' + incompatibleOpt +\n        '` is not compatible with multi-get'\n      ));\n      return;\n    }\n    if (!isRemote(this)) {\n      allDocsKeysParse(opts);\n      if (opts.keys.length === 0) {\n        return this._allDocs({limit: 0}, callback);\n      }\n    }\n  }\n\n  return this._allDocs(opts, callback);\n});\n\nAbstractPouchDB.prototype.changes = function (opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  return new Changes$2(this, opts, callback);\n};\n\nAbstractPouchDB.prototype.close = adapterFun('close', function (callback) {\n  this._closed = true;\n  this.emit('closed');\n  return this._close(callback);\n});\n\nAbstractPouchDB.prototype.info = adapterFun('info', function (callback) {\n  var self = this;\n  this._info(function (err, info) {\n    if (err) {\n      return callback(err);\n    }\n    // assume we know better than the adapter, unless it informs us\n    info.db_name = info.db_name || self.name;\n    info.auto_compaction = !!(self.auto_compaction && !isRemote(self));\n    info.adapter = self.adapter;\n    callback(null, info);\n  });\n});\n\nAbstractPouchDB.prototype.id = adapterFun('id', function (callback) {\n  return this._id(callback);\n});\n\n/* istanbul ignore next */\nAbstractPouchDB.prototype.type = function () {\n  return (typeof this._type === 'function') ? this._type() : this.adapter;\n};\n\nAbstractPouchDB.prototype.bulkDocs =\n  adapterFun('bulkDocs', function (req, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n\n  opts = opts || {};\n\n  if (Array.isArray(req)) {\n    req = {\n      docs: req\n    };\n  }\n\n  if (!req || !req.docs || !Array.isArray(req.docs)) {\n    return callback(createError(MISSING_BULK_DOCS));\n  }\n\n  for (var i = 0; i < req.docs.length; ++i) {\n    if (typeof req.docs[i] !== 'object' || Array.isArray(req.docs[i])) {\n      return callback(createError(NOT_AN_OBJECT));\n    }\n  }\n\n  var attachmentError;\n  req.docs.forEach(function (doc) {\n    if (doc._attachments) {\n      Object.keys(doc._attachments).forEach(function (name) {\n        attachmentError = attachmentError || attachmentNameError(name);\n        if (!doc._attachments[name].content_type) {\n          guardedConsole('warn', 'Attachment', name, 'on document', doc._id, 'is missing content_type');\n        }\n      });\n    }\n  });\n\n  if (attachmentError) {\n    return callback(createError(BAD_REQUEST, attachmentError));\n  }\n\n  if (!('new_edits' in opts)) {\n    if ('new_edits' in req) {\n      opts.new_edits = req.new_edits;\n    } else {\n      opts.new_edits = true;\n    }\n  }\n\n  var adapter = this;\n  if (!opts.new_edits && !isRemote(adapter)) {\n    // ensure revisions of the same doc are sorted, so that\n    // the local adapter processes them correctly (#2935)\n    req.docs.sort(compareByIdThenRev);\n  }\n\n  cleanDocs(req.docs);\n\n  // in the case of conflicts, we want to return the _ids to the user\n  // however, the underlying adapter may destroy the docs array, so\n  // create a copy here\n  var ids = req.docs.map(function (doc) {\n    return doc._id;\n  });\n\n  return this._bulkDocs(req, opts, function (err, res) {\n    if (err) {\n      return callback(err);\n    }\n    if (!opts.new_edits) {\n      // this is what couch does when new_edits is false\n      res = res.filter(function (x) {\n        return x.error;\n      });\n    }\n    // add ids for error/conflict responses (not required for CouchDB)\n    if (!isRemote(adapter)) {\n      for (var i = 0, l = res.length; i < l; i++) {\n        res[i].id = res[i].id || ids[i];\n      }\n    }\n\n    callback(null, res);\n  });\n});\n\nAbstractPouchDB.prototype.registerDependentDatabase =\n  adapterFun('registerDependentDatabase', function (dependentDb,\n                                                          callback) {\n  var depDB = new this.constructor(dependentDb, this.__opts);\n\n  function diffFun(doc) {\n    doc.dependentDbs = doc.dependentDbs || {};\n    if (doc.dependentDbs[dependentDb]) {\n      return false; // no update required\n    }\n    doc.dependentDbs[dependentDb] = true;\n    return doc;\n  }\n  upsert(this, '_local/_pouch_dependentDbs', diffFun)\n    .then(function () {\n      callback(null, {db: depDB});\n    })[\"catch\"](callback);\n});\n\nAbstractPouchDB.prototype.destroy =\n  adapterFun('destroy', function (opts, callback) {\n\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n\n  var self = this;\n  var usePrefix = 'use_prefix' in self ? self.use_prefix : true;\n\n  function destroyDb() {\n    // call destroy method of the particular adaptor\n    self._destroy(opts, function (err, resp) {\n      if (err) {\n        return callback(err);\n      }\n      self._destroyed = true;\n      self.emit('destroyed');\n      callback(null, resp || { 'ok': true });\n    });\n  }\n\n  if (isRemote(self)) {\n    // no need to check for dependent DBs if it's a remote DB\n    return destroyDb();\n  }\n\n  self.get('_local/_pouch_dependentDbs', function (err, localDoc) {\n    if (err) {\n      /* istanbul ignore if */\n      if (err.status !== 404) {\n        return callback(err);\n      } else { // no dependencies\n        return destroyDb();\n      }\n    }\n    var dependentDbs = localDoc.dependentDbs;\n    var PouchDB = self.constructor;\n    var deletedMap = Object.keys(dependentDbs).map(function (name) {\n      // use_prefix is only false in the browser\n      /* istanbul ignore next */\n      var trueName = usePrefix ?\n        name.replace(new RegExp('^' + PouchDB.prefix), '') : name;\n      return new PouchDB(trueName, self.__opts).destroy();\n    });\n    PouchPromise.all(deletedMap).then(destroyDb, callback);\n  });\n});\n\nfunction TaskQueue$1() {\n  this.isReady = false;\n  this.failed = false;\n  this.queue = [];\n}\n\nTaskQueue$1.prototype.execute = function () {\n  var fun;\n  if (this.failed) {\n    while ((fun = this.queue.shift())) {\n      fun(this.failed);\n    }\n  } else {\n    while ((fun = this.queue.shift())) {\n      fun();\n    }\n  }\n};\n\nTaskQueue$1.prototype.fail = function (err) {\n  this.failed = err;\n  this.execute();\n};\n\nTaskQueue$1.prototype.ready = function (db) {\n  this.isReady = true;\n  this.db = db;\n  this.execute();\n};\n\nTaskQueue$1.prototype.addTask = function (fun) {\n  this.queue.push(fun);\n  if (this.failed) {\n    this.execute();\n  }\n};\n\nfunction parseAdapter(name, opts) {\n  var match = name.match(/([a-z-]*):\\/\\/(.*)/);\n  if (match) {\n    // the http adapter expects the fully qualified name\n    return {\n      name: /https?/.test(match[1]) ? match[1] + '://' + match[2] : match[2],\n      adapter: match[1]\n    };\n  }\n\n  var adapters = PouchDB.adapters;\n  var preferredAdapters = PouchDB.preferredAdapters;\n  var prefix = PouchDB.prefix;\n  var adapterName = opts.adapter;\n\n  if (!adapterName) { // automatically determine adapter\n    for (var i = 0; i < preferredAdapters.length; ++i) {\n      adapterName = preferredAdapters[i];\n      // check for browsers that have been upgraded from websql-only to websql+idb\n      /* istanbul ignore if */\n      if (adapterName === 'idb' && 'websql' in adapters &&\n          hasLocalStorage() && localStorage['_pouch__websqldb_' + prefix + name]) {\n        // log it, because this can be confusing during development\n        guardedConsole('log', 'PouchDB is downgrading \"' + name + '\" to WebSQL to' +\n          ' avoid data loss, because it was already opened with WebSQL.');\n        continue; // keep using websql to avoid user data loss\n      }\n      break;\n    }\n  }\n\n  var adapter = adapters[adapterName];\n\n  // if adapter is invalid, then an error will be thrown later\n  var usePrefix = (adapter && 'use_prefix' in adapter) ?\n    adapter.use_prefix : true;\n\n  return {\n    name: usePrefix ? (prefix + name) : name,\n    adapter: adapterName\n  };\n}\n\n// OK, so here's the deal. Consider this code:\n//     var db1 = new PouchDB('foo');\n//     var db2 = new PouchDB('foo');\n//     db1.destroy();\n// ^ these two both need to emit 'destroyed' events,\n// as well as the PouchDB constructor itself.\n// So we have one db object (whichever one got destroy() called on it)\n// responsible for emitting the initial event, which then gets emitted\n// by the constructor, which then broadcasts it to any other dbs\n// that may have been created with the same name.\nfunction prepareForDestruction(self) {\n\n  function onDestroyed(from_constructor) {\n    self.removeListener('closed', onClosed);\n    if (!from_constructor) {\n      self.constructor.emit('destroyed', self.name);\n    }\n  }\n\n  function onClosed() {\n    self.removeListener('destroyed', onDestroyed);\n    self.constructor.emit('unref', self);\n  }\n\n  self.once('destroyed', onDestroyed);\n  self.once('closed', onClosed);\n  self.constructor.emit('ref', self);\n}\n\ninherits(PouchDB, AbstractPouchDB);\nfunction PouchDB(name, opts) {\n  // In Node our test suite only tests this for PouchAlt unfortunately\n  /* istanbul ignore if */\n  if (!(this instanceof PouchDB)) {\n    return new PouchDB(name, opts);\n  }\n\n  var self = this;\n  opts = opts || {};\n\n  if (name && typeof name === 'object') {\n    opts = name;\n    name = opts.name;\n    delete opts.name;\n  }\n\n  this.__opts = opts = clone(opts);\n\n  self.auto_compaction = opts.auto_compaction;\n  self.prefix = PouchDB.prefix;\n\n  if (typeof name !== 'string') {\n    throw new Error('Missing/invalid DB name');\n  }\n\n  var prefixedName = (opts.prefix || '') + name;\n  var backend = parseAdapter(prefixedName, opts);\n\n  opts.name = backend.name;\n  opts.adapter = opts.adapter || backend.adapter;\n\n  self.name = name;\n  self._adapter = opts.adapter;\n  PouchDB.emit('debug', ['adapter', 'Picked adapter: ', opts.adapter]);\n\n  if (!PouchDB.adapters[opts.adapter] ||\n      !PouchDB.adapters[opts.adapter].valid()) {\n    throw new Error('Invalid Adapter: ' + opts.adapter);\n  }\n\n  AbstractPouchDB.call(self);\n  self.taskqueue = new TaskQueue$1();\n\n  self.adapter = opts.adapter;\n\n  PouchDB.adapters[opts.adapter].call(self, opts, function (err) {\n    if (err) {\n      return self.taskqueue.fail(err);\n    }\n    prepareForDestruction(self);\n\n    self.emit('created', self);\n    PouchDB.emit('created', self.name);\n    self.taskqueue.ready(self);\n  });\n\n}\n\nPouchDB.adapters = {};\nPouchDB.preferredAdapters = [];\n\nPouchDB.prefix = '_pouch_';\n\nvar eventEmitter = new events.EventEmitter();\n\nfunction setUpEventEmitter(Pouch) {\n  Object.keys(events.EventEmitter.prototype).forEach(function (key) {\n    if (typeof events.EventEmitter.prototype[key] === 'function') {\n      Pouch[key] = eventEmitter[key].bind(eventEmitter);\n    }\n  });\n\n  // these are created in constructor.js, and allow us to notify each DB with\n  // the same name that it was destroyed, via the constructor object\n  var destructListeners = Pouch._destructionListeners = new ExportedMap();\n\n  Pouch.on('ref', function onConstructorRef(db) {\n    if (!destructListeners.has(db.name)) {\n      destructListeners.set(db.name, []);\n    }\n    destructListeners.get(db.name).push(db);\n  });\n\n  Pouch.on('unref', function onConstructorUnref(db) {\n    if (!destructListeners.has(db.name)) {\n      return;\n    }\n    var dbList = destructListeners.get(db.name);\n    var pos = dbList.indexOf(db);\n    if (pos < 0) {\n      /* istanbul ignore next */\n      return;\n    }\n    dbList.splice(pos, 1);\n    if (dbList.length > 1) {\n      /* istanbul ignore next */\n      destructListeners.set(db.name, dbList);\n    } else {\n      destructListeners[\"delete\"](db.name);\n    }\n  });\n\n  Pouch.on('destroyed', function onConstructorDestroyed(name) {\n    if (!destructListeners.has(name)) {\n      return;\n    }\n    var dbList = destructListeners.get(name);\n    destructListeners[\"delete\"](name);\n    dbList.forEach(function (db) {\n      db.emit('destroyed',true);\n    });\n  });\n}\n\nsetUpEventEmitter(PouchDB);\n\nPouchDB.adapter = function (id, obj, addToPreferredAdapters) {\n  /* istanbul ignore else */\n  if (obj.valid()) {\n    PouchDB.adapters[id] = obj;\n    if (addToPreferredAdapters) {\n      PouchDB.preferredAdapters.push(id);\n    }\n  }\n};\n\nPouchDB.plugin = function (obj) {\n  if (typeof obj === 'function') { // function style for plugins\n    obj(PouchDB);\n  } else if (typeof obj !== 'object' || Object.keys(obj).length === 0) {\n    throw new Error('Invalid plugin: got \"' + obj + '\", expected an object or a function');\n  } else {\n    Object.keys(obj).forEach(function (id) { // object style for plugins\n      PouchDB.prototype[id] = obj[id];\n    });\n  }\n  if (this.__defaults) {\n    PouchDB.__defaults = $inject_Object_assign({}, this.__defaults);\n  }\n  return PouchDB;\n};\n\nPouchDB.defaults = function (defaultOpts) {\n  function PouchAlt(name, opts) {\n    if (!(this instanceof PouchAlt)) {\n      return new PouchAlt(name, opts);\n    }\n\n    opts = opts || {};\n\n    if (name && typeof name === 'object') {\n      opts = name;\n      name = opts.name;\n      delete opts.name;\n    }\n\n    opts = $inject_Object_assign({}, PouchAlt.__defaults, opts);\n    PouchDB.call(this, name, opts);\n  }\n\n  inherits(PouchAlt, PouchDB);\n\n  PouchAlt.preferredAdapters = PouchDB.preferredAdapters.slice();\n  Object.keys(PouchDB).forEach(function (key) {\n    if (!(key in PouchAlt)) {\n      PouchAlt[key] = PouchDB[key];\n    }\n  });\n\n  // make default options transitive\n  // https://github.com/pouchdb/pouchdb/issues/5922\n  PouchAlt.__defaults = $inject_Object_assign({}, this.__defaults, defaultOpts);\n\n  return PouchAlt;\n};\n\n// managed automatically by set-version.js\nvar version = \"6.4.3\";\n\nfunction debugPouch(PouchDB) {\n  PouchDB.debug = debug;\n  var logs = {};\n  /* istanbul ignore next */\n  PouchDB.on('debug', function (args) {\n    // first argument is log identifier\n    var logId = args[0];\n    // rest should be passed verbatim to debug module\n    var logArgs = args.slice(1);\n    if (!logs[logId]) {\n      logs[logId] = debug('pouchdb:' + logId);\n    }\n    logs[logId].apply(null, logArgs);\n  });\n}\n\n// this would just be \"return doc[field]\", but fields\n// can be \"deep\" due to dot notation\nfunction getFieldFromDoc(doc, parsedField) {\n  var value = doc;\n  for (var i = 0, len = parsedField.length; i < len; i++) {\n    var key = parsedField[i];\n    value = value[key];\n    if (!value) {\n      break;\n    }\n  }\n  return value;\n}\n\nfunction compare$1(left, right) {\n  return left < right ? -1 : left > right ? 1 : 0;\n}\n\n// Converts a string in dot notation to an array of its components, with backslash escaping\nfunction parseField(fieldName) {\n  // fields may be deep (e.g. \"foo.bar.baz\"), so parse\n  var fields = [];\n  var current = '';\n  for (var i = 0, len = fieldName.length; i < len; i++) {\n    var ch = fieldName[i];\n    if (ch === '.') {\n      if (i > 0 && fieldName[i - 1] === '\\\\') { // escaped delimiter\n        current = current.substring(0, current.length - 1) + '.';\n      } else { // not escaped, so delimiter\n        fields.push(current);\n        current = '';\n      }\n    } else { // normal character\n      current += ch;\n    }\n  }\n  fields.push(current);\n  return fields;\n}\n\nvar combinationFields = ['$or', '$nor', '$not'];\nfunction isCombinationalField(field) {\n  return combinationFields.indexOf(field) > -1;\n}\n\nfunction getKey(obj) {\n  return Object.keys(obj)[0];\n}\n\nfunction getValue(obj) {\n  return obj[getKey(obj)];\n}\n\n\n// flatten an array of selectors joined by an $and operator\nfunction mergeAndedSelectors(selectors) {\n\n  // sort to ensure that e.g. if the user specified\n  // $and: [{$gt: 'a'}, {$gt: 'b'}], then it's collapsed into\n  // just {$gt: 'b'}\n  var res = {};\n\n  selectors.forEach(function (selector) {\n    Object.keys(selector).forEach(function (field) {\n      var matcher = selector[field];\n      if (typeof matcher !== 'object') {\n        matcher = {$eq: matcher};\n      }\n\n      if (isCombinationalField(field)) {\n        if (matcher instanceof Array) {\n          res[field] = matcher.map(function (m) {\n            return mergeAndedSelectors([m]);\n          });\n        } else {\n          res[field] = mergeAndedSelectors([matcher]);\n        }\n      } else {\n        var fieldMatchers = res[field] = res[field] || {};\n        Object.keys(matcher).forEach(function (operator) {\n          var value = matcher[operator];\n\n          if (operator === '$gt' || operator === '$gte') {\n            return mergeGtGte(operator, value, fieldMatchers);\n          } else if (operator === '$lt' || operator === '$lte') {\n            return mergeLtLte(operator, value, fieldMatchers);\n          } else if (operator === '$ne') {\n            return mergeNe(value, fieldMatchers);\n          } else if (operator === '$eq') {\n            return mergeEq(value, fieldMatchers);\n          }\n          fieldMatchers[operator] = value;\n        });\n      }\n    });\n  });\n\n  return res;\n}\n\n\n\n// collapse logically equivalent gt/gte values\nfunction mergeGtGte(operator, value, fieldMatchers) {\n  if (typeof fieldMatchers.$eq !== 'undefined') {\n    return; // do nothing\n  }\n  if (typeof fieldMatchers.$gte !== 'undefined') {\n    if (operator === '$gte') {\n      if (value > fieldMatchers.$gte) { // more specificity\n        fieldMatchers.$gte = value;\n      }\n    } else { // operator === '$gt'\n      if (value >= fieldMatchers.$gte) { // more specificity\n        delete fieldMatchers.$gte;\n        fieldMatchers.$gt = value;\n      }\n    }\n  } else if (typeof fieldMatchers.$gt !== 'undefined') {\n    if (operator === '$gte') {\n      if (value > fieldMatchers.$gt) { // more specificity\n        delete fieldMatchers.$gt;\n        fieldMatchers.$gte = value;\n      }\n    } else { // operator === '$gt'\n      if (value > fieldMatchers.$gt) { // more specificity\n        fieldMatchers.$gt = value;\n      }\n    }\n  } else {\n    fieldMatchers[operator] = value;\n  }\n}\n\n// collapse logically equivalent lt/lte values\nfunction mergeLtLte(operator, value, fieldMatchers) {\n  if (typeof fieldMatchers.$eq !== 'undefined') {\n    return; // do nothing\n  }\n  if (typeof fieldMatchers.$lte !== 'undefined') {\n    if (operator === '$lte') {\n      if (value < fieldMatchers.$lte) { // more specificity\n        fieldMatchers.$lte = value;\n      }\n    } else { // operator === '$gt'\n      if (value <= fieldMatchers.$lte) { // more specificity\n        delete fieldMatchers.$lte;\n        fieldMatchers.$lt = value;\n      }\n    }\n  } else if (typeof fieldMatchers.$lt !== 'undefined') {\n    if (operator === '$lte') {\n      if (value < fieldMatchers.$lt) { // more specificity\n        delete fieldMatchers.$lt;\n        fieldMatchers.$lte = value;\n      }\n    } else { // operator === '$gt'\n      if (value < fieldMatchers.$lt) { // more specificity\n        fieldMatchers.$lt = value;\n      }\n    }\n  } else {\n    fieldMatchers[operator] = value;\n  }\n}\n\n// combine $ne values into one array\nfunction mergeNe(value, fieldMatchers) {\n  if ('$ne' in fieldMatchers) {\n    // there are many things this could \"not\" be\n    fieldMatchers.$ne.push(value);\n  } else { // doesn't exist yet\n    fieldMatchers.$ne = [value];\n  }\n}\n\n// add $eq into the mix\nfunction mergeEq(value, fieldMatchers) {\n  // these all have less specificity than the $eq\n  // TODO: check for user errors here\n  delete fieldMatchers.$gt;\n  delete fieldMatchers.$gte;\n  delete fieldMatchers.$lt;\n  delete fieldMatchers.$lte;\n  delete fieldMatchers.$ne;\n  fieldMatchers.$eq = value;\n}\n\n\n//\n// normalize the selector\n//\nfunction massageSelector(input) {\n  var result = clone(input);\n  var wasAnded = false;\n  if ('$and' in result) {\n    result = mergeAndedSelectors(result['$and']);\n    wasAnded = true;\n  }\n\n  ['$or', '$nor'].forEach(function (orOrNor) {\n    if (orOrNor in result) {\n      // message each individual selector\n      // e.g. {foo: 'bar'} becomes {foo: {$eq: 'bar'}}\n      result[orOrNor].forEach(function (subSelector) {\n        var fields = Object.keys(subSelector);\n        for (var i = 0; i < fields.length; i++) {\n          var field = fields[i];\n          var matcher = subSelector[field];\n          if (typeof matcher !== 'object' || matcher === null) {\n            subSelector[field] = {$eq: matcher};\n          }\n        }\n      });\n    }\n  });\n\n  if ('$not' in result) {\n    //This feels a little like forcing, but it will work for now,\n    //I would like to come back to this and make the merging of selectors a little more generic\n    result['$not'] = mergeAndedSelectors([result['$not']]);\n  }\n\n  var fields = Object.keys(result);\n\n  for (var i = 0; i < fields.length; i++) {\n    var field = fields[i];\n    var matcher = result[field];\n\n    if (typeof matcher !== 'object' || matcher === null) {\n      matcher = {$eq: matcher};\n    } else if ('$ne' in matcher && !wasAnded) {\n      // I put these in an array, since there may be more than one\n      // but in the \"mergeAnded\" operation, I already take care of that\n      matcher.$ne = [matcher.$ne];\n    }\n    result[field] = matcher;\n  }\n\n  return result;\n}\n\nfunction pad(str, padWith, upToLength) {\n  var padding = '';\n  var targetLength = upToLength - str.length;\n  /* istanbul ignore next */\n  while (padding.length < targetLength) {\n    padding += padWith;\n  }\n  return padding;\n}\n\nfunction padLeft(str, padWith, upToLength) {\n  var padding = pad(str, padWith, upToLength);\n  return padding + str;\n}\n\nvar MIN_MAGNITUDE = -324; // verified by -Number.MIN_VALUE\nvar MAGNITUDE_DIGITS = 3; // ditto\nvar SEP = ''; // set to '_' for easier debugging \n\nfunction collate(a, b) {\n\n  if (a === b) {\n    return 0;\n  }\n\n  a = normalizeKey(a);\n  b = normalizeKey(b);\n\n  var ai = collationIndex(a);\n  var bi = collationIndex(b);\n  if ((ai - bi) !== 0) {\n    return ai - bi;\n  }\n  switch (typeof a) {\n    case 'number':\n      return a - b;\n    case 'boolean':\n      return a < b ? -1 : 1;\n    case 'string':\n      return stringCollate(a, b);\n  }\n  return Array.isArray(a) ? arrayCollate(a, b) : objectCollate(a, b);\n}\n\n// couch considers null/NaN/Infinity/-Infinity === undefined,\n// for the purposes of mapreduce indexes. also, dates get stringified.\nfunction normalizeKey(key) {\n  switch (typeof key) {\n    case 'undefined':\n      return null;\n    case 'number':\n      if (key === Infinity || key === -Infinity || isNaN(key)) {\n        return null;\n      }\n      return key;\n    case 'object':\n      var origKey = key;\n      if (Array.isArray(key)) {\n        var len = key.length;\n        key = new Array(len);\n        for (var i = 0; i < len; i++) {\n          key[i] = normalizeKey(origKey[i]);\n        }\n      /* istanbul ignore next */\n      } else if (key instanceof Date) {\n        return key.toJSON();\n      } else if (key !== null) { // generic object\n        key = {};\n        for (var k in origKey) {\n          if (origKey.hasOwnProperty(k)) {\n            var val = origKey[k];\n            if (typeof val !== 'undefined') {\n              key[k] = normalizeKey(val);\n            }\n          }\n        }\n      }\n  }\n  return key;\n}\n\nfunction indexify(key) {\n  if (key !== null) {\n    switch (typeof key) {\n      case 'boolean':\n        return key ? 1 : 0;\n      case 'number':\n        return numToIndexableString(key);\n      case 'string':\n        // We've to be sure that key does not contain \\u0000\n        // Do order-preserving replacements:\n        // 0 -> 1, 1\n        // 1 -> 1, 2\n        // 2 -> 2, 2\n        return key\n          .replace(/\\u0002/g, '\\u0002\\u0002')\n          .replace(/\\u0001/g, '\\u0001\\u0002')\n          .replace(/\\u0000/g, '\\u0001\\u0001');\n      case 'object':\n        var isArray = Array.isArray(key);\n        var arr = isArray ? key : Object.keys(key);\n        var i = -1;\n        var len = arr.length;\n        var result = '';\n        if (isArray) {\n          while (++i < len) {\n            result += toIndexableString(arr[i]);\n          }\n        } else {\n          while (++i < len) {\n            var objKey = arr[i];\n            result += toIndexableString(objKey) +\n                toIndexableString(key[objKey]);\n          }\n        }\n        return result;\n    }\n  }\n  return '';\n}\n\n// convert the given key to a string that would be appropriate\n// for lexical sorting, e.g. within a database, where the\n// sorting is the same given by the collate() function.\nfunction toIndexableString(key) {\n  var zero = '\\u0000';\n  key = normalizeKey(key);\n  return collationIndex(key) + SEP + indexify(key) + zero;\n}\n\nfunction parseNumber(str, i) {\n  var originalIdx = i;\n  var num;\n  var zero = str[i] === '1';\n  if (zero) {\n    num = 0;\n    i++;\n  } else {\n    var neg = str[i] === '0';\n    i++;\n    var numAsString = '';\n    var magAsString = str.substring(i, i + MAGNITUDE_DIGITS);\n    var magnitude = parseInt(magAsString, 10) + MIN_MAGNITUDE;\n    /* istanbul ignore next */\n    if (neg) {\n      magnitude = -magnitude;\n    }\n    i += MAGNITUDE_DIGITS;\n    while (true) {\n      var ch = str[i];\n      if (ch === '\\u0000') {\n        break;\n      } else {\n        numAsString += ch;\n      }\n      i++;\n    }\n    numAsString = numAsString.split('.');\n    if (numAsString.length === 1) {\n      num = parseInt(numAsString, 10);\n    } else {\n      /* istanbul ignore next */\n      num = parseFloat(numAsString[0] + '.' + numAsString[1]);\n    }\n    /* istanbul ignore next */\n    if (neg) {\n      num = num - 10;\n    }\n    /* istanbul ignore next */\n    if (magnitude !== 0) {\n      // parseFloat is more reliable than pow due to rounding errors\n      // e.g. Number.MAX_VALUE would return Infinity if we did\n      // num * Math.pow(10, magnitude);\n      num = parseFloat(num + 'e' + magnitude);\n    }\n  }\n  return {num: num, length : i - originalIdx};\n}\n\n// move up the stack while parsing\n// this function moved outside of parseIndexableString for performance\nfunction pop(stack, metaStack) {\n  var obj = stack.pop();\n\n  if (metaStack.length) {\n    var lastMetaElement = metaStack[metaStack.length - 1];\n    if (obj === lastMetaElement.element) {\n      // popping a meta-element, e.g. an object whose value is another object\n      metaStack.pop();\n      lastMetaElement = metaStack[metaStack.length - 1];\n    }\n    var element = lastMetaElement.element;\n    var lastElementIndex = lastMetaElement.index;\n    if (Array.isArray(element)) {\n      element.push(obj);\n    } else if (lastElementIndex === stack.length - 2) { // obj with key+value\n      var key = stack.pop();\n      element[key] = obj;\n    } else {\n      stack.push(obj); // obj with key only\n    }\n  }\n}\n\nfunction parseIndexableString(str) {\n  var stack = [];\n  var metaStack = []; // stack for arrays and objects\n  var i = 0;\n\n  /*eslint no-constant-condition: [\"error\", { \"checkLoops\": false }]*/\n  while (true) {\n    var collationIndex = str[i++];\n    if (collationIndex === '\\u0000') {\n      if (stack.length === 1) {\n        return stack.pop();\n      } else {\n        pop(stack, metaStack);\n        continue;\n      }\n    }\n    switch (collationIndex) {\n      case '1':\n        stack.push(null);\n        break;\n      case '2':\n        stack.push(str[i] === '1');\n        i++;\n        break;\n      case '3':\n        var parsedNum = parseNumber(str, i);\n        stack.push(parsedNum.num);\n        i += parsedNum.length;\n        break;\n      case '4':\n        var parsedStr = '';\n        /*eslint no-constant-condition: [\"error\", { \"checkLoops\": false }]*/\n        while (true) {\n          var ch = str[i];\n          if (ch === '\\u0000') {\n            break;\n          }\n          parsedStr += ch;\n          i++;\n        }\n        // perform the reverse of the order-preserving replacement\n        // algorithm (see above)\n        parsedStr = parsedStr.replace(/\\u0001\\u0001/g, '\\u0000')\n          .replace(/\\u0001\\u0002/g, '\\u0001')\n          .replace(/\\u0002\\u0002/g, '\\u0002');\n        stack.push(parsedStr);\n        break;\n      case '5':\n        var arrayElement = { element: [], index: stack.length };\n        stack.push(arrayElement.element);\n        metaStack.push(arrayElement);\n        break;\n      case '6':\n        var objElement = { element: {}, index: stack.length };\n        stack.push(objElement.element);\n        metaStack.push(objElement);\n        break;\n      /* istanbul ignore next */\n      default:\n        throw new Error(\n          'bad collationIndex or unexpectedly reached end of input: ' +\n            collationIndex);\n    }\n  }\n}\n\nfunction arrayCollate(a, b) {\n  var len = Math.min(a.length, b.length);\n  for (var i = 0; i < len; i++) {\n    var sort = collate(a[i], b[i]);\n    if (sort !== 0) {\n      return sort;\n    }\n  }\n  return (a.length === b.length) ? 0 :\n    (a.length > b.length) ? 1 : -1;\n}\nfunction stringCollate(a, b) {\n  // See: https://github.com/daleharvey/pouchdb/issues/40\n  // This is incompatible with the CouchDB implementation, but its the\n  // best we can do for now\n  return (a === b) ? 0 : ((a > b) ? 1 : -1);\n}\nfunction objectCollate(a, b) {\n  var ak = Object.keys(a), bk = Object.keys(b);\n  var len = Math.min(ak.length, bk.length);\n  for (var i = 0; i < len; i++) {\n    // First sort the keys\n    var sort = collate(ak[i], bk[i]);\n    if (sort !== 0) {\n      return sort;\n    }\n    // if the keys are equal sort the values\n    sort = collate(a[ak[i]], b[bk[i]]);\n    if (sort !== 0) {\n      return sort;\n    }\n\n  }\n  return (ak.length === bk.length) ? 0 :\n    (ak.length > bk.length) ? 1 : -1;\n}\n// The collation is defined by erlangs ordered terms\n// the atoms null, true, false come first, then numbers, strings,\n// arrays, then objects\n// null/undefined/NaN/Infinity/-Infinity are all considered null\nfunction collationIndex(x) {\n  var id = ['boolean', 'number', 'string', 'object'];\n  var idx = id.indexOf(typeof x);\n  //false if -1 otherwise true, but fast!!!!1\n  if (~idx) {\n    if (x === null) {\n      return 1;\n    }\n    if (Array.isArray(x)) {\n      return 5;\n    }\n    return idx < 3 ? (idx + 2) : (idx + 3);\n  }\n  /* istanbul ignore next */\n  if (Array.isArray(x)) {\n    return 5;\n  }\n}\n\n// conversion:\n// x yyy zz...zz\n// x = 0 for negative, 1 for 0, 2 for positive\n// y = exponent (for negative numbers negated) moved so that it's >= 0\n// z = mantisse\nfunction numToIndexableString(num) {\n\n  if (num === 0) {\n    return '1';\n  }\n\n  // convert number to exponential format for easier and\n  // more succinct string sorting\n  var expFormat = num.toExponential().split(/e\\+?/);\n  var magnitude = parseInt(expFormat[1], 10);\n\n  var neg = num < 0;\n\n  var result = neg ? '0' : '2';\n\n  // first sort by magnitude\n  // it's easier if all magnitudes are positive\n  var magForComparison = ((neg ? -magnitude : magnitude) - MIN_MAGNITUDE);\n  var magString = padLeft((magForComparison).toString(), '0', MAGNITUDE_DIGITS);\n\n  result += SEP + magString;\n\n  // then sort by the factor\n  var factor = Math.abs(parseFloat(expFormat[0])); // [1..10)\n  /* istanbul ignore next */\n  if (neg) { // for negative reverse ordering\n    factor = 10 - factor;\n  }\n\n  var factorStr = factor.toFixed(20);\n\n  // strip zeros from the end\n  factorStr = factorStr.replace(/\\.?0+$/, '');\n\n  result += SEP + factorStr;\n\n  return result;\n}\n\n// create a comparator based on the sort object\nfunction createFieldSorter(sort) {\n\n  function getFieldValuesAsArray(doc) {\n    return sort.map(function (sorting) {\n      var fieldName = getKey(sorting);\n      var parsedField = parseField(fieldName);\n      var docFieldValue = getFieldFromDoc(doc, parsedField);\n      return docFieldValue;\n    });\n  }\n\n  return function (aRow, bRow) {\n    var aFieldValues = getFieldValuesAsArray(aRow.doc);\n    var bFieldValues = getFieldValuesAsArray(bRow.doc);\n    var collation = collate(aFieldValues, bFieldValues);\n    if (collation !== 0) {\n      return collation;\n    }\n    // this is what mango seems to do\n    return compare$1(aRow.doc._id, bRow.doc._id);\n  };\n}\n\nfunction filterInMemoryFields(rows, requestDef, inMemoryFields) {\n  rows = rows.filter(function (row) {\n    return rowFilter(row.doc, requestDef.selector, inMemoryFields);\n  });\n\n  if (requestDef.sort) {\n    // in-memory sort\n    var fieldSorter = createFieldSorter(requestDef.sort);\n    rows = rows.sort(fieldSorter);\n    if (typeof requestDef.sort[0] !== 'string' &&\n        getValue(requestDef.sort[0]) === 'desc') {\n      rows = rows.reverse();\n    }\n  }\n\n  if ('limit' in requestDef || 'skip' in requestDef) {\n    // have to do the limit in-memory\n    var skip = requestDef.skip || 0;\n    var limit = ('limit' in requestDef ? requestDef.limit : rows.length) + skip;\n    rows = rows.slice(skip, limit);\n  }\n  return rows;\n}\n\nfunction rowFilter(doc, selector, inMemoryFields) {\n  return inMemoryFields.every(function (field) {\n    var matcher = selector[field];\n    var parsedField = parseField(field);\n    var docFieldValue = getFieldFromDoc(doc, parsedField);\n    if (isCombinationalField(field)) {\n      return matchCominationalSelector(field, matcher, doc);\n    }\n\n    return matchSelector(matcher, doc, parsedField, docFieldValue);\n  });\n}\n\nfunction matchSelector(matcher, doc, parsedField, docFieldValue) {\n  if (!matcher) {\n    // no filtering necessary; this field is just needed for sorting\n    return true;\n  }\n\n  return Object.keys(matcher).every(function (userOperator) {\n    var userValue = matcher[userOperator];\n    return match(userOperator, doc, userValue, parsedField, docFieldValue);\n  });\n}\n\nfunction matchCominationalSelector(field, matcher, doc) {\n\n  if (field === '$or') {\n    return matcher.some(function (orMatchers) {\n      return rowFilter(doc, orMatchers, Object.keys(orMatchers));\n    });\n  }\n\n  if (field === '$not') {\n    return !rowFilter(doc, matcher, Object.keys(matcher));\n  }\n\n  //`$nor`\n  return !matcher.find(function (orMatchers) {\n    return rowFilter(doc, orMatchers, Object.keys(orMatchers));\n  });\n\n}\n\nfunction match(userOperator, doc, userValue, parsedField, docFieldValue) {\n  if (!matchers[userOperator]) {\n    throw new Error('unknown operator \"' + userOperator +\n      '\" - should be one of $eq, $lte, $lt, $gt, $gte, $exists, $ne, $in, ' +\n      '$nin, $size, $mod, $regex, $elemMatch, $type, $allMatch or $all');\n  }\n  return matchers[userOperator](doc, userValue, parsedField, docFieldValue);\n}\n\nfunction fieldExists(docFieldValue) {\n  return typeof docFieldValue !== 'undefined' && docFieldValue !== null;\n}\n\nfunction fieldIsNotUndefined(docFieldValue) {\n  return typeof docFieldValue !== 'undefined';\n}\n\nfunction modField(docFieldValue, userValue) {\n  var divisor = userValue[0];\n  var mod = userValue[1];\n  if (divisor === 0) {\n    throw new Error('Bad divisor, cannot divide by zero');\n  }\n\n  if (parseInt(divisor, 10) !== divisor ) {\n    throw new Error('Divisor is not an integer');\n  }\n\n  if (parseInt(mod, 10) !== mod ) {\n    throw new Error('Modulus is not an integer');\n  }\n\n  if (parseInt(docFieldValue, 10) !== docFieldValue) {\n    return false;\n  }\n\n  return docFieldValue % divisor === mod;\n}\n\nfunction arrayContainsValue(docFieldValue, userValue) {\n  return userValue.some(function (val) {\n    if (docFieldValue instanceof Array) {\n      return docFieldValue.indexOf(val) > -1;\n    }\n\n    return docFieldValue === val;\n  });\n}\n\nfunction arrayContainsAllValues(docFieldValue, userValue) {\n  return userValue.every(function (val) {\n    return docFieldValue.indexOf(val) > -1;\n  });\n}\n\nfunction arraySize(docFieldValue, userValue) {\n  return docFieldValue.length === userValue;\n}\n\nfunction regexMatch(docFieldValue, userValue) {\n  var re = new RegExp(userValue);\n\n  return re.test(docFieldValue);\n}\n\nfunction typeMatch(docFieldValue, userValue) {\n\n  switch (userValue) {\n    case 'null':\n      return docFieldValue === null;\n    case 'boolean':\n      return typeof (docFieldValue) === 'boolean';\n    case 'number':\n      return typeof (docFieldValue) === 'number';\n    case 'string':\n      return typeof (docFieldValue) === 'string';\n    case 'array':\n      return docFieldValue instanceof Array;\n    case 'object':\n      return ({}).toString.call(docFieldValue) === '[object Object]';\n  }\n\n  throw new Error(userValue + ' not supported as a type.' +\n                  'Please use one of object, string, array, number, boolean or null.');\n\n}\n\nvar matchers = {\n\n  '$elemMatch': function (doc, userValue, parsedField, docFieldValue) {\n    if (!Array.isArray(docFieldValue)) {\n      return false;\n    }\n\n    if (docFieldValue.length === 0) {\n      return false;\n    }\n\n    if (typeof docFieldValue[0] === 'object') {\n      return docFieldValue.some(function (val) {\n        return rowFilter(val, userValue, Object.keys(userValue));\n      });\n    }\n\n    return docFieldValue.some(function (val) {\n      return matchSelector(userValue, doc, parsedField, val);\n    });\n  },\n\n  '$allMatch': function (doc, userValue, parsedField, docFieldValue) {\n    if (!Array.isArray(docFieldValue)) {\n      return false;\n    }\n\n    /* istanbul ignore next */\n    if (docFieldValue.length === 0) {\n      return false;\n    }\n\n    if (typeof docFieldValue[0] === 'object') {\n      return docFieldValue.every(function (val) {\n        return rowFilter(val, userValue, Object.keys(userValue));\n      });\n    }\n\n    return docFieldValue.every(function (val) {\n      return matchSelector(userValue, doc, parsedField, val);\n    });\n  },\n\n  '$eq': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) === 0;\n  },\n\n  '$gte': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) >= 0;\n  },\n\n  '$gt': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) > 0;\n  },\n\n  '$lte': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) <= 0;\n  },\n\n  '$lt': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) < 0;\n  },\n\n  '$exists': function (doc, userValue, parsedField, docFieldValue) {\n    //a field that is null is still considered to exist\n    if (userValue) {\n      return fieldIsNotUndefined(docFieldValue);\n    }\n\n    return !fieldIsNotUndefined(docFieldValue);\n  },\n\n  '$mod': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldExists(docFieldValue) && modField(docFieldValue, userValue);\n  },\n\n  '$ne': function (doc, userValue, parsedField, docFieldValue) {\n    return userValue.every(function (neValue) {\n      return collate(docFieldValue, neValue) !== 0;\n    });\n  },\n  '$in': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldExists(docFieldValue) && arrayContainsValue(docFieldValue, userValue);\n  },\n\n  '$nin': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldExists(docFieldValue) && !arrayContainsValue(docFieldValue, userValue);\n  },\n\n  '$size': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldExists(docFieldValue) && arraySize(docFieldValue, userValue);\n  },\n\n  '$all': function (doc, userValue, parsedField, docFieldValue) {\n    return Array.isArray(docFieldValue) && arrayContainsAllValues(docFieldValue, userValue);\n  },\n\n  '$regex': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldExists(docFieldValue) && regexMatch(docFieldValue, userValue);\n  },\n\n  '$type': function (doc, userValue, parsedField, docFieldValue) {\n    return typeMatch(docFieldValue, userValue);\n  }\n};\n\n// return true if the given doc matches the supplied selector\nfunction matchesSelector(doc, selector) {\n  /* istanbul ignore if */\n  if (typeof selector !== 'object') {\n    // match the CouchDB error message\n    throw new Error('Selector error: expected a JSON object');\n  }\n\n  selector = massageSelector(selector);\n  var row = {\n    'doc': doc\n  };\n\n  var rowsMatched = filterInMemoryFields([row], { 'selector': selector }, Object.keys(selector));\n  return rowsMatched && rowsMatched.length === 1;\n}\n\nfunction evalFilter(input) {\n  return scopeEval('\"use strict\";\\nreturn ' + input + ';', {});\n}\n\nfunction evalView(input) {\n  var code = [\n    'return function(doc) {',\n    '  \"use strict\";',\n    '  var emitted = false;',\n    '  var emit = function (a, b) {',\n    '    emitted = true;',\n    '  };',\n    '  var view = ' + input + ';',\n    '  view(doc);',\n    '  if (emitted) {',\n    '    return true;',\n    '  }',\n    '};'\n  ].join('\\n');\n\n  return scopeEval(code, {});\n}\n\nfunction validate(opts, callback) {\n  if (opts.selector) {\n    if (opts.filter && opts.filter !== '_selector') {\n      var filterName = typeof opts.filter === 'string' ?\n        opts.filter : 'function';\n      return callback(new Error('selector invalid for filter \"' + filterName + '\"'));\n    }\n  }\n  callback();\n}\n\nfunction normalize(opts) {\n  if (opts.view && !opts.filter) {\n    opts.filter = '_view';\n  }\n\n  if (opts.selector && !opts.filter) {\n    opts.filter = '_selector';\n  }\n\n  if (opts.filter && typeof opts.filter === 'string') {\n    if (opts.filter === '_view') {\n      opts.view = normalizeDesignDocFunctionName(opts.view);\n    } else {\n      opts.filter = normalizeDesignDocFunctionName(opts.filter);\n    }\n  }\n}\n\nfunction shouldFilter(changesHandler, opts) {\n  return opts.filter && typeof opts.filter === 'string' &&\n    !opts.doc_ids && !isRemote(changesHandler.db);\n}\n\nfunction filter(changesHandler, opts) {\n  var callback = opts.complete;\n  if (opts.filter === '_view') {\n    if (!opts.view || typeof opts.view !== 'string') {\n      var err = createError(BAD_REQUEST,\n        '`view` filter parameter not found or invalid.');\n      return callback(err);\n    }\n    // fetch a view from a design doc, make it behave like a filter\n    var viewName = parseDesignDocFunctionName(opts.view);\n    changesHandler.db.get('_design/' + viewName[0], function (err, ddoc) {\n      /* istanbul ignore if */\n      if (changesHandler.isCancelled) {\n        return callback(null, {status: 'cancelled'});\n      }\n      /* istanbul ignore next */\n      if (err) {\n        return callback(generateErrorFromResponse(err));\n      }\n      var mapFun = ddoc && ddoc.views && ddoc.views[viewName[1]] &&\n        ddoc.views[viewName[1]].map;\n      if (!mapFun) {\n        return callback(createError(MISSING_DOC,\n          (ddoc.views ? 'missing json key: ' + viewName[1] :\n            'missing json key: views')));\n      }\n      opts.filter = evalView(mapFun);\n      changesHandler.doChanges(opts);\n    });\n  } else if (opts.selector) {\n    opts.filter = function (doc) {\n      return matchesSelector(doc, opts.selector);\n    };\n    changesHandler.doChanges(opts);\n  } else {\n    // fetch a filter from a design doc\n    var filterName = parseDesignDocFunctionName(opts.filter);\n    changesHandler.db.get('_design/' + filterName[0], function (err, ddoc) {\n      /* istanbul ignore if */\n      if (changesHandler.isCancelled) {\n        return callback(null, {status: 'cancelled'});\n      }\n      /* istanbul ignore next */\n      if (err) {\n        return callback(generateErrorFromResponse(err));\n      }\n      var filterFun = ddoc && ddoc.filters && ddoc.filters[filterName[1]];\n      if (!filterFun) {\n        return callback(createError(MISSING_DOC,\n          ((ddoc && ddoc.filters) ? 'missing json key: ' + filterName[1]\n            : 'missing json key: filters')));\n      }\n      opts.filter = evalFilter(filterFun);\n      changesHandler.doChanges(opts);\n    });\n  }\n}\n\nfunction applyChangesFilterPlugin(PouchDB) {\n  PouchDB._changesFilterPlugin = {\n    validate: validate,\n    normalize: normalize,\n    shouldFilter: shouldFilter,\n    filter: filter\n  };\n}\n\n// TODO: remove from pouchdb-core (breaking)\nPouchDB.plugin(debugPouch);\n\n// TODO: remove from pouchdb-core (breaking)\nPouchDB.plugin(applyChangesFilterPlugin);\n\nPouchDB.version = version;\n\nfunction toObject(array) {\n  return array.reduce(function (obj, item) {\n    obj[item] = true;\n    return obj;\n  }, {});\n}\n// List of top level reserved words for doc\nvar reservedWords = toObject([\n  '_id',\n  '_rev',\n  '_attachments',\n  '_deleted',\n  '_revisions',\n  '_revs_info',\n  '_conflicts',\n  '_deleted_conflicts',\n  '_local_seq',\n  '_rev_tree',\n  //replication documents\n  '_replication_id',\n  '_replication_state',\n  '_replication_state_time',\n  '_replication_state_reason',\n  '_replication_stats',\n  // Specific to Couchbase Sync Gateway\n  '_removed'\n]);\n\n// List of reserved words that should end up the document\nvar dataWords = toObject([\n  '_attachments',\n  //replication documents\n  '_replication_id',\n  '_replication_state',\n  '_replication_state_time',\n  '_replication_state_reason',\n  '_replication_stats'\n]);\n\nfunction parseRevisionInfo(rev$$1) {\n  if (!/^\\d+-./.test(rev$$1)) {\n    return createError(INVALID_REV);\n  }\n  var idx = rev$$1.indexOf('-');\n  var left = rev$$1.substring(0, idx);\n  var right = rev$$1.substring(idx + 1);\n  return {\n    prefix: parseInt(left, 10),\n    id: right\n  };\n}\n\nfunction makeRevTreeFromRevisions(revisions, opts) {\n  var pos = revisions.start - revisions.ids.length + 1;\n\n  var revisionIds = revisions.ids;\n  var ids = [revisionIds[0], opts, []];\n\n  for (var i = 1, len = revisionIds.length; i < len; i++) {\n    ids = [revisionIds[i], {status: 'missing'}, [ids]];\n  }\n\n  return [{\n    pos: pos,\n    ids: ids\n  }];\n}\n\n// Preprocess documents, parse their revisions, assign an id and a\n// revision for new writes that are missing them, etc\nfunction parseDoc(doc, newEdits) {\n\n  var nRevNum;\n  var newRevId;\n  var revInfo;\n  var opts = {status: 'available'};\n  if (doc._deleted) {\n    opts.deleted = true;\n  }\n\n  if (newEdits) {\n    if (!doc._id) {\n      doc._id = uuid();\n    }\n    newRevId = rev();\n    if (doc._rev) {\n      revInfo = parseRevisionInfo(doc._rev);\n      if (revInfo.error) {\n        return revInfo;\n      }\n      doc._rev_tree = [{\n        pos: revInfo.prefix,\n        ids: [revInfo.id, {status: 'missing'}, [[newRevId, opts, []]]]\n      }];\n      nRevNum = revInfo.prefix + 1;\n    } else {\n      doc._rev_tree = [{\n        pos: 1,\n        ids : [newRevId, opts, []]\n      }];\n      nRevNum = 1;\n    }\n  } else {\n    if (doc._revisions) {\n      doc._rev_tree = makeRevTreeFromRevisions(doc._revisions, opts);\n      nRevNum = doc._revisions.start;\n      newRevId = doc._revisions.ids[0];\n    }\n    if (!doc._rev_tree) {\n      revInfo = parseRevisionInfo(doc._rev);\n      if (revInfo.error) {\n        return revInfo;\n      }\n      nRevNum = revInfo.prefix;\n      newRevId = revInfo.id;\n      doc._rev_tree = [{\n        pos: nRevNum,\n        ids: [newRevId, opts, []]\n      }];\n    }\n  }\n\n  invalidIdError(doc._id);\n\n  doc._rev = nRevNum + '-' + newRevId;\n\n  var result = {metadata : {}, data : {}};\n  for (var key in doc) {\n    /* istanbul ignore else */\n    if (Object.prototype.hasOwnProperty.call(doc, key)) {\n      var specialKey = key[0] === '_';\n      if (specialKey && !reservedWords[key]) {\n        var error = createError(DOC_VALIDATION, key);\n        error.message = DOC_VALIDATION.message + ': ' + key;\n        throw error;\n      } else if (specialKey && !dataWords[key]) {\n        result.metadata[key.slice(1)] = doc[key];\n      } else {\n        result.data[key] = doc[key];\n      }\n    }\n  }\n  return result;\n}\n\nvar thisAtob = function (str) {\n  return atob(str);\n};\n\nvar thisBtoa = function (str) {\n  return btoa(str);\n};\n\n// Abstracts constructing a Blob object, so it also works in older\n// browsers that don't support the native Blob constructor (e.g.\n// old QtWebKit versions, Android < 4.4).\nfunction createBlob(parts, properties) {\n  /* global BlobBuilder,MSBlobBuilder,MozBlobBuilder,WebKitBlobBuilder */\n  parts = parts || [];\n  properties = properties || {};\n  try {\n    return new Blob(parts, properties);\n  } catch (e) {\n    if (e.name !== \"TypeError\") {\n      throw e;\n    }\n    var Builder = typeof BlobBuilder !== 'undefined' ? BlobBuilder :\n                  typeof MSBlobBuilder !== 'undefined' ? MSBlobBuilder :\n                  typeof MozBlobBuilder !== 'undefined' ? MozBlobBuilder :\n                  WebKitBlobBuilder;\n    var builder = new Builder();\n    for (var i = 0; i < parts.length; i += 1) {\n      builder.append(parts[i]);\n    }\n    return builder.getBlob(properties.type);\n  }\n}\n\n// From http://stackoverflow.com/questions/14967647/ (continues on next line)\n// encode-decode-image-with-base64-breaks-image (2013-04-21)\nfunction binaryStringToArrayBuffer(bin) {\n  var length = bin.length;\n  var buf = new ArrayBuffer(length);\n  var arr = new Uint8Array(buf);\n  for (var i = 0; i < length; i++) {\n    arr[i] = bin.charCodeAt(i);\n  }\n  return buf;\n}\n\nfunction binStringToBluffer(binString, type) {\n  return createBlob([binaryStringToArrayBuffer(binString)], {type: type});\n}\n\nfunction b64ToBluffer(b64, type) {\n  return binStringToBluffer(thisAtob(b64), type);\n}\n\n//Can't find original post, but this is close\n//http://stackoverflow.com/questions/6965107/ (continues on next line)\n//converting-between-strings-and-arraybuffers\nfunction arrayBufferToBinaryString(buffer) {\n  var binary = '';\n  var bytes = new Uint8Array(buffer);\n  var length = bytes.byteLength;\n  for (var i = 0; i < length; i++) {\n    binary += String.fromCharCode(bytes[i]);\n  }\n  return binary;\n}\n\n// shim for browsers that don't support it\nfunction readAsBinaryString(blob, callback) {\n  if (typeof FileReader === 'undefined') {\n    // fix for Firefox in a web worker\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=901097\n    return callback(arrayBufferToBinaryString(\n      new FileReaderSync().readAsArrayBuffer(blob)));\n  }\n\n  var reader = new FileReader();\n  var hasBinaryString = typeof reader.readAsBinaryString === 'function';\n  reader.onloadend = function (e) {\n    var result = e.target.result || '';\n    if (hasBinaryString) {\n      return callback(result);\n    }\n    callback(arrayBufferToBinaryString(result));\n  };\n  if (hasBinaryString) {\n    reader.readAsBinaryString(blob);\n  } else {\n    reader.readAsArrayBuffer(blob);\n  }\n}\n\nfunction blobToBinaryString(blobOrBuffer, callback) {\n  readAsBinaryString(blobOrBuffer, function (bin) {\n    callback(bin);\n  });\n}\n\nfunction blobToBase64(blobOrBuffer, callback) {\n  blobToBinaryString(blobOrBuffer, function (base64) {\n    callback(thisBtoa(base64));\n  });\n}\n\n// simplified API. universal browser support is assumed\nfunction readAsArrayBuffer(blob, callback) {\n  if (typeof FileReader === 'undefined') {\n    // fix for Firefox in a web worker:\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=901097\n    return callback(new FileReaderSync().readAsArrayBuffer(blob));\n  }\n\n  var reader = new FileReader();\n  reader.onloadend = function (e) {\n    var result = e.target.result || new ArrayBuffer(0);\n    callback(result);\n  };\n  reader.readAsArrayBuffer(blob);\n}\n\n// this is not used in the browser\n\nvar setImmediateShim = global.setImmediate || global.setTimeout;\nvar MD5_CHUNK_SIZE = 32768;\n\nfunction rawToBase64(raw) {\n  return thisBtoa(raw);\n}\n\nfunction sliceBlob(blob, start, end) {\n  if (blob.webkitSlice) {\n    return blob.webkitSlice(start, end);\n  }\n  return blob.slice(start, end);\n}\n\nfunction appendBlob(buffer, blob, start, end, callback) {\n  if (start > 0 || end < blob.size) {\n    // only slice blob if we really need to\n    blob = sliceBlob(blob, start, end);\n  }\n  readAsArrayBuffer(blob, function (arrayBuffer) {\n    buffer.append(arrayBuffer);\n    callback();\n  });\n}\n\nfunction appendString(buffer, string, start, end, callback) {\n  if (start > 0 || end < string.length) {\n    // only create a substring if we really need to\n    string = string.substring(start, end);\n  }\n  buffer.appendBinary(string);\n  callback();\n}\n\nfunction binaryMd5(data, callback) {\n  var inputIsString = typeof data === 'string';\n  var len = inputIsString ? data.length : data.size;\n  var chunkSize = Math.min(MD5_CHUNK_SIZE, len);\n  var chunks = Math.ceil(len / chunkSize);\n  var currentChunk = 0;\n  var buffer = inputIsString ? new Md5() : new Md5.ArrayBuffer();\n\n  var append = inputIsString ? appendString : appendBlob;\n\n  function next() {\n    setImmediateShim(loadNextChunk);\n  }\n\n  function done() {\n    var raw = buffer.end(true);\n    var base64 = rawToBase64(raw);\n    callback(base64);\n    buffer.destroy();\n  }\n\n  function loadNextChunk() {\n    var start = currentChunk * chunkSize;\n    var end = start + chunkSize;\n    currentChunk++;\n    if (currentChunk < chunks) {\n      append(buffer, data, start, end, next);\n    } else {\n      append(buffer, data, start, end, done);\n    }\n  }\n  loadNextChunk();\n}\n\nfunction stringMd5(string) {\n  return Md5.hash(string);\n}\n\nfunction parseBase64(data) {\n  try {\n    return thisAtob(data);\n  } catch (e) {\n    var err = createError(BAD_ARG,\n      'Attachment is not a valid base64 string');\n    return {error: err};\n  }\n}\n\nfunction preprocessString(att, blobType, callback) {\n  var asBinary = parseBase64(att.data);\n  if (asBinary.error) {\n    return callback(asBinary.error);\n  }\n\n  att.length = asBinary.length;\n  if (blobType === 'blob') {\n    att.data = binStringToBluffer(asBinary, att.content_type);\n  } else if (blobType === 'base64') {\n    att.data = thisBtoa(asBinary);\n  } else { // binary\n    att.data = asBinary;\n  }\n  binaryMd5(asBinary, function (result) {\n    att.digest = 'md5-' + result;\n    callback();\n  });\n}\n\nfunction preprocessBlob(att, blobType, callback) {\n  binaryMd5(att.data, function (md5) {\n    att.digest = 'md5-' + md5;\n    // size is for blobs (browser), length is for buffers (node)\n    att.length = att.data.size || att.data.length || 0;\n    if (blobType === 'binary') {\n      blobToBinaryString(att.data, function (binString) {\n        att.data = binString;\n        callback();\n      });\n    } else if (blobType === 'base64') {\n      blobToBase64(att.data, function (b64) {\n        att.data = b64;\n        callback();\n      });\n    } else {\n      callback();\n    }\n  });\n}\n\nfunction preprocessAttachment(att, blobType, callback) {\n  if (att.stub) {\n    return callback();\n  }\n  if (typeof att.data === 'string') { // input is a base64 string\n    preprocessString(att, blobType, callback);\n  } else { // input is a blob\n    preprocessBlob(att, blobType, callback);\n  }\n}\n\nfunction preprocessAttachments(docInfos, blobType, callback) {\n\n  if (!docInfos.length) {\n    return callback();\n  }\n\n  var docv = 0;\n  var overallErr;\n\n  docInfos.forEach(function (docInfo) {\n    var attachments = docInfo.data && docInfo.data._attachments ?\n      Object.keys(docInfo.data._attachments) : [];\n    var recv = 0;\n\n    if (!attachments.length) {\n      return done();\n    }\n\n    function processedAttachment(err) {\n      overallErr = err;\n      recv++;\n      if (recv === attachments.length) {\n        done();\n      }\n    }\n\n    for (var key in docInfo.data._attachments) {\n      if (docInfo.data._attachments.hasOwnProperty(key)) {\n        preprocessAttachment(docInfo.data._attachments[key],\n          blobType, processedAttachment);\n      }\n    }\n  });\n\n  function done() {\n    docv++;\n    if (docInfos.length === docv) {\n      if (overallErr) {\n        callback(overallErr);\n      } else {\n        callback();\n      }\n    }\n  }\n}\n\nfunction updateDoc(revLimit, prev, docInfo, results,\n                   i, cb, writeDoc, newEdits) {\n\n  if (revExists(prev.rev_tree, docInfo.metadata.rev)) {\n    results[i] = docInfo;\n    return cb();\n  }\n\n  // sometimes this is pre-calculated. historically not always\n  var previousWinningRev = prev.winningRev || winningRev(prev);\n  var previouslyDeleted = 'deleted' in prev ? prev.deleted :\n    isDeleted(prev, previousWinningRev);\n  var deleted = 'deleted' in docInfo.metadata ? docInfo.metadata.deleted :\n    isDeleted(docInfo.metadata);\n  var isRoot = /^1-/.test(docInfo.metadata.rev);\n\n  if (previouslyDeleted && !deleted && newEdits && isRoot) {\n    var newDoc = docInfo.data;\n    newDoc._rev = previousWinningRev;\n    newDoc._id = docInfo.metadata.id;\n    docInfo = parseDoc(newDoc, newEdits);\n  }\n\n  var merged = merge(prev.rev_tree, docInfo.metadata.rev_tree[0], revLimit);\n\n  var inConflict = newEdits && ((\n    (previouslyDeleted && deleted && merged.conflicts !== 'new_leaf') ||\n    (!previouslyDeleted && merged.conflicts !== 'new_leaf') ||\n    (previouslyDeleted && !deleted && merged.conflicts === 'new_branch')));\n\n  if (inConflict) {\n    var err = createError(REV_CONFLICT);\n    results[i] = err;\n    return cb();\n  }\n\n  var newRev = docInfo.metadata.rev;\n  docInfo.metadata.rev_tree = merged.tree;\n  docInfo.stemmedRevs = merged.stemmedRevs || [];\n  /* istanbul ignore else */\n  if (prev.rev_map) {\n    docInfo.metadata.rev_map = prev.rev_map; // used only by leveldb\n  }\n\n  // recalculate\n  var winningRev$$1 = winningRev(docInfo.metadata);\n  var winningRevIsDeleted = isDeleted(docInfo.metadata, winningRev$$1);\n\n  // calculate the total number of documents that were added/removed,\n  // from the perspective of total_rows/doc_count\n  var delta = (previouslyDeleted === winningRevIsDeleted) ? 0 :\n    previouslyDeleted < winningRevIsDeleted ? -1 : 1;\n\n  var newRevIsDeleted;\n  if (newRev === winningRev$$1) {\n    // if the new rev is the same as the winning rev, we can reuse that value\n    newRevIsDeleted = winningRevIsDeleted;\n  } else {\n    // if they're not the same, then we need to recalculate\n    newRevIsDeleted = isDeleted(docInfo.metadata, newRev);\n  }\n\n  writeDoc(docInfo, winningRev$$1, winningRevIsDeleted, newRevIsDeleted,\n    true, delta, i, cb);\n}\n\nfunction rootIsMissing(docInfo) {\n  return docInfo.metadata.rev_tree[0].ids[1].status === 'missing';\n}\n\nfunction processDocs(revLimit, docInfos, api, fetchedDocs, tx, results,\n                     writeDoc, opts, overallCallback) {\n\n  // Default to 1000 locally\n  revLimit = revLimit || 1000;\n\n  function insertDoc(docInfo, resultsIdx, callback) {\n    // Cant insert new deleted documents\n    var winningRev$$1 = winningRev(docInfo.metadata);\n    var deleted = isDeleted(docInfo.metadata, winningRev$$1);\n    if ('was_delete' in opts && deleted) {\n      results[resultsIdx] = createError(MISSING_DOC, 'deleted');\n      return callback();\n    }\n\n    // 4712 - detect whether a new document was inserted with a _rev\n    var inConflict = newEdits && rootIsMissing(docInfo);\n\n    if (inConflict) {\n      var err = createError(REV_CONFLICT);\n      results[resultsIdx] = err;\n      return callback();\n    }\n\n    var delta = deleted ? 0 : 1;\n\n    writeDoc(docInfo, winningRev$$1, deleted, deleted, false,\n      delta, resultsIdx, callback);\n  }\n\n  var newEdits = opts.new_edits;\n  var idsToDocs = new ExportedMap();\n\n  var docsDone = 0;\n  var docsToDo = docInfos.length;\n\n  function checkAllDocsDone() {\n    if (++docsDone === docsToDo && overallCallback) {\n      overallCallback();\n    }\n  }\n\n  docInfos.forEach(function (currentDoc, resultsIdx) {\n\n    if (currentDoc._id && isLocalId(currentDoc._id)) {\n      var fun = currentDoc._deleted ? '_removeLocal' : '_putLocal';\n      api[fun](currentDoc, {ctx: tx}, function (err, res) {\n        results[resultsIdx] = err || res;\n        checkAllDocsDone();\n      });\n      return;\n    }\n\n    var id = currentDoc.metadata.id;\n    if (idsToDocs.has(id)) {\n      docsToDo--; // duplicate\n      idsToDocs.get(id).push([currentDoc, resultsIdx]);\n    } else {\n      idsToDocs.set(id, [[currentDoc, resultsIdx]]);\n    }\n  });\n\n  // in the case of new_edits, the user can provide multiple docs\n  // with the same id. these need to be processed sequentially\n  idsToDocs.forEach(function (docs, id) {\n    var numDone = 0;\n\n    function docWritten() {\n      if (++numDone < docs.length) {\n        nextDoc();\n      } else {\n        checkAllDocsDone();\n      }\n    }\n    function nextDoc() {\n      var value = docs[numDone];\n      var currentDoc = value[0];\n      var resultsIdx = value[1];\n\n      if (fetchedDocs.has(id)) {\n        updateDoc(revLimit, fetchedDocs.get(id), currentDoc, results,\n          resultsIdx, docWritten, writeDoc, newEdits);\n      } else {\n        // Ensure stemming applies to new writes as well\n        var merged = merge([], currentDoc.metadata.rev_tree[0], revLimit);\n        currentDoc.metadata.rev_tree = merged.tree;\n        currentDoc.stemmedRevs = merged.stemmedRevs || [];\n        insertDoc(currentDoc, resultsIdx, docWritten);\n      }\n    }\n    nextDoc();\n  });\n}\n\n// IndexedDB requires a versioned database structure, so we use the\n// version here to manage migrations.\nvar ADAPTER_VERSION = 5;\n\n// The object stores created for each database\n// DOC_STORE stores the document meta data, its revision history and state\n// Keyed by document id\nvar DOC_STORE = 'document-store';\n// BY_SEQ_STORE stores a particular version of a document, keyed by its\n// sequence id\nvar BY_SEQ_STORE = 'by-sequence';\n// Where we store attachments\nvar ATTACH_STORE = 'attach-store';\n// Where we store many-to-many relations\n// between attachment digests and seqs\nvar ATTACH_AND_SEQ_STORE = 'attach-seq-store';\n\n// Where we store database-wide meta data in a single record\n// keyed by id: META_STORE\nvar META_STORE = 'meta-store';\n// Where we store local documents\nvar LOCAL_STORE = 'local-store';\n// Where we detect blob support\nvar DETECT_BLOB_SUPPORT_STORE = 'detect-blob-support';\n\nfunction safeJsonParse(str) {\n  // This try/catch guards against stack overflow errors.\n  // JSON.parse() is faster than vuvuzela.parse() but vuvuzela\n  // cannot overflow.\n  try {\n    return JSON.parse(str);\n  } catch (e) {\n    /* istanbul ignore next */\n    return vuvuzela.parse(str);\n  }\n}\n\nfunction safeJsonStringify(json) {\n  try {\n    return JSON.stringify(json);\n  } catch (e) {\n    /* istanbul ignore next */\n    return vuvuzela.stringify(json);\n  }\n}\n\nfunction idbError(callback) {\n  return function (evt) {\n    var message = 'unknown_error';\n    if (evt.target && evt.target.error) {\n      message = evt.target.error.name || evt.target.error.message;\n    }\n    callback(createError(IDB_ERROR, message, evt.type));\n  };\n}\n\n// Unfortunately, the metadata has to be stringified\n// when it is put into the database, because otherwise\n// IndexedDB can throw errors for deeply-nested objects.\n// Originally we just used JSON.parse/JSON.stringify; now\n// we use this custom vuvuzela library that avoids recursion.\n// If we could do it all over again, we'd probably use a\n// format for the revision trees other than JSON.\nfunction encodeMetadata(metadata, winningRev, deleted) {\n  return {\n    data: safeJsonStringify(metadata),\n    winningRev: winningRev,\n    deletedOrLocal: deleted ? '1' : '0',\n    seq: metadata.seq, // highest seq for this doc\n    id: metadata.id\n  };\n}\n\nfunction decodeMetadata(storedObject) {\n  if (!storedObject) {\n    return null;\n  }\n  var metadata = safeJsonParse(storedObject.data);\n  metadata.winningRev = storedObject.winningRev;\n  metadata.deleted = storedObject.deletedOrLocal === '1';\n  metadata.seq = storedObject.seq;\n  return metadata;\n}\n\n// read the doc back out from the database. we don't store the\n// _id or _rev because we already have _doc_id_rev.\nfunction decodeDoc(doc) {\n  if (!doc) {\n    return doc;\n  }\n  var idx = doc._doc_id_rev.lastIndexOf(':');\n  doc._id = doc._doc_id_rev.substring(0, idx - 1);\n  doc._rev = doc._doc_id_rev.substring(idx + 1);\n  delete doc._doc_id_rev;\n  return doc;\n}\n\n// Read a blob from the database, encoding as necessary\n// and translating from base64 if the IDB doesn't support\n// native Blobs\nfunction readBlobData(body, type, asBlob, callback) {\n  if (asBlob) {\n    if (!body) {\n      callback(createBlob([''], {type: type}));\n    } else if (typeof body !== 'string') { // we have blob support\n      callback(body);\n    } else { // no blob support\n      callback(b64ToBluffer(body, type));\n    }\n  } else { // as base64 string\n    if (!body) {\n      callback('');\n    } else if (typeof body !== 'string') { // we have blob support\n      readAsBinaryString(body, function (binary) {\n        callback(thisBtoa(binary));\n      });\n    } else { // no blob support\n      callback(body);\n    }\n  }\n}\n\nfunction fetchAttachmentsIfNecessary(doc, opts, txn, cb) {\n  var attachments = Object.keys(doc._attachments || {});\n  if (!attachments.length) {\n    return cb && cb();\n  }\n  var numDone = 0;\n\n  function checkDone() {\n    if (++numDone === attachments.length && cb) {\n      cb();\n    }\n  }\n\n  function fetchAttachment(doc, att) {\n    var attObj = doc._attachments[att];\n    var digest = attObj.digest;\n    var req = txn.objectStore(ATTACH_STORE).get(digest);\n    req.onsuccess = function (e) {\n      attObj.body = e.target.result.body;\n      checkDone();\n    };\n  }\n\n  attachments.forEach(function (att) {\n    if (opts.attachments && opts.include_docs) {\n      fetchAttachment(doc, att);\n    } else {\n      doc._attachments[att].stub = true;\n      checkDone();\n    }\n  });\n}\n\n// IDB-specific postprocessing necessary because\n// we don't know whether we stored a true Blob or\n// a base64-encoded string, and if it's a Blob it\n// needs to be read outside of the transaction context\nfunction postProcessAttachments(results, asBlob) {\n  return PouchPromise.all(results.map(function (row) {\n    if (row.doc && row.doc._attachments) {\n      var attNames = Object.keys(row.doc._attachments);\n      return PouchPromise.all(attNames.map(function (att) {\n        var attObj = row.doc._attachments[att];\n        if (!('body' in attObj)) { // already processed\n          return;\n        }\n        var body = attObj.body;\n        var type = attObj.content_type;\n        return new PouchPromise(function (resolve) {\n          readBlobData(body, type, asBlob, function (data) {\n            row.doc._attachments[att] = $inject_Object_assign(\n              pick(attObj, ['digest', 'content_type']),\n              {data: data}\n            );\n            resolve();\n          });\n        });\n      }));\n    }\n  }));\n}\n\nfunction compactRevs(revs, docId, txn) {\n\n  var possiblyOrphanedDigests = [];\n  var seqStore = txn.objectStore(BY_SEQ_STORE);\n  var attStore = txn.objectStore(ATTACH_STORE);\n  var attAndSeqStore = txn.objectStore(ATTACH_AND_SEQ_STORE);\n  var count = revs.length;\n\n  function checkDone() {\n    count--;\n    if (!count) { // done processing all revs\n      deleteOrphanedAttachments();\n    }\n  }\n\n  function deleteOrphanedAttachments() {\n    if (!possiblyOrphanedDigests.length) {\n      return;\n    }\n    possiblyOrphanedDigests.forEach(function (digest) {\n      var countReq = attAndSeqStore.index('digestSeq').count(\n        IDBKeyRange.bound(\n          digest + '::', digest + '::\\uffff', false, false));\n      countReq.onsuccess = function (e) {\n        var count = e.target.result;\n        if (!count) {\n          // orphaned\n          attStore[\"delete\"](digest);\n        }\n      };\n    });\n  }\n\n  revs.forEach(function (rev$$1) {\n    var index = seqStore.index('_doc_id_rev');\n    var key = docId + \"::\" + rev$$1;\n    index.getKey(key).onsuccess = function (e) {\n      var seq = e.target.result;\n      if (typeof seq !== 'number') {\n        return checkDone();\n      }\n      seqStore[\"delete\"](seq);\n\n      var cursor = attAndSeqStore.index('seq')\n        .openCursor(IDBKeyRange.only(seq));\n\n      cursor.onsuccess = function (event) {\n        var cursor = event.target.result;\n        if (cursor) {\n          var digest = cursor.value.digestSeq.split('::')[0];\n          possiblyOrphanedDigests.push(digest);\n          attAndSeqStore[\"delete\"](cursor.primaryKey);\n          cursor[\"continue\"]();\n        } else { // done\n          checkDone();\n        }\n      };\n    };\n  });\n}\n\nfunction openTransactionSafely(idb, stores, mode) {\n  try {\n    return {\n      txn: idb.transaction(stores, mode)\n    };\n  } catch (err) {\n    return {\n      error: err\n    };\n  }\n}\n\nvar changesHandler$$1 = new Changes();\n\nfunction idbBulkDocs(dbOpts, req, opts, api, idb, callback) {\n  var docInfos = req.docs;\n  var txn;\n  var docStore;\n  var bySeqStore;\n  var attachStore;\n  var attachAndSeqStore;\n  var metaStore;\n  var docInfoError;\n  var metaDoc;\n\n  for (var i = 0, len = docInfos.length; i < len; i++) {\n    var doc = docInfos[i];\n    if (doc._id && isLocalId(doc._id)) {\n      continue;\n    }\n    doc = docInfos[i] = parseDoc(doc, opts.new_edits);\n    if (doc.error && !docInfoError) {\n      docInfoError = doc;\n    }\n  }\n\n  if (docInfoError) {\n    return callback(docInfoError);\n  }\n\n  var allDocsProcessed = false;\n  var docCountDelta = 0;\n  var results = new Array(docInfos.length);\n  var fetchedDocs = new ExportedMap();\n  var preconditionErrored = false;\n  var blobType = api._meta.blobSupport ? 'blob' : 'base64';\n\n  preprocessAttachments(docInfos, blobType, function (err) {\n    if (err) {\n      return callback(err);\n    }\n    startTransaction();\n  });\n\n  function startTransaction() {\n\n    var stores = [\n      DOC_STORE, BY_SEQ_STORE,\n      ATTACH_STORE,\n      LOCAL_STORE, ATTACH_AND_SEQ_STORE,\n      META_STORE\n    ];\n    var txnResult = openTransactionSafely(idb, stores, 'readwrite');\n    if (txnResult.error) {\n      return callback(txnResult.error);\n    }\n    txn = txnResult.txn;\n    txn.onabort = idbError(callback);\n    txn.ontimeout = idbError(callback);\n    txn.oncomplete = complete;\n    docStore = txn.objectStore(DOC_STORE);\n    bySeqStore = txn.objectStore(BY_SEQ_STORE);\n    attachStore = txn.objectStore(ATTACH_STORE);\n    attachAndSeqStore = txn.objectStore(ATTACH_AND_SEQ_STORE);\n    metaStore = txn.objectStore(META_STORE);\n\n    metaStore.get(META_STORE).onsuccess = function (e) {\n      metaDoc = e.target.result;\n      updateDocCountIfReady();\n    };\n\n    verifyAttachments(function (err) {\n      if (err) {\n        preconditionErrored = true;\n        return callback(err);\n      }\n      fetchExistingDocs();\n    });\n  }\n\n  function onAllDocsProcessed() {\n    allDocsProcessed = true;\n    updateDocCountIfReady();\n  }\n\n  function idbProcessDocs() {\n    processDocs(dbOpts.revs_limit, docInfos, api, fetchedDocs,\n                txn, results, writeDoc, opts, onAllDocsProcessed);\n  }\n\n  function updateDocCountIfReady() {\n    if (!metaDoc || !allDocsProcessed) {\n      return;\n    }\n    // caching the docCount saves a lot of time in allDocs() and\n    // info(), which is why we go to all the trouble of doing this\n    metaDoc.docCount += docCountDelta;\n    metaStore.put(metaDoc);\n  }\n\n  function fetchExistingDocs() {\n\n    if (!docInfos.length) {\n      return;\n    }\n\n    var numFetched = 0;\n\n    function checkDone() {\n      if (++numFetched === docInfos.length) {\n        idbProcessDocs();\n      }\n    }\n\n    function readMetadata(event) {\n      var metadata = decodeMetadata(event.target.result);\n\n      if (metadata) {\n        fetchedDocs.set(metadata.id, metadata);\n      }\n      checkDone();\n    }\n\n    for (var i = 0, len = docInfos.length; i < len; i++) {\n      var docInfo = docInfos[i];\n      if (docInfo._id && isLocalId(docInfo._id)) {\n        checkDone(); // skip local docs\n        continue;\n      }\n      var req = docStore.get(docInfo.metadata.id);\n      req.onsuccess = readMetadata;\n    }\n  }\n\n  function complete() {\n    if (preconditionErrored) {\n      return;\n    }\n\n    changesHandler$$1.notify(api._meta.name);\n    callback(null, results);\n  }\n\n  function verifyAttachment(digest, callback) {\n\n    var req = attachStore.get(digest);\n    req.onsuccess = function (e) {\n      if (!e.target.result) {\n        var err = createError(MISSING_STUB,\n          'unknown stub attachment with digest ' +\n          digest);\n        err.status = 412;\n        callback(err);\n      } else {\n        callback();\n      }\n    };\n  }\n\n  function verifyAttachments(finish) {\n\n\n    var digests = [];\n    docInfos.forEach(function (docInfo) {\n      if (docInfo.data && docInfo.data._attachments) {\n        Object.keys(docInfo.data._attachments).forEach(function (filename) {\n          var att = docInfo.data._attachments[filename];\n          if (att.stub) {\n            digests.push(att.digest);\n          }\n        });\n      }\n    });\n    if (!digests.length) {\n      return finish();\n    }\n    var numDone = 0;\n    var err;\n\n    function checkDone() {\n      if (++numDone === digests.length) {\n        finish(err);\n      }\n    }\n    digests.forEach(function (digest) {\n      verifyAttachment(digest, function (attErr) {\n        if (attErr && !err) {\n          err = attErr;\n        }\n        checkDone();\n      });\n    });\n  }\n\n  function writeDoc(docInfo, winningRev$$1, winningRevIsDeleted, newRevIsDeleted,\n                    isUpdate, delta, resultsIdx, callback) {\n\n    docInfo.metadata.winningRev = winningRev$$1;\n    docInfo.metadata.deleted = winningRevIsDeleted;\n\n    var doc = docInfo.data;\n    doc._id = docInfo.metadata.id;\n    doc._rev = docInfo.metadata.rev;\n\n    if (newRevIsDeleted) {\n      doc._deleted = true;\n    }\n\n    var hasAttachments = doc._attachments &&\n      Object.keys(doc._attachments).length;\n    if (hasAttachments) {\n      return writeAttachments(docInfo, winningRev$$1, winningRevIsDeleted,\n        isUpdate, resultsIdx, callback);\n    }\n\n    docCountDelta += delta;\n    updateDocCountIfReady();\n\n    finishDoc(docInfo, winningRev$$1, winningRevIsDeleted,\n      isUpdate, resultsIdx, callback);\n  }\n\n  function finishDoc(docInfo, winningRev$$1, winningRevIsDeleted,\n                     isUpdate, resultsIdx, callback) {\n\n    var doc = docInfo.data;\n    var metadata = docInfo.metadata;\n\n    doc._doc_id_rev = metadata.id + '::' + metadata.rev;\n    delete doc._id;\n    delete doc._rev;\n\n    function afterPutDoc(e) {\n      var revsToDelete = docInfo.stemmedRevs || [];\n\n      if (isUpdate && api.auto_compaction) {\n        revsToDelete = revsToDelete.concat(compactTree(docInfo.metadata));\n      }\n\n      if (revsToDelete && revsToDelete.length) {\n        compactRevs(revsToDelete, docInfo.metadata.id, txn);\n      }\n\n      metadata.seq = e.target.result;\n      // Current _rev is calculated from _rev_tree on read\n      // delete metadata.rev;\n      var metadataToStore = encodeMetadata(metadata, winningRev$$1,\n        winningRevIsDeleted);\n      var metaDataReq = docStore.put(metadataToStore);\n      metaDataReq.onsuccess = afterPutMetadata;\n    }\n\n    function afterPutDocError(e) {\n      // ConstraintError, need to update, not put (see #1638 for details)\n      e.preventDefault(); // avoid transaction abort\n      e.stopPropagation(); // avoid transaction onerror\n      var index = bySeqStore.index('_doc_id_rev');\n      var getKeyReq = index.getKey(doc._doc_id_rev);\n      getKeyReq.onsuccess = function (e) {\n        var putReq = bySeqStore.put(doc, e.target.result);\n        putReq.onsuccess = afterPutDoc;\n      };\n    }\n\n    function afterPutMetadata() {\n      results[resultsIdx] = {\n        ok: true,\n        id: metadata.id,\n        rev: metadata.rev\n      };\n      fetchedDocs.set(docInfo.metadata.id, docInfo.metadata);\n      insertAttachmentMappings(docInfo, metadata.seq, callback);\n    }\n\n    var putReq = bySeqStore.put(doc);\n\n    putReq.onsuccess = afterPutDoc;\n    putReq.onerror = afterPutDocError;\n  }\n\n  function writeAttachments(docInfo, winningRev$$1, winningRevIsDeleted,\n                            isUpdate, resultsIdx, callback) {\n\n\n    var doc = docInfo.data;\n\n    var numDone = 0;\n    var attachments = Object.keys(doc._attachments);\n\n    function collectResults() {\n      if (numDone === attachments.length) {\n        finishDoc(docInfo, winningRev$$1, winningRevIsDeleted,\n          isUpdate, resultsIdx, callback);\n      }\n    }\n\n    function attachmentSaved() {\n      numDone++;\n      collectResults();\n    }\n\n    attachments.forEach(function (key) {\n      var att = docInfo.data._attachments[key];\n      if (!att.stub) {\n        var data = att.data;\n        delete att.data;\n        att.revpos = parseInt(winningRev$$1, 10);\n        var digest = att.digest;\n        saveAttachment(digest, data, attachmentSaved);\n      } else {\n        numDone++;\n        collectResults();\n      }\n    });\n  }\n\n  // map seqs to attachment digests, which\n  // we will need later during compaction\n  function insertAttachmentMappings(docInfo, seq, callback) {\n\n    var attsAdded = 0;\n    var attsToAdd = Object.keys(docInfo.data._attachments || {});\n\n    if (!attsToAdd.length) {\n      return callback();\n    }\n\n    function checkDone() {\n      if (++attsAdded === attsToAdd.length) {\n        callback();\n      }\n    }\n\n    function add(att) {\n      var digest = docInfo.data._attachments[att].digest;\n      var req = attachAndSeqStore.put({\n        seq: seq,\n        digestSeq: digest + '::' + seq\n      });\n\n      req.onsuccess = checkDone;\n      req.onerror = function (e) {\n        // this callback is for a constaint error, which we ignore\n        // because this docid/rev has already been associated with\n        // the digest (e.g. when new_edits == false)\n        e.preventDefault(); // avoid transaction abort\n        e.stopPropagation(); // avoid transaction onerror\n        checkDone();\n      };\n    }\n    for (var i = 0; i < attsToAdd.length; i++) {\n      add(attsToAdd[i]); // do in parallel\n    }\n  }\n\n  function saveAttachment(digest, data, callback) {\n\n\n    var getKeyReq = attachStore.count(digest);\n    getKeyReq.onsuccess = function (e) {\n      var count = e.target.result;\n      if (count) {\n        return callback(); // already exists\n      }\n      var newAtt = {\n        digest: digest,\n        body: data\n      };\n      var putReq = attachStore.put(newAtt);\n      putReq.onsuccess = callback;\n    };\n  }\n}\n\n// Abstraction over IDBCursor and getAll()/getAllKeys() that allows us to batch our operations\n// while falling back to a normal IDBCursor operation on browsers that don't support getAll() or\n// getAllKeys(). This allows for a much faster implementation than just straight-up cursors, because\n// we're not processing each document one-at-a-time.\nfunction runBatchedCursor(objectStore, keyRange, descending, batchSize, onBatch) {\n\n  // Bail out of getAll()/getAllKeys() in the following cases:\n  // 1) either method is unsupported - we need both\n  // 2) batchSize is 1 (might as well use IDBCursor), or batchSize is -1 (i.e. batchSize unlimited,\n  //    not really clear the user wants a batched approach where the entire DB is read into memory,\n  //    perhaps they are filtering on a per-doc basis)\n  // 3) descending – no real way to do this via getAll()/getAllKeys()\n\n  var useGetAll = typeof objectStore.getAll === 'function' &&\n    typeof objectStore.getAllKeys === 'function' &&\n    batchSize > 1 && !descending;\n\n  var keysBatch;\n  var valuesBatch;\n  var pseudoCursor;\n\n  function onGetAll(e) {\n    valuesBatch = e.target.result;\n    if (keysBatch) {\n      onBatch(keysBatch, valuesBatch, pseudoCursor);\n    }\n  }\n\n  function onGetAllKeys(e) {\n    keysBatch = e.target.result;\n    if (valuesBatch) {\n      onBatch(keysBatch, valuesBatch, pseudoCursor);\n    }\n  }\n\n  function continuePseudoCursor() {\n    if (!keysBatch.length) { // no more results\n      return onBatch();\n    }\n    // fetch next batch, exclusive start\n    var lastKey = keysBatch[keysBatch.length - 1];\n    var newKeyRange;\n    if (keyRange && keyRange.upper) {\n      try {\n        newKeyRange = IDBKeyRange.bound(lastKey, keyRange.upper,\n          true, keyRange.upperOpen);\n      } catch (e) {\n        if (e.name === \"DataError\" && e.code === 0) {\n          return onBatch(); // we're done, startkey and endkey are equal\n        }\n      }\n    } else {\n      newKeyRange = IDBKeyRange.lowerBound(lastKey, true);\n    }\n    keyRange = newKeyRange;\n    keysBatch = null;\n    valuesBatch = null;\n    objectStore.getAll(keyRange, batchSize).onsuccess = onGetAll;\n    objectStore.getAllKeys(keyRange, batchSize).onsuccess = onGetAllKeys;\n  }\n\n  function onCursor(e) {\n    var cursor = e.target.result;\n    if (!cursor) { // done\n      return onBatch();\n    }\n    // regular IDBCursor acts like a batch where batch size is always 1\n    onBatch([cursor.key], [cursor.value], cursor);\n  }\n\n  if (useGetAll) {\n    pseudoCursor = {\"continue\": continuePseudoCursor};\n    objectStore.getAll(keyRange, batchSize).onsuccess = onGetAll;\n    objectStore.getAllKeys(keyRange, batchSize).onsuccess = onGetAllKeys;\n  } else if (descending) {\n    objectStore.openCursor(keyRange, 'prev').onsuccess = onCursor;\n  } else {\n    objectStore.openCursor(keyRange).onsuccess = onCursor;\n  }\n}\n\n// simple shim for objectStore.getAll(), falling back to IDBCursor\nfunction getAll(objectStore, keyRange, onSuccess) {\n  if (typeof objectStore.getAll === 'function') {\n    // use native getAll\n    objectStore.getAll(keyRange).onsuccess = onSuccess;\n    return;\n  }\n  // fall back to cursors\n  var values = [];\n\n  function onCursor(e) {\n    var cursor = e.target.result;\n    if (cursor) {\n      values.push(cursor.value);\n      cursor[\"continue\"]();\n    } else {\n      onSuccess({\n        target: {\n          result: values\n        }\n      });\n    }\n  }\n\n  objectStore.openCursor(keyRange).onsuccess = onCursor;\n}\n\nfunction allDocsKeys(keys, docStore, onBatch) {\n  // It's not guaranted to be returned in right order  \n  var valuesBatch = [];\n  var count = 0;\n  keys.forEach(function (key, index) {\n    docStore.get(key).onsuccess = function (event) {\n      if (event.target.result) {\n        valuesBatch[index] = event.target.result;\n      } else {\n        valuesBatch[index] = {key: key, error: 'not_found'};\n      }\n      count++;\n      if (count === keys.length) {\n        onBatch(keys, valuesBatch, {});\n      }\n    };\n  });\n}\n\nfunction createKeyRange(start, end, inclusiveEnd, key, descending) {\n  try {\n    if (start && end) {\n      if (descending) {\n        return IDBKeyRange.bound(end, start, !inclusiveEnd, false);\n      } else {\n        return IDBKeyRange.bound(start, end, false, !inclusiveEnd);\n      }\n    } else if (start) {\n      if (descending) {\n        return IDBKeyRange.upperBound(start);\n      } else {\n        return IDBKeyRange.lowerBound(start);\n      }\n    } else if (end) {\n      if (descending) {\n        return IDBKeyRange.lowerBound(end, !inclusiveEnd);\n      } else {\n        return IDBKeyRange.upperBound(end, !inclusiveEnd);\n      }\n    } else if (key) {\n      return IDBKeyRange.only(key);\n    }\n  } catch (e) {\n    return {error: e};\n  }\n  return null;\n}\n\nfunction idbAllDocs(opts, idb, callback) {\n  var start = 'startkey' in opts ? opts.startkey : false;\n  var end = 'endkey' in opts ? opts.endkey : false;\n  var key = 'key' in opts ? opts.key : false;\n  var keys = 'keys' in opts ? opts.keys : false; \n  var skip = opts.skip || 0;\n  var limit = typeof opts.limit === 'number' ? opts.limit : -1;\n  var inclusiveEnd = opts.inclusive_end !== false;\n\n  var keyRange; \n  var keyRangeError;\n  if (!keys) {\n    keyRange = createKeyRange(start, end, inclusiveEnd, key, opts.descending);\n    keyRangeError = keyRange && keyRange.error;\n    if (keyRangeError && \n      !(keyRangeError.name === \"DataError\" && keyRangeError.code === 0)) {\n      // DataError with error code 0 indicates start is less than end, so\n      // can just do an empty query. Else need to throw\n      return callback(createError(IDB_ERROR,\n        keyRangeError.name, keyRangeError.message));\n    }\n  }\n\n  var stores = [DOC_STORE, BY_SEQ_STORE, META_STORE];\n\n  if (opts.attachments) {\n    stores.push(ATTACH_STORE);\n  }\n  var txnResult = openTransactionSafely(idb, stores, 'readonly');\n  if (txnResult.error) {\n    return callback(txnResult.error);\n  }\n  var txn = txnResult.txn;\n  txn.oncomplete = onTxnComplete;\n  txn.onabort = idbError(callback);\n  var docStore = txn.objectStore(DOC_STORE);\n  var seqStore = txn.objectStore(BY_SEQ_STORE);\n  var metaStore = txn.objectStore(META_STORE);\n  var docIdRevIndex = seqStore.index('_doc_id_rev');\n  var results = [];\n  var docCount;\n  var updateSeq;\n\n  metaStore.get(META_STORE).onsuccess = function (e) {\n    docCount = e.target.result.docCount;\n  };\n\n  /* istanbul ignore if */\n  if (opts.update_seq) {\n    getMaxUpdateSeq(seqStore, function (e) { \n      if (e.target.result && e.target.result.length > 0) {\n        updateSeq = e.target.result[0];\n      }\n    });\n  }\n\n  function getMaxUpdateSeq(objectStore, onSuccess) {\n    function onCursor(e) {\n      var cursor = e.target.result;\n      var maxKey = undefined;\n      if (cursor && cursor.key) {\n        maxKey = cursor.key;\n      } \n      return onSuccess({\n        target: {\n          result: [maxKey]\n        }\n      });\n    }\n    objectStore.openCursor(null, 'prev').onsuccess = onCursor;\n  }\n\n  // if the user specifies include_docs=true, then we don't\n  // want to block the main cursor while we're fetching the doc\n  function fetchDocAsynchronously(metadata, row, winningRev$$1) {\n    var key = metadata.id + \"::\" + winningRev$$1;\n    docIdRevIndex.get(key).onsuccess =  function onGetDoc(e) {\n      row.doc = decodeDoc(e.target.result);\n      if (opts.conflicts) {\n        var conflicts = collectConflicts(metadata);\n        if (conflicts.length) {\n          row.doc._conflicts = conflicts;\n        }\n      }\n      fetchAttachmentsIfNecessary(row.doc, opts, txn);\n    };\n  }\n\n  function allDocsInner(winningRev$$1, metadata) {\n    var row = {\n      id: metadata.id,\n      key: metadata.id,\n      value: {\n        rev: winningRev$$1\n      }\n    };\n    var deleted = metadata.deleted;\n    if (deleted) {\n      if (keys) {\n        results.push(row);\n        // deleted docs are okay with \"keys\" requests\n        row.value.deleted = true;\n        row.doc = null;\n      }\n    } else if (skip-- <= 0) {\n      results.push(row);\n      if (opts.include_docs) {\n        fetchDocAsynchronously(metadata, row, winningRev$$1);\n      }\n    }\n  }\n\n  function processBatch(batchValues) {\n    for (var i = 0, len = batchValues.length; i < len; i++) {\n      if (results.length === limit) {\n        break;\n      }\n      var batchValue = batchValues[i];\n      if (batchValue.error && keys) {\n        // key was not found with \"keys\" requests\n        results.push(batchValue);\n        continue;\n      }\n      var metadata = decodeMetadata(batchValue);\n      var winningRev$$1 = metadata.winningRev;\n      allDocsInner(winningRev$$1, metadata);\n    }\n  }\n\n  function onBatch(batchKeys, batchValues, cursor) {\n    if (!cursor) {\n      return;\n    }\n    processBatch(batchValues);\n    if (results.length < limit) {\n      cursor[\"continue\"]();\n    }\n  }\n\n  function onGetAll(e) {\n    var values = e.target.result;\n    if (opts.descending) {\n      values = values.reverse();\n    }\n    processBatch(values);\n  }\n\n  function onResultsReady() {\n    var returnVal = {\n      total_rows: docCount,\n      offset: opts.skip,\n      rows: results\n    };\n    \n    /* istanbul ignore if */\n    if (opts.update_seq && updateSeq !== undefined) {\n      returnVal.update_seq = updateSeq;\n    }\n    callback(null, returnVal);\n  }\n\n  function onTxnComplete() {\n    if (opts.attachments) {\n      postProcessAttachments(results, opts.binary).then(onResultsReady);\n    } else {\n      onResultsReady();\n    }\n  }\n\n  // don't bother doing any requests if start > end or limit === 0\n  if (keyRangeError || limit === 0) {\n    return;\n  }\n  if (keys) {\n    return allDocsKeys(opts.keys, docStore, onBatch);\n  }\n  if (limit === -1) { // just fetch everything\n    return getAll(docStore, keyRange, onGetAll);\n  }\n  // else do a cursor\n  // choose a batch size based on the skip, since we'll need to skip that many\n  runBatchedCursor(docStore, keyRange, opts.descending, limit + skip, onBatch);\n}\n\n//\n// Blobs are not supported in all versions of IndexedDB, notably\n// Chrome <37 and Android <5. In those versions, storing a blob will throw.\n//\n// Various other blob bugs exist in Chrome v37-42 (inclusive).\n// Detecting them is expensive and confusing to users, and Chrome 37-42\n// is at very low usage worldwide, so we do a hacky userAgent check instead.\n//\n// content-type bug: https://code.google.com/p/chromium/issues/detail?id=408120\n// 404 bug: https://code.google.com/p/chromium/issues/detail?id=447916\n// FileReader bug: https://code.google.com/p/chromium/issues/detail?id=447836\n//\nfunction checkBlobSupport(txn) {\n  return new PouchPromise(function (resolve) {\n    var blob$$1 = createBlob(['']);\n    var req = txn.objectStore(DETECT_BLOB_SUPPORT_STORE).put(blob$$1, 'key');\n\n    req.onsuccess = function () {\n      var matchedChrome = navigator.userAgent.match(/Chrome\\/(\\d+)/);\n      var matchedEdge = navigator.userAgent.match(/Edge\\//);\n      // MS Edge pretends to be Chrome 42:\n      // https://msdn.microsoft.com/en-us/library/hh869301%28v=vs.85%29.aspx\n      resolve(matchedEdge || !matchedChrome ||\n        parseInt(matchedChrome[1], 10) >= 43);\n    };\n\n    txn.onabort = function (e) {\n      // If the transaction aborts now its due to not being able to\n      // write to the database, likely due to the disk being full\n      e.preventDefault();\n      e.stopPropagation();\n      resolve(false);\n    };\n  })[\"catch\"](function () {\n    return false; // error, so assume unsupported\n  });\n}\n\nfunction countDocs(txn, cb) {\n  var index = txn.objectStore(DOC_STORE).index('deletedOrLocal');\n  index.count(IDBKeyRange.only('0')).onsuccess = function (e) {\n    cb(e.target.result);\n  };\n}\n\n// This task queue ensures that IDB open calls are done in their own tick\n// and sequentially - i.e. we wait for the async IDB open to *fully* complete\n// before calling the next one. This works around IE/Edge race conditions in IDB.\n\nvar running = false;\nvar queue = [];\n\nfunction tryCode(fun, err, res, PouchDB) {\n  try {\n    fun(err, res);\n  } catch (err) {\n    // Shouldn't happen, but in some odd cases\n    // IndexedDB implementations might throw a sync\n    // error, in which case this will at least log it.\n    PouchDB.emit('error', err);\n  }\n}\n\nfunction applyNext() {\n  if (running || !queue.length) {\n    return;\n  }\n  running = true;\n  queue.shift()();\n}\n\nfunction enqueueTask(action, callback, PouchDB) {\n  queue.push(function runAction() {\n    action(function runCallback(err, res) {\n      tryCode(callback, err, res, PouchDB);\n      running = false;\n      nextTick(function runNext() {\n        applyNext(PouchDB);\n      });\n    });\n  });\n  applyNext();\n}\n\nfunction changes(opts, api, dbName, idb) {\n  opts = clone(opts);\n\n  if (opts.continuous) {\n    var id = dbName + ':' + uuid();\n    changesHandler$$1.addListener(dbName, id, api, opts);\n    changesHandler$$1.notify(dbName);\n    return {\n      cancel: function () {\n        changesHandler$$1.removeListener(dbName, id);\n      }\n    };\n  }\n\n  var docIds = opts.doc_ids && new ExportedSet(opts.doc_ids);\n\n  opts.since = opts.since || 0;\n  var lastSeq = opts.since;\n\n  var limit = 'limit' in opts ? opts.limit : -1;\n  if (limit === 0) {\n    limit = 1; // per CouchDB _changes spec\n  }\n  var returnDocs;\n  if ('return_docs' in opts) {\n    returnDocs = opts.return_docs;\n  } else if ('returnDocs' in opts) {\n    // TODO: Remove 'returnDocs' in favor of 'return_docs' in a future release\n    returnDocs = opts.returnDocs;\n  } else {\n    returnDocs = true;\n  }\n\n  var results = [];\n  var numResults = 0;\n  var filter = filterChange(opts);\n  var docIdsToMetadata = new ExportedMap();\n\n  var txn;\n  var bySeqStore;\n  var docStore;\n  var docIdRevIndex;\n\n  function onBatch(batchKeys, batchValues, cursor) {\n    if (!cursor || !batchKeys.length) { // done\n      return;\n    }\n\n    var winningDocs = new Array(batchKeys.length);\n    var metadatas = new Array(batchKeys.length);\n\n    function processMetadataAndWinningDoc(metadata, winningDoc) {\n      var change = opts.processChange(winningDoc, metadata, opts);\n      lastSeq = change.seq = metadata.seq;\n\n      var filtered = filter(change);\n      if (typeof filtered === 'object') { // anything but true/false indicates error\n        return opts.complete(filtered);\n      }\n\n      if (filtered) {\n        numResults++;\n        if (returnDocs) {\n          results.push(change);\n        }\n        // process the attachment immediately\n        // for the benefit of live listeners\n        if (opts.attachments && opts.include_docs) {\n          fetchAttachmentsIfNecessary(winningDoc, opts, txn, function () {\n            postProcessAttachments([change], opts.binary).then(function () {\n              opts.onChange(change);\n            });\n          });\n        } else {\n          opts.onChange(change);\n        }\n      }\n    }\n\n    function onBatchDone() {\n      for (var i = 0, len = winningDocs.length; i < len; i++) {\n        if (numResults === limit) {\n          break;\n        }\n        var winningDoc = winningDocs[i];\n        if (!winningDoc) {\n          continue;\n        }\n        var metadata = metadatas[i];\n        processMetadataAndWinningDoc(metadata, winningDoc);\n      }\n\n      if (numResults !== limit) {\n        cursor[\"continue\"]();\n      }\n    }\n\n    // Fetch all metadatas/winningdocs from this batch in parallel, then process\n    // them all only once all data has been collected. This is done in parallel\n    // because it's faster than doing it one-at-a-time.\n    var numDone = 0;\n    batchValues.forEach(function (value, i) {\n      var doc = decodeDoc(value);\n      var seq = batchKeys[i];\n      fetchWinningDocAndMetadata(doc, seq, function (metadata, winningDoc) {\n        metadatas[i] = metadata;\n        winningDocs[i] = winningDoc;\n        if (++numDone === batchKeys.length) {\n          onBatchDone();\n        }\n      });\n    });\n  }\n\n  function onGetMetadata(doc, seq, metadata, cb) {\n    if (metadata.seq !== seq) {\n      // some other seq is later\n      return cb();\n    }\n\n    if (metadata.winningRev === doc._rev) {\n      // this is the winning doc\n      return cb(metadata, doc);\n    }\n\n    // fetch winning doc in separate request\n    var docIdRev = doc._id + '::' + metadata.winningRev;\n    var req = docIdRevIndex.get(docIdRev);\n    req.onsuccess = function (e) {\n      cb(metadata, decodeDoc(e.target.result));\n    };\n  }\n\n  function fetchWinningDocAndMetadata(doc, seq, cb) {\n    if (docIds && !docIds.has(doc._id)) {\n      return cb();\n    }\n\n    var metadata = docIdsToMetadata.get(doc._id);\n    if (metadata) { // cached\n      return onGetMetadata(doc, seq, metadata, cb);\n    }\n    // metadata not cached, have to go fetch it\n    docStore.get(doc._id).onsuccess = function (e) {\n      metadata = decodeMetadata(e.target.result);\n      docIdsToMetadata.set(doc._id, metadata);\n      onGetMetadata(doc, seq, metadata, cb);\n    };\n  }\n\n  function finish() {\n    opts.complete(null, {\n      results: results,\n      last_seq: lastSeq\n    });\n  }\n\n  function onTxnComplete() {\n    if (!opts.continuous && opts.attachments) {\n      // cannot guarantee that postProcessing was already done,\n      // so do it again\n      postProcessAttachments(results).then(finish);\n    } else {\n      finish();\n    }\n  }\n\n  var objectStores = [DOC_STORE, BY_SEQ_STORE];\n  if (opts.attachments) {\n    objectStores.push(ATTACH_STORE);\n  }\n  var txnResult = openTransactionSafely(idb, objectStores, 'readonly');\n  if (txnResult.error) {\n    return opts.complete(txnResult.error);\n  }\n  txn = txnResult.txn;\n  txn.onabort = idbError(opts.complete);\n  txn.oncomplete = onTxnComplete;\n\n  bySeqStore = txn.objectStore(BY_SEQ_STORE);\n  docStore = txn.objectStore(DOC_STORE);\n  docIdRevIndex = bySeqStore.index('_doc_id_rev');\n\n  var keyRange = (opts.since && !opts.descending) ?\n    IDBKeyRange.lowerBound(opts.since, true) : null;\n\n  runBatchedCursor(bySeqStore, keyRange, opts.descending, limit, onBatch);\n}\n\nvar cachedDBs = new ExportedMap();\nvar blobSupportPromise;\nvar openReqList = new ExportedMap();\n\nfunction IdbPouch(opts, callback) {\n  var api = this;\n\n  enqueueTask(function (thisCallback) {\n    init(api, opts, thisCallback);\n  }, callback, api.constructor);\n}\n\nfunction init(api, opts, callback) {\n\n  var dbName = opts.name;\n\n  var idb = null;\n  api._meta = null;\n\n  // called when creating a fresh new database\n  function createSchema(db) {\n    var docStore = db.createObjectStore(DOC_STORE, {keyPath : 'id'});\n    db.createObjectStore(BY_SEQ_STORE, {autoIncrement: true})\n      .createIndex('_doc_id_rev', '_doc_id_rev', {unique: true});\n    db.createObjectStore(ATTACH_STORE, {keyPath: 'digest'});\n    db.createObjectStore(META_STORE, {keyPath: 'id', autoIncrement: false});\n    db.createObjectStore(DETECT_BLOB_SUPPORT_STORE);\n\n    // added in v2\n    docStore.createIndex('deletedOrLocal', 'deletedOrLocal', {unique : false});\n\n    // added in v3\n    db.createObjectStore(LOCAL_STORE, {keyPath: '_id'});\n\n    // added in v4\n    var attAndSeqStore = db.createObjectStore(ATTACH_AND_SEQ_STORE,\n      {autoIncrement: true});\n    attAndSeqStore.createIndex('seq', 'seq');\n    attAndSeqStore.createIndex('digestSeq', 'digestSeq', {unique: true});\n  }\n\n  // migration to version 2\n  // unfortunately \"deletedOrLocal\" is a misnomer now that we no longer\n  // store local docs in the main doc-store, but whaddyagonnado\n  function addDeletedOrLocalIndex(txn, callback) {\n    var docStore = txn.objectStore(DOC_STORE);\n    docStore.createIndex('deletedOrLocal', 'deletedOrLocal', {unique : false});\n\n    docStore.openCursor().onsuccess = function (event) {\n      var cursor = event.target.result;\n      if (cursor) {\n        var metadata = cursor.value;\n        var deleted = isDeleted(metadata);\n        metadata.deletedOrLocal = deleted ? \"1\" : \"0\";\n        docStore.put(metadata);\n        cursor[\"continue\"]();\n      } else {\n        callback();\n      }\n    };\n  }\n\n  // migration to version 3 (part 1)\n  function createLocalStoreSchema(db) {\n    db.createObjectStore(LOCAL_STORE, {keyPath: '_id'})\n      .createIndex('_doc_id_rev', '_doc_id_rev', {unique: true});\n  }\n\n  // migration to version 3 (part 2)\n  function migrateLocalStore(txn, cb) {\n    var localStore = txn.objectStore(LOCAL_STORE);\n    var docStore = txn.objectStore(DOC_STORE);\n    var seqStore = txn.objectStore(BY_SEQ_STORE);\n\n    var cursor = docStore.openCursor();\n    cursor.onsuccess = function (event) {\n      var cursor = event.target.result;\n      if (cursor) {\n        var metadata = cursor.value;\n        var docId = metadata.id;\n        var local = isLocalId(docId);\n        var rev$$1 = winningRev(metadata);\n        if (local) {\n          var docIdRev = docId + \"::\" + rev$$1;\n          // remove all seq entries\n          // associated with this docId\n          var start = docId + \"::\";\n          var end = docId + \"::~\";\n          var index = seqStore.index('_doc_id_rev');\n          var range = IDBKeyRange.bound(start, end, false, false);\n          var seqCursor = index.openCursor(range);\n          seqCursor.onsuccess = function (e) {\n            seqCursor = e.target.result;\n            if (!seqCursor) {\n              // done\n              docStore[\"delete\"](cursor.primaryKey);\n              cursor[\"continue\"]();\n            } else {\n              var data = seqCursor.value;\n              if (data._doc_id_rev === docIdRev) {\n                localStore.put(data);\n              }\n              seqStore[\"delete\"](seqCursor.primaryKey);\n              seqCursor[\"continue\"]();\n            }\n          };\n        } else {\n          cursor[\"continue\"]();\n        }\n      } else if (cb) {\n        cb();\n      }\n    };\n  }\n\n  // migration to version 4 (part 1)\n  function addAttachAndSeqStore(db) {\n    var attAndSeqStore = db.createObjectStore(ATTACH_AND_SEQ_STORE,\n      {autoIncrement: true});\n    attAndSeqStore.createIndex('seq', 'seq');\n    attAndSeqStore.createIndex('digestSeq', 'digestSeq', {unique: true});\n  }\n\n  // migration to version 4 (part 2)\n  function migrateAttsAndSeqs(txn, callback) {\n    var seqStore = txn.objectStore(BY_SEQ_STORE);\n    var attStore = txn.objectStore(ATTACH_STORE);\n    var attAndSeqStore = txn.objectStore(ATTACH_AND_SEQ_STORE);\n\n    // need to actually populate the table. this is the expensive part,\n    // so as an optimization, check first that this database even\n    // contains attachments\n    var req = attStore.count();\n    req.onsuccess = function (e) {\n      var count = e.target.result;\n      if (!count) {\n        return callback(); // done\n      }\n\n      seqStore.openCursor().onsuccess = function (e) {\n        var cursor = e.target.result;\n        if (!cursor) {\n          return callback(); // done\n        }\n        var doc = cursor.value;\n        var seq = cursor.primaryKey;\n        var atts = Object.keys(doc._attachments || {});\n        var digestMap = {};\n        for (var j = 0; j < atts.length; j++) {\n          var att = doc._attachments[atts[j]];\n          digestMap[att.digest] = true; // uniq digests, just in case\n        }\n        var digests = Object.keys(digestMap);\n        for (j = 0; j < digests.length; j++) {\n          var digest = digests[j];\n          attAndSeqStore.put({\n            seq: seq,\n            digestSeq: digest + '::' + seq\n          });\n        }\n        cursor[\"continue\"]();\n      };\n    };\n  }\n\n  // migration to version 5\n  // Instead of relying on on-the-fly migration of metadata,\n  // this brings the doc-store to its modern form:\n  // - metadata.winningrev\n  // - metadata.seq\n  // - stringify the metadata when storing it\n  function migrateMetadata(txn) {\n\n    function decodeMetadataCompat(storedObject) {\n      if (!storedObject.data) {\n        // old format, when we didn't store it stringified\n        storedObject.deleted = storedObject.deletedOrLocal === '1';\n        return storedObject;\n      }\n      return decodeMetadata(storedObject);\n    }\n\n    // ensure that every metadata has a winningRev and seq,\n    // which was previously created on-the-fly but better to migrate\n    var bySeqStore = txn.objectStore(BY_SEQ_STORE);\n    var docStore = txn.objectStore(DOC_STORE);\n    var cursor = docStore.openCursor();\n    cursor.onsuccess = function (e) {\n      var cursor = e.target.result;\n      if (!cursor) {\n        return; // done\n      }\n      var metadata = decodeMetadataCompat(cursor.value);\n\n      metadata.winningRev = metadata.winningRev ||\n        winningRev(metadata);\n\n      function fetchMetadataSeq() {\n        // metadata.seq was added post-3.2.0, so if it's missing,\n        // we need to fetch it manually\n        var start = metadata.id + '::';\n        var end = metadata.id + '::\\uffff';\n        var req = bySeqStore.index('_doc_id_rev').openCursor(\n          IDBKeyRange.bound(start, end));\n\n        var metadataSeq = 0;\n        req.onsuccess = function (e) {\n          var cursor = e.target.result;\n          if (!cursor) {\n            metadata.seq = metadataSeq;\n            return onGetMetadataSeq();\n          }\n          var seq = cursor.primaryKey;\n          if (seq > metadataSeq) {\n            metadataSeq = seq;\n          }\n          cursor[\"continue\"]();\n        };\n      }\n\n      function onGetMetadataSeq() {\n        var metadataToStore = encodeMetadata(metadata,\n          metadata.winningRev, metadata.deleted);\n\n        var req = docStore.put(metadataToStore);\n        req.onsuccess = function () {\n          cursor[\"continue\"]();\n        };\n      }\n\n      if (metadata.seq) {\n        return onGetMetadataSeq();\n      }\n\n      fetchMetadataSeq();\n    };\n\n  }\n\n  api._remote = false;\n  api.type = function () {\n    return 'idb';\n  };\n\n  api._id = toPromise(function (callback) {\n    callback(null, api._meta.instanceId);\n  });\n\n  api._bulkDocs = function idb_bulkDocs(req, reqOpts, callback) {\n    idbBulkDocs(opts, req, reqOpts, api, idb, callback);\n  };\n\n  // First we look up the metadata in the ids database, then we fetch the\n  // current revision(s) from the by sequence store\n  api._get = function idb_get(id, opts, callback) {\n    var doc;\n    var metadata;\n    var err;\n    var txn = opts.ctx;\n    if (!txn) {\n      var txnResult = openTransactionSafely(idb,\n        [DOC_STORE, BY_SEQ_STORE, ATTACH_STORE], 'readonly');\n      if (txnResult.error) {\n        return callback(txnResult.error);\n      }\n      txn = txnResult.txn;\n    }\n\n    function finish() {\n      callback(err, {doc: doc, metadata: metadata, ctx: txn});\n    }\n\n    txn.objectStore(DOC_STORE).get(id).onsuccess = function (e) {\n      metadata = decodeMetadata(e.target.result);\n      // we can determine the result here if:\n      // 1. there is no such document\n      // 2. the document is deleted and we don't ask about specific rev\n      // When we ask with opts.rev we expect the answer to be either\n      // doc (possibly with _deleted=true) or missing error\n      if (!metadata) {\n        err = createError(MISSING_DOC, 'missing');\n        return finish();\n      }\n\n      var rev$$1;\n      if (!opts.rev) {\n        rev$$1 = metadata.winningRev;\n        var deleted = isDeleted(metadata);\n        if (deleted) {\n          err = createError(MISSING_DOC, \"deleted\");\n          return finish();\n        }\n      } else {\n        rev$$1 = opts.latest ? latest(opts.rev, metadata) : opts.rev;\n      }\n\n      var objectStore = txn.objectStore(BY_SEQ_STORE);\n      var key = metadata.id + '::' + rev$$1;\n\n      objectStore.index('_doc_id_rev').get(key).onsuccess = function (e) {\n        doc = e.target.result;\n        if (doc) {\n          doc = decodeDoc(doc);\n        }\n        if (!doc) {\n          err = createError(MISSING_DOC, 'missing');\n          return finish();\n        }\n        finish();\n      };\n    };\n  };\n\n  api._getAttachment = function (docId, attachId, attachment, opts, callback) {\n    var txn;\n    if (opts.ctx) {\n      txn = opts.ctx;\n    } else {\n      var txnResult = openTransactionSafely(idb,\n        [DOC_STORE, BY_SEQ_STORE, ATTACH_STORE], 'readonly');\n      if (txnResult.error) {\n        return callback(txnResult.error);\n      }\n      txn = txnResult.txn;\n    }\n    var digest = attachment.digest;\n    var type = attachment.content_type;\n\n    txn.objectStore(ATTACH_STORE).get(digest).onsuccess = function (e) {\n      var body = e.target.result.body;\n      readBlobData(body, type, opts.binary, function (blobData) {\n        callback(null, blobData);\n      });\n    };\n  };\n\n  api._info = function idb_info(callback) {\n    var updateSeq;\n    var docCount;\n\n    var txnResult = openTransactionSafely(idb, [META_STORE, BY_SEQ_STORE], 'readonly');\n    if (txnResult.error) {\n      return callback(txnResult.error);\n    }\n    var txn = txnResult.txn;\n    txn.objectStore(META_STORE).get(META_STORE).onsuccess = function (e) {\n      docCount = e.target.result.docCount;\n    };\n    txn.objectStore(BY_SEQ_STORE).openCursor(null, 'prev').onsuccess = function (e) {\n      var cursor = e.target.result;\n      updateSeq = cursor ? cursor.key : 0;\n    };\n\n    txn.oncomplete = function () {\n      callback(null, {\n        doc_count: docCount,\n        update_seq: updateSeq,\n        // for debugging\n        idb_attachment_format: (api._meta.blobSupport ? 'binary' : 'base64')\n      });\n    };\n  };\n\n  api._allDocs = function idb_allDocs(opts, callback) {\n    idbAllDocs(opts, idb, callback);\n  };\n\n  api._changes = function idbChanges(opts) {\n    return changes(opts, api, dbName, idb);\n  };\n\n  api._close = function (callback) {\n    // https://developer.mozilla.org/en-US/docs/IndexedDB/IDBDatabase#close\n    // \"Returns immediately and closes the connection in a separate thread...\"\n    idb.close();\n    cachedDBs[\"delete\"](dbName);\n    callback();\n  };\n\n  api._getRevisionTree = function (docId, callback) {\n    var txnResult = openTransactionSafely(idb, [DOC_STORE], 'readonly');\n    if (txnResult.error) {\n      return callback(txnResult.error);\n    }\n    var txn = txnResult.txn;\n    var req = txn.objectStore(DOC_STORE).get(docId);\n    req.onsuccess = function (event) {\n      var doc = decodeMetadata(event.target.result);\n      if (!doc) {\n        callback(createError(MISSING_DOC));\n      } else {\n        callback(null, doc.rev_tree);\n      }\n    };\n  };\n\n  // This function removes revisions of document docId\n  // which are listed in revs and sets this document\n  // revision to to rev_tree\n  api._doCompaction = function (docId, revs, callback) {\n    var stores = [\n      DOC_STORE,\n      BY_SEQ_STORE,\n      ATTACH_STORE,\n      ATTACH_AND_SEQ_STORE\n    ];\n    var txnResult = openTransactionSafely(idb, stores, 'readwrite');\n    if (txnResult.error) {\n      return callback(txnResult.error);\n    }\n    var txn = txnResult.txn;\n\n    var docStore = txn.objectStore(DOC_STORE);\n\n    docStore.get(docId).onsuccess = function (event) {\n      var metadata = decodeMetadata(event.target.result);\n      traverseRevTree(metadata.rev_tree, function (isLeaf, pos,\n                                                         revHash, ctx, opts) {\n        var rev$$1 = pos + '-' + revHash;\n        if (revs.indexOf(rev$$1) !== -1) {\n          opts.status = 'missing';\n        }\n      });\n      compactRevs(revs, docId, txn);\n      var winningRev$$1 = metadata.winningRev;\n      var deleted = metadata.deleted;\n      txn.objectStore(DOC_STORE).put(\n        encodeMetadata(metadata, winningRev$$1, deleted));\n    };\n    txn.onabort = idbError(callback);\n    txn.oncomplete = function () {\n      callback();\n    };\n  };\n\n\n  api._getLocal = function (id, callback) {\n    var txnResult = openTransactionSafely(idb, [LOCAL_STORE], 'readonly');\n    if (txnResult.error) {\n      return callback(txnResult.error);\n    }\n    var tx = txnResult.txn;\n    var req = tx.objectStore(LOCAL_STORE).get(id);\n\n    req.onerror = idbError(callback);\n    req.onsuccess = function (e) {\n      var doc = e.target.result;\n      if (!doc) {\n        callback(createError(MISSING_DOC));\n      } else {\n        delete doc['_doc_id_rev']; // for backwards compat\n        callback(null, doc);\n      }\n    };\n  };\n\n  api._putLocal = function (doc, opts, callback) {\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    delete doc._revisions; // ignore this, trust the rev\n    var oldRev = doc._rev;\n    var id = doc._id;\n    if (!oldRev) {\n      doc._rev = '0-1';\n    } else {\n      doc._rev = '0-' + (parseInt(oldRev.split('-')[1], 10) + 1);\n    }\n\n    var tx = opts.ctx;\n    var ret;\n    if (!tx) {\n      var txnResult = openTransactionSafely(idb, [LOCAL_STORE], 'readwrite');\n      if (txnResult.error) {\n        return callback(txnResult.error);\n      }\n      tx = txnResult.txn;\n      tx.onerror = idbError(callback);\n      tx.oncomplete = function () {\n        if (ret) {\n          callback(null, ret);\n        }\n      };\n    }\n\n    var oStore = tx.objectStore(LOCAL_STORE);\n    var req;\n    if (oldRev) {\n      req = oStore.get(id);\n      req.onsuccess = function (e) {\n        var oldDoc = e.target.result;\n        if (!oldDoc || oldDoc._rev !== oldRev) {\n          callback(createError(REV_CONFLICT));\n        } else { // update\n          var req = oStore.put(doc);\n          req.onsuccess = function () {\n            ret = {ok: true, id: doc._id, rev: doc._rev};\n            if (opts.ctx) { // return immediately\n              callback(null, ret);\n            }\n          };\n        }\n      };\n    } else { // new doc\n      req = oStore.add(doc);\n      req.onerror = function (e) {\n        // constraint error, already exists\n        callback(createError(REV_CONFLICT));\n        e.preventDefault(); // avoid transaction abort\n        e.stopPropagation(); // avoid transaction onerror\n      };\n      req.onsuccess = function () {\n        ret = {ok: true, id: doc._id, rev: doc._rev};\n        if (opts.ctx) { // return immediately\n          callback(null, ret);\n        }\n      };\n    }\n  };\n\n  api._removeLocal = function (doc, opts, callback) {\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    var tx = opts.ctx;\n    if (!tx) {\n      var txnResult = openTransactionSafely(idb, [LOCAL_STORE], 'readwrite');\n      if (txnResult.error) {\n        return callback(txnResult.error);\n      }\n      tx = txnResult.txn;\n      tx.oncomplete = function () {\n        if (ret) {\n          callback(null, ret);\n        }\n      };\n    }\n    var ret;\n    var id = doc._id;\n    var oStore = tx.objectStore(LOCAL_STORE);\n    var req = oStore.get(id);\n\n    req.onerror = idbError(callback);\n    req.onsuccess = function (e) {\n      var oldDoc = e.target.result;\n      if (!oldDoc || oldDoc._rev !== doc._rev) {\n        callback(createError(MISSING_DOC));\n      } else {\n        oStore[\"delete\"](id);\n        ret = {ok: true, id: id, rev: '0-0'};\n        if (opts.ctx) { // return immediately\n          callback(null, ret);\n        }\n      }\n    };\n  };\n\n  api._destroy = function (opts, callback) {\n    changesHandler$$1.removeAllListeners(dbName);\n\n    //Close open request for \"dbName\" database to fix ie delay.\n    var openReq = openReqList.get(dbName);\n    if (openReq && openReq.result) {\n      openReq.result.close();\n      cachedDBs[\"delete\"](dbName);\n    }\n    var req = indexedDB.deleteDatabase(dbName);\n\n    req.onsuccess = function () {\n      //Remove open request from the list.\n      openReqList[\"delete\"](dbName);\n      if (hasLocalStorage() && (dbName in localStorage)) {\n        delete localStorage[dbName];\n      }\n      callback(null, { 'ok': true });\n    };\n\n    req.onerror = idbError(callback);\n  };\n\n  var cached = cachedDBs.get(dbName);\n\n  if (cached) {\n    idb = cached.idb;\n    api._meta = cached.global;\n    return nextTick(function () {\n      callback(null, api);\n    });\n  }\n\n  var req;\n  if (opts.storage) {\n    req = tryStorageOption(dbName, opts.storage);\n  } else {\n    req = indexedDB.open(dbName, ADAPTER_VERSION);\n  }\n\n  openReqList.set(dbName, req);\n\n  req.onupgradeneeded = function (e) {\n    var db = e.target.result;\n    if (e.oldVersion < 1) {\n      return createSchema(db); // new db, initial schema\n    }\n    // do migrations\n\n    var txn = e.currentTarget.transaction;\n    // these migrations have to be done in this function, before\n    // control is returned to the event loop, because IndexedDB\n\n    if (e.oldVersion < 3) {\n      createLocalStoreSchema(db); // v2 -> v3\n    }\n    if (e.oldVersion < 4) {\n      addAttachAndSeqStore(db); // v3 -> v4\n    }\n\n    var migrations = [\n      addDeletedOrLocalIndex, // v1 -> v2\n      migrateLocalStore,      // v2 -> v3\n      migrateAttsAndSeqs,     // v3 -> v4\n      migrateMetadata         // v4 -> v5\n    ];\n\n    var i = e.oldVersion;\n\n    function next() {\n      var migration = migrations[i - 1];\n      i++;\n      if (migration) {\n        migration(txn, next);\n      }\n    }\n\n    next();\n  };\n\n  req.onsuccess = function (e) {\n\n    idb = e.target.result;\n\n    idb.onversionchange = function () {\n      idb.close();\n      cachedDBs[\"delete\"](dbName);\n    };\n\n    idb.onabort = function (e) {\n      guardedConsole('error', 'Database has a global failure', e.target.error);\n      idb.close();\n      cachedDBs[\"delete\"](dbName);\n    };\n\n    // Do a few setup operations (in parallel as much as possible):\n    // 1. Fetch meta doc\n    // 2. Check blob support\n    // 3. Calculate docCount\n    // 4. Generate an instanceId if necessary\n    // 5. Store docCount and instanceId on meta doc\n\n    var txn = idb.transaction([\n      META_STORE,\n      DETECT_BLOB_SUPPORT_STORE,\n      DOC_STORE\n    ], 'readwrite');\n\n    var storedMetaDoc = false;\n    var metaDoc;\n    var docCount;\n    var blobSupport;\n    var instanceId;\n\n    function completeSetup() {\n      if (typeof blobSupport === 'undefined' || !storedMetaDoc) {\n        return;\n      }\n      api._meta = {\n        name: dbName,\n        instanceId: instanceId,\n        blobSupport: blobSupport\n      };\n\n      cachedDBs.set(dbName, {\n        idb: idb,\n        global: api._meta\n      });\n      callback(null, api);\n    }\n\n    function storeMetaDocIfReady() {\n      if (typeof docCount === 'undefined' || typeof metaDoc === 'undefined') {\n        return;\n      }\n      var instanceKey = dbName + '_id';\n      if (instanceKey in metaDoc) {\n        instanceId = metaDoc[instanceKey];\n      } else {\n        metaDoc[instanceKey] = instanceId = uuid();\n      }\n      metaDoc.docCount = docCount;\n      txn.objectStore(META_STORE).put(metaDoc);\n    }\n\n    //\n    // fetch or generate the instanceId\n    //\n    txn.objectStore(META_STORE).get(META_STORE).onsuccess = function (e) {\n      metaDoc = e.target.result || { id: META_STORE };\n      storeMetaDocIfReady();\n    };\n\n    //\n    // countDocs\n    //\n    countDocs(txn, function (count) {\n      docCount = count;\n      storeMetaDocIfReady();\n    });\n\n    //\n    // check blob support\n    //\n    if (!blobSupportPromise) {\n      // make sure blob support is only checked once\n      blobSupportPromise = checkBlobSupport(txn);\n    }\n\n    blobSupportPromise.then(function (val) {\n      blobSupport = val;\n      completeSetup();\n    });\n\n    // only when the metadata put transaction has completed,\n    // consider the setup done\n    txn.oncomplete = function () {\n      storedMetaDoc = true;\n      completeSetup();\n    };\n    txn.onabort = idbError(callback);\n  };\n\n  req.onerror = function () {\n    var msg = 'Failed to open indexedDB, are you in private browsing mode?';\n    guardedConsole('error', msg);\n    callback(createError(IDB_ERROR, msg));\n  };\n}\n\nIdbPouch.valid = function () {\n  // Issue #2533, we finally gave up on doing bug\n  // detection instead of browser sniffing. Safari brought us\n  // to our knees.\n  var isSafari = typeof openDatabase !== 'undefined' &&\n    /(Safari|iPhone|iPad|iPod)/.test(navigator.userAgent) &&\n    !/Chrome/.test(navigator.userAgent) &&\n    !/BlackBerry/.test(navigator.platform);\n\n  // Safari <10.1 does not meet our requirements for IDB support (#5572)\n  // since Safari 10.1 shipped with fetch, we can use that to detect it\n  var hasFetch = typeof fetch === 'function' &&\n    fetch.toString().indexOf('[native code') !== -1;\n\n  // On Firefox SecurityError is thrown while referencing indexedDB if cookies\n  // are not allowed. `typeof indexedDB` also triggers the error.\n  try {\n    // some outdated implementations of IDB that appear on Samsung\n    // and HTC Android devices <4.4 are missing IDBKeyRange\n    return (!isSafari || hasFetch) && typeof indexedDB !== 'undefined' &&\n      typeof IDBKeyRange !== 'undefined';\n  } catch (e) {\n    return false;\n  }\n};\n\nfunction tryStorageOption(dbName, storage) {\n  try { // option only available in Firefox 26+\n    return indexedDB.open(dbName, {\n      version: ADAPTER_VERSION,\n      storage: storage\n    });\n  } catch (err) {\n      return indexedDB.open(dbName, ADAPTER_VERSION);\n  }\n}\n\nfunction IDBPouch (PouchDB) {\n  PouchDB.adapter('idb', IdbPouch, true);\n}\n\n//\n// Parsing hex strings. Yeah.\n//\n// So basically we need this because of a bug in WebSQL:\n// https://code.google.com/p/chromium/issues/detail?id=422690\n// https://bugs.webkit.org/show_bug.cgi?id=137637\n//\n// UTF-8 and UTF-16 are provided as separate functions\n// for meager performance improvements\n//\n\nfunction decodeUtf8(str) {\n  return decodeURIComponent(escape(str));\n}\n\nfunction hexToInt(charCode) {\n  // '0'-'9' is 48-57\n  // 'A'-'F' is 65-70\n  // SQLite will only give us uppercase hex\n  return charCode < 65 ? (charCode - 48) : (charCode - 55);\n}\n\n\n// Example:\n// pragma encoding=utf8;\n// select hex('A');\n// returns '41'\nfunction parseHexUtf8(str, start, end) {\n  var result = '';\n  while (start < end) {\n    result += String.fromCharCode(\n      (hexToInt(str.charCodeAt(start++)) << 4) |\n        hexToInt(str.charCodeAt(start++)));\n  }\n  return result;\n}\n\n// Example:\n// pragma encoding=utf16;\n// select hex('A');\n// returns '4100'\n// notice that the 00 comes after the 41 (i.e. it's swizzled)\nfunction parseHexUtf16(str, start, end) {\n  var result = '';\n  while (start < end) {\n    // UTF-16, so swizzle the bytes\n    result += String.fromCharCode(\n      (hexToInt(str.charCodeAt(start + 2)) << 12) |\n        (hexToInt(str.charCodeAt(start + 3)) << 8) |\n        (hexToInt(str.charCodeAt(start)) << 4) |\n        hexToInt(str.charCodeAt(start + 1)));\n    start += 4;\n  }\n  return result;\n}\n\nfunction parseHexString(str, encoding) {\n  if (encoding === 'UTF-8') {\n    return decodeUtf8(parseHexUtf8(str, 0, str.length));\n  } else {\n    return parseHexUtf16(str, 0, str.length);\n  }\n}\n\nfunction quote(str) {\n  return \"'\" + str + \"'\";\n}\n\nvar ADAPTER_VERSION$1 = 7; // used to manage migrations\n\n// The object stores created for each database\n// DOC_STORE stores the document meta data, its revision history and state\nvar DOC_STORE$1 = quote('document-store');\n// BY_SEQ_STORE stores a particular version of a document, keyed by its\n// sequence id\nvar BY_SEQ_STORE$1 = quote('by-sequence');\n// Where we store attachments\nvar ATTACH_STORE$1 = quote('attach-store');\nvar LOCAL_STORE$1 = quote('local-store');\nvar META_STORE$1 = quote('metadata-store');\n// where we store many-to-many relations between attachment\n// digests and seqs\nvar ATTACH_AND_SEQ_STORE$1 = quote('attach-seq-store');\n\n// escapeBlob and unescapeBlob are workarounds for a websql bug:\n// https://code.google.com/p/chromium/issues/detail?id=422690\n// https://bugs.webkit.org/show_bug.cgi?id=137637\n// The goal is to never actually insert the \\u0000 character\n// in the database.\nfunction escapeBlob(str) {\n  return str\n    .replace(/\\u0002/g, '\\u0002\\u0002')\n    .replace(/\\u0001/g, '\\u0001\\u0002')\n    .replace(/\\u0000/g, '\\u0001\\u0001');\n}\n\nfunction unescapeBlob(str) {\n  return str\n    .replace(/\\u0001\\u0001/g, '\\u0000')\n    .replace(/\\u0001\\u0002/g, '\\u0001')\n    .replace(/\\u0002\\u0002/g, '\\u0002');\n}\n\nfunction stringifyDoc(doc) {\n  // don't bother storing the id/rev. it uses lots of space,\n  // in persistent map/reduce especially\n  delete doc._id;\n  delete doc._rev;\n  return JSON.stringify(doc);\n}\n\nfunction unstringifyDoc(doc, id, rev$$1) {\n  doc = JSON.parse(doc);\n  doc._id = id;\n  doc._rev = rev$$1;\n  return doc;\n}\n\n// question mark groups IN queries, e.g. 3 -> '(?,?,?)'\nfunction qMarks(num) {\n  var s = '(';\n  while (num--) {\n    s += '?';\n    if (num) {\n      s += ',';\n    }\n  }\n  return s + ')';\n}\n\nfunction select(selector, table, joiner, where, orderBy) {\n  return 'SELECT ' + selector + ' FROM ' +\n    (typeof table === 'string' ? table : table.join(' JOIN ')) +\n    (joiner ? (' ON ' + joiner) : '') +\n    (where ? (' WHERE ' +\n    (typeof where === 'string' ? where : where.join(' AND '))) : '') +\n    (orderBy ? (' ORDER BY ' + orderBy) : '');\n}\n\nfunction compactRevs$1(revs, docId, tx) {\n\n  if (!revs.length) {\n    return;\n  }\n\n  var numDone = 0;\n  var seqs = [];\n\n  function checkDone() {\n    if (++numDone === revs.length) { // done\n      deleteOrphans();\n    }\n  }\n\n  function deleteOrphans() {\n    // find orphaned attachment digests\n\n    if (!seqs.length) {\n      return;\n    }\n\n    var sql = 'SELECT DISTINCT digest AS digest FROM ' +\n      ATTACH_AND_SEQ_STORE$1 + ' WHERE seq IN ' + qMarks(seqs.length);\n\n    tx.executeSql(sql, seqs, function (tx, res) {\n\n      var digestsToCheck = [];\n      for (var i = 0; i < res.rows.length; i++) {\n        digestsToCheck.push(res.rows.item(i).digest);\n      }\n      if (!digestsToCheck.length) {\n        return;\n      }\n\n      var sql = 'DELETE FROM ' + ATTACH_AND_SEQ_STORE$1 +\n        ' WHERE seq IN (' +\n        seqs.map(function () { return '?'; }).join(',') +\n        ')';\n      tx.executeSql(sql, seqs, function (tx) {\n\n        var sql = 'SELECT digest FROM ' + ATTACH_AND_SEQ_STORE$1 +\n          ' WHERE digest IN (' +\n          digestsToCheck.map(function () { return '?'; }).join(',') +\n          ')';\n        tx.executeSql(sql, digestsToCheck, function (tx, res) {\n          var nonOrphanedDigests = new ExportedSet();\n          for (var i = 0; i < res.rows.length; i++) {\n            nonOrphanedDigests.add(res.rows.item(i).digest);\n          }\n          digestsToCheck.forEach(function (digest) {\n            if (nonOrphanedDigests.has(digest)) {\n              return;\n            }\n            tx.executeSql(\n              'DELETE FROM ' + ATTACH_AND_SEQ_STORE$1 + ' WHERE digest=?',\n              [digest]);\n            tx.executeSql(\n              'DELETE FROM ' + ATTACH_STORE$1 + ' WHERE digest=?', [digest]);\n          });\n        });\n      });\n    });\n  }\n\n  // update by-seq and attach stores in parallel\n  revs.forEach(function (rev$$1) {\n    var sql = 'SELECT seq FROM ' + BY_SEQ_STORE$1 +\n      ' WHERE doc_id=? AND rev=?';\n\n    tx.executeSql(sql, [docId, rev$$1], function (tx, res) {\n      if (!res.rows.length) { // already deleted\n        return checkDone();\n      }\n      var seq = res.rows.item(0).seq;\n      seqs.push(seq);\n\n      tx.executeSql(\n        'DELETE FROM ' + BY_SEQ_STORE$1 + ' WHERE seq=?', [seq], checkDone);\n    });\n  });\n}\n\nfunction websqlError(callback) {\n  return function (event) {\n    guardedConsole('error', 'WebSQL threw an error', event);\n    // event may actually be a SQLError object, so report is as such\n    var errorNameMatch = event && event.constructor.toString()\n        .match(/function ([^(]+)/);\n    var errorName = (errorNameMatch && errorNameMatch[1]) || event.type;\n    var errorReason = event.target || event.message;\n    callback(createError(WSQ_ERROR, errorReason, errorName));\n  };\n}\n\nfunction getSize(opts) {\n  if ('size' in opts) {\n    // triggers immediate popup in iOS, fixes #2347\n    // e.g. 5000001 asks for 5 MB, 10000001 asks for 10 MB,\n    return opts.size * 1000000;\n  }\n  // In iOS, doesn't matter as long as it's <= 5000000.\n  // Except that if you request too much, our tests fail\n  // because of the native \"do you accept?\" popup.\n  // In Android <=4.3, this value is actually used as an\n  // honest-to-god ceiling for data, so we need to\n  // set it to a decently high number.\n  var isAndroid = typeof navigator !== 'undefined' &&\n    /Android/.test(navigator.userAgent);\n  return isAndroid ? 5000000 : 1; // in PhantomJS, if you use 0 it will crash\n}\n\nfunction websqlBulkDocs(dbOpts, req, opts, api, db, websqlChanges, callback) {\n  var newEdits = opts.new_edits;\n  var userDocs = req.docs;\n\n  // Parse the docs, give them a sequence number for the result\n  var docInfos = userDocs.map(function (doc) {\n    if (doc._id && isLocalId(doc._id)) {\n      return doc;\n    }\n    var newDoc = parseDoc(doc, newEdits);\n    return newDoc;\n  });\n\n  var docInfoErrors = docInfos.filter(function (docInfo) {\n    return docInfo.error;\n  });\n  if (docInfoErrors.length) {\n    return callback(docInfoErrors[0]);\n  }\n\n  var tx;\n  var results = new Array(docInfos.length);\n  var fetchedDocs = new ExportedMap();\n\n  var preconditionErrored;\n  function complete() {\n    if (preconditionErrored) {\n      return callback(preconditionErrored);\n    }\n    websqlChanges.notify(api._name);\n    callback(null, results);\n  }\n\n  function verifyAttachment(digest, callback) {\n    var sql = 'SELECT count(*) as cnt FROM ' + ATTACH_STORE$1 +\n      ' WHERE digest=?';\n    tx.executeSql(sql, [digest], function (tx, result) {\n      if (result.rows.item(0).cnt === 0) {\n        var err = createError(MISSING_STUB,\n          'unknown stub attachment with digest ' +\n          digest);\n        callback(err);\n      } else {\n        callback();\n      }\n    });\n  }\n\n  function verifyAttachments(finish) {\n    var digests = [];\n    docInfos.forEach(function (docInfo) {\n      if (docInfo.data && docInfo.data._attachments) {\n        Object.keys(docInfo.data._attachments).forEach(function (filename) {\n          var att = docInfo.data._attachments[filename];\n          if (att.stub) {\n            digests.push(att.digest);\n          }\n        });\n      }\n    });\n    if (!digests.length) {\n      return finish();\n    }\n    var numDone = 0;\n    var err;\n\n    function checkDone() {\n      if (++numDone === digests.length) {\n        finish(err);\n      }\n    }\n    digests.forEach(function (digest) {\n      verifyAttachment(digest, function (attErr) {\n        if (attErr && !err) {\n          err = attErr;\n        }\n        checkDone();\n      });\n    });\n  }\n\n  function writeDoc(docInfo, winningRev$$1, winningRevIsDeleted, newRevIsDeleted,\n                    isUpdate, delta, resultsIdx, callback) {\n\n    function finish() {\n      var data = docInfo.data;\n      var deletedInt = newRevIsDeleted ? 1 : 0;\n\n      var id = data._id;\n      var rev = data._rev;\n      var json = stringifyDoc(data);\n      var sql = 'INSERT INTO ' + BY_SEQ_STORE$1 +\n        ' (doc_id, rev, json, deleted) VALUES (?, ?, ?, ?);';\n      var sqlArgs = [id, rev, json, deletedInt];\n\n      // map seqs to attachment digests, which\n      // we will need later during compaction\n      function insertAttachmentMappings(seq, callback) {\n        var attsAdded = 0;\n        var attsToAdd = Object.keys(data._attachments || {});\n\n        if (!attsToAdd.length) {\n          return callback();\n        }\n        function checkDone() {\n          if (++attsAdded === attsToAdd.length) {\n            callback();\n          }\n          return false; // ack handling a constraint error\n        }\n        function add(att) {\n          var sql = 'INSERT INTO ' + ATTACH_AND_SEQ_STORE$1 +\n            ' (digest, seq) VALUES (?,?)';\n          var sqlArgs = [data._attachments[att].digest, seq];\n          tx.executeSql(sql, sqlArgs, checkDone, checkDone);\n          // second callback is for a constaint error, which we ignore\n          // because this docid/rev has already been associated with\n          // the digest (e.g. when new_edits == false)\n        }\n        for (var i = 0; i < attsToAdd.length; i++) {\n          add(attsToAdd[i]); // do in parallel\n        }\n      }\n\n      tx.executeSql(sql, sqlArgs, function (tx, result) {\n        var seq = result.insertId;\n        insertAttachmentMappings(seq, function () {\n          dataWritten(tx, seq);\n        });\n      }, function () {\n        // constraint error, recover by updating instead (see #1638)\n        var fetchSql = select('seq', BY_SEQ_STORE$1, null,\n          'doc_id=? AND rev=?');\n        tx.executeSql(fetchSql, [id, rev], function (tx, res) {\n          var seq = res.rows.item(0).seq;\n          var sql = 'UPDATE ' + BY_SEQ_STORE$1 +\n            ' SET json=?, deleted=? WHERE doc_id=? AND rev=?;';\n          var sqlArgs = [json, deletedInt, id, rev];\n          tx.executeSql(sql, sqlArgs, function (tx) {\n            insertAttachmentMappings(seq, function () {\n              dataWritten(tx, seq);\n            });\n          });\n        });\n        return false; // ack that we've handled the error\n      });\n    }\n\n    function collectResults(attachmentErr) {\n      if (!err) {\n        if (attachmentErr) {\n          err = attachmentErr;\n          callback(err);\n        } else if (recv === attachments.length) {\n          finish();\n        }\n      }\n    }\n\n    var err = null;\n    var recv = 0;\n\n    docInfo.data._id = docInfo.metadata.id;\n    docInfo.data._rev = docInfo.metadata.rev;\n    var attachments = Object.keys(docInfo.data._attachments || {});\n\n\n    if (newRevIsDeleted) {\n      docInfo.data._deleted = true;\n    }\n\n    function attachmentSaved(err) {\n      recv++;\n      collectResults(err);\n    }\n\n    attachments.forEach(function (key) {\n      var att = docInfo.data._attachments[key];\n      if (!att.stub) {\n        var data = att.data;\n        delete att.data;\n        att.revpos = parseInt(winningRev$$1, 10);\n        var digest = att.digest;\n        saveAttachment(digest, data, attachmentSaved);\n      } else {\n        recv++;\n        collectResults();\n      }\n    });\n\n    if (!attachments.length) {\n      finish();\n    }\n\n    function dataWritten(tx, seq) {\n      var id = docInfo.metadata.id;\n\n      var revsToCompact = docInfo.stemmedRevs || [];\n      if (isUpdate && api.auto_compaction) {\n        revsToCompact = compactTree(docInfo.metadata).concat(revsToCompact);\n      }\n      if (revsToCompact.length) {\n        compactRevs$1(revsToCompact, id, tx);\n      }\n\n      docInfo.metadata.seq = seq;\n      var rev = docInfo.metadata.rev;\n      delete docInfo.metadata.rev;\n\n      var sql = isUpdate ?\n      'UPDATE ' + DOC_STORE$1 +\n      ' SET json=?, max_seq=?, winningseq=' +\n      '(SELECT seq FROM ' + BY_SEQ_STORE$1 +\n      ' WHERE doc_id=' + DOC_STORE$1 + '.id AND rev=?) WHERE id=?'\n        : 'INSERT INTO ' + DOC_STORE$1 +\n      ' (id, winningseq, max_seq, json) VALUES (?,?,?,?);';\n      var metadataStr = safeJsonStringify(docInfo.metadata);\n      var params = isUpdate ?\n        [metadataStr, seq, winningRev$$1, id] :\n        [id, seq, seq, metadataStr];\n      tx.executeSql(sql, params, function () {\n        results[resultsIdx] = {\n          ok: true,\n          id: docInfo.metadata.id,\n          rev: rev\n        };\n        fetchedDocs.set(id, docInfo.metadata);\n        callback();\n      });\n    }\n  }\n\n  function websqlProcessDocs() {\n    processDocs(dbOpts.revs_limit, docInfos, api, fetchedDocs, tx,\n                results, writeDoc, opts);\n  }\n\n  function fetchExistingDocs(callback) {\n    if (!docInfos.length) {\n      return callback();\n    }\n\n    var numFetched = 0;\n\n    function checkDone() {\n      if (++numFetched === docInfos.length) {\n        callback();\n      }\n    }\n\n    docInfos.forEach(function (docInfo) {\n      if (docInfo._id && isLocalId(docInfo._id)) {\n        return checkDone(); // skip local docs\n      }\n      var id = docInfo.metadata.id;\n      tx.executeSql('SELECT json FROM ' + DOC_STORE$1 +\n      ' WHERE id = ?', [id], function (tx, result) {\n        if (result.rows.length) {\n          var metadata = safeJsonParse(result.rows.item(0).json);\n          fetchedDocs.set(id, metadata);\n        }\n        checkDone();\n      });\n    });\n  }\n\n  function saveAttachment(digest, data, callback) {\n    var sql = 'SELECT digest FROM ' + ATTACH_STORE$1 + ' WHERE digest=?';\n    tx.executeSql(sql, [digest], function (tx, result) {\n      if (result.rows.length) { // attachment already exists\n        return callback();\n      }\n      // we could just insert before selecting and catch the error,\n      // but my hunch is that it's cheaper not to serialize the blob\n      // from JS to C if we don't have to (TODO: confirm this)\n      sql = 'INSERT INTO ' + ATTACH_STORE$1 +\n      ' (digest, body, escaped) VALUES (?,?,1)';\n      tx.executeSql(sql, [digest, escapeBlob(data)], function () {\n        callback();\n      }, function () {\n        // ignore constaint errors, means it already exists\n        callback();\n        return false; // ack we handled the error\n      });\n    });\n  }\n\n  preprocessAttachments(docInfos, 'binary', function (err) {\n    if (err) {\n      return callback(err);\n    }\n    db.transaction(function (txn) {\n      tx = txn;\n      verifyAttachments(function (err) {\n        if (err) {\n          preconditionErrored = err;\n        } else {\n          fetchExistingDocs(websqlProcessDocs);\n        }\n      });\n    }, websqlError(callback), complete);\n  });\n}\n\nvar cachedDatabases = new ExportedMap();\n\n// openDatabase passed in through opts (e.g. for node-websql)\nfunction openDatabaseWithOpts(opts) {\n  return opts.websql(opts.name, opts.version, opts.description, opts.size);\n}\n\nfunction openDBSafely(opts) {\n  try {\n    return {\n      db: openDatabaseWithOpts(opts)\n    };\n  } catch (err) {\n    return {\n      error: err\n    };\n  }\n}\n\nfunction openDB(opts) {\n  var cachedResult = cachedDatabases.get(opts.name);\n  if (!cachedResult) {\n    cachedResult = openDBSafely(opts);\n    cachedDatabases.set(opts.name, cachedResult);\n  }\n  return cachedResult;\n}\n\nvar websqlChanges = new Changes();\n\nfunction fetchAttachmentsIfNecessary$1(doc, opts, api, txn, cb) {\n  var attachments = Object.keys(doc._attachments || {});\n  if (!attachments.length) {\n    return cb && cb();\n  }\n  var numDone = 0;\n\n  function checkDone() {\n    if (++numDone === attachments.length && cb) {\n      cb();\n    }\n  }\n\n  function fetchAttachment(doc, att) {\n    var attObj = doc._attachments[att];\n    var attOpts = {binary: opts.binary, ctx: txn};\n    api._getAttachment(doc._id, att, attObj, attOpts, function (_, data) {\n      doc._attachments[att] = $inject_Object_assign(\n        pick(attObj, ['digest', 'content_type']),\n        { data: data }\n      );\n      checkDone();\n    });\n  }\n\n  attachments.forEach(function (att) {\n    if (opts.attachments && opts.include_docs) {\n      fetchAttachment(doc, att);\n    } else {\n      doc._attachments[att].stub = true;\n      checkDone();\n    }\n  });\n}\n\nvar POUCH_VERSION = 1;\n\n// these indexes cover the ground for most allDocs queries\nvar BY_SEQ_STORE_DELETED_INDEX_SQL =\n  'CREATE INDEX IF NOT EXISTS \\'by-seq-deleted-idx\\' ON ' +\n  BY_SEQ_STORE$1 + ' (seq, deleted)';\nvar BY_SEQ_STORE_DOC_ID_REV_INDEX_SQL =\n  'CREATE UNIQUE INDEX IF NOT EXISTS \\'by-seq-doc-id-rev\\' ON ' +\n    BY_SEQ_STORE$1 + ' (doc_id, rev)';\nvar DOC_STORE_WINNINGSEQ_INDEX_SQL =\n  'CREATE INDEX IF NOT EXISTS \\'doc-winningseq-idx\\' ON ' +\n  DOC_STORE$1 + ' (winningseq)';\nvar ATTACH_AND_SEQ_STORE_SEQ_INDEX_SQL =\n  'CREATE INDEX IF NOT EXISTS \\'attach-seq-seq-idx\\' ON ' +\n    ATTACH_AND_SEQ_STORE$1 + ' (seq)';\nvar ATTACH_AND_SEQ_STORE_ATTACH_INDEX_SQL =\n  'CREATE UNIQUE INDEX IF NOT EXISTS \\'attach-seq-digest-idx\\' ON ' +\n    ATTACH_AND_SEQ_STORE$1 + ' (digest, seq)';\n\nvar DOC_STORE_AND_BY_SEQ_JOINER = BY_SEQ_STORE$1 +\n  '.seq = ' + DOC_STORE$1 + '.winningseq';\n\nvar SELECT_DOCS = BY_SEQ_STORE$1 + '.seq AS seq, ' +\n  BY_SEQ_STORE$1 + '.deleted AS deleted, ' +\n  BY_SEQ_STORE$1 + '.json AS data, ' +\n  BY_SEQ_STORE$1 + '.rev AS rev, ' +\n  DOC_STORE$1 + '.json AS metadata';\n\nfunction WebSqlPouch(opts, callback) {\n  var api = this;\n  var instanceId = null;\n  var size = getSize(opts);\n  var idRequests = [];\n  var encoding;\n\n  api._name = opts.name;\n\n  // extend the options here, because sqlite plugin has a ton of options\n  // and they are constantly changing, so it's more prudent to allow anything\n  var websqlOpts = $inject_Object_assign({}, opts, {\n    version: POUCH_VERSION,\n    description: opts.name,\n    size: size\n  });\n  var openDBResult = openDB(websqlOpts);\n  if (openDBResult.error) {\n    return websqlError(callback)(openDBResult.error);\n  }\n  var db = openDBResult.db;\n  if (typeof db.readTransaction !== 'function') {\n    // doesn't exist in sqlite plugin\n    db.readTransaction = db.transaction;\n  }\n\n  function dbCreated() {\n    // note the db name in case the browser upgrades to idb\n    if (hasLocalStorage()) {\n      window.localStorage['_pouch__websqldb_' + api._name] = true;\n    }\n    callback(null, api);\n  }\n\n  // In this migration, we added the 'deleted' and 'local' columns to the\n  // by-seq and doc store tables.\n  // To preserve existing user data, we re-process all the existing JSON\n  // and add these values.\n  // Called migration2 because it corresponds to adapter version (db_version) #2\n  function runMigration2(tx, callback) {\n    // index used for the join in the allDocs query\n    tx.executeSql(DOC_STORE_WINNINGSEQ_INDEX_SQL);\n\n    tx.executeSql('ALTER TABLE ' + BY_SEQ_STORE$1 +\n      ' ADD COLUMN deleted TINYINT(1) DEFAULT 0', [], function () {\n      tx.executeSql(BY_SEQ_STORE_DELETED_INDEX_SQL);\n      tx.executeSql('ALTER TABLE ' + DOC_STORE$1 +\n        ' ADD COLUMN local TINYINT(1) DEFAULT 0', [], function () {\n        tx.executeSql('CREATE INDEX IF NOT EXISTS \\'doc-store-local-idx\\' ON ' +\n          DOC_STORE$1 + ' (local, id)');\n\n        var sql = 'SELECT ' + DOC_STORE$1 + '.winningseq AS seq, ' + DOC_STORE$1 +\n          '.json AS metadata FROM ' + BY_SEQ_STORE$1 + ' JOIN ' + DOC_STORE$1 +\n          ' ON ' + BY_SEQ_STORE$1 + '.seq = ' + DOC_STORE$1 + '.winningseq';\n\n        tx.executeSql(sql, [], function (tx, result) {\n\n          var deleted = [];\n          var local = [];\n\n          for (var i = 0; i < result.rows.length; i++) {\n            var item = result.rows.item(i);\n            var seq = item.seq;\n            var metadata = JSON.parse(item.metadata);\n            if (isDeleted(metadata)) {\n              deleted.push(seq);\n            }\n            if (isLocalId(metadata.id)) {\n              local.push(metadata.id);\n            }\n          }\n          tx.executeSql('UPDATE ' + DOC_STORE$1 + 'SET local = 1 WHERE id IN ' +\n            qMarks(local.length), local, function () {\n            tx.executeSql('UPDATE ' + BY_SEQ_STORE$1 +\n              ' SET deleted = 1 WHERE seq IN ' +\n              qMarks(deleted.length), deleted, callback);\n          });\n        });\n      });\n    });\n  }\n\n  // in this migration, we make all the local docs unversioned\n  function runMigration3(tx, callback) {\n    var local = 'CREATE TABLE IF NOT EXISTS ' + LOCAL_STORE$1 +\n      ' (id UNIQUE, rev, json)';\n    tx.executeSql(local, [], function () {\n      var sql = 'SELECT ' + DOC_STORE$1 + '.id AS id, ' +\n        BY_SEQ_STORE$1 + '.json AS data ' +\n        'FROM ' + BY_SEQ_STORE$1 + ' JOIN ' +\n        DOC_STORE$1 + ' ON ' + BY_SEQ_STORE$1 + '.seq = ' +\n        DOC_STORE$1 + '.winningseq WHERE local = 1';\n      tx.executeSql(sql, [], function (tx, res) {\n        var rows = [];\n        for (var i = 0; i < res.rows.length; i++) {\n          rows.push(res.rows.item(i));\n        }\n        function doNext() {\n          if (!rows.length) {\n            return callback(tx);\n          }\n          var row = rows.shift();\n          var rev$$1 = JSON.parse(row.data)._rev;\n          tx.executeSql('INSERT INTO ' + LOCAL_STORE$1 +\n              ' (id, rev, json) VALUES (?,?,?)',\n              [row.id, rev$$1, row.data], function (tx) {\n            tx.executeSql('DELETE FROM ' + DOC_STORE$1 + ' WHERE id=?',\n                [row.id], function (tx) {\n              tx.executeSql('DELETE FROM ' + BY_SEQ_STORE$1 + ' WHERE seq=?',\n                  [row.seq], function () {\n                doNext();\n              });\n            });\n          });\n        }\n        doNext();\n      });\n    });\n  }\n\n  // in this migration, we remove doc_id_rev and just use rev\n  function runMigration4(tx, callback) {\n\n    function updateRows(rows) {\n      function doNext() {\n        if (!rows.length) {\n          return callback(tx);\n        }\n        var row = rows.shift();\n        var doc_id_rev = parseHexString(row.hex, encoding);\n        var idx = doc_id_rev.lastIndexOf('::');\n        var doc_id = doc_id_rev.substring(0, idx);\n        var rev$$1 = doc_id_rev.substring(idx + 2);\n        var sql = 'UPDATE ' + BY_SEQ_STORE$1 +\n          ' SET doc_id=?, rev=? WHERE doc_id_rev=?';\n        tx.executeSql(sql, [doc_id, rev$$1, doc_id_rev], function () {\n          doNext();\n        });\n      }\n      doNext();\n    }\n\n    var sql = 'ALTER TABLE ' + BY_SEQ_STORE$1 + ' ADD COLUMN doc_id';\n    tx.executeSql(sql, [], function (tx) {\n      var sql = 'ALTER TABLE ' + BY_SEQ_STORE$1 + ' ADD COLUMN rev';\n      tx.executeSql(sql, [], function (tx) {\n        tx.executeSql(BY_SEQ_STORE_DOC_ID_REV_INDEX_SQL, [], function (tx) {\n          var sql = 'SELECT hex(doc_id_rev) as hex FROM ' + BY_SEQ_STORE$1;\n          tx.executeSql(sql, [], function (tx, res) {\n            var rows = [];\n            for (var i = 0; i < res.rows.length; i++) {\n              rows.push(res.rows.item(i));\n            }\n            updateRows(rows);\n          });\n        });\n      });\n    });\n  }\n\n  // in this migration, we add the attach_and_seq table\n  // for issue #2818\n  function runMigration5(tx, callback) {\n\n    function migrateAttsAndSeqs(tx) {\n      // need to actually populate the table. this is the expensive part,\n      // so as an optimization, check first that this database even\n      // contains attachments\n      var sql = 'SELECT COUNT(*) AS cnt FROM ' + ATTACH_STORE$1;\n      tx.executeSql(sql, [], function (tx, res) {\n        var count = res.rows.item(0).cnt;\n        if (!count) {\n          return callback(tx);\n        }\n\n        var offset = 0;\n        var pageSize = 10;\n        function nextPage() {\n          var sql = select(\n            SELECT_DOCS + ', ' + DOC_STORE$1 + '.id AS id',\n            [DOC_STORE$1, BY_SEQ_STORE$1],\n            DOC_STORE_AND_BY_SEQ_JOINER,\n            null,\n            DOC_STORE$1 + '.id '\n          );\n          sql += ' LIMIT ' + pageSize + ' OFFSET ' + offset;\n          offset += pageSize;\n          tx.executeSql(sql, [], function (tx, res) {\n            if (!res.rows.length) {\n              return callback(tx);\n            }\n            var digestSeqs = {};\n            function addDigestSeq(digest, seq) {\n              // uniq digest/seq pairs, just in case there are dups\n              var seqs = digestSeqs[digest] = (digestSeqs[digest] || []);\n              if (seqs.indexOf(seq) === -1) {\n                seqs.push(seq);\n              }\n            }\n            for (var i = 0; i < res.rows.length; i++) {\n              var row = res.rows.item(i);\n              var doc = unstringifyDoc(row.data, row.id, row.rev);\n              var atts = Object.keys(doc._attachments || {});\n              for (var j = 0; j < atts.length; j++) {\n                var att = doc._attachments[atts[j]];\n                addDigestSeq(att.digest, row.seq);\n              }\n            }\n            var digestSeqPairs = [];\n            Object.keys(digestSeqs).forEach(function (digest) {\n              var seqs = digestSeqs[digest];\n              seqs.forEach(function (seq) {\n                digestSeqPairs.push([digest, seq]);\n              });\n            });\n            if (!digestSeqPairs.length) {\n              return nextPage();\n            }\n            var numDone = 0;\n            digestSeqPairs.forEach(function (pair) {\n              var sql = 'INSERT INTO ' + ATTACH_AND_SEQ_STORE$1 +\n                ' (digest, seq) VALUES (?,?)';\n              tx.executeSql(sql, pair, function () {\n                if (++numDone === digestSeqPairs.length) {\n                  nextPage();\n                }\n              });\n            });\n          });\n        }\n        nextPage();\n      });\n    }\n\n    var attachAndRev = 'CREATE TABLE IF NOT EXISTS ' +\n      ATTACH_AND_SEQ_STORE$1 + ' (digest, seq INTEGER)';\n    tx.executeSql(attachAndRev, [], function (tx) {\n      tx.executeSql(\n        ATTACH_AND_SEQ_STORE_ATTACH_INDEX_SQL, [], function (tx) {\n          tx.executeSql(\n            ATTACH_AND_SEQ_STORE_SEQ_INDEX_SQL, [],\n            migrateAttsAndSeqs);\n        });\n    });\n  }\n\n  // in this migration, we use escapeBlob() and unescapeBlob()\n  // instead of reading out the binary as HEX, which is slow\n  function runMigration6(tx, callback) {\n    var sql = 'ALTER TABLE ' + ATTACH_STORE$1 +\n      ' ADD COLUMN escaped TINYINT(1) DEFAULT 0';\n    tx.executeSql(sql, [], callback);\n  }\n\n  // issue #3136, in this migration we need a \"latest seq\" as well\n  // as the \"winning seq\" in the doc store\n  function runMigration7(tx, callback) {\n    var sql = 'ALTER TABLE ' + DOC_STORE$1 +\n      ' ADD COLUMN max_seq INTEGER';\n    tx.executeSql(sql, [], function (tx) {\n      var sql = 'UPDATE ' + DOC_STORE$1 + ' SET max_seq=(SELECT MAX(seq) FROM ' +\n        BY_SEQ_STORE$1 + ' WHERE doc_id=id)';\n      tx.executeSql(sql, [], function (tx) {\n        // add unique index after filling, else we'll get a constraint\n        // error when we do the ALTER TABLE\n        var sql =\n          'CREATE UNIQUE INDEX IF NOT EXISTS \\'doc-max-seq-idx\\' ON ' +\n          DOC_STORE$1 + ' (max_seq)';\n        tx.executeSql(sql, [], callback);\n      });\n    });\n  }\n\n  function checkEncoding(tx, cb) {\n    // UTF-8 on chrome/android, UTF-16 on safari < 7.1\n    tx.executeSql('SELECT HEX(\"a\") AS hex', [], function (tx, res) {\n        var hex = res.rows.item(0).hex;\n        encoding = hex.length === 2 ? 'UTF-8' : 'UTF-16';\n        cb();\n      }\n    );\n  }\n\n  function onGetInstanceId() {\n    while (idRequests.length > 0) {\n      var idCallback = idRequests.pop();\n      idCallback(null, instanceId);\n    }\n  }\n\n  function onGetVersion(tx, dbVersion) {\n    if (dbVersion === 0) {\n      // initial schema\n\n      var meta = 'CREATE TABLE IF NOT EXISTS ' + META_STORE$1 +\n        ' (dbid, db_version INTEGER)';\n      var attach = 'CREATE TABLE IF NOT EXISTS ' + ATTACH_STORE$1 +\n        ' (digest UNIQUE, escaped TINYINT(1), body BLOB)';\n      var attachAndRev = 'CREATE TABLE IF NOT EXISTS ' +\n        ATTACH_AND_SEQ_STORE$1 + ' (digest, seq INTEGER)';\n      // TODO: migrate winningseq to INTEGER\n      var doc = 'CREATE TABLE IF NOT EXISTS ' + DOC_STORE$1 +\n        ' (id unique, json, winningseq, max_seq INTEGER UNIQUE)';\n      var seq = 'CREATE TABLE IF NOT EXISTS ' + BY_SEQ_STORE$1 +\n        ' (seq INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT, ' +\n        'json, deleted TINYINT(1), doc_id, rev)';\n      var local = 'CREATE TABLE IF NOT EXISTS ' + LOCAL_STORE$1 +\n        ' (id UNIQUE, rev, json)';\n\n      // creates\n      tx.executeSql(attach);\n      tx.executeSql(local);\n      tx.executeSql(attachAndRev, [], function () {\n        tx.executeSql(ATTACH_AND_SEQ_STORE_SEQ_INDEX_SQL);\n        tx.executeSql(ATTACH_AND_SEQ_STORE_ATTACH_INDEX_SQL);\n      });\n      tx.executeSql(doc, [], function () {\n        tx.executeSql(DOC_STORE_WINNINGSEQ_INDEX_SQL);\n        tx.executeSql(seq, [], function () {\n          tx.executeSql(BY_SEQ_STORE_DELETED_INDEX_SQL);\n          tx.executeSql(BY_SEQ_STORE_DOC_ID_REV_INDEX_SQL);\n          tx.executeSql(meta, [], function () {\n            // mark the db version, and new dbid\n            var initSeq = 'INSERT INTO ' + META_STORE$1 +\n              ' (db_version, dbid) VALUES (?,?)';\n            instanceId = uuid();\n            var initSeqArgs = [ADAPTER_VERSION$1, instanceId];\n            tx.executeSql(initSeq, initSeqArgs, function () {\n              onGetInstanceId();\n            });\n          });\n        });\n      });\n    } else { // version > 0\n\n      var setupDone = function () {\n        var migrated = dbVersion < ADAPTER_VERSION$1;\n        if (migrated) {\n          // update the db version within this transaction\n          tx.executeSql('UPDATE ' + META_STORE$1 + ' SET db_version = ' +\n            ADAPTER_VERSION$1);\n        }\n        // notify db.id() callers\n        var sql = 'SELECT dbid FROM ' + META_STORE$1;\n        tx.executeSql(sql, [], function (tx, result) {\n          instanceId = result.rows.item(0).dbid;\n          onGetInstanceId();\n        });\n      };\n\n      // would love to use promises here, but then websql\n      // ends the transaction early\n      var tasks = [\n        runMigration2,\n        runMigration3,\n        runMigration4,\n        runMigration5,\n        runMigration6,\n        runMigration7,\n        setupDone\n      ];\n\n      // run each migration sequentially\n      var i = dbVersion;\n      var nextMigration = function (tx) {\n        tasks[i - 1](tx, nextMigration);\n        i++;\n      };\n      nextMigration(tx);\n    }\n  }\n\n  function setup() {\n    db.transaction(function (tx) {\n      // first check the encoding\n      checkEncoding(tx, function () {\n        // then get the version\n        fetchVersion(tx);\n      });\n    }, websqlError(callback), dbCreated);\n  }\n\n  function fetchVersion(tx) {\n    var sql = 'SELECT sql FROM sqlite_master WHERE tbl_name = ' + META_STORE$1;\n    tx.executeSql(sql, [], function (tx, result) {\n      if (!result.rows.length) {\n        // database hasn't even been created yet (version 0)\n        onGetVersion(tx, 0);\n      } else if (!/db_version/.test(result.rows.item(0).sql)) {\n        // table was created, but without the new db_version column,\n        // so add it.\n        tx.executeSql('ALTER TABLE ' + META_STORE$1 +\n          ' ADD COLUMN db_version INTEGER', [], function () {\n          // before version 2, this column didn't even exist\n          onGetVersion(tx, 1);\n        });\n      } else { // column exists, we can safely get it\n        tx.executeSql('SELECT db_version FROM ' + META_STORE$1,\n          [], function (tx, result) {\n          var dbVersion = result.rows.item(0).db_version;\n          onGetVersion(tx, dbVersion);\n        });\n      }\n    });\n  }\n\n  setup();\n\n  function getMaxSeq(tx, callback) {\n    var sql = 'SELECT MAX(seq) AS seq FROM ' + BY_SEQ_STORE$1;\n    tx.executeSql(sql, [], function (tx, res) {\n      var updateSeq = res.rows.item(0).seq || 0;\n      callback(updateSeq);\n    });\n  }\n\n  function countDocs(tx, callback) {\n    // count the total rows\n    var sql = select(\n      'COUNT(' + DOC_STORE$1 + '.id) AS \\'num\\'',\n      [DOC_STORE$1, BY_SEQ_STORE$1],\n      DOC_STORE_AND_BY_SEQ_JOINER,\n      BY_SEQ_STORE$1 + '.deleted=0');\n\n    tx.executeSql(sql, [], function (tx, result) {\n      callback(result.rows.item(0).num);\n    });\n  }\n\n  api._remote = false;\n  api.type = function () {\n    return 'websql';\n  };\n\n  api._id = toPromise(function (callback) {\n    callback(null, instanceId);\n  });\n\n  api._info = function (callback) {\n    var seq;\n    var docCount;\n    db.readTransaction(function (tx) {\n      getMaxSeq(tx, function (theSeq) {\n        seq = theSeq;\n      });\n      countDocs(tx, function (theDocCount) {\n        docCount = theDocCount;\n      });\n    }, websqlError(callback), function () {\n      callback(null, {\n        doc_count: docCount,\n        update_seq: seq,\n        websql_encoding: encoding\n      });\n    });\n  };\n\n  api._bulkDocs = function (req, reqOpts, callback) {\n    websqlBulkDocs(opts, req, reqOpts, api, db, websqlChanges, callback);\n  };\n\n  function latest$$1(tx, id, rev$$1, callback, finish) {\n    var sql = select(\n        SELECT_DOCS,\n        [DOC_STORE$1, BY_SEQ_STORE$1],\n        DOC_STORE_AND_BY_SEQ_JOINER,\n        DOC_STORE$1 + '.id=?');\n    var sqlArgs = [id];\n\n    tx.executeSql(sql, sqlArgs, function (a, results) {\n      if (!results.rows.length) {\n        var err = createError(MISSING_DOC, 'missing');\n        return finish(err);\n      }\n      var item = results.rows.item(0);\n      var metadata = safeJsonParse(item.metadata);\n      callback(latest(rev$$1, metadata));\n    });\n  }\n\n  api._get = function (id, opts, callback) {\n    var doc;\n    var metadata;\n    var tx = opts.ctx;\n    if (!tx) {\n      return db.readTransaction(function (txn) {\n        api._get(id, $inject_Object_assign({ctx: txn}, opts), callback);\n      });\n    }\n\n    function finish(err) {\n      callback(err, {doc: doc, metadata: metadata, ctx: tx});\n    }\n\n    var sql;\n    var sqlArgs;\n\n    if (!opts.rev) {\n      sql = select(\n        SELECT_DOCS,\n        [DOC_STORE$1, BY_SEQ_STORE$1],\n        DOC_STORE_AND_BY_SEQ_JOINER,\n        DOC_STORE$1 + '.id=?');\n      sqlArgs = [id];\n    } else if (opts.latest) {\n      latest$$1(tx, id, opts.rev, function (latestRev) {\n        opts.latest = false;\n        opts.rev = latestRev;\n        api._get(id, opts, callback);\n      }, finish);\n      return;\n    } else {\n      sql = select(\n        SELECT_DOCS,\n        [DOC_STORE$1, BY_SEQ_STORE$1],\n        DOC_STORE$1 + '.id=' + BY_SEQ_STORE$1 + '.doc_id',\n        [BY_SEQ_STORE$1 + '.doc_id=?', BY_SEQ_STORE$1 + '.rev=?']);\n      sqlArgs = [id, opts.rev];\n    }\n\n    tx.executeSql(sql, sqlArgs, function (a, results) {\n      if (!results.rows.length) {\n        var missingErr = createError(MISSING_DOC, 'missing');\n        return finish(missingErr);\n      }\n      var item = results.rows.item(0);\n      metadata = safeJsonParse(item.metadata);\n      if (item.deleted && !opts.rev) {\n        var deletedErr = createError(MISSING_DOC, 'deleted');\n        return finish(deletedErr);\n      }\n      doc = unstringifyDoc(item.data, metadata.id, item.rev);\n      finish();\n    });\n  };\n\n  api._allDocs = function (opts, callback) {\n    var results = [];\n    var totalRows;\n    var updateSeq;\n\n    var start = 'startkey' in opts ? opts.startkey : false;\n    var end = 'endkey' in opts ? opts.endkey : false;\n    var key = 'key' in opts ? opts.key : false;\n    var keys = 'keys' in opts ? opts.keys : false;\n    var descending = 'descending' in opts ? opts.descending : false;\n    var limit = 'limit' in opts ? opts.limit : -1;\n    var offset = 'skip' in opts ? opts.skip : 0;\n    var inclusiveEnd = opts.inclusive_end !== false;\n    \n    var sqlArgs = [];\n    var criteria = [];\n\n    if (keys) {\n      var destinctKeys = [];\n      var bindingStr = \"\";\n      keys.forEach(function (key) {\n        if (destinctKeys.indexOf(key) === -1) {\n          destinctKeys.push(key);\n          bindingStr += '?,';\n        }\n      });\n      bindingStr = bindingStr.substring(0, bindingStr.length - 1); // keys is never empty\n      criteria.push(DOC_STORE$1 + '.id IN (' + bindingStr + ')');\n      sqlArgs = sqlArgs.concat(destinctKeys);\n    } else if (key !== false) {\n      criteria.push(DOC_STORE$1 + '.id = ?');\n      sqlArgs.push(key);\n    } else if (start !== false || end !== false) {\n      if (start !== false) {\n        criteria.push(DOC_STORE$1 + '.id ' + (descending ? '<=' : '>=') + ' ?');\n        sqlArgs.push(start);\n      }\n      if (end !== false) {\n        var comparator = descending ? '>' : '<';\n        if (inclusiveEnd) {\n          comparator += '=';\n        }\n        criteria.push(DOC_STORE$1 + '.id ' + comparator + ' ?');\n        sqlArgs.push(end);\n      }\n      if (key !== false) {\n        criteria.push(DOC_STORE$1 + '.id = ?');\n        sqlArgs.push(key);\n      }\n    }\n\n    if (!keys) {\n      // report deleted if keys are specified\n      criteria.push(BY_SEQ_STORE$1 + '.deleted = 0');\n    }\n\n    db.readTransaction(function (tx) {\n      // count the docs in parallel to other operations\n      countDocs(tx, function (docCount) {\n        totalRows = docCount;\n      });\n\n      /* istanbul ignore if */\n      if (opts.update_seq) {\n        // get max sequence in parallel to other operations\n        getMaxSeq(tx, function (theSeq) {\n          updateSeq = theSeq;\n        });\n      }\n\n      if (limit === 0) {\n        return;\n      }\n\n      // do a single query to fetch the documents\n      var sql = select(\n        SELECT_DOCS,\n        [DOC_STORE$1, BY_SEQ_STORE$1],\n        DOC_STORE_AND_BY_SEQ_JOINER,\n        criteria,\n        DOC_STORE$1 + '.id ' + (descending ? 'DESC' : 'ASC')\n        );\n      sql += ' LIMIT ' + limit + ' OFFSET ' + offset;\n\n      tx.executeSql(sql, sqlArgs, function (tx, result) {\n        for (var i = 0, l = result.rows.length; i < l; i++) {\n          var item = result.rows.item(i);\n          var metadata = safeJsonParse(item.metadata);\n          var id = metadata.id;\n          var data = unstringifyDoc(item.data, id, item.rev);\n          var winningRev$$1 = data._rev;\n          var doc = {\n            id: id,\n            key: id,\n            value: {rev: winningRev$$1}\n          };\n          if (opts.include_docs) {\n            doc.doc = data;\n            doc.doc._rev = winningRev$$1;\n            if (opts.conflicts) {\n              var conflicts = collectConflicts(metadata);\n              if (conflicts.length) {\n                doc.doc._conflicts = conflicts;\n              }\n            }\n            fetchAttachmentsIfNecessary$1(doc.doc, opts, api, tx);\n          }\n          if (item.deleted) {\n            if (keys) {\n              doc.value.deleted = true;\n              doc.doc = null;\n            } else {\n              // propably should not happen\n              continue;\n            }\n          }\n          if (!keys) {\n            results.push(doc);\n          } else {\n            var index = keys.indexOf(id, index);\n            do {\n              results[index] = doc;\n              index = keys.indexOf(id, index + 1);\n            } while (index > -1 && index < keys.length);\n          }\n        }\n        if (keys) {\n          keys.forEach(function (key, index) {\n            if (!results[index]) {\n              results[index] = {key: key, error: 'not_found'};\n            }\n          });\n        }\n      });\n    }, websqlError(callback), function () {\n      var returnVal = {\n        total_rows: totalRows,\n        offset: opts.skip,\n        rows: results\n      };\n\n      /* istanbul ignore if */\n      if (opts.update_seq) {\n        returnVal.update_seq = updateSeq;\n      }\n      callback(null, returnVal);\n    });\n  };\n\n  api._changes = function (opts) {\n    opts = clone(opts);\n\n    if (opts.continuous) {\n      var id = api._name + ':' + uuid();\n      websqlChanges.addListener(api._name, id, api, opts);\n      websqlChanges.notify(api._name);\n      return {\n        cancel: function () {\n          websqlChanges.removeListener(api._name, id);\n        }\n      };\n    }\n\n    var descending = opts.descending;\n\n    // Ignore the `since` parameter when `descending` is true\n    opts.since = opts.since && !descending ? opts.since : 0;\n\n    var limit = 'limit' in opts ? opts.limit : -1;\n    if (limit === 0) {\n      limit = 1; // per CouchDB _changes spec\n    }\n\n    var returnDocs;\n    if ('return_docs' in opts) {\n      returnDocs = opts.return_docs;\n    } else if ('returnDocs' in opts) {\n      // TODO: Remove 'returnDocs' in favor of 'return_docs' in a future release\n      returnDocs = opts.returnDocs;\n    } else {\n      returnDocs = true;\n    }\n    var results = [];\n    var numResults = 0;\n\n    function fetchChanges() {\n\n      var selectStmt =\n        DOC_STORE$1 + '.json AS metadata, ' +\n        DOC_STORE$1 + '.max_seq AS maxSeq, ' +\n        BY_SEQ_STORE$1 + '.json AS winningDoc, ' +\n        BY_SEQ_STORE$1 + '.rev AS winningRev ';\n\n      var from = DOC_STORE$1 + ' JOIN ' + BY_SEQ_STORE$1;\n\n      var joiner = DOC_STORE$1 + '.id=' + BY_SEQ_STORE$1 + '.doc_id' +\n        ' AND ' + DOC_STORE$1 + '.winningseq=' + BY_SEQ_STORE$1 + '.seq';\n\n      var criteria = ['maxSeq > ?'];\n      var sqlArgs = [opts.since];\n\n      if (opts.doc_ids) {\n        criteria.push(DOC_STORE$1 + '.id IN ' + qMarks(opts.doc_ids.length));\n        sqlArgs = sqlArgs.concat(opts.doc_ids);\n      }\n\n      var orderBy = 'maxSeq ' + (descending ? 'DESC' : 'ASC');\n\n      var sql = select(selectStmt, from, joiner, criteria, orderBy);\n\n      var filter = filterChange(opts);\n      if (!opts.view && !opts.filter) {\n        // we can just limit in the query\n        sql += ' LIMIT ' + limit;\n      }\n\n      var lastSeq = opts.since || 0;\n      db.readTransaction(function (tx) {\n        tx.executeSql(sql, sqlArgs, function (tx, result) {\n          function reportChange(change) {\n            return function () {\n              opts.onChange(change);\n            };\n          }\n          for (var i = 0, l = result.rows.length; i < l; i++) {\n            var item = result.rows.item(i);\n            var metadata = safeJsonParse(item.metadata);\n            lastSeq = item.maxSeq;\n\n            var doc = unstringifyDoc(item.winningDoc, metadata.id,\n              item.winningRev);\n            var change = opts.processChange(doc, metadata, opts);\n            change.seq = item.maxSeq;\n\n            var filtered = filter(change);\n            if (typeof filtered === 'object') {\n              return opts.complete(filtered);\n            }\n\n            if (filtered) {\n              numResults++;\n              if (returnDocs) {\n                results.push(change);\n              }\n              // process the attachment immediately\n              // for the benefit of live listeners\n              if (opts.attachments && opts.include_docs) {\n                fetchAttachmentsIfNecessary$1(doc, opts, api, tx,\n                  reportChange(change));\n              } else {\n                reportChange(change)();\n              }\n            }\n            if (numResults === limit) {\n              break;\n            }\n          }\n        });\n      }, websqlError(opts.complete), function () {\n        if (!opts.continuous) {\n          opts.complete(null, {\n            results: results,\n            last_seq: lastSeq\n          });\n        }\n      });\n    }\n\n    fetchChanges();\n  };\n\n  api._close = function (callback) {\n    //WebSQL databases do not need to be closed\n    callback();\n  };\n\n  api._getAttachment = function (docId, attachId, attachment, opts, callback) {\n    var res;\n    var tx = opts.ctx;\n    var digest = attachment.digest;\n    var type = attachment.content_type;\n    var sql = 'SELECT escaped, ' +\n      'CASE WHEN escaped = 1 THEN body ELSE HEX(body) END AS body FROM ' +\n      ATTACH_STORE$1 + ' WHERE digest=?';\n    tx.executeSql(sql, [digest], function (tx, result) {\n      // websql has a bug where \\u0000 causes early truncation in strings\n      // and blobs. to work around this, we used to use the hex() function,\n      // but that's not performant. after migration 6, we remove \\u0000\n      // and add it back in afterwards\n      var item = result.rows.item(0);\n      var data = item.escaped ? unescapeBlob(item.body) :\n        parseHexString(item.body, encoding);\n      if (opts.binary) {\n        res = binStringToBluffer(data, type);\n      } else {\n        res = thisBtoa(data);\n      }\n      callback(null, res);\n    });\n  };\n\n  api._getRevisionTree = function (docId, callback) {\n    db.readTransaction(function (tx) {\n      var sql = 'SELECT json AS metadata FROM ' + DOC_STORE$1 + ' WHERE id = ?';\n      tx.executeSql(sql, [docId], function (tx, result) {\n        if (!result.rows.length) {\n          callback(createError(MISSING_DOC));\n        } else {\n          var data = safeJsonParse(result.rows.item(0).metadata);\n          callback(null, data.rev_tree);\n        }\n      });\n    });\n  };\n\n  api._doCompaction = function (docId, revs, callback) {\n    if (!revs.length) {\n      return callback();\n    }\n    db.transaction(function (tx) {\n\n      // update doc store\n      var sql = 'SELECT json AS metadata FROM ' + DOC_STORE$1 + ' WHERE id = ?';\n      tx.executeSql(sql, [docId], function (tx, result) {\n        var metadata = safeJsonParse(result.rows.item(0).metadata);\n        traverseRevTree(metadata.rev_tree, function (isLeaf, pos,\n                                                           revHash, ctx, opts) {\n          var rev$$1 = pos + '-' + revHash;\n          if (revs.indexOf(rev$$1) !== -1) {\n            opts.status = 'missing';\n          }\n        });\n\n        var sql = 'UPDATE ' + DOC_STORE$1 + ' SET json = ? WHERE id = ?';\n        tx.executeSql(sql, [safeJsonStringify(metadata), docId]);\n      });\n\n      compactRevs$1(revs, docId, tx);\n    }, websqlError(callback), function () {\n      callback();\n    });\n  };\n\n  api._getLocal = function (id, callback) {\n    db.readTransaction(function (tx) {\n      var sql = 'SELECT json, rev FROM ' + LOCAL_STORE$1 + ' WHERE id=?';\n      tx.executeSql(sql, [id], function (tx, res) {\n        if (res.rows.length) {\n          var item = res.rows.item(0);\n          var doc = unstringifyDoc(item.json, id, item.rev);\n          callback(null, doc);\n        } else {\n          callback(createError(MISSING_DOC));\n        }\n      });\n    });\n  };\n\n  api._putLocal = function (doc, opts, callback) {\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    delete doc._revisions; // ignore this, trust the rev\n    var oldRev = doc._rev;\n    var id = doc._id;\n    var newRev;\n    if (!oldRev) {\n      newRev = doc._rev = '0-1';\n    } else {\n      newRev = doc._rev = '0-' + (parseInt(oldRev.split('-')[1], 10) + 1);\n    }\n    var json = stringifyDoc(doc);\n\n    var ret;\n    function putLocal(tx) {\n      var sql;\n      var values;\n      if (oldRev) {\n        sql = 'UPDATE ' + LOCAL_STORE$1 + ' SET rev=?, json=? ' +\n          'WHERE id=? AND rev=?';\n        values = [newRev, json, id, oldRev];\n      } else {\n        sql = 'INSERT INTO ' + LOCAL_STORE$1 + ' (id, rev, json) VALUES (?,?,?)';\n        values = [id, newRev, json];\n      }\n      tx.executeSql(sql, values, function (tx, res) {\n        if (res.rowsAffected) {\n          ret = {ok: true, id: id, rev: newRev};\n          if (opts.ctx) { // return immediately\n            callback(null, ret);\n          }\n        } else {\n          callback(createError(REV_CONFLICT));\n        }\n      }, function () {\n        callback(createError(REV_CONFLICT));\n        return false; // ack that we handled the error\n      });\n    }\n\n    if (opts.ctx) {\n      putLocal(opts.ctx);\n    } else {\n      db.transaction(putLocal, websqlError(callback), function () {\n        if (ret) {\n          callback(null, ret);\n        }\n      });\n    }\n  };\n\n  api._removeLocal = function (doc, opts, callback) {\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    var ret;\n\n    function removeLocal(tx) {\n      var sql = 'DELETE FROM ' + LOCAL_STORE$1 + ' WHERE id=? AND rev=?';\n      var params = [doc._id, doc._rev];\n      tx.executeSql(sql, params, function (tx, res) {\n        if (!res.rowsAffected) {\n          return callback(createError(MISSING_DOC));\n        }\n        ret = {ok: true, id: doc._id, rev: '0-0'};\n        if (opts.ctx) { // return immediately\n          callback(null, ret);\n        }\n      });\n    }\n\n    if (opts.ctx) {\n      removeLocal(opts.ctx);\n    } else {\n      db.transaction(removeLocal, websqlError(callback), function () {\n        if (ret) {\n          callback(null, ret);\n        }\n      });\n    }\n  };\n\n  api._destroy = function (opts, callback) {\n    websqlChanges.removeAllListeners(api._name);\n    db.transaction(function (tx) {\n      var stores = [DOC_STORE$1, BY_SEQ_STORE$1, ATTACH_STORE$1, META_STORE$1,\n        LOCAL_STORE$1, ATTACH_AND_SEQ_STORE$1];\n      stores.forEach(function (store) {\n        tx.executeSql('DROP TABLE IF EXISTS ' + store, []);\n      });\n    }, websqlError(callback), function () {\n      if (hasLocalStorage()) {\n        delete window.localStorage['_pouch__websqldb_' + api._name];\n        delete window.localStorage[api._name];\n      }\n      callback(null, {'ok': true});\n    });\n  };\n}\n\nfunction canOpenTestDB() {\n  try {\n    openDatabase('_pouch_validate_websql', 1, '', 1);\n    return true;\n  } catch (err) {\n    return false;\n  }\n}\n\n// WKWebView had a bug where WebSQL would throw a DOM Exception 18\n// (see https://bugs.webkit.org/show_bug.cgi?id=137760 and\n// https://github.com/pouchdb/pouchdb/issues/5079)\n// This has been fixed in latest WebKit, so we try to detect it here.\nfunction isValidWebSQL() {\n  // WKWebView UA:\n  //   Mozilla/5.0 (iPhone; CPU iPhone OS 9_2 like Mac OS X)\n  //   AppleWebKit/601.1.46 (KHTML, like Gecko) Mobile/13C75\n  // Chrome for iOS UA:\n  //   Mozilla/5.0 (iPhone; U; CPU iPhone OS 5_1_1 like Mac OS X; en)\n  //   AppleWebKit/534.46.0 (KHTML, like Gecko) CriOS/19.0.1084.60\n  //   Mobile/9B206 Safari/7534.48.3\n  // Firefox for iOS UA:\n  //   Mozilla/5.0 (iPhone; CPU iPhone OS 8_3 like Mac OS X) AppleWebKit/600.1.4\n  //   (KHTML, like Gecko) FxiOS/1.0 Mobile/12F69 Safari/600.1.4\n\n  // indexedDB is null on some UIWebViews and undefined in others\n  // see: https://bugs.webkit.org/show_bug.cgi?id=137034\n  if (typeof indexedDB === 'undefined' || indexedDB === null ||\n      !/iP(hone|od|ad)/.test(navigator.userAgent)) {\n    // definitely not WKWebView, avoid creating an unnecessary database\n    return true;\n  }\n  // Cache the result in LocalStorage. Reason we do this is because if we\n  // call openDatabase() too many times, Safari craps out in SauceLabs and\n  // starts throwing DOM Exception 14s.\n  var hasLS = hasLocalStorage();\n  // Include user agent in the hash, so that if Safari is upgraded, we don't\n  // continually think it's broken.\n  var localStorageKey = '_pouch__websqldb_valid_' + navigator.userAgent;\n  if (hasLS && localStorage[localStorageKey]) {\n    return localStorage[localStorageKey] === '1';\n  }\n  var openedTestDB = canOpenTestDB();\n  if (hasLS) {\n    localStorage[localStorageKey] = openedTestDB ? '1' : '0';\n  }\n  return openedTestDB;\n}\n\nfunction valid() {\n  if (typeof openDatabase !== 'function') {\n    return false;\n  }\n  return isValidWebSQL();\n}\n\nfunction openDB$2(name, version, description, size) {\n  // Traditional WebSQL API\n  return openDatabase(name, version, description, size);\n}\n\nfunction WebSQLPouch(opts, callback) {\n  var msg = 'WebSQL is deprecated and will be removed in future releases of PouchDB. ' +\n      'Please migrate to IndexedDB: https://pouchdb.com/2018/01/23/pouchdb-6.4.2.html';\n  guardedConsole('warn', msg);\n  var _opts = $inject_Object_assign({\n    websql: openDB$2\n  }, opts);\n\n  WebSqlPouch.call(this, _opts, callback);\n}\n\nWebSQLPouch.valid = valid;\n\nWebSQLPouch.use_prefix = true;\n\nfunction WebSqlPouch$1 (PouchDB) {\n  PouchDB.adapter('websql', WebSQLPouch, true);\n}\n\n/* global fetch */\n/* global Headers */\nfunction wrappedFetch() {\n  var wrappedPromise = {};\n\n  var promise = new PouchPromise(function (resolve, reject) {\n    wrappedPromise.resolve = resolve;\n    wrappedPromise.reject = reject;\n  });\n\n  var args = new Array(arguments.length);\n\n  for (var i = 0; i < args.length; i++) {\n    args[i] = arguments[i];\n  }\n\n  wrappedPromise.promise = promise;\n\n  PouchPromise.resolve().then(function () {\n    return fetch.apply(null, args);\n  }).then(function (response) {\n    wrappedPromise.resolve(response);\n  })[\"catch\"](function (error) {\n    wrappedPromise.reject(error);\n  });\n\n  return wrappedPromise;\n}\n\nfunction fetchRequest(options, callback) {\n  var wrappedPromise, timer, response;\n\n  var headers = new Headers();\n\n  var fetchOptions = {\n    method: options.method,\n    credentials: 'include',\n    headers: headers\n  };\n\n  if (options.json) {\n    headers.set('Accept', 'application/json');\n    headers.set('Content-Type', options.headers['Content-Type'] ||\n      'application/json');\n  }\n\n  if (options.body &&\n      options.processData &&\n      typeof options.body !== 'string') {\n    fetchOptions.body = JSON.stringify(options.body);\n  } else if ('body' in options) {\n    fetchOptions.body = options.body;\n  } else {\n    fetchOptions.body = null;\n  }\n\n  Object.keys(options.headers).forEach(function (key) {\n    if (options.headers.hasOwnProperty(key)) {\n      headers.set(key, options.headers[key]);\n    }\n  });\n\n  wrappedPromise = wrappedFetch(options.url, fetchOptions);\n\n  if (options.timeout > 0) {\n    timer = setTimeout(function () {\n      wrappedPromise.reject(new Error('Load timeout for resource: ' +\n        options.url));\n    }, options.timeout);\n  }\n\n  wrappedPromise.promise.then(function (fetchResponse) {\n    response = {\n      statusCode: fetchResponse.status\n    };\n\n    if (options.timeout > 0) {\n      clearTimeout(timer);\n    }\n\n    if (response.statusCode >= 200 && response.statusCode < 300) {\n      return options.binary ? fetchResponse.blob() : fetchResponse.text();\n    }\n\n    return fetchResponse.json();\n  }).then(function (result) {\n    if (response.statusCode >= 200 && response.statusCode < 300) {\n      callback(null, response, result);\n    } else {\n      result.status = response.statusCode;\n      callback(result);\n    }\n  })[\"catch\"](function (error) {\n    if (!error) {\n      // this happens when the listener is canceled\n      error = new Error('canceled');\n    }\n    callback(error);\n  });\n\n  return {abort: wrappedPromise.reject};\n}\n\nfunction xhRequest(options, callback) {\n\n  var xhr, timer;\n  var timedout = false;\n\n  var abortReq = function () {\n    xhr.abort();\n    cleanUp();\n  };\n\n  var timeoutReq = function () {\n    timedout = true;\n    xhr.abort();\n    cleanUp();\n  };\n\n  var ret = {abort: abortReq};\n\n  var cleanUp = function () {\n    clearTimeout(timer);\n    ret.abort = function () {};\n    if (xhr) {\n      xhr.onprogress = undefined;\n      if (xhr.upload) {\n        xhr.upload.onprogress = undefined;\n      }\n      xhr.onreadystatechange = undefined;\n      xhr = undefined;\n    }\n  };\n\n  if (options.xhr) {\n    xhr = new options.xhr();\n  } else {\n    xhr = new XMLHttpRequest();\n  }\n\n  try {\n    xhr.open(options.method, options.url);\n  } catch (exception) {\n    return callback(new Error(exception.name || 'Url is invalid'));\n  }\n\n  xhr.withCredentials = ('withCredentials' in options) ?\n    options.withCredentials : true;\n\n  if (options.method === 'GET') {\n    delete options.headers['Content-Type'];\n  } else if (options.json) {\n    options.headers.Accept = 'application/json';\n    options.headers['Content-Type'] = options.headers['Content-Type'] ||\n      'application/json';\n    if (options.body &&\n        options.processData &&\n        typeof options.body !== \"string\") {\n      options.body = JSON.stringify(options.body);\n    }\n  }\n\n  if (options.binary) {\n    xhr.responseType = 'arraybuffer';\n  }\n\n  if (!('body' in options)) {\n    options.body = null;\n  }\n\n  for (var key in options.headers) {\n    if (options.headers.hasOwnProperty(key)) {\n      xhr.setRequestHeader(key, options.headers[key]);\n    }\n  }\n\n  if (options.timeout > 0) {\n    timer = setTimeout(timeoutReq, options.timeout);\n    xhr.onprogress = function () {\n      clearTimeout(timer);\n      if (xhr.readyState !== 4) {\n        timer = setTimeout(timeoutReq, options.timeout);\n      }\n    };\n    if (typeof xhr.upload !== 'undefined') { // does not exist in ie9\n      xhr.upload.onprogress = xhr.onprogress;\n    }\n  }\n\n  xhr.onreadystatechange = function () {\n    if (xhr.readyState !== 4) {\n      return;\n    }\n\n    var response = {\n      statusCode: xhr.status\n    };\n\n    if (xhr.status >= 200 && xhr.status < 300) {\n      var data;\n      if (options.binary) {\n        data = createBlob([xhr.response || ''], {\n          type: xhr.getResponseHeader('Content-Type')\n        });\n      } else {\n        data = xhr.responseText;\n      }\n      callback(null, response, data);\n    } else {\n      var err = {};\n      if (timedout) {\n        err = new Error('ETIMEDOUT');\n        err.code = 'ETIMEDOUT';\n      } else if (typeof xhr.response === 'string' && xhr.response !== '') {\n        try {\n          err = JSON.parse(xhr.response);\n        } catch (e) {}\n      }\n\n      err.status = xhr.status;\n\n      callback(err);\n    }\n    cleanUp();\n  };\n\n  if (options.body && (options.body instanceof Blob)) {\n    readAsArrayBuffer(options.body, function (arrayBuffer) {\n      xhr.send(arrayBuffer);\n    });\n  } else {\n    xhr.send(options.body);\n  }\n\n  return ret;\n}\n\nfunction testXhr() {\n  try {\n    new XMLHttpRequest();\n    return true;\n  } catch (err) {\n    return false;\n  }\n}\n\nvar hasXhr = testXhr();\n\nfunction ajax(options, callback) {\n  if (!false && (hasXhr || options.xhr)) {\n    return xhRequest(options, callback);\n  } else {\n    return fetchRequest(options, callback);\n  }\n}\n\n// the blob already has a type; do nothing\n\nfunction defaultBody() {\n  return '';\n}\n\nfunction ajaxCore(options, callback) {\n\n  options = clone(options);\n\n  var defaultOptions = {\n    method : \"GET\",\n    headers: {},\n    json: true,\n    processData: true,\n    timeout: 10000,\n    cache: false\n  };\n\n  options = $inject_Object_assign(defaultOptions, options);\n\n  function onSuccess(obj, resp, cb) {\n    if (!options.binary && options.json && typeof obj === 'string') {\n      /* istanbul ignore next */\n      try {\n        obj = JSON.parse(obj);\n      } catch (e) {\n        // Probably a malformed JSON from server\n        return cb(e);\n      }\n    }\n    if (Array.isArray(obj)) {\n      obj = obj.map(function (v) {\n        if (v.error || v.missing) {\n          return generateErrorFromResponse(v);\n        } else {\n          return v;\n        }\n      });\n    }\n    if (options.binary) {\n      \n    }\n    cb(null, obj, resp);\n  }\n\n  if (options.json) {\n    if (!options.binary) {\n      options.headers.Accept = 'application/json';\n    }\n    options.headers['Content-Type'] = options.headers['Content-Type'] ||\n      'application/json';\n  }\n\n  if (options.binary) {\n    options.encoding = null;\n    options.json = false;\n  }\n\n  if (!options.processData) {\n    options.json = false;\n  }\n\n  return ajax(options, function (err, response, body) {\n\n    if (err) {\n      return callback(generateErrorFromResponse(err));\n    }\n\n    var error;\n    var content_type = response.headers && response.headers['content-type'];\n    var data = body || defaultBody();\n\n    // CouchDB doesn't always return the right content-type for JSON data, so\n    // we check for ^{ and }$ (ignoring leading/trailing whitespace)\n    if (!options.binary && (options.json || !options.processData) &&\n        typeof data !== 'object' &&\n        (/json/.test(content_type) ||\n         (/^[\\s]*\\{/.test(data) && /\\}[\\s]*$/.test(data)))) {\n      try {\n        data = JSON.parse(data.toString());\n      } catch (e) {}\n    }\n\n    if (response.statusCode >= 200 && response.statusCode < 300) {\n      onSuccess(data, response, callback);\n    } else {\n      error = generateErrorFromResponse(data);\n      error.status = response.statusCode;\n      callback(error);\n    }\n  });\n}\n\nfunction ajax$1(opts, callback) {\n\n  // cache-buster, specifically designed to work around IE's aggressive caching\n  // see http://www.dashbay.com/2011/05/internet-explorer-caches-ajax/\n  // Also Safari caches POSTs, so we need to cache-bust those too.\n  var ua = (navigator && navigator.userAgent) ?\n    navigator.userAgent.toLowerCase() : '';\n\n  var isSafari = ua.indexOf('safari') !== -1 && ua.indexOf('chrome') === -1;\n  var isIE = ua.indexOf('msie') !== -1;\n  var isTrident = ua.indexOf('trident') !== -1;\n  var isEdge = ua.indexOf('edge') !== -1;\n\n  // it appears the new version of safari also caches GETs,\n  // see https://github.com/pouchdb/pouchdb/issues/5010\n  var shouldCacheBust = (isSafari ||\n    ((isIE || isTrident || isEdge) && opts.method === 'GET'));\n\n  var cache = 'cache' in opts ? opts.cache : true;\n\n  var isBlobUrl = /^blob:/.test(opts.url); // don't append nonces for blob URLs\n\n  if (!isBlobUrl && (shouldCacheBust || !cache)) {\n    var hasArgs = opts.url.indexOf('?') !== -1;\n    opts.url += (hasArgs ? '&' : '?') + '_nonce=' + Date.now();\n  }\n\n  return ajaxCore(opts, callback);\n}\n\n// dead simple promise pool, inspired by https://github.com/timdp/es6-promise-pool\n// but much smaller in code size. limits the number of concurrent promises that are executed\n\n\nfunction pool(promiseFactories, limit) {\n  return new PouchPromise(function (resolve, reject) {\n    var running = 0;\n    var current = 0;\n    var done = 0;\n    var len = promiseFactories.length;\n    var err;\n\n    function runNext() {\n      running++;\n      promiseFactories[current++]().then(onSuccess, onError);\n    }\n\n    function doNext() {\n      if (++done === len) {\n        /* istanbul ignore if */\n        if (err) {\n          reject(err);\n        } else {\n          resolve();\n        }\n      } else {\n        runNextBatch();\n      }\n    }\n\n    function onSuccess() {\n      running--;\n      doNext();\n    }\n\n    /* istanbul ignore next */\n    function onError(thisErr) {\n      running--;\n      err = err || thisErr;\n      doNext();\n    }\n\n    function runNextBatch() {\n      while (running < limit && current < len) {\n        runNext();\n      }\n    }\n\n    runNextBatch();\n  });\n}\n\nvar CHANGES_BATCH_SIZE = 25;\nvar MAX_SIMULTANEOUS_REVS = 50;\nvar CHANGES_TIMEOUT_BUFFER = 5000;\nvar DEFAULT_HEARTBEAT = 10000;\n\nvar supportsBulkGetMap = {};\n\nfunction readAttachmentsAsBlobOrBuffer(row) {\n  var doc = row.doc || row.ok;\n  var atts = doc._attachments;\n  if (!atts) {\n    return;\n  }\n  Object.keys(atts).forEach(function (filename) {\n    var att = atts[filename];\n    att.data = b64ToBluffer(att.data, att.content_type);\n  });\n}\n\nfunction encodeDocId(id) {\n  if (/^_design/.test(id)) {\n    return '_design/' + encodeURIComponent(id.slice(8));\n  }\n  if (/^_local/.test(id)) {\n    return '_local/' + encodeURIComponent(id.slice(7));\n  }\n  return encodeURIComponent(id);\n}\n\nfunction preprocessAttachments$2(doc) {\n  if (!doc._attachments || !Object.keys(doc._attachments)) {\n    return PouchPromise.resolve();\n  }\n\n  return PouchPromise.all(Object.keys(doc._attachments).map(function (key) {\n    var attachment = doc._attachments[key];\n    if (attachment.data && typeof attachment.data !== 'string') {\n      return new PouchPromise(function (resolve) {\n        blobToBase64(attachment.data, resolve);\n      }).then(function (b64) {\n        attachment.data = b64;\n      });\n    }\n  }));\n}\n\nfunction hasUrlPrefix(opts) {\n  if (!opts.prefix) {\n    return false;\n  }\n\n  var protocol = parseUri(opts.prefix).protocol;\n\n  return protocol === 'http' || protocol === 'https';\n}\n\n// Get all the information you possibly can about the URI given by name and\n// return it as a suitable object.\nfunction getHost(name, opts) {\n\n  // encode db name if opts.prefix is a url (#5574)\n  if (hasUrlPrefix(opts)) {\n    var dbName = opts.name.substr(opts.prefix.length);\n    name = opts.prefix + encodeURIComponent(dbName);\n  }\n\n  // Prase the URI into all its little bits\n  var uri = parseUri(name);\n\n  // Store the user and password as a separate auth object\n  if (uri.user || uri.password) {\n    uri.auth = {username: uri.user, password: uri.password};\n  }\n\n  // Split the path part of the URI into parts using '/' as the delimiter\n  // after removing any leading '/' and any trailing '/'\n  var parts = uri.path.replace(/(^\\/|\\/$)/g, '').split('/');\n\n  // Store the first part as the database name and remove it from the parts\n  // array\n  uri.db = parts.pop();\n  // Prevent double encoding of URI component\n  if (uri.db.indexOf('%') === -1) {\n    uri.db = encodeURIComponent(uri.db);\n  }\n\n  // Restore the path by joining all the remaining parts (all the parts\n  // except for the database name) with '/'s\n  uri.path = parts.join('/');\n\n  return uri;\n}\n\n// Generate a URL with the host data given by opts and the given path\nfunction genDBUrl(opts, path) {\n  return genUrl(opts, opts.db + '/' + path);\n}\n\n// Generate a URL with the host data given by opts and the given path\nfunction genUrl(opts, path) {\n  // If the host already has a path, then we need to have a path delimiter\n  // Otherwise, the path delimiter is the empty string\n  var pathDel = !opts.path ? '' : '/';\n\n  // If the host already has a path, then we need to have a path delimiter\n  // Otherwise, the path delimiter is the empty string\n  return opts.protocol + '://' + opts.host +\n         (opts.port ? (':' + opts.port) : '') +\n         '/' + opts.path + pathDel + path;\n}\n\nfunction paramsToStr(params) {\n  return '?' + Object.keys(params).map(function (k) {\n    return k + '=' + encodeURIComponent(params[k]);\n  }).join('&');\n}\n\n// Implements the PouchDB API for dealing with CouchDB instances over HTTP\nfunction HttpPouch(opts, callback) {\n\n  // The functions that will be publicly available for HttpPouch\n  var api = this;\n\n  var host = getHost(opts.name, opts);\n  var dbUrl = genDBUrl(host, '');\n\n  opts = clone(opts);\n  var ajaxOpts = opts.ajax || {};\n\n  if (opts.auth || host.auth) {\n    var nAuth = opts.auth || host.auth;\n    var str = nAuth.username + ':' + nAuth.password;\n    var token = thisBtoa(unescape(encodeURIComponent(str)));\n    ajaxOpts.headers = ajaxOpts.headers || {};\n    ajaxOpts.headers.Authorization = 'Basic ' + token;\n  }\n\n  // Not strictly necessary, but we do this because numerous tests\n  // rely on swapping ajax in and out.\n  api._ajax = ajax$1;\n\n  function ajax(userOpts, options, callback) {\n    var reqAjax = (userOpts || {}).ajax || {};\n    var reqOpts = $inject_Object_assign(clone(ajaxOpts), reqAjax, options);\n    var defaultHeaders = clone(ajaxOpts.headers || {});\n    reqOpts.headers = $inject_Object_assign(defaultHeaders, reqAjax.headers,\n      options.headers || {});\n    /* istanbul ignore if */\n    if (api.constructor.listeners('debug').length) {\n      api.constructor.emit('debug', ['http', reqOpts.method, reqOpts.url]);\n    }\n    return api._ajax(reqOpts, callback);\n  }\n\n  function ajaxPromise(userOpts, opts) {\n    return new PouchPromise(function (resolve, reject) {\n      ajax(userOpts, opts, function (err, res) {\n        /* istanbul ignore if */\n        if (err) {\n          return reject(err);\n        }\n        resolve(res);\n      });\n    });\n  }\n\n  function adapterFun$$1(name, fun) {\n    return adapterFun(name, getArguments(function (args) {\n      setup().then(function () {\n        return fun.apply(this, args);\n      })[\"catch\"](function (e) {\n        var callback = args.pop();\n        callback(e);\n      });\n    }));\n  }\n\n  var setupPromise;\n\n  function setup() {\n    // TODO: Remove `skipSetup` in favor of `skip_setup` in a future release\n    if (opts.skipSetup || opts.skip_setup) {\n      return PouchPromise.resolve();\n    }\n\n    // If there is a setup in process or previous successful setup\n    // done then we will use that\n    // If previous setups have been rejected we will try again\n    if (setupPromise) {\n      return setupPromise;\n    }\n\n    var checkExists = {method: 'GET', url: dbUrl};\n    setupPromise = ajaxPromise({}, checkExists)[\"catch\"](function (err) {\n      if (err && err.status && err.status === 404) {\n        // Doesnt exist, create it\n        explainError(404, 'PouchDB is just detecting if the remote exists.');\n        return ajaxPromise({}, {method: 'PUT', url: dbUrl});\n      } else {\n        return PouchPromise.reject(err);\n      }\n    })[\"catch\"](function (err) {\n      // If we try to create a database that already exists, skipped in\n      // istanbul since its catching a race condition.\n      /* istanbul ignore if */\n      if (err && err.status && err.status === 412) {\n        return true;\n      }\n      return PouchPromise.reject(err);\n    });\n\n    setupPromise[\"catch\"](function () {\n      setupPromise = null;\n    });\n\n    return setupPromise;\n  }\n\n  nextTick(function () {\n    callback(null, api);\n  });\n\n  api._remote = true;\n  /* istanbul ignore next */\n  api.type = function () {\n    return 'http';\n  };\n\n  api.id = adapterFun$$1('id', function (callback) {\n    ajax({}, {method: 'GET', url: genUrl(host, '')}, function (err, result) {\n      var uuid$$1 = (result && result.uuid) ?\n        (result.uuid + host.db) : genDBUrl(host, '');\n      callback(null, uuid$$1);\n    });\n  });\n\n  api.request = adapterFun$$1('request', function (options, callback) {\n    options.url = genDBUrl(host, options.url);\n    ajax({}, options, callback);\n  });\n\n  // Sends a POST request to the host calling the couchdb _compact function\n  //    version: The version of CouchDB it is running\n  api.compact = adapterFun$$1('compact', function (opts, callback) {\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    opts = clone(opts);\n    ajax(opts, {\n      url: genDBUrl(host, '_compact'),\n      method: 'POST'\n    }, function () {\n      function ping() {\n        api.info(function (err, res) {\n          // CouchDB may send a \"compact_running:true\" if it's\n          // already compacting. PouchDB Server doesn't.\n          /* istanbul ignore else */\n          if (res && !res.compact_running) {\n            callback(null, {ok: true});\n          } else {\n            setTimeout(ping, opts.interval || 200);\n          }\n        });\n      }\n      // Ping the http if it's finished compaction\n      ping();\n    });\n  });\n\n  api.bulkGet = adapterFun('bulkGet', function (opts, callback) {\n    var self = this;\n\n    function doBulkGet(cb) {\n      var params = {};\n      if (opts.revs) {\n        params.revs = true;\n      }\n      if (opts.attachments) {\n        /* istanbul ignore next */\n        params.attachments = true;\n      }\n      if (opts.latest) {\n        params.latest = true;\n      }\n      ajax(opts, {\n        url: genDBUrl(host, '_bulk_get' + paramsToStr(params)),\n        method: 'POST',\n        body: { docs: opts.docs}\n      }, function (err, result) {\n        if (!err && opts.attachments && opts.binary) {\n          result.results.forEach(function (res) {\n            res.docs.forEach(readAttachmentsAsBlobOrBuffer);\n          });\n        }\n        cb(err, result);\n      });\n    }\n\n    /* istanbul ignore next */\n    function doBulkGetShim() {\n      // avoid \"url too long error\" by splitting up into multiple requests\n      var batchSize = MAX_SIMULTANEOUS_REVS;\n      var numBatches = Math.ceil(opts.docs.length / batchSize);\n      var numDone = 0;\n      var results = new Array(numBatches);\n\n      function onResult(batchNum) {\n        return function (err, res) {\n          // err is impossible because shim returns a list of errs in that case\n          results[batchNum] = res.results;\n          if (++numDone === numBatches) {\n            callback(null, {results: flatten(results)});\n          }\n        };\n      }\n\n      for (var i = 0; i < numBatches; i++) {\n        var subOpts = pick(opts, ['revs', 'attachments', 'binary', 'latest']);\n        subOpts.ajax = ajaxOpts;\n        subOpts.docs = opts.docs.slice(i * batchSize,\n          Math.min(opts.docs.length, (i + 1) * batchSize));\n        bulkGet(self, subOpts, onResult(i));\n      }\n    }\n\n    // mark the whole database as either supporting or not supporting _bulk_get\n    var dbUrl = genUrl(host, '');\n    var supportsBulkGet = supportsBulkGetMap[dbUrl];\n\n    /* istanbul ignore next */\n    if (typeof supportsBulkGet !== 'boolean') {\n      // check if this database supports _bulk_get\n      doBulkGet(function (err, res) {\n        if (err) {\n          supportsBulkGetMap[dbUrl] = false;\n          explainError(\n            err.status,\n            'PouchDB is just detecting if the remote ' +\n            'supports the _bulk_get API.'\n          );\n          doBulkGetShim();\n        } else {\n          supportsBulkGetMap[dbUrl] = true;\n          callback(null, res);\n        }\n      });\n    } else if (supportsBulkGet) {\n      doBulkGet(callback);\n    } else {\n      doBulkGetShim();\n    }\n  });\n\n  // Calls GET on the host, which gets back a JSON string containing\n  //    couchdb: A welcome string\n  //    version: The version of CouchDB it is running\n  api._info = function (callback) {\n    setup().then(function () {\n      ajax({}, {\n        method: 'GET',\n        url: genDBUrl(host, '')\n      }, function (err, res) {\n        /* istanbul ignore next */\n        if (err) {\n        return callback(err);\n        }\n        res.host = genDBUrl(host, '');\n        callback(null, res);\n      });\n    })[\"catch\"](callback);\n  };\n\n  // Get the document with the given id from the database given by host.\n  // The id could be solely the _id in the database, or it may be a\n  // _design/ID or _local/ID path\n  api.get = adapterFun$$1('get', function (id, opts, callback) {\n    // If no options were given, set the callback to the second parameter\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    opts = clone(opts);\n\n    // List of parameters to add to the GET request\n    var params = {};\n\n    if (opts.revs) {\n      params.revs = true;\n    }\n\n    if (opts.revs_info) {\n      params.revs_info = true;\n    }\n\n    if (opts.latest) {\n      params.latest = true;\n    }\n\n    if (opts.open_revs) {\n      if (opts.open_revs !== \"all\") {\n        opts.open_revs = JSON.stringify(opts.open_revs);\n      }\n      params.open_revs = opts.open_revs;\n    }\n\n    if (opts.rev) {\n      params.rev = opts.rev;\n    }\n\n    if (opts.conflicts) {\n      params.conflicts = opts.conflicts;\n    }\n\n    /* istanbul ignore if */\n    if (opts.update_seq) {\n      params.update_seq = opts.update_seq;\n    }\n\n    id = encodeDocId(id);\n\n    // Set the options for the ajax call\n    var options = {\n      method: 'GET',\n      url: genDBUrl(host, id + paramsToStr(params))\n    };\n\n    function fetchAttachments(doc) {\n      var atts = doc._attachments;\n      var filenames = atts && Object.keys(atts);\n      if (!atts || !filenames.length) {\n        return;\n      }\n      // we fetch these manually in separate XHRs, because\n      // Sync Gateway would normally send it back as multipart/mixed,\n      // which we cannot parse. Also, this is more efficient than\n      // receiving attachments as base64-encoded strings.\n      function fetch(filename) {\n        var att = atts[filename];\n        var path = encodeDocId(doc._id) + '/' + encodeAttachmentId(filename) +\n          '?rev=' + doc._rev;\n        return ajaxPromise(opts, {\n          method: 'GET',\n          url: genDBUrl(host, path),\n          binary: true\n        }).then(function (blob) {\n          if (opts.binary) {\n            return blob;\n          }\n          return new PouchPromise(function (resolve) {\n            blobToBase64(blob, resolve);\n          });\n        }).then(function (data) {\n          delete att.stub;\n          delete att.length;\n          att.data = data;\n        });\n      }\n\n      var promiseFactories = filenames.map(function (filename) {\n        return function () {\n          return fetch(filename);\n        };\n      });\n\n      // This limits the number of parallel xhr requests to 5 any time\n      // to avoid issues with maximum browser request limits\n      return pool(promiseFactories, 5);\n    }\n\n    function fetchAllAttachments(docOrDocs) {\n      if (Array.isArray(docOrDocs)) {\n        return PouchPromise.all(docOrDocs.map(function (doc) {\n          if (doc.ok) {\n            return fetchAttachments(doc.ok);\n          }\n        }));\n      }\n      return fetchAttachments(docOrDocs);\n    }\n\n    ajaxPromise(opts, options).then(function (res) {\n      return PouchPromise.resolve().then(function () {\n        if (opts.attachments) {\n          return fetchAllAttachments(res);\n        }\n      }).then(function () {\n        callback(null, res);\n      });\n    })[\"catch\"](function (e) {\n      e.docId = id;\n      callback(e);\n    });\n  });\n\n  // Delete the document given by doc from the database given by host.\n  api.remove = adapterFun$$1('remove',\n      function (docOrId, optsOrRev, opts, callback) {\n    var doc;\n    if (typeof optsOrRev === 'string') {\n      // id, rev, opts, callback style\n      doc = {\n        _id: docOrId,\n        _rev: optsOrRev\n      };\n      if (typeof opts === 'function') {\n        callback = opts;\n        opts = {};\n      }\n    } else {\n      // doc, opts, callback style\n      doc = docOrId;\n      if (typeof optsOrRev === 'function') {\n        callback = optsOrRev;\n        opts = {};\n      } else {\n        callback = opts;\n        opts = optsOrRev;\n      }\n    }\n\n    var rev$$1 = (doc._rev || opts.rev);\n\n    // Delete the document\n    ajax(opts, {\n      method: 'DELETE',\n      url: genDBUrl(host, encodeDocId(doc._id)) + '?rev=' + rev$$1\n    }, callback);\n  });\n\n  function encodeAttachmentId(attachmentId) {\n    return attachmentId.split(\"/\").map(encodeURIComponent).join(\"/\");\n  }\n\n  // Get the attachment\n  api.getAttachment =\n    adapterFun$$1('getAttachment', function (docId, attachmentId, opts,\n                                                callback) {\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    var params = opts.rev ? ('?rev=' + opts.rev) : '';\n    var url = genDBUrl(host, encodeDocId(docId)) + '/' +\n      encodeAttachmentId(attachmentId) + params;\n    ajax(opts, {\n      method: 'GET',\n      url: url,\n      binary: true\n    }, callback);\n  });\n\n  // Remove the attachment given by the id and rev\n  api.removeAttachment =\n    adapterFun$$1('removeAttachment', function (docId, attachmentId, rev$$1,\n                                                   callback) {\n\n    var url = genDBUrl(host, encodeDocId(docId) + '/' +\n      encodeAttachmentId(attachmentId)) + '?rev=' + rev$$1;\n\n    ajax({}, {\n      method: 'DELETE',\n      url: url\n    }, callback);\n  });\n\n  // Add the attachment given by blob and its contentType property\n  // to the document with the given id, the revision given by rev, and\n  // add it to the database given by host.\n  api.putAttachment =\n    adapterFun$$1('putAttachment', function (docId, attachmentId, rev$$1, blob,\n                                                type, callback) {\n    if (typeof type === 'function') {\n      callback = type;\n      type = blob;\n      blob = rev$$1;\n      rev$$1 = null;\n    }\n    var id = encodeDocId(docId) + '/' + encodeAttachmentId(attachmentId);\n    var url = genDBUrl(host, id);\n    if (rev$$1) {\n      url += '?rev=' + rev$$1;\n    }\n\n    if (typeof blob === 'string') {\n      // input is assumed to be a base64 string\n      var binary;\n      try {\n        binary = thisAtob(blob);\n      } catch (err) {\n        return callback(createError(BAD_ARG,\n                        'Attachment is not a valid base64 string'));\n      }\n      blob = binary ? binStringToBluffer(binary, type) : '';\n    }\n\n    var opts = {\n      headers: {'Content-Type': type},\n      method: 'PUT',\n      url: url,\n      processData: false,\n      body: blob,\n      timeout: ajaxOpts.timeout || 60000\n    };\n    // Add the attachment\n    ajax({}, opts, callback);\n  });\n\n  // Update/create multiple documents given by req in the database\n  // given by host.\n  api._bulkDocs = function (req, opts, callback) {\n    // If new_edits=false then it prevents the database from creating\n    // new revision numbers for the documents. Instead it just uses\n    // the old ones. This is used in database replication.\n    req.new_edits = opts.new_edits;\n\n    setup().then(function () {\n      return PouchPromise.all(req.docs.map(preprocessAttachments$2));\n    }).then(function () {\n      // Update/create the documents\n      ajax(opts, {\n        method: 'POST',\n        url: genDBUrl(host, '_bulk_docs'),\n        timeout: opts.timeout,\n        body: req\n      }, function (err, results) {\n        if (err) {\n          return callback(err);\n        }\n        results.forEach(function (result) {\n          result.ok = true; // smooths out cloudant not adding this\n        });\n        callback(null, results);\n      });\n    })[\"catch\"](callback);\n  };\n\n\n  // Update/create document\n  api._put = function (doc, opts, callback) {\n    setup().then(function () {\n      return preprocessAttachments$2(doc);\n    }).then(function () {\n      // Update/create the document\n      ajax(opts, {\n        method: 'PUT',\n        url: genDBUrl(host, encodeDocId(doc._id)),\n        body: doc\n      }, function (err, result) {\n        if (err) {\n          err.docId = doc && doc._id;\n          return callback(err);\n        }\n        callback(null, result);\n      });\n    })[\"catch\"](callback);\n  };\n\n\n  // Get a listing of the documents in the database given\n  // by host and ordered by increasing id.\n  api.allDocs = adapterFun$$1('allDocs', function (opts, callback) {\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    opts = clone(opts);\n\n    // List of parameters to add to the GET request\n    var params = {};\n    var body;\n    var method = 'GET';\n\n    if (opts.conflicts) {\n      params.conflicts = true;\n    }\n\n    /* istanbul ignore if */\n    if (opts.update_seq) {\n      params.update_seq = true;\n    }\n\n    if (opts.descending) {\n      params.descending = true;\n    }\n\n    if (opts.include_docs) {\n      params.include_docs = true;\n    }\n\n    // added in CouchDB 1.6.0\n    if (opts.attachments) {\n      params.attachments = true;\n    }\n\n    if (opts.key) {\n      params.key = JSON.stringify(opts.key);\n    }\n\n    if (opts.start_key) {\n      opts.startkey = opts.start_key;\n    }\n\n    if (opts.startkey) {\n      params.startkey = JSON.stringify(opts.startkey);\n    }\n\n    if (opts.end_key) {\n      opts.endkey = opts.end_key;\n    }\n\n    if (opts.endkey) {\n      params.endkey = JSON.stringify(opts.endkey);\n    }\n\n    if (typeof opts.inclusive_end !== 'undefined') {\n      params.inclusive_end = !!opts.inclusive_end;\n    }\n\n    if (typeof opts.limit !== 'undefined') {\n      params.limit = opts.limit;\n    }\n\n    if (typeof opts.skip !== 'undefined') {\n      params.skip = opts.skip;\n    }\n\n    var paramStr = paramsToStr(params);\n\n    if (typeof opts.keys !== 'undefined') {\n      method = 'POST';\n      body = {keys: opts.keys};\n    }\n\n    // Get the document listing\n    ajaxPromise(opts, {\n      method: method,\n      url: genDBUrl(host, '_all_docs' + paramStr),\n      body: body\n    }).then(function (res) {\n      if (opts.include_docs && opts.attachments && opts.binary) {\n        res.rows.forEach(readAttachmentsAsBlobOrBuffer);\n      }\n      callback(null, res);\n    })[\"catch\"](callback);\n  });\n\n  // Get a list of changes made to documents in the database given by host.\n  // TODO According to the README, there should be two other methods here,\n  // api.changes.addListener and api.changes.removeListener.\n  api._changes = function (opts) {\n\n    // We internally page the results of a changes request, this means\n    // if there is a large set of changes to be returned we can start\n    // processing them quicker instead of waiting on the entire\n    // set of changes to return and attempting to process them at once\n    var batchSize = 'batch_size' in opts ? opts.batch_size : CHANGES_BATCH_SIZE;\n\n    opts = clone(opts);\n\n    if (opts.continuous && !('heartbeat' in opts)) {\n      opts.heartbeat = DEFAULT_HEARTBEAT;\n    }\n\n    var requestTimeout = ('timeout' in opts) ? opts.timeout :\n      ('timeout' in ajaxOpts) ? ajaxOpts.timeout :\n      30 * 1000;\n\n    // ensure CHANGES_TIMEOUT_BUFFER applies\n    if ('timeout' in opts && opts.timeout &&\n      (requestTimeout - opts.timeout) < CHANGES_TIMEOUT_BUFFER) {\n        requestTimeout = opts.timeout + CHANGES_TIMEOUT_BUFFER;\n    }\n\n    if ('heartbeat' in opts && opts.heartbeat &&\n       (requestTimeout - opts.heartbeat) < CHANGES_TIMEOUT_BUFFER) {\n        requestTimeout = opts.heartbeat + CHANGES_TIMEOUT_BUFFER;\n    }\n\n    var params = {};\n    if ('timeout' in opts && opts.timeout) {\n      params.timeout = opts.timeout;\n    }\n\n    var limit = (typeof opts.limit !== 'undefined') ? opts.limit : false;\n    var returnDocs;\n    if ('return_docs' in opts) {\n      returnDocs = opts.return_docs;\n    } else if ('returnDocs' in opts) {\n      // TODO: Remove 'returnDocs' in favor of 'return_docs' in a future release\n      returnDocs = opts.returnDocs;\n    } else {\n      returnDocs = true;\n    }\n    //\n    var leftToFetch = limit;\n\n    if (opts.style) {\n      params.style = opts.style;\n    }\n\n    if (opts.include_docs || opts.filter && typeof opts.filter === 'function') {\n      params.include_docs = true;\n    }\n\n    if (opts.attachments) {\n      params.attachments = true;\n    }\n\n    if (opts.continuous) {\n      params.feed = 'longpoll';\n    }\n\n    if (opts.seq_interval) {\n      params.seq_interval = opts.seq_interval;\n    }\n\n    if (opts.conflicts) {\n      params.conflicts = true;\n    }\n\n    if (opts.descending) {\n      params.descending = true;\n    }\n    \n    /* istanbul ignore if */\n    if (opts.update_seq) {\n      params.update_seq = true;\n    }\n\n    if ('heartbeat' in opts) {\n      // If the heartbeat value is false, it disables the default heartbeat\n      if (opts.heartbeat) {\n        params.heartbeat = opts.heartbeat;\n      }\n    }\n\n    if (opts.filter && typeof opts.filter === 'string') {\n      params.filter = opts.filter;\n    }\n\n    if (opts.view && typeof opts.view === 'string') {\n      params.filter = '_view';\n      params.view = opts.view;\n    }\n\n    // If opts.query_params exists, pass it through to the changes request.\n    // These parameters may be used by the filter on the source database.\n    if (opts.query_params && typeof opts.query_params === 'object') {\n      for (var param_name in opts.query_params) {\n        /* istanbul ignore else */\n        if (opts.query_params.hasOwnProperty(param_name)) {\n          params[param_name] = opts.query_params[param_name];\n        }\n      }\n    }\n\n    var method = 'GET';\n    var body;\n\n    if (opts.doc_ids) {\n      // set this automagically for the user; it's annoying that couchdb\n      // requires both a \"filter\" and a \"doc_ids\" param.\n      params.filter = '_doc_ids';\n      method = 'POST';\n      body = {doc_ids: opts.doc_ids };\n    }\n    /* istanbul ignore next */\n    else if (opts.selector) {\n      // set this automagically for the user, similar to above\n      params.filter = '_selector';\n      method = 'POST';\n      body = {selector: opts.selector };\n    }\n\n    var xhr;\n    var lastFetchedSeq;\n\n    // Get all the changes starting wtih the one immediately after the\n    // sequence number given by since.\n    var fetch = function (since, callback) {\n      if (opts.aborted) {\n        return;\n      }\n      params.since = since;\n      // \"since\" can be any kind of json object in Coudant/CouchDB 2.x\n      /* istanbul ignore next */\n      if (typeof params.since === \"object\") {\n        params.since = JSON.stringify(params.since);\n      }\n\n      if (opts.descending) {\n        if (limit) {\n          params.limit = leftToFetch;\n        }\n      } else {\n        params.limit = (!limit || leftToFetch > batchSize) ?\n          batchSize : leftToFetch;\n      }\n\n      // Set the options for the ajax call\n      var xhrOpts = {\n        method: method,\n        url: genDBUrl(host, '_changes' + paramsToStr(params)),\n        timeout: requestTimeout,\n        body: body\n      };\n      lastFetchedSeq = since;\n\n      /* istanbul ignore if */\n      if (opts.aborted) {\n        return;\n      }\n\n      // Get the changes\n      setup().then(function () {\n        xhr = ajax(opts, xhrOpts, callback);\n      })[\"catch\"](callback);\n    };\n\n    // If opts.since exists, get all the changes from the sequence\n    // number given by opts.since. Otherwise, get all the changes\n    // from the sequence number 0.\n    var results = {results: []};\n\n    var fetched = function (err, res) {\n      if (opts.aborted) {\n        return;\n      }\n      var raw_results_length = 0;\n      // If the result of the ajax call (res) contains changes (res.results)\n      if (res && res.results) {\n        raw_results_length = res.results.length;\n        results.last_seq = res.last_seq;\n        var pending = null;\n        var lastSeq = null;\n        // Attach 'pending' property if server supports it (CouchDB 2.0+)\n        /* istanbul ignore if */\n        if (typeof res.pending === 'number') {\n          pending = res.pending;\n        }\n        if (typeof results.last_seq === 'string' || typeof results.last_seq === 'number') {\n          lastSeq = results.last_seq;\n        }\n        // For each change\n        var req = {};\n        req.query = opts.query_params;\n        res.results = res.results.filter(function (c) {\n          leftToFetch--;\n          var ret = filterChange(opts)(c);\n          if (ret) {\n            if (opts.include_docs && opts.attachments && opts.binary) {\n              readAttachmentsAsBlobOrBuffer(c);\n            }\n            if (returnDocs) {\n              results.results.push(c);\n            }\n            opts.onChange(c, pending, lastSeq);\n          }\n          return ret;\n        });\n      } else if (err) {\n        // In case of an error, stop listening for changes and call\n        // opts.complete\n        opts.aborted = true;\n        opts.complete(err);\n        return;\n      }\n\n      // The changes feed may have timed out with no results\n      // if so reuse last update sequence\n      if (res && res.last_seq) {\n        lastFetchedSeq = res.last_seq;\n      }\n\n      var finished = (limit && leftToFetch <= 0) ||\n        (res && raw_results_length < batchSize) ||\n        (opts.descending);\n\n      if ((opts.continuous && !(limit && leftToFetch <= 0)) || !finished) {\n        // Queue a call to fetch again with the newest sequence number\n        nextTick(function () { fetch(lastFetchedSeq, fetched); });\n      } else {\n        // We're done, call the callback\n        opts.complete(null, results);\n      }\n    };\n\n    fetch(opts.since || 0, fetched);\n\n    // Return a method to cancel this method from processing any more\n    return {\n      cancel: function () {\n        opts.aborted = true;\n        if (xhr) {\n          xhr.abort();\n        }\n      }\n    };\n  };\n\n  // Given a set of document/revision IDs (given by req), tets the subset of\n  // those that do NOT correspond to revisions stored in the database.\n  // See http://wiki.apache.org/couchdb/HttpPostRevsDiff\n  api.revsDiff = adapterFun$$1('revsDiff', function (req, opts, callback) {\n    // If no options were given, set the callback to be the second parameter\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n\n    // Get the missing document/revision IDs\n    ajax(opts, {\n      method: 'POST',\n      url: genDBUrl(host, '_revs_diff'),\n      body: req\n    }, callback);\n  });\n\n  api._close = function (callback) {\n    callback();\n  };\n\n  api._destroy = function (options, callback) {\n    ajax(options, {\n      url: genDBUrl(host, ''),\n      method: 'DELETE'\n    }, function (err, resp) {\n      if (err && err.status && err.status !== 404) {\n        return callback(err);\n      }\n      callback(null, resp);\n    });\n  };\n}\n\n// HttpPouch is a valid adapter.\nHttpPouch.valid = function () {\n  return true;\n};\n\nfunction HttpPouch$1 (PouchDB) {\n  PouchDB.adapter('http', HttpPouch, false);\n  PouchDB.adapter('https', HttpPouch, false);\n}\n\nfunction QueryParseError(message) {\n  this.status = 400;\n  this.name = 'query_parse_error';\n  this.message = message;\n  this.error = true;\n  try {\n    Error.captureStackTrace(this, QueryParseError);\n  } catch (e) {}\n}\n\ninherits(QueryParseError, Error);\n\nfunction NotFoundError(message) {\n  this.status = 404;\n  this.name = 'not_found';\n  this.message = message;\n  this.error = true;\n  try {\n    Error.captureStackTrace(this, NotFoundError);\n  } catch (e) {}\n}\n\ninherits(NotFoundError, Error);\n\nfunction BuiltInError(message) {\n  this.status = 500;\n  this.name = 'invalid_value';\n  this.message = message;\n  this.error = true;\n  try {\n    Error.captureStackTrace(this, BuiltInError);\n  } catch (e) {}\n}\n\ninherits(BuiltInError, Error);\n\nfunction promisedCallback(promise, callback) {\n  if (callback) {\n    promise.then(function (res) {\n      nextTick(function () {\n        callback(null, res);\n      });\n    }, function (reason) {\n      nextTick(function () {\n        callback(reason);\n      });\n    });\n  }\n  return promise;\n}\n\nfunction callbackify(fun) {\n  return getArguments(function (args) {\n    var cb = args.pop();\n    var promise = fun.apply(this, args);\n    if (typeof cb === 'function') {\n      promisedCallback(promise, cb);\n    }\n    return promise;\n  });\n}\n\n// Promise finally util similar to Q.finally\nfunction fin(promise, finalPromiseFactory) {\n  return promise.then(function (res) {\n    return finalPromiseFactory().then(function () {\n      return res;\n    });\n  }, function (reason) {\n    return finalPromiseFactory().then(function () {\n      throw reason;\n    });\n  });\n}\n\nfunction sequentialize(queue, promiseFactory) {\n  return function () {\n    var args = arguments;\n    var that = this;\n    return queue.add(function () {\n      return promiseFactory.apply(that, args);\n    });\n  };\n}\n\n// uniq an array of strings, order not guaranteed\n// similar to underscore/lodash _.uniq\nfunction uniq(arr) {\n  var theSet = new ExportedSet(arr);\n  var result = new Array(theSet.size);\n  var index = -1;\n  theSet.forEach(function (value) {\n    result[++index] = value;\n  });\n  return result;\n}\n\nfunction mapToKeysArray(map) {\n  var result = new Array(map.size);\n  var index = -1;\n  map.forEach(function (value, key) {\n    result[++index] = key;\n  });\n  return result;\n}\n\nfunction createBuiltInError(name) {\n  var message = 'builtin ' + name +\n    ' function requires map values to be numbers' +\n    ' or number arrays';\n  return new BuiltInError(message);\n}\n\nfunction sum(values) {\n  var result = 0;\n  for (var i = 0, len = values.length; i < len; i++) {\n    var num = values[i];\n    if (typeof num !== 'number') {\n      if (Array.isArray(num)) {\n        // lists of numbers are also allowed, sum them separately\n        result = typeof result === 'number' ? [result] : result;\n        for (var j = 0, jLen = num.length; j < jLen; j++) {\n          var jNum = num[j];\n          if (typeof jNum !== 'number') {\n            throw createBuiltInError('_sum');\n          } else if (typeof result[j] === 'undefined') {\n            result.push(jNum);\n          } else {\n            result[j] += jNum;\n          }\n        }\n      } else { // not array/number\n        throw createBuiltInError('_sum');\n      }\n    } else if (typeof result === 'number') {\n      result += num;\n    } else { // add number to array\n      result[0] += num;\n    }\n  }\n  return result;\n}\n\nvar log = guardedConsole.bind(null, 'log');\nvar isArray = Array.isArray;\nvar toJSON = JSON.parse;\n\nfunction evalFunctionWithEval(func, emit) {\n  return scopeEval(\n    \"return (\" + func.replace(/;\\s*$/, \"\") + \");\",\n    {\n      emit: emit,\n      sum: sum,\n      log: log,\n      isArray: isArray,\n      toJSON: toJSON\n    }\n  );\n}\n\n/*\n * Simple task queue to sequentialize actions. Assumes\n * callbacks will eventually fire (once).\n */\n\n\nfunction TaskQueue$2() {\n  this.promise = new PouchPromise(function (fulfill) {fulfill(); });\n}\nTaskQueue$2.prototype.add = function (promiseFactory) {\n  this.promise = this.promise[\"catch\"](function () {\n    // just recover\n  }).then(function () {\n    return promiseFactory();\n  });\n  return this.promise;\n};\nTaskQueue$2.prototype.finish = function () {\n  return this.promise;\n};\n\nfunction stringify(input) {\n  if (!input) {\n    return 'undefined'; // backwards compat for empty reduce\n  }\n  // for backwards compat with mapreduce, functions/strings are stringified\n  // as-is. everything else is JSON-stringified.\n  switch (typeof input) {\n    case 'function':\n      // e.g. a mapreduce map\n      return input.toString();\n    case 'string':\n      // e.g. a mapreduce built-in _reduce function\n      return input.toString();\n    default:\n      // e.g. a JSON object in the case of mango queries\n      return JSON.stringify(input);\n  }\n}\n\n/* create a string signature for a view so we can cache it and uniq it */\nfunction createViewSignature(mapFun, reduceFun) {\n  // the \"undefined\" part is for backwards compatibility\n  return stringify(mapFun) + stringify(reduceFun) + 'undefined';\n}\n\nfunction createView(sourceDB, viewName, mapFun, reduceFun, temporary, localDocName) {\n  var viewSignature = createViewSignature(mapFun, reduceFun);\n\n  var cachedViews;\n  if (!temporary) {\n    // cache this to ensure we don't try to update the same view twice\n    cachedViews = sourceDB._cachedViews = sourceDB._cachedViews || {};\n    if (cachedViews[viewSignature]) {\n      return cachedViews[viewSignature];\n    }\n  }\n\n  var promiseForView = sourceDB.info().then(function (info) {\n\n    var depDbName = info.db_name + '-mrview-' +\n      (temporary ? 'temp' : stringMd5(viewSignature));\n\n    // save the view name in the source db so it can be cleaned up if necessary\n    // (e.g. when the _design doc is deleted, remove all associated view data)\n    function diffFunction(doc) {\n      doc.views = doc.views || {};\n      var fullViewName = viewName;\n      if (fullViewName.indexOf('/') === -1) {\n        fullViewName = viewName + '/' + viewName;\n      }\n      var depDbs = doc.views[fullViewName] = doc.views[fullViewName] || {};\n      /* istanbul ignore if */\n      if (depDbs[depDbName]) {\n        return; // no update necessary\n      }\n      depDbs[depDbName] = true;\n      return doc;\n    }\n    return upsert(sourceDB, '_local/' + localDocName, diffFunction).then(function () {\n      return sourceDB.registerDependentDatabase(depDbName).then(function (res) {\n        var db = res.db;\n        db.auto_compaction = true;\n        var view = {\n          name: depDbName,\n          db: db,\n          sourceDB: sourceDB,\n          adapter: sourceDB.adapter,\n          mapFun: mapFun,\n          reduceFun: reduceFun\n        };\n        return view.db.get('_local/lastSeq')[\"catch\"](function (err) {\n          /* istanbul ignore if */\n          if (err.status !== 404) {\n            throw err;\n          }\n        }).then(function (lastSeqDoc) {\n          view.seq = lastSeqDoc ? lastSeqDoc.seq : 0;\n          if (cachedViews) {\n            view.db.once('destroyed', function () {\n              delete cachedViews[viewSignature];\n            });\n          }\n          return view;\n        });\n      });\n    });\n  });\n\n  if (cachedViews) {\n    cachedViews[viewSignature] = promiseForView;\n  }\n  return promiseForView;\n}\n\nvar persistentQueues = {};\nvar tempViewQueue = new TaskQueue$2();\nvar CHANGES_BATCH_SIZE$1 = 50;\n\nfunction parseViewName(name) {\n  // can be either 'ddocname/viewname' or just 'viewname'\n  // (where the ddoc name is the same)\n  return name.indexOf('/') === -1 ? [name, name] : name.split('/');\n}\n\nfunction isGenOne(changes) {\n  // only return true if the current change is 1-\n  // and there are no other leafs\n  return changes.length === 1 && /^1-/.test(changes[0].rev);\n}\n\nfunction emitError(db, e) {\n  try {\n    db.emit('error', e);\n  } catch (err) {\n    guardedConsole('error',\n      'The user\\'s map/reduce function threw an uncaught error.\\n' +\n      'You can debug this error by doing:\\n' +\n      'myDatabase.on(\\'error\\', function (err) { debugger; });\\n' +\n      'Please double-check your map/reduce function.');\n    guardedConsole('error', e);\n  }\n}\n\n/**\n * Returns an \"abstract\" mapreduce object of the form:\n *\n *   {\n *     query: queryFun,\n *     viewCleanup: viewCleanupFun\n *   }\n *\n * Arguments are:\n *\n * localDoc: string\n *   This is for the local doc that gets saved in order to track the\n *   \"dependent\" DBs and clean them up for viewCleanup. It should be\n *   unique, so that indexer plugins don't collide with each other.\n * mapper: function (mapFunDef, emit)\n *   Returns a map function based on the mapFunDef, which in the case of\n *   normal map/reduce is just the de-stringified function, but may be\n *   something else, such as an object in the case of pouchdb-find.\n * reducer: function (reduceFunDef)\n *   Ditto, but for reducing. Modules don't have to support reducing\n *   (e.g. pouchdb-find).\n * ddocValidator: function (ddoc, viewName)\n *   Throws an error if the ddoc or viewName is not valid.\n *   This could be a way to communicate to the user that the configuration for the\n *   indexer is invalid.\n */\nfunction createAbstractMapReduce(localDocName, mapper, reducer, ddocValidator) {\n\n  function tryMap(db, fun, doc) {\n    // emit an event if there was an error thrown by a map function.\n    // putting try/catches in a single function also avoids deoptimizations.\n    try {\n      fun(doc);\n    } catch (e) {\n      emitError(db, e);\n    }\n  }\n\n  function tryReduce(db, fun, keys, values, rereduce) {\n    // same as above, but returning the result or an error. there are two separate\n    // functions to avoid extra memory allocations since the tryCode() case is used\n    // for custom map functions (common) vs this function, which is only used for\n    // custom reduce functions (rare)\n    try {\n      return {output : fun(keys, values, rereduce)};\n    } catch (e) {\n      emitError(db, e);\n      return {error: e};\n    }\n  }\n\n  function sortByKeyThenValue(x, y) {\n    var keyCompare = collate(x.key, y.key);\n    return keyCompare !== 0 ? keyCompare : collate(x.value, y.value);\n  }\n\n  function sliceResults(results, limit, skip) {\n    skip = skip || 0;\n    if (typeof limit === 'number') {\n      return results.slice(skip, limit + skip);\n    } else if (skip > 0) {\n      return results.slice(skip);\n    }\n    return results;\n  }\n\n  function rowToDocId(row) {\n    var val = row.value;\n    // Users can explicitly specify a joined doc _id, or it\n    // defaults to the doc _id that emitted the key/value.\n    var docId = (val && typeof val === 'object' && val._id) || row.id;\n    return docId;\n  }\n\n  function readAttachmentsAsBlobOrBuffer(res) {\n    res.rows.forEach(function (row) {\n      var atts = row.doc && row.doc._attachments;\n      if (!atts) {\n        return;\n      }\n      Object.keys(atts).forEach(function (filename) {\n        var att = atts[filename];\n        atts[filename].data = b64ToBluffer(att.data, att.content_type);\n      });\n    });\n  }\n\n  function postprocessAttachments(opts) {\n    return function (res) {\n      if (opts.include_docs && opts.attachments && opts.binary) {\n        readAttachmentsAsBlobOrBuffer(res);\n      }\n      return res;\n    };\n  }\n\n  function addHttpParam(paramName, opts, params, asJson) {\n    // add an http param from opts to params, optionally json-encoded\n    var val = opts[paramName];\n    if (typeof val !== 'undefined') {\n      if (asJson) {\n        val = encodeURIComponent(JSON.stringify(val));\n      }\n      params.push(paramName + '=' + val);\n    }\n  }\n\n  function coerceInteger(integerCandidate) {\n    if (typeof integerCandidate !== 'undefined') {\n      var asNumber = Number(integerCandidate);\n      // prevents e.g. '1foo' or '1.1' being coerced to 1\n      if (!isNaN(asNumber) && asNumber === parseInt(integerCandidate, 10)) {\n        return asNumber;\n      } else {\n        return integerCandidate;\n      }\n    }\n  }\n\n  function coerceOptions(opts) {\n    opts.group_level = coerceInteger(opts.group_level);\n    opts.limit = coerceInteger(opts.limit);\n    opts.skip = coerceInteger(opts.skip);\n    return opts;\n  }\n\n  function checkPositiveInteger(number) {\n    if (number) {\n      if (typeof number !== 'number') {\n        return  new QueryParseError('Invalid value for integer: \"' +\n          number + '\"');\n      }\n      if (number < 0) {\n        return new QueryParseError('Invalid value for positive integer: ' +\n          '\"' + number + '\"');\n      }\n    }\n  }\n\n  function checkQueryParseError(options, fun) {\n    var startkeyName = options.descending ? 'endkey' : 'startkey';\n    var endkeyName = options.descending ? 'startkey' : 'endkey';\n\n    if (typeof options[startkeyName] !== 'undefined' &&\n      typeof options[endkeyName] !== 'undefined' &&\n      collate(options[startkeyName], options[endkeyName]) > 0) {\n      throw new QueryParseError('No rows can match your key range, ' +\n        'reverse your start_key and end_key or set {descending : true}');\n    } else if (fun.reduce && options.reduce !== false) {\n      if (options.include_docs) {\n        throw new QueryParseError('{include_docs:true} is invalid for reduce');\n      } else if (options.keys && options.keys.length > 1 &&\n        !options.group && !options.group_level) {\n        throw new QueryParseError('Multi-key fetches for reduce views must use ' +\n          '{group: true}');\n      }\n    }\n    ['group_level', 'limit', 'skip'].forEach(function (optionName) {\n      var error = checkPositiveInteger(options[optionName]);\n      if (error) {\n        throw error;\n      }\n    });\n  }\n\n  function httpQuery(db, fun, opts) {\n    // List of parameters to add to the PUT request\n    var params = [];\n    var body;\n    var method = 'GET';\n\n    // If opts.reduce exists and is defined, then add it to the list\n    // of parameters.\n    // If reduce=false then the results are that of only the map function\n    // not the final result of map and reduce.\n    addHttpParam('reduce', opts, params);\n    addHttpParam('include_docs', opts, params);\n    addHttpParam('attachments', opts, params);\n    addHttpParam('limit', opts, params);\n    addHttpParam('descending', opts, params);\n    addHttpParam('group', opts, params);\n    addHttpParam('group_level', opts, params);\n    addHttpParam('skip', opts, params);\n    addHttpParam('stale', opts, params);\n    addHttpParam('conflicts', opts, params);\n    addHttpParam('startkey', opts, params, true);\n    addHttpParam('start_key', opts, params, true);\n    addHttpParam('endkey', opts, params, true);\n    addHttpParam('end_key', opts, params, true);\n    addHttpParam('inclusive_end', opts, params);\n    addHttpParam('key', opts, params, true);\n    addHttpParam('update_seq', opts, params);\n\n    // Format the list of parameters into a valid URI query string\n    params = params.join('&');\n    params = params === '' ? '' : '?' + params;\n\n    // If keys are supplied, issue a POST to circumvent GET query string limits\n    // see http://wiki.apache.org/couchdb/HTTP_view_API#Querying_Options\n    if (typeof opts.keys !== 'undefined') {\n      var MAX_URL_LENGTH = 2000;\n      // according to http://stackoverflow.com/a/417184/680742,\n      // the de facto URL length limit is 2000 characters\n\n      var keysAsString =\n        'keys=' + encodeURIComponent(JSON.stringify(opts.keys));\n      if (keysAsString.length + params.length + 1 <= MAX_URL_LENGTH) {\n        // If the keys are short enough, do a GET. we do this to work around\n        // Safari not understanding 304s on POSTs (see pouchdb/pouchdb#1239)\n        params += (params[0] === '?' ? '&' : '?') + keysAsString;\n      } else {\n        method = 'POST';\n        if (typeof fun === 'string') {\n          body = {keys: opts.keys};\n        } else { // fun is {map : mapfun}, so append to this\n          fun.keys = opts.keys;\n        }\n      }\n    }\n\n    // We are referencing a query defined in the design doc\n    if (typeof fun === 'string') {\n      var parts = parseViewName(fun);\n      return db.request({\n        method: method,\n        url: '_design/' + parts[0] + '/_view/' + parts[1] + params,\n        body: body\n      }).then(\n        /* istanbul ignore next */\n        function (result) {\n          // fail the entire request if the result contains an error\n          result.rows.forEach(function (row) {\n            if (row.value && row.value.error && row.value.error === \"builtin_reduce_error\") {\n              throw new Error(row.reason);\n            }\n          });\n\n          return result;\n      })\n      .then(postprocessAttachments(opts));\n    }\n\n    // We are using a temporary view, terrible for performance, good for testing\n    body = body || {};\n    Object.keys(fun).forEach(function (key) {\n      if (Array.isArray(fun[key])) {\n        body[key] = fun[key];\n      } else {\n        body[key] = fun[key].toString();\n      }\n    });\n    return db.request({\n      method: 'POST',\n      url: '_temp_view' + params,\n      body: body\n    }).then(postprocessAttachments(opts));\n  }\n\n  // custom adapters can define their own api._query\n  // and override the default behavior\n  /* istanbul ignore next */\n  function customQuery(db, fun, opts) {\n    return new PouchPromise(function (resolve, reject) {\n      db._query(fun, opts, function (err, res) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(res);\n      });\n    });\n  }\n\n  // custom adapters can define their own api._viewCleanup\n  // and override the default behavior\n  /* istanbul ignore next */\n  function customViewCleanup(db) {\n    return new PouchPromise(function (resolve, reject) {\n      db._viewCleanup(function (err, res) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(res);\n      });\n    });\n  }\n\n  function defaultsTo(value) {\n    return function (reason) {\n      /* istanbul ignore else */\n      if (reason.status === 404) {\n        return value;\n      } else {\n        throw reason;\n      }\n    };\n  }\n\n  // returns a promise for a list of docs to update, based on the input docId.\n  // the order doesn't matter, because post-3.2.0, bulkDocs\n  // is an atomic operation in all three adapters.\n  function getDocsToPersist(docId, view, docIdsToChangesAndEmits) {\n    var metaDocId = '_local/doc_' + docId;\n    var defaultMetaDoc = {_id: metaDocId, keys: []};\n    var docData = docIdsToChangesAndEmits.get(docId);\n    var indexableKeysToKeyValues = docData[0];\n    var changes = docData[1];\n\n    function getMetaDoc() {\n      if (isGenOne(changes)) {\n        // generation 1, so we can safely assume initial state\n        // for performance reasons (avoids unnecessary GETs)\n        return PouchPromise.resolve(defaultMetaDoc);\n      }\n      return view.db.get(metaDocId)[\"catch\"](defaultsTo(defaultMetaDoc));\n    }\n\n    function getKeyValueDocs(metaDoc) {\n      if (!metaDoc.keys.length) {\n        // no keys, no need for a lookup\n        return PouchPromise.resolve({rows: []});\n      }\n      return view.db.allDocs({\n        keys: metaDoc.keys,\n        include_docs: true\n      });\n    }\n\n    function processKeyValueDocs(metaDoc, kvDocsRes) {\n      var kvDocs = [];\n      var oldKeys = new ExportedSet();\n\n      for (var i = 0, len = kvDocsRes.rows.length; i < len; i++) {\n        var row = kvDocsRes.rows[i];\n        var doc = row.doc;\n        if (!doc) { // deleted\n          continue;\n        }\n        kvDocs.push(doc);\n        oldKeys.add(doc._id);\n        doc._deleted = !indexableKeysToKeyValues.has(doc._id);\n        if (!doc._deleted) {\n          var keyValue = indexableKeysToKeyValues.get(doc._id);\n          if ('value' in keyValue) {\n            doc.value = keyValue.value;\n          }\n        }\n      }\n      var newKeys = mapToKeysArray(indexableKeysToKeyValues);\n      newKeys.forEach(function (key) {\n        if (!oldKeys.has(key)) {\n          // new doc\n          var kvDoc = {\n            _id: key\n          };\n          var keyValue = indexableKeysToKeyValues.get(key);\n          if ('value' in keyValue) {\n            kvDoc.value = keyValue.value;\n          }\n          kvDocs.push(kvDoc);\n        }\n      });\n      metaDoc.keys = uniq(newKeys.concat(metaDoc.keys));\n      kvDocs.push(metaDoc);\n\n      return kvDocs;\n    }\n\n    return getMetaDoc().then(function (metaDoc) {\n      return getKeyValueDocs(metaDoc).then(function (kvDocsRes) {\n        return processKeyValueDocs(metaDoc, kvDocsRes);\n      });\n    });\n  }\n\n  // updates all emitted key/value docs and metaDocs in the mrview database\n  // for the given batch of documents from the source database\n  function saveKeyValues(view, docIdsToChangesAndEmits, seq) {\n    var seqDocId = '_local/lastSeq';\n    return view.db.get(seqDocId)[\n      \"catch\"](defaultsTo({_id: seqDocId, seq: 0}))\n      .then(function (lastSeqDoc) {\n        var docIds = mapToKeysArray(docIdsToChangesAndEmits);\n        return PouchPromise.all(docIds.map(function (docId) {\n          return getDocsToPersist(docId, view, docIdsToChangesAndEmits);\n        })).then(function (listOfDocsToPersist) {\n          var docsToPersist = flatten(listOfDocsToPersist);\n          lastSeqDoc.seq = seq;\n          docsToPersist.push(lastSeqDoc);\n          // write all docs in a single operation, update the seq once\n          return view.db.bulkDocs({docs : docsToPersist});\n        });\n      });\n  }\n\n  function getQueue(view) {\n    var viewName = typeof view === 'string' ? view : view.name;\n    var queue = persistentQueues[viewName];\n    if (!queue) {\n      queue = persistentQueues[viewName] = new TaskQueue$2();\n    }\n    return queue;\n  }\n\n  function updateView(view) {\n    return sequentialize(getQueue(view), function () {\n      return updateViewInQueue(view);\n    })();\n  }\n\n  function updateViewInQueue(view) {\n    // bind the emit function once\n    var mapResults;\n    var doc;\n\n    function emit(key, value) {\n      var output = {id: doc._id, key: normalizeKey(key)};\n      // Don't explicitly store the value unless it's defined and non-null.\n      // This saves on storage space, because often people don't use it.\n      if (typeof value !== 'undefined' && value !== null) {\n        output.value = normalizeKey(value);\n      }\n      mapResults.push(output);\n    }\n\n    var mapFun = mapper(view.mapFun, emit);\n\n    var currentSeq = view.seq || 0;\n\n    function processChange(docIdsToChangesAndEmits, seq) {\n      return function () {\n        return saveKeyValues(view, docIdsToChangesAndEmits, seq);\n      };\n    }\n\n    var queue = new TaskQueue$2();\n\n    function processNextBatch() {\n      return view.sourceDB.changes({\n        conflicts: true,\n        include_docs: true,\n        style: 'all_docs',\n        since: currentSeq,\n        limit: CHANGES_BATCH_SIZE$1\n      }).then(processBatch);\n    }\n\n    function processBatch(response) {\n      var results = response.results;\n      if (!results.length) {\n        return;\n      }\n      var docIdsToChangesAndEmits = createDocIdsToChangesAndEmits(results);\n      queue.add(processChange(docIdsToChangesAndEmits, currentSeq));\n      if (results.length < CHANGES_BATCH_SIZE$1) {\n        return;\n      }\n      return processNextBatch();\n    }\n\n    function createDocIdsToChangesAndEmits(results) {\n      var docIdsToChangesAndEmits = new ExportedMap();\n      for (var i = 0, len = results.length; i < len; i++) {\n        var change = results[i];\n        if (change.doc._id[0] !== '_') {\n          mapResults = [];\n          doc = change.doc;\n\n          if (!doc._deleted) {\n            tryMap(view.sourceDB, mapFun, doc);\n          }\n          mapResults.sort(sortByKeyThenValue);\n\n          var indexableKeysToKeyValues = createIndexableKeysToKeyValues(mapResults);\n          docIdsToChangesAndEmits.set(change.doc._id, [\n            indexableKeysToKeyValues,\n            change.changes\n          ]);\n        }\n        currentSeq = change.seq;\n      }\n      return docIdsToChangesAndEmits;\n    }\n\n    function createIndexableKeysToKeyValues(mapResults) {\n      var indexableKeysToKeyValues = new ExportedMap();\n      var lastKey;\n      for (var i = 0, len = mapResults.length; i < len; i++) {\n        var emittedKeyValue = mapResults[i];\n        var complexKey = [emittedKeyValue.key, emittedKeyValue.id];\n        if (i > 0 && collate(emittedKeyValue.key, lastKey) === 0) {\n          complexKey.push(i); // dup key+id, so make it unique\n        }\n        indexableKeysToKeyValues.set(toIndexableString(complexKey), emittedKeyValue);\n        lastKey = emittedKeyValue.key;\n      }\n      return indexableKeysToKeyValues;\n    }\n\n    return processNextBatch().then(function () {\n      return queue.finish();\n    }).then(function () {\n      view.seq = currentSeq;\n    });\n  }\n\n  function reduceView(view, results, options) {\n    if (options.group_level === 0) {\n      delete options.group_level;\n    }\n\n    var shouldGroup = options.group || options.group_level;\n\n    var reduceFun = reducer(view.reduceFun);\n\n    var groups = [];\n    var lvl = isNaN(options.group_level) ? Number.POSITIVE_INFINITY :\n      options.group_level;\n    results.forEach(function (e) {\n      var last = groups[groups.length - 1];\n      var groupKey = shouldGroup ? e.key : null;\n\n      // only set group_level for array keys\n      if (shouldGroup && Array.isArray(groupKey)) {\n        groupKey = groupKey.slice(0, lvl);\n      }\n\n      if (last && collate(last.groupKey, groupKey) === 0) {\n        last.keys.push([e.key, e.id]);\n        last.values.push(e.value);\n        return;\n      }\n      groups.push({\n        keys: [[e.key, e.id]],\n        values: [e.value],\n        groupKey: groupKey\n      });\n    });\n    results = [];\n    for (var i = 0, len = groups.length; i < len; i++) {\n      var e = groups[i];\n      var reduceTry = tryReduce(view.sourceDB, reduceFun, e.keys, e.values, false);\n      if (reduceTry.error && reduceTry.error instanceof BuiltInError) {\n        // CouchDB returns an error if a built-in errors out\n        throw reduceTry.error;\n      }\n      results.push({\n        // CouchDB just sets the value to null if a non-built-in errors out\n        value: reduceTry.error ? null : reduceTry.output,\n        key: e.groupKey\n      });\n    }\n    // no total_rows/offset when reducing\n    return {rows: sliceResults(results, options.limit, options.skip)};\n  }\n\n  function queryView(view, opts) {\n    return sequentialize(getQueue(view), function () {\n      return queryViewInQueue(view, opts);\n    })();\n  }\n\n  function queryViewInQueue(view, opts) {\n    var totalRows;\n    var shouldReduce = view.reduceFun && opts.reduce !== false;\n    var skip = opts.skip || 0;\n    if (typeof opts.keys !== 'undefined' && !opts.keys.length) {\n      // equivalent query\n      opts.limit = 0;\n      delete opts.keys;\n    }\n\n    function fetchFromView(viewOpts) {\n      viewOpts.include_docs = true;\n      return view.db.allDocs(viewOpts).then(function (res) {\n        totalRows = res.total_rows;\n        return res.rows.map(function (result) {\n\n          // implicit migration - in older versions of PouchDB,\n          // we explicitly stored the doc as {id: ..., key: ..., value: ...}\n          // this is tested in a migration test\n          /* istanbul ignore next */\n          if ('value' in result.doc && typeof result.doc.value === 'object' &&\n            result.doc.value !== null) {\n            var keys = Object.keys(result.doc.value).sort();\n            // this detection method is not perfect, but it's unlikely the user\n            // emitted a value which was an object with these 3 exact keys\n            var expectedKeys = ['id', 'key', 'value'];\n            if (!(keys < expectedKeys || keys > expectedKeys)) {\n              return result.doc.value;\n            }\n          }\n\n          var parsedKeyAndDocId = parseIndexableString(result.doc._id);\n          return {\n            key: parsedKeyAndDocId[0],\n            id: parsedKeyAndDocId[1],\n            value: ('value' in result.doc ? result.doc.value : null)\n          };\n        });\n      });\n    }\n\n    function onMapResultsReady(rows) {\n      var finalResults;\n      if (shouldReduce) {\n        finalResults = reduceView(view, rows, opts);\n      } else {\n        finalResults = {\n          total_rows: totalRows,\n          offset: skip,\n          rows: rows\n        };\n      }\n      /* istanbul ignore if */\n      if (opts.update_seq) {\n        finalResults.update_seq = view.seq;\n      }\n      if (opts.include_docs) {\n        var docIds = uniq(rows.map(rowToDocId));\n\n        return view.sourceDB.allDocs({\n          keys: docIds,\n          include_docs: true,\n          conflicts: opts.conflicts,\n          attachments: opts.attachments,\n          binary: opts.binary\n        }).then(function (allDocsRes) {\n          var docIdsToDocs = new ExportedMap();\n          allDocsRes.rows.forEach(function (row) {\n            docIdsToDocs.set(row.id, row.doc);\n          });\n          rows.forEach(function (row) {\n            var docId = rowToDocId(row);\n            var doc = docIdsToDocs.get(docId);\n            if (doc) {\n              row.doc = doc;\n            }\n          });\n          return finalResults;\n        });\n      } else {\n        return finalResults;\n      }\n    }\n\n    if (typeof opts.keys !== 'undefined') {\n      var keys = opts.keys;\n      var fetchPromises = keys.map(function (key) {\n        var viewOpts = {\n          startkey : toIndexableString([key]),\n          endkey   : toIndexableString([key, {}])\n        };\n        /* istanbul ignore if */\n        if (opts.update_seq) {\n          viewOpts.update_seq = true;\n        }\n        return fetchFromView(viewOpts);\n      });\n      return PouchPromise.all(fetchPromises).then(flatten).then(onMapResultsReady);\n    } else { // normal query, no 'keys'\n      var viewOpts = {\n        descending : opts.descending\n      };\n      /* istanbul ignore if */\n      if (opts.update_seq) {\n        viewOpts.update_seq = true;\n      }\n      var startkey;\n      var endkey;\n      if ('start_key' in opts) {\n        startkey = opts.start_key;\n      }\n      if ('startkey' in opts) {\n        startkey = opts.startkey;\n      }\n      if ('end_key' in opts) {\n        endkey = opts.end_key;\n      }\n      if ('endkey' in opts) {\n        endkey = opts.endkey;\n      }\n      if (typeof startkey !== 'undefined') {\n        viewOpts.startkey = opts.descending ?\n          toIndexableString([startkey, {}]) :\n          toIndexableString([startkey]);\n      }\n      if (typeof endkey !== 'undefined') {\n        var inclusiveEnd = opts.inclusive_end !== false;\n        if (opts.descending) {\n          inclusiveEnd = !inclusiveEnd;\n        }\n\n        viewOpts.endkey = toIndexableString(\n          inclusiveEnd ? [endkey, {}] : [endkey]);\n      }\n      if (typeof opts.key !== 'undefined') {\n        var keyStart = toIndexableString([opts.key]);\n        var keyEnd = toIndexableString([opts.key, {}]);\n        if (viewOpts.descending) {\n          viewOpts.endkey = keyStart;\n          viewOpts.startkey = keyEnd;\n        } else {\n          viewOpts.startkey = keyStart;\n          viewOpts.endkey = keyEnd;\n        }\n      }\n      if (!shouldReduce) {\n        if (typeof opts.limit === 'number') {\n          viewOpts.limit = opts.limit;\n        }\n        viewOpts.skip = skip;\n      }\n      return fetchFromView(viewOpts).then(onMapResultsReady);\n    }\n  }\n\n  function httpViewCleanup(db) {\n    return db.request({\n      method: 'POST',\n      url: '_view_cleanup'\n    });\n  }\n\n  function localViewCleanup(db) {\n    return db.get('_local/' + localDocName).then(function (metaDoc) {\n      var docsToViews = new ExportedMap();\n      Object.keys(metaDoc.views).forEach(function (fullViewName) {\n        var parts = parseViewName(fullViewName);\n        var designDocName = '_design/' + parts[0];\n        var viewName = parts[1];\n        var views = docsToViews.get(designDocName);\n        if (!views) {\n          views = new ExportedSet();\n          docsToViews.set(designDocName, views);\n        }\n        views.add(viewName);\n      });\n      var opts = {\n        keys : mapToKeysArray(docsToViews),\n        include_docs : true\n      };\n      return db.allDocs(opts).then(function (res) {\n        var viewsToStatus = {};\n        res.rows.forEach(function (row) {\n          var ddocName = row.key.substring(8); // cuts off '_design/'\n          docsToViews.get(row.key).forEach(function (viewName) {\n            var fullViewName = ddocName + '/' + viewName;\n            /* istanbul ignore if */\n            if (!metaDoc.views[fullViewName]) {\n              // new format, without slashes, to support PouchDB 2.2.0\n              // migration test in pouchdb's browser.migration.js verifies this\n              fullViewName = viewName;\n            }\n            var viewDBNames = Object.keys(metaDoc.views[fullViewName]);\n            // design doc deleted, or view function nonexistent\n            var statusIsGood = row.doc && row.doc.views &&\n              row.doc.views[viewName];\n            viewDBNames.forEach(function (viewDBName) {\n              viewsToStatus[viewDBName] =\n                viewsToStatus[viewDBName] || statusIsGood;\n            });\n          });\n        });\n        var dbsToDelete = Object.keys(viewsToStatus).filter(\n          function (viewDBName) { return !viewsToStatus[viewDBName]; });\n        var destroyPromises = dbsToDelete.map(function (viewDBName) {\n          return sequentialize(getQueue(viewDBName), function () {\n            return new db.constructor(viewDBName, db.__opts).destroy();\n          })();\n        });\n        return PouchPromise.all(destroyPromises).then(function () {\n          return {ok: true};\n        });\n      });\n    }, defaultsTo({ok: true}));\n  }\n\n  function queryPromised(db, fun, opts) {\n    /* istanbul ignore next */\n    if (typeof db._query === 'function') {\n      return customQuery(db, fun, opts);\n    }\n    if (isRemote(db)) {\n      return httpQuery(db, fun, opts);\n    }\n    \n    if (typeof fun !== 'string') {\n      // temp_view\n      checkQueryParseError(opts, fun);\n\n      tempViewQueue.add(function () {\n        var createViewPromise = createView(\n          /* sourceDB */ db,\n          /* viewName */ 'temp_view/temp_view',\n          /* mapFun */ fun.map,\n          /* reduceFun */ fun.reduce,\n          /* temporary */ true,\n          /* localDocName */ localDocName);\n        return createViewPromise.then(function (view) {\n          return fin(updateView(view).then(function () {\n            return queryView(view, opts);\n          }), function () {\n            return view.db.destroy();\n          });\n        });\n      });\n      return tempViewQueue.finish();\n    } else {\n      // persistent view\n      var fullViewName = fun;\n      var parts = parseViewName(fullViewName);\n      var designDocName = parts[0];\n      var viewName = parts[1];\n      return db.get('_design/' + designDocName).then(function (doc) {\n        var fun = doc.views && doc.views[viewName];\n\n        if (!fun) {\n          // basic validator; it's assumed that every subclass would want this\n          throw new NotFoundError('ddoc ' + doc._id + ' has no view named ' +\n            viewName);\n        }\n\n        ddocValidator(doc, viewName);\n        checkQueryParseError(opts, fun);\n\n        var createViewPromise = createView(\n          /* sourceDB */ db,\n          /* viewName */ fullViewName,\n          /* mapFun */ fun.map,\n          /* reduceFun */ fun.reduce,\n          /* temporary */ false,\n          /* localDocName */ localDocName);\n        return createViewPromise.then(function (view) {\n          if (opts.stale === 'ok' || opts.stale === 'update_after') {\n            if (opts.stale === 'update_after') {\n              nextTick(function () {\n                updateView(view);\n              });\n            }\n            return queryView(view, opts);\n          } else { // stale not ok\n            return updateView(view).then(function () {\n              return queryView(view, opts);\n            });\n          }\n        });\n      });\n    }\n  }\n\n  function abstractQuery(fun, opts, callback) {\n    var db = this;\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    opts = opts ? coerceOptions(opts) : {};\n\n    if (typeof fun === 'function') {\n      fun = {map : fun};\n    }\n\n    var promise = PouchPromise.resolve().then(function () {\n      return queryPromised(db, fun, opts);\n    });\n    promisedCallback(promise, callback);\n    return promise;\n  }\n\n  var abstractViewCleanup = callbackify(function () {\n    var db = this;\n    /* istanbul ignore next */\n    if (typeof db._viewCleanup === 'function') {\n      return customViewCleanup(db);\n    }\n    if (isRemote(db)) {\n      return httpViewCleanup(db);\n    }\n    return localViewCleanup(db);\n  });\n\n  return {\n    query: abstractQuery,\n    viewCleanup: abstractViewCleanup\n  };\n}\n\nvar builtInReduce = {\n  _sum: function (keys, values) {\n    return sum(values);\n  },\n\n  _count: function (keys, values) {\n    return values.length;\n  },\n\n  _stats: function (keys, values) {\n    // no need to implement rereduce=true, because Pouch\n    // will never call it\n    function sumsqr(values) {\n      var _sumsqr = 0;\n      for (var i = 0, len = values.length; i < len; i++) {\n        var num = values[i];\n        _sumsqr += (num * num);\n      }\n      return _sumsqr;\n    }\n    return {\n      sum     : sum(values),\n      min     : Math.min.apply(null, values),\n      max     : Math.max.apply(null, values),\n      count   : values.length,\n      sumsqr : sumsqr(values)\n    };\n  }\n};\n\nfunction getBuiltIn(reduceFunString) {\n  if (/^_sum/.test(reduceFunString)) {\n    return builtInReduce._sum;\n  } else if (/^_count/.test(reduceFunString)) {\n    return builtInReduce._count;\n  } else if (/^_stats/.test(reduceFunString)) {\n    return builtInReduce._stats;\n  } else if (/^_/.test(reduceFunString)) {\n    throw new Error(reduceFunString + ' is not a supported reduce function.');\n  }\n}\n\nfunction mapper(mapFun, emit) {\n  // for temp_views one can use emit(doc, emit), see #38\n  if (typeof mapFun === \"function\" && mapFun.length === 2) {\n    var origMap = mapFun;\n    return function (doc) {\n      return origMap(doc, emit);\n    };\n  } else {\n    return evalFunctionWithEval(mapFun.toString(), emit);\n  }\n}\n\nfunction reducer(reduceFun) {\n  var reduceFunString = reduceFun.toString();\n  var builtIn = getBuiltIn(reduceFunString);\n  if (builtIn) {\n    return builtIn;\n  } else {\n    return evalFunctionWithEval(reduceFunString);\n  }\n}\n\nfunction ddocValidator(ddoc, viewName) {\n  var fun = ddoc.views && ddoc.views[viewName];\n  if (typeof fun.map !== 'string') {\n    throw new NotFoundError('ddoc ' + ddoc._id + ' has no string view named ' +\n      viewName + ', instead found object of type: ' + typeof fun.map);\n  }\n}\n\nvar localDocName = 'mrviews';\nvar abstract = createAbstractMapReduce(localDocName, mapper, reducer, ddocValidator);\n\nfunction query(fun, opts, callback) {\n  return abstract.query.call(this, fun, opts, callback);\n}\n\nfunction viewCleanup(callback) {\n  return abstract.viewCleanup.call(this, callback);\n}\n\nvar mapreduce = {\n  query: query,\n  viewCleanup: viewCleanup\n};\n\nfunction isGenOne$1(rev$$1) {\n  return /^1-/.test(rev$$1);\n}\n\nfunction fileHasChanged(localDoc, remoteDoc, filename) {\n  return !localDoc._attachments ||\n         !localDoc._attachments[filename] ||\n         localDoc._attachments[filename].digest !== remoteDoc._attachments[filename].digest;\n}\n\nfunction getDocAttachments(db, doc) {\n  var filenames = Object.keys(doc._attachments);\n  return PouchPromise.all(filenames.map(function (filename) {\n    return db.getAttachment(doc._id, filename, {rev: doc._rev});\n  }));\n}\n\nfunction getDocAttachmentsFromTargetOrSource(target, src, doc) {\n  var doCheckForLocalAttachments = isRemote(src) && !isRemote(target);\n  var filenames = Object.keys(doc._attachments);\n\n  if (!doCheckForLocalAttachments) {\n    return getDocAttachments(src, doc);\n  }\n\n  return target.get(doc._id).then(function (localDoc) {\n    return PouchPromise.all(filenames.map(function (filename) {\n      if (fileHasChanged(localDoc, doc, filename)) {\n        return src.getAttachment(doc._id, filename);\n      }\n\n      return target.getAttachment(localDoc._id, filename);\n    }));\n  })[\"catch\"](function (error) {\n    /* istanbul ignore if */\n    if (error.status !== 404) {\n      throw error;\n    }\n\n    return getDocAttachments(src, doc);\n  });\n}\n\nfunction createBulkGetOpts(diffs) {\n  var requests = [];\n  Object.keys(diffs).forEach(function (id) {\n    var missingRevs = diffs[id].missing;\n    missingRevs.forEach(function (missingRev) {\n      requests.push({\n        id: id,\n        rev: missingRev\n      });\n    });\n  });\n\n  return {\n    docs: requests,\n    revs: true,\n    latest: true\n  };\n}\n\n//\n// Fetch all the documents from the src as described in the \"diffs\",\n// which is a mapping of docs IDs to revisions. If the state ever\n// changes to \"cancelled\", then the returned promise will be rejected.\n// Else it will be resolved with a list of fetched documents.\n//\nfunction getDocs(src, target, diffs, state) {\n  diffs = clone(diffs); // we do not need to modify this\n\n  var resultDocs = [],\n      ok = true;\n\n  function getAllDocs() {\n\n    var bulkGetOpts = createBulkGetOpts(diffs);\n\n    if (!bulkGetOpts.docs.length) { // optimization: skip empty requests\n      return;\n    }\n\n    return src.bulkGet(bulkGetOpts).then(function (bulkGetResponse) {\n      /* istanbul ignore if */\n      if (state.cancelled) {\n        throw new Error('cancelled');\n      }\n      return PouchPromise.all(bulkGetResponse.results.map(function (bulkGetInfo) {\n        return PouchPromise.all(bulkGetInfo.docs.map(function (doc) {\n          var remoteDoc = doc.ok;\n\n          if (doc.error) {\n            // when AUTO_COMPACTION is set, docs can be returned which look\n            // like this: {\"missing\":\"1-7c3ac256b693c462af8442f992b83696\"}\n            ok = false;\n          }\n\n          if (!remoteDoc || !remoteDoc._attachments) {\n            return remoteDoc;\n          }\n\n          return getDocAttachmentsFromTargetOrSource(target, src, remoteDoc)\n                   .then(function (attachments) {\n                           var filenames = Object.keys(remoteDoc._attachments);\n                           attachments\n                             .forEach(function (attachment, i) {\n                                        var att = remoteDoc._attachments[filenames[i]];\n                                        delete att.stub;\n                                        delete att.length;\n                                        att.data = attachment;\n                                      });\n\n                                      return remoteDoc;\n                                    });\n        }));\n      }))\n\n      .then(function (results) {\n        resultDocs = resultDocs.concat(flatten(results).filter(Boolean));\n      });\n    });\n  }\n\n  function hasAttachments(doc) {\n    return doc._attachments && Object.keys(doc._attachments).length > 0;\n  }\n\n  function hasConflicts(doc) {\n    return doc._conflicts && doc._conflicts.length > 0;\n  }\n\n  function fetchRevisionOneDocs(ids) {\n    // Optimization: fetch gen-1 docs and attachments in\n    // a single request using _all_docs\n    return src.allDocs({\n      keys: ids,\n      include_docs: true,\n      conflicts: true\n    }).then(function (res) {\n      if (state.cancelled) {\n        throw new Error('cancelled');\n      }\n      res.rows.forEach(function (row) {\n        if (row.deleted || !row.doc || !isGenOne$1(row.value.rev) ||\n            hasAttachments(row.doc) || hasConflicts(row.doc)) {\n          // if any of these conditions apply, we need to fetch using get()\n          return;\n        }\n\n        // strip _conflicts array to appease CSG (#5793)\n        /* istanbul ignore if */\n        if (row.doc._conflicts) {\n          delete row.doc._conflicts;\n        }\n\n        // the doc we got back from allDocs() is sufficient\n        resultDocs.push(row.doc);\n        delete diffs[row.id];\n      });\n    });\n  }\n\n  function getRevisionOneDocs() {\n    // filter out the generation 1 docs and get them\n    // leaving the non-generation one docs to be got otherwise\n    var ids = Object.keys(diffs).filter(function (id) {\n      var missing = diffs[id].missing;\n      return missing.length === 1 && isGenOne$1(missing[0]);\n    });\n    if (ids.length > 0) {\n      return fetchRevisionOneDocs(ids);\n    }\n  }\n\n  function returnResult() {\n    return { ok:ok, docs:resultDocs };\n  }\n\n  return PouchPromise.resolve()\n    .then(getRevisionOneDocs)\n    .then(getAllDocs)\n    .then(returnResult);\n}\n\nvar CHECKPOINT_VERSION = 1;\nvar REPLICATOR = \"pouchdb\";\n// This is an arbitrary number to limit the\n// amount of replication history we save in the checkpoint.\n// If we save too much, the checkpoing docs will become very big,\n// if we save fewer, we'll run a greater risk of having to\n// read all the changes from 0 when checkpoint PUTs fail\n// CouchDB 2.0 has a more involved history pruning,\n// but let's go for the simple version for now.\nvar CHECKPOINT_HISTORY_SIZE = 5;\nvar LOWEST_SEQ = 0;\n\nfunction updateCheckpoint(db, id, checkpoint, session, returnValue) {\n  return db.get(id)[\"catch\"](function (err) {\n    if (err.status === 404) {\n      if (db.adapter === 'http' || db.adapter === 'https') {\n        explainError(\n          404, 'PouchDB is just checking if a remote checkpoint exists.'\n        );\n      }\n      return {\n        session_id: session,\n        _id: id,\n        history: [],\n        replicator: REPLICATOR,\n        version: CHECKPOINT_VERSION\n      };\n    }\n    throw err;\n  }).then(function (doc) {\n    if (returnValue.cancelled) {\n      return;\n    }\n\n    // if the checkpoint has not changed, do not update\n    if (doc.last_seq === checkpoint) {\n      return;\n    }\n\n    // Filter out current entry for this replication\n    doc.history = (doc.history || []).filter(function (item) {\n      return item.session_id !== session;\n    });\n\n    // Add the latest checkpoint to history\n    doc.history.unshift({\n      last_seq: checkpoint,\n      session_id: session\n    });\n\n    // Just take the last pieces in history, to\n    // avoid really big checkpoint docs.\n    // see comment on history size above\n    doc.history = doc.history.slice(0, CHECKPOINT_HISTORY_SIZE);\n\n    doc.version = CHECKPOINT_VERSION;\n    doc.replicator = REPLICATOR;\n\n    doc.session_id = session;\n    doc.last_seq = checkpoint;\n\n    return db.put(doc)[\"catch\"](function (err) {\n      if (err.status === 409) {\n        // retry; someone is trying to write a checkpoint simultaneously\n        return updateCheckpoint(db, id, checkpoint, session, returnValue);\n      }\n      throw err;\n    });\n  });\n}\n\nfunction Checkpointer(src, target, id, returnValue, opts) {\n  this.src = src;\n  this.target = target;\n  this.id = id;\n  this.returnValue = returnValue;\n  this.opts = opts || {};\n}\n\nCheckpointer.prototype.writeCheckpoint = function (checkpoint, session) {\n  var self = this;\n  return this.updateTarget(checkpoint, session).then(function () {\n    return self.updateSource(checkpoint, session);\n  });\n};\n\nCheckpointer.prototype.updateTarget = function (checkpoint, session) {\n  if (this.opts.writeTargetCheckpoint) {\n    return updateCheckpoint(this.target, this.id, checkpoint,\n      session, this.returnValue);\n  } else {\n    return PouchPromise.resolve(true);\n  }\n};\n\nCheckpointer.prototype.updateSource = function (checkpoint, session) {\n  if (this.opts.writeSourceCheckpoint) {\n    var self = this;\n    return updateCheckpoint(this.src, this.id, checkpoint,\n      session, this.returnValue)[\n      \"catch\"](function (err) {\n        if (isForbiddenError(err)) {\n          self.opts.writeSourceCheckpoint = false;\n          return true;\n        }\n        throw err;\n      });\n  } else {\n    return PouchPromise.resolve(true);\n  }\n};\n\nvar comparisons = {\n  \"undefined\": function (targetDoc, sourceDoc) {\n    // This is the previous comparison function\n    if (collate(targetDoc.last_seq, sourceDoc.last_seq) === 0) {\n      return sourceDoc.last_seq;\n    }\n    /* istanbul ignore next */\n    return 0;\n  },\n  \"1\": function (targetDoc, sourceDoc) {\n    // This is the comparison function ported from CouchDB\n    return compareReplicationLogs(sourceDoc, targetDoc).last_seq;\n  }\n};\n\nCheckpointer.prototype.getCheckpoint = function () {\n  var self = this;\n\n  if (self.opts && self.opts.writeSourceCheckpoint && !self.opts.writeTargetCheckpoint) {\n    return self.src.get(self.id).then(function (sourceDoc) {\n      return sourceDoc.last_seq || LOWEST_SEQ;\n    })[\"catch\"](function (err) {\n      /* istanbul ignore if */\n      if (err.status !== 404) {\n        throw err;\n      }\n      return LOWEST_SEQ;\n    });\n  }\n\n  return self.target.get(self.id).then(function (targetDoc) {\n    if (self.opts && self.opts.writeTargetCheckpoint && !self.opts.writeSourceCheckpoint) {\n      return targetDoc.last_seq || LOWEST_SEQ;\n    }\n\n    return self.src.get(self.id).then(function (sourceDoc) {\n      // Since we can't migrate an old version doc to a new one\n      // (no session id), we just go with the lowest seq in this case\n      /* istanbul ignore if */\n      if (targetDoc.version !== sourceDoc.version) {\n        return LOWEST_SEQ;\n      }\n\n      var version;\n      if (targetDoc.version) {\n        version = targetDoc.version.toString();\n      } else {\n        version = \"undefined\";\n      }\n\n      if (version in comparisons) {\n        return comparisons[version](targetDoc, sourceDoc);\n      }\n      /* istanbul ignore next */\n      return LOWEST_SEQ;\n    }, function (err) {\n      if (err.status === 404 && targetDoc.last_seq) {\n        return self.src.put({\n          _id: self.id,\n          last_seq: LOWEST_SEQ\n        }).then(function () {\n          return LOWEST_SEQ;\n        }, function (err) {\n          if (isForbiddenError(err)) {\n            self.opts.writeSourceCheckpoint = false;\n            return targetDoc.last_seq;\n          }\n          /* istanbul ignore next */\n          return LOWEST_SEQ;\n        });\n      }\n      throw err;\n    });\n  })[\"catch\"](function (err) {\n    if (err.status !== 404) {\n      throw err;\n    }\n    return LOWEST_SEQ;\n  });\n};\n// This checkpoint comparison is ported from CouchDBs source\n// they come from here:\n// https://github.com/apache/couchdb-couch-replicator/blob/master/src/couch_replicator.erl#L863-L906\n\nfunction compareReplicationLogs(srcDoc, tgtDoc) {\n  if (srcDoc.session_id === tgtDoc.session_id) {\n    return {\n      last_seq: srcDoc.last_seq,\n      history: srcDoc.history\n    };\n  }\n\n  return compareReplicationHistory(srcDoc.history, tgtDoc.history);\n}\n\nfunction compareReplicationHistory(sourceHistory, targetHistory) {\n  // the erlang loop via function arguments is not so easy to repeat in JS\n  // therefore, doing this as recursion\n  var S = sourceHistory[0];\n  var sourceRest = sourceHistory.slice(1);\n  var T = targetHistory[0];\n  var targetRest = targetHistory.slice(1);\n\n  if (!S || targetHistory.length === 0) {\n    return {\n      last_seq: LOWEST_SEQ,\n      history: []\n    };\n  }\n\n  var sourceId = S.session_id;\n  /* istanbul ignore if */\n  if (hasSessionId(sourceId, targetHistory)) {\n    return {\n      last_seq: S.last_seq,\n      history: sourceHistory\n    };\n  }\n\n  var targetId = T.session_id;\n  if (hasSessionId(targetId, sourceRest)) {\n    return {\n      last_seq: T.last_seq,\n      history: targetRest\n    };\n  }\n\n  return compareReplicationHistory(sourceRest, targetRest);\n}\n\nfunction hasSessionId(sessionId, history) {\n  var props = history[0];\n  var rest = history.slice(1);\n\n  if (!sessionId || history.length === 0) {\n    return false;\n  }\n\n  if (sessionId === props.session_id) {\n    return true;\n  }\n\n  return hasSessionId(sessionId, rest);\n}\n\nfunction isForbiddenError(err) {\n  return typeof err.status === 'number' && Math.floor(err.status / 100) === 4;\n}\n\nvar STARTING_BACK_OFF = 0;\n\nfunction backOff(opts, returnValue, error, callback) {\n  if (opts.retry === false) {\n    returnValue.emit('error', error);\n    returnValue.removeAllListeners();\n    return;\n  }\n  if (typeof opts.back_off_function !== 'function') {\n    opts.back_off_function = defaultBackOff;\n  }\n  returnValue.emit('requestError', error);\n  if (returnValue.state === 'active' || returnValue.state === 'pending') {\n    returnValue.emit('paused', error);\n    returnValue.state = 'stopped';\n    var backOffSet = function backoffTimeSet() {\n      opts.current_back_off = STARTING_BACK_OFF;\n    };\n    var removeBackOffSetter = function removeBackOffTimeSet() {\n      returnValue.removeListener('active', backOffSet);\n    };\n    returnValue.once('paused', removeBackOffSetter);\n    returnValue.once('active', backOffSet);\n  }\n\n  opts.current_back_off = opts.current_back_off || STARTING_BACK_OFF;\n  opts.current_back_off = opts.back_off_function(opts.current_back_off);\n  setTimeout(callback, opts.current_back_off);\n}\n\nfunction sortObjectPropertiesByKey(queryParams) {\n  return Object.keys(queryParams).sort(collate).reduce(function (result, key) {\n    result[key] = queryParams[key];\n    return result;\n  }, {});\n}\n\n// Generate a unique id particular to this replication.\n// Not guaranteed to align perfectly with CouchDB's rep ids.\nfunction generateReplicationId(src, target, opts) {\n  var docIds = opts.doc_ids ? opts.doc_ids.sort(collate) : '';\n  var filterFun = opts.filter ? opts.filter.toString() : '';\n  var queryParams = '';\n  var filterViewName =  '';\n  var selector = '';\n\n  // possibility for checkpoints to be lost here as behaviour of\n  // JSON.stringify is not stable (see #6226)\n  /* istanbul ignore if */\n  if (opts.selector) {\n    selector = JSON.stringify(opts.selector);\n  }\n\n  if (opts.filter && opts.query_params) {\n    queryParams = JSON.stringify(sortObjectPropertiesByKey(opts.query_params));\n  }\n\n  if (opts.filter && opts.filter === '_view') {\n    filterViewName = opts.view.toString();\n  }\n\n  return PouchPromise.all([src.id(), target.id()]).then(function (res) {\n    var queryData = res[0] + res[1] + filterFun + filterViewName +\n      queryParams + docIds + selector;\n    return new PouchPromise(function (resolve) {\n      binaryMd5(queryData, resolve);\n    });\n  }).then(function (md5sum) {\n    // can't use straight-up md5 alphabet, because\n    // the char '/' is interpreted as being for attachments,\n    // and + is also not url-safe\n    md5sum = md5sum.replace(/\\//g, '.').replace(/\\+/g, '_');\n    return '_local/' + md5sum;\n  });\n}\n\nfunction replicate(src, target, opts, returnValue, result) {\n  var batches = [];               // list of batches to be processed\n  var currentBatch;               // the batch currently being processed\n  var pendingBatch = {\n    seq: 0,\n    changes: [],\n    docs: []\n  }; // next batch, not yet ready to be processed\n  var writingCheckpoint = false;  // true while checkpoint is being written\n  var changesCompleted = false;   // true when all changes received\n  var replicationCompleted = false; // true when replication has completed\n  var last_seq = 0;\n  var continuous = opts.continuous || opts.live || false;\n  var batch_size = opts.batch_size || 100;\n  var batches_limit = opts.batches_limit || 10;\n  var changesPending = false;     // true while src.changes is running\n  var doc_ids = opts.doc_ids;\n  var selector = opts.selector;\n  var repId;\n  var checkpointer;\n  var changedDocs = [];\n  // Like couchdb, every replication gets a unique session id\n  var session = uuid();\n  var seq_interval = opts.seq_interval;\n\n  result = result || {\n    ok: true,\n    start_time: new Date(),\n    docs_read: 0,\n    docs_written: 0,\n    doc_write_failures: 0,\n    errors: []\n  };\n\n  var changesOpts = {};\n  returnValue.ready(src, target);\n\n  function initCheckpointer() {\n    if (checkpointer) {\n      return PouchPromise.resolve();\n    }\n    return generateReplicationId(src, target, opts).then(function (res) {\n      repId = res;\n\n      var checkpointOpts = {};\n      if (opts.checkpoint === false) {\n        checkpointOpts = { writeSourceCheckpoint: false, writeTargetCheckpoint: false };\n      } else if (opts.checkpoint === 'source') {\n        checkpointOpts = { writeSourceCheckpoint: true, writeTargetCheckpoint: false };\n      } else if (opts.checkpoint === 'target') {\n        checkpointOpts = { writeSourceCheckpoint: false, writeTargetCheckpoint: true };\n      } else {\n        checkpointOpts = { writeSourceCheckpoint: true, writeTargetCheckpoint: true };\n      }\n\n      checkpointer = new Checkpointer(src, target, repId, returnValue, checkpointOpts);\n    });\n  }\n\n  function writeDocs() {\n    changedDocs = [];\n\n    if (currentBatch.docs.length === 0) {\n      return;\n    }\n    var docs = currentBatch.docs;\n    var bulkOpts = {timeout: opts.timeout};\n    return target.bulkDocs({docs: docs, new_edits: false}, bulkOpts).then(function (res) {\n      /* istanbul ignore if */\n      if (returnValue.cancelled) {\n        completeReplication();\n        throw new Error('cancelled');\n      }\n\n      // `res` doesn't include full documents (which live in `docs`), so we create a map of \n      // (id -> error), and check for errors while iterating over `docs`\n      var errorsById = Object.create(null);\n      res.forEach(function (res) {\n        if (res.error) {\n          errorsById[res.id] = res;\n        }\n      });\n\n      var errorsNo = Object.keys(errorsById).length;\n      result.doc_write_failures += errorsNo;\n      result.docs_written += docs.length - errorsNo;\n\n      docs.forEach(function (doc) {\n        var error = errorsById[doc._id];\n        if (error) {\n          result.errors.push(error);\n          // Normalize error name. i.e. 'Unauthorized' -> 'unauthorized' (eg Sync Gateway)\n          var errorName = (error.name || '').toLowerCase();\n          if (errorName === 'unauthorized' || errorName === 'forbidden') {\n            returnValue.emit('denied', clone(error));\n          } else {\n            throw error;\n          }\n        } else {\n          changedDocs.push(doc);\n        }\n      });\n\n    }, function (err) {\n      result.doc_write_failures += docs.length;\n      throw err;\n    });\n  }\n\n  function finishBatch() {\n    if (currentBatch.error) {\n      throw new Error('There was a problem getting docs.');\n    }\n    result.last_seq = last_seq = currentBatch.seq;\n    var outResult = clone(result);\n    if (changedDocs.length) {\n      outResult.docs = changedDocs;\n      // Attach 'pending' property if server supports it (CouchDB 2.0+)\n      /* istanbul ignore if */\n      if (typeof currentBatch.pending === 'number') {\n        outResult.pending = currentBatch.pending;\n        delete currentBatch.pending;\n      }\n      returnValue.emit('change', outResult);\n    }\n    writingCheckpoint = true;\n    return checkpointer.writeCheckpoint(currentBatch.seq,\n        session).then(function () {\n      writingCheckpoint = false;\n      /* istanbul ignore if */\n      if (returnValue.cancelled) {\n        completeReplication();\n        throw new Error('cancelled');\n      }\n      currentBatch = undefined;\n      getChanges();\n    })[\"catch\"](function (err) {\n      onCheckpointError(err);\n      throw err;\n    });\n  }\n\n  function getDiffs() {\n    var diff = {};\n    currentBatch.changes.forEach(function (change) {\n      // Couchbase Sync Gateway emits these, but we can ignore them\n      /* istanbul ignore if */\n      if (change.id === \"_user/\") {\n        return;\n      }\n      diff[change.id] = change.changes.map(function (x) {\n        return x.rev;\n      });\n    });\n    return target.revsDiff(diff).then(function (diffs) {\n      /* istanbul ignore if */\n      if (returnValue.cancelled) {\n        completeReplication();\n        throw new Error('cancelled');\n      }\n      // currentBatch.diffs elements are deleted as the documents are written\n      currentBatch.diffs = diffs;\n    });\n  }\n\n  function getBatchDocs() {\n    return getDocs(src, target, currentBatch.diffs, returnValue).then(function (got) {\n      currentBatch.error = !got.ok;\n      got.docs.forEach(function (doc) {\n        delete currentBatch.diffs[doc._id];\n        result.docs_read++;\n        currentBatch.docs.push(doc);\n      });\n    });\n  }\n\n  function startNextBatch() {\n    if (returnValue.cancelled || currentBatch) {\n      return;\n    }\n    if (batches.length === 0) {\n      processPendingBatch(true);\n      return;\n    }\n    currentBatch = batches.shift();\n    getDiffs()\n      .then(getBatchDocs)\n      .then(writeDocs)\n      .then(finishBatch)\n      .then(startNextBatch)[\n      \"catch\"](function (err) {\n        abortReplication('batch processing terminated with error', err);\n      });\n  }\n\n\n  function processPendingBatch(immediate) {\n    if (pendingBatch.changes.length === 0) {\n      if (batches.length === 0 && !currentBatch) {\n        if ((continuous && changesOpts.live) || changesCompleted) {\n          returnValue.state = 'pending';\n          returnValue.emit('paused');\n        }\n        if (changesCompleted) {\n          completeReplication();\n        }\n      }\n      return;\n    }\n    if (\n      immediate ||\n      changesCompleted ||\n      pendingBatch.changes.length >= batch_size\n    ) {\n      batches.push(pendingBatch);\n      pendingBatch = {\n        seq: 0,\n        changes: [],\n        docs: []\n      };\n      if (returnValue.state === 'pending' || returnValue.state === 'stopped') {\n        returnValue.state = 'active';\n        returnValue.emit('active');\n      }\n      startNextBatch();\n    }\n  }\n\n\n  function abortReplication(reason, err) {\n    if (replicationCompleted) {\n      return;\n    }\n    if (!err.message) {\n      err.message = reason;\n    }\n    result.ok = false;\n    result.status = 'aborting';\n    batches = [];\n    pendingBatch = {\n      seq: 0,\n      changes: [],\n      docs: []\n    };\n    completeReplication(err);\n  }\n\n\n  function completeReplication(fatalError) {\n    if (replicationCompleted) {\n      return;\n    }\n    /* istanbul ignore if */\n    if (returnValue.cancelled) {\n      result.status = 'cancelled';\n      if (writingCheckpoint) {\n        return;\n      }\n    }\n    result.status = result.status || 'complete';\n    result.end_time = new Date();\n    result.last_seq = last_seq;\n    replicationCompleted = true;\n\n    if (fatalError) {\n      // need to extend the error because Firefox considers \".result\" read-only\n      fatalError = createError(fatalError);\n      fatalError.result = result;\n\n      // Normalize error name. i.e. 'Unauthorized' -> 'unauthorized' (eg Sync Gateway)\n      var errorName = (fatalError.name || '').toLowerCase();\n      if (errorName === 'unauthorized' || errorName === 'forbidden') {\n        returnValue.emit('error', fatalError);\n        returnValue.removeAllListeners();\n      } else {\n        backOff(opts, returnValue, fatalError, function () {\n          replicate(src, target, opts, returnValue);\n        });\n      }\n    } else {\n      returnValue.emit('complete', result);\n      returnValue.removeAllListeners();\n    }\n  }\n\n\n  function onChange(change, pending, lastSeq) {\n    /* istanbul ignore if */\n    if (returnValue.cancelled) {\n      return completeReplication();\n    }\n    // Attach 'pending' property if server supports it (CouchDB 2.0+)\n    /* istanbul ignore if */\n    if (typeof pending === 'number') {\n      pendingBatch.pending = pending;\n    }\n\n    var filter = filterChange(opts)(change);\n    if (!filter) {\n      return;\n    }\n    pendingBatch.seq = change.seq || lastSeq;\n    pendingBatch.changes.push(change);\n    processPendingBatch(batches.length === 0 && changesOpts.live);\n  }\n\n\n  function onChangesComplete(changes) {\n    changesPending = false;\n    /* istanbul ignore if */\n    if (returnValue.cancelled) {\n      return completeReplication();\n    }\n\n    // if no results were returned then we're done,\n    // else fetch more\n    if (changes.results.length > 0) {\n      changesOpts.since = changes.last_seq;\n      getChanges();\n      processPendingBatch(true);\n    } else {\n\n      var complete = function () {\n        if (continuous) {\n          changesOpts.live = true;\n          getChanges();\n        } else {\n          changesCompleted = true;\n        }\n        processPendingBatch(true);\n      };\n\n      // update the checkpoint so we start from the right seq next time\n      if (!currentBatch && changes.results.length === 0) {\n        writingCheckpoint = true;\n        checkpointer.writeCheckpoint(changes.last_seq,\n            session).then(function () {\n          writingCheckpoint = false;\n          result.last_seq = last_seq = changes.last_seq;\n          complete();\n        })[\n        \"catch\"](onCheckpointError);\n      } else {\n        complete();\n      }\n    }\n  }\n\n\n  function onChangesError(err) {\n    changesPending = false;\n    /* istanbul ignore if */\n    if (returnValue.cancelled) {\n      return completeReplication();\n    }\n    abortReplication('changes rejected', err);\n  }\n\n\n  function getChanges() {\n    if (!(\n      !changesPending &&\n      !changesCompleted &&\n      batches.length < batches_limit\n      )) {\n      return;\n    }\n    changesPending = true;\n    function abortChanges() {\n      changes.cancel();\n    }\n    function removeListener() {\n      returnValue.removeListener('cancel', abortChanges);\n    }\n\n    if (returnValue._changes) { // remove old changes() and listeners\n      returnValue.removeListener('cancel', returnValue._abortChanges);\n      returnValue._changes.cancel();\n    }\n    returnValue.once('cancel', abortChanges);\n\n    var changes = src.changes(changesOpts)\n      .on('change', onChange);\n    changes.then(removeListener, removeListener);\n    changes.then(onChangesComplete)[\n      \"catch\"](onChangesError);\n\n    if (opts.retry) {\n      // save for later so we can cancel if necessary\n      returnValue._changes = changes;\n      returnValue._abortChanges = abortChanges;\n    }\n  }\n\n\n  function startChanges() {\n    initCheckpointer().then(function () {\n      /* istanbul ignore if */\n      if (returnValue.cancelled) {\n        completeReplication();\n        return;\n      }\n      return checkpointer.getCheckpoint().then(function (checkpoint) {\n        last_seq = checkpoint;\n        changesOpts = {\n          since: last_seq,\n          limit: batch_size,\n          batch_size: batch_size,\n          style: 'all_docs',\n          doc_ids: doc_ids,\n          selector: selector,\n          return_docs: true // required so we know when we're done\n        };\n        if (seq_interval !== false) {\n          changesOpts.seq_interval = seq_interval || batch_size;\n        }\n        if (opts.filter) {\n          if (typeof opts.filter !== 'string') {\n            // required for the client-side filter in onChange\n            changesOpts.include_docs = true;\n          } else { // ddoc filter\n            changesOpts.filter = opts.filter;\n          }\n        }\n        if ('heartbeat' in opts) {\n          changesOpts.heartbeat = opts.heartbeat;\n        }\n        if ('timeout' in opts) {\n          changesOpts.timeout = opts.timeout;\n        }\n        if (opts.query_params) {\n          changesOpts.query_params = opts.query_params;\n        }\n        if (opts.view) {\n          changesOpts.view = opts.view;\n        }\n        getChanges();\n      });\n    })[\"catch\"](function (err) {\n      abortReplication('getCheckpoint rejected with ', err);\n    });\n  }\n\n  /* istanbul ignore next */\n  function onCheckpointError(err) {\n    writingCheckpoint = false;\n    abortReplication('writeCheckpoint completed with error', err);\n  }\n\n  /* istanbul ignore if */\n  if (returnValue.cancelled) { // cancelled immediately\n    completeReplication();\n    return;\n  }\n\n  if (!returnValue._addedListeners) {\n    returnValue.once('cancel', completeReplication);\n\n    if (typeof opts.complete === 'function') {\n      returnValue.once('error', opts.complete);\n      returnValue.once('complete', function (result) {\n        opts.complete(null, result);\n      });\n    }\n    returnValue._addedListeners = true;\n  }\n\n  if (typeof opts.since === 'undefined') {\n    startChanges();\n  } else {\n    initCheckpointer().then(function () {\n      writingCheckpoint = true;\n      return checkpointer.writeCheckpoint(opts.since, session);\n    }).then(function () {\n      writingCheckpoint = false;\n      /* istanbul ignore if */\n      if (returnValue.cancelled) {\n        completeReplication();\n        return;\n      }\n      last_seq = opts.since;\n      startChanges();\n    })[\"catch\"](onCheckpointError);\n  }\n}\n\n// We create a basic promise so the caller can cancel the replication possibly\n// before we have actually started listening to changes etc\ninherits(Replication, events.EventEmitter);\nfunction Replication() {\n  events.EventEmitter.call(this);\n  this.cancelled = false;\n  this.state = 'pending';\n  var self = this;\n  var promise = new PouchPromise(function (fulfill, reject) {\n    self.once('complete', fulfill);\n    self.once('error', reject);\n  });\n  self.then = function (resolve, reject) {\n    return promise.then(resolve, reject);\n  };\n  self[\"catch\"] = function (reject) {\n    return promise[\"catch\"](reject);\n  };\n  // As we allow error handling via \"error\" event as well,\n  // put a stub in here so that rejecting never throws UnhandledError.\n  self[\"catch\"](function () {});\n}\n\nReplication.prototype.cancel = function () {\n  this.cancelled = true;\n  this.state = 'cancelled';\n  this.emit('cancel');\n};\n\nReplication.prototype.ready = function (src, target) {\n  var self = this;\n  if (self._readyCalled) {\n    return;\n  }\n  self._readyCalled = true;\n\n  function onDestroy() {\n    self.cancel();\n  }\n  src.once('destroyed', onDestroy);\n  target.once('destroyed', onDestroy);\n  function cleanup() {\n    src.removeListener('destroyed', onDestroy);\n    target.removeListener('destroyed', onDestroy);\n  }\n  self.once('complete', cleanup);\n};\n\nfunction toPouch(db, opts) {\n  var PouchConstructor = opts.PouchConstructor;\n  if (typeof db === 'string') {\n    return new PouchConstructor(db, opts);\n  } else {\n    return db;\n  }\n}\n\nfunction replicateWrapper(src, target, opts, callback) {\n\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  if (typeof opts === 'undefined') {\n    opts = {};\n  }\n\n  if (opts.doc_ids && !Array.isArray(opts.doc_ids)) {\n    throw createError(BAD_REQUEST,\n                       \"`doc_ids` filter parameter is not a list.\");\n  }\n\n  opts.complete = callback;\n  opts = clone(opts);\n  opts.continuous = opts.continuous || opts.live;\n  opts.retry = ('retry' in opts) ? opts.retry : false;\n  /*jshint validthis:true */\n  opts.PouchConstructor = opts.PouchConstructor || this;\n  var replicateRet = new Replication(opts);\n  var srcPouch = toPouch(src, opts);\n  var targetPouch = toPouch(target, opts);\n  replicate(srcPouch, targetPouch, opts, replicateRet);\n  return replicateRet;\n}\n\ninherits(Sync, events.EventEmitter);\nfunction sync$1(src, target, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  if (typeof opts === 'undefined') {\n    opts = {};\n  }\n  opts = clone(opts);\n  /*jshint validthis:true */\n  opts.PouchConstructor = opts.PouchConstructor || this;\n  src = toPouch(src, opts);\n  target = toPouch(target, opts);\n  return new Sync(src, target, opts, callback);\n}\n\nfunction Sync(src, target, opts, callback) {\n  var self = this;\n  this.canceled = false;\n\n  var optsPush = opts.push ? $inject_Object_assign({}, opts, opts.push) : opts;\n  var optsPull = opts.pull ? $inject_Object_assign({}, opts, opts.pull) : opts;\n\n  this.push = replicateWrapper(src, target, optsPush);\n  this.pull = replicateWrapper(target, src, optsPull);\n\n  this.pushPaused = true;\n  this.pullPaused = true;\n\n  function pullChange(change) {\n    self.emit('change', {\n      direction: 'pull',\n      change: change\n    });\n  }\n  function pushChange(change) {\n    self.emit('change', {\n      direction: 'push',\n      change: change\n    });\n  }\n  function pushDenied(doc) {\n    self.emit('denied', {\n      direction: 'push',\n      doc: doc\n    });\n  }\n  function pullDenied(doc) {\n    self.emit('denied', {\n      direction: 'pull',\n      doc: doc\n    });\n  }\n  function pushPaused() {\n    self.pushPaused = true;\n    /* istanbul ignore if */\n    if (self.pullPaused) {\n      self.emit('paused');\n    }\n  }\n  function pullPaused() {\n    self.pullPaused = true;\n    /* istanbul ignore if */\n    if (self.pushPaused) {\n      self.emit('paused');\n    }\n  }\n  function pushActive() {\n    self.pushPaused = false;\n    /* istanbul ignore if */\n    if (self.pullPaused) {\n      self.emit('active', {\n        direction: 'push'\n      });\n    }\n  }\n  function pullActive() {\n    self.pullPaused = false;\n    /* istanbul ignore if */\n    if (self.pushPaused) {\n      self.emit('active', {\n        direction: 'pull'\n      });\n    }\n  }\n\n  var removed = {};\n\n  function removeAll(type) { // type is 'push' or 'pull'\n    return function (event, func) {\n      var isChange = event === 'change' &&\n        (func === pullChange || func === pushChange);\n      var isDenied = event === 'denied' &&\n        (func === pullDenied || func === pushDenied);\n      var isPaused = event === 'paused' &&\n        (func === pullPaused || func === pushPaused);\n      var isActive = event === 'active' &&\n        (func === pullActive || func === pushActive);\n\n      if (isChange || isDenied || isPaused || isActive) {\n        if (!(event in removed)) {\n          removed[event] = {};\n        }\n        removed[event][type] = true;\n        if (Object.keys(removed[event]).length === 2) {\n          // both push and pull have asked to be removed\n          self.removeAllListeners(event);\n        }\n      }\n    };\n  }\n\n  if (opts.live) {\n    this.push.on('complete', self.pull.cancel.bind(self.pull));\n    this.pull.on('complete', self.push.cancel.bind(self.push));\n  }\n\n  function addOneListener(ee, event, listener) {\n    if (ee.listeners(event).indexOf(listener) == -1) {\n      ee.on(event, listener);\n    }\n  }\n\n  this.on('newListener', function (event) {\n    if (event === 'change') {\n      addOneListener(self.pull, 'change', pullChange);\n      addOneListener(self.push, 'change', pushChange);\n    } else if (event === 'denied') {\n      addOneListener(self.pull, 'denied', pullDenied);\n      addOneListener(self.push, 'denied', pushDenied);\n    } else if (event === 'active') {\n      addOneListener(self.pull, 'active', pullActive);\n      addOneListener(self.push, 'active', pushActive);\n    } else if (event === 'paused') {\n      addOneListener(self.pull, 'paused', pullPaused);\n      addOneListener(self.push, 'paused', pushPaused);\n    }\n  });\n\n  this.on('removeListener', function (event) {\n    if (event === 'change') {\n      self.pull.removeListener('change', pullChange);\n      self.push.removeListener('change', pushChange);\n    } else if (event === 'denied') {\n      self.pull.removeListener('denied', pullDenied);\n      self.push.removeListener('denied', pushDenied);\n    } else if (event === 'active') {\n      self.pull.removeListener('active', pullActive);\n      self.push.removeListener('active', pushActive);\n    } else if (event === 'paused') {\n      self.pull.removeListener('paused', pullPaused);\n      self.push.removeListener('paused', pushPaused);\n    }\n  });\n\n  this.pull.on('removeListener', removeAll('pull'));\n  this.push.on('removeListener', removeAll('push'));\n\n  var promise = PouchPromise.all([\n    this.push,\n    this.pull\n  ]).then(function (resp) {\n    var out = {\n      push: resp[0],\n      pull: resp[1]\n    };\n    self.emit('complete', out);\n    if (callback) {\n      callback(null, out);\n    }\n    self.removeAllListeners();\n    return out;\n  }, function (err) {\n    self.cancel();\n    if (callback) {\n      // if there's a callback, then the callback can receive\n      // the error event\n      callback(err);\n    } else {\n      // if there's no callback, then we're safe to emit an error\n      // event, which would otherwise throw an unhandled error\n      // due to 'error' being a special event in EventEmitters\n      self.emit('error', err);\n    }\n    self.removeAllListeners();\n    if (callback) {\n      // no sense throwing if we're already emitting an 'error' event\n      throw err;\n    }\n  });\n\n  this.then = function (success, err) {\n    return promise.then(success, err);\n  };\n\n  this[\"catch\"] = function (err) {\n    return promise[\"catch\"](err);\n  };\n}\n\nSync.prototype.cancel = function () {\n  if (!this.canceled) {\n    this.canceled = true;\n    this.push.cancel();\n    this.pull.cancel();\n  }\n};\n\nfunction replication(PouchDB) {\n  PouchDB.replicate = replicateWrapper;\n  PouchDB.sync = sync$1;\n\n  Object.defineProperty(PouchDB.prototype, 'replicate', {\n    get: function () {\n      var self = this;\n      if (typeof this.replicateMethods === 'undefined') {\n        this.replicateMethods = {\n          from: function (other, opts, callback) {\n            return self.constructor.replicate(other, self, opts, callback);\n          },\n          to: function (other, opts, callback) {\n            return self.constructor.replicate(self, other, opts, callback);\n          }\n        };\n      }\n      return this.replicateMethods;\n    }\n  });\n\n  PouchDB.prototype.sync = function (dbName, opts, callback) {\n    return this.constructor.sync(this, dbName, opts, callback);\n  };\n}\n\nPouchDB.plugin(IDBPouch)\n  .plugin(WebSqlPouch$1)\n  .plugin(HttpPouch$1)\n  .plugin(mapreduce)\n  .plugin(replication);\n\n// Pull from src because pouchdb-node/pouchdb-browser themselves\n// are aggressively optimized and jsnext:main would normally give us this\n// aggressive bundle.\n\nmodule.exports = PouchDB;\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"1\":1,\"10\":10,\"11\":11,\"16\":16,\"2\":2,\"4\":4,\"5\":5,\"6\":6,\"7\":7}]},{},[17])(17)\n});\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))\n\n/***/ }),\n/* 23 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function($) {/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__events__ = __webpack_require__(2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__events___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__events__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_routie__ = __webpack_require__(24);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_routie___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_routie__);\n\n\n\n$(window).on(__WEBPACK_IMPORTED_MODULE_0__events___default.a.AJAX + ' ' + __WEBPACK_IMPORTED_MODULE_0__events___default.a.LOADED, function () {\n    __WEBPACK_IMPORTED_MODULE_1_routie___default()({\n        'navigation': function navigation() {\n            $('#NavbarCollapse').addClass('in');\n        },\n        'carousel:id:num': function carouselIdNum(id, num) {\n            $('#Carousel' + id).carousel(num);\n        }\n    });\n});\n/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(0)))\n\n/***/ }),\n/* 24 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar path = __webpack_require__(25);\n\nvar methods = ['get', 'post', 'put', 'patch', 'delete', 'del', 'all'];\n\nvar __slice = [].slice;\n\nmodule.exports = function (map) {\n    var args, root, _map, cb;\n    args = __slice.call(arguments, 1);\n\n    if (typeof args[args.length - 1] === \"function\") cb = args.pop();\n\n    root = path.join.apply(path, args);\n    _map = {};\n    methods.forEach(function (m) {\n        _map[m] = function (subpath) {\n            var args = __slice.call(arguments);\n            args.length < 2 ? args.unshift(root) : args[0] = root + args[0];\n            return map[m].apply(map, args);\n        }\n    });\n    if (cb) cb(_map);\n    return _map;\n};\n\n/***/ }),\n/* 25 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// resolves . and .. elements in a path array with directory names there\n// must be no slashes, empty elements, or device names (c:\\) in the array\n// (so also no leading and trailing slashes - it does not distinguish\n// relative and absolute paths)\nfunction normalizeArray(parts, allowAboveRoot) {\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = parts.length - 1; i >= 0; i--) {\n    var last = parts[i];\n    if (last === '.') {\n      parts.splice(i, 1);\n    } else if (last === '..') {\n      parts.splice(i, 1);\n      up++;\n    } else if (up) {\n      parts.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (allowAboveRoot) {\n    for (; up--; up) {\n      parts.unshift('..');\n    }\n  }\n\n  return parts;\n}\n\n// Split a filename into [root, dir, basename, ext], unix version\n// 'root' is just a slash, or nothing.\nvar splitPathRe =\n    /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\nvar splitPath = function(filename) {\n  return splitPathRe.exec(filename).slice(1);\n};\n\n// path.resolve([from ...], to)\n// posix version\nexports.resolve = function() {\n  var resolvedPath = '',\n      resolvedAbsolute = false;\n\n  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n    var path = (i >= 0) ? arguments[i] : process.cwd();\n\n    // Skip empty and invalid entries\n    if (typeof path !== 'string') {\n      throw new TypeError('Arguments to path.resolve must be strings');\n    } else if (!path) {\n      continue;\n    }\n\n    resolvedPath = path + '/' + resolvedPath;\n    resolvedAbsolute = path.charAt(0) === '/';\n  }\n\n  // At this point the path should be resolved to a full absolute path, but\n  // handle relative paths to be safe (might happen when process.cwd() fails)\n\n  // Normalize the path\n  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {\n    return !!p;\n  }), !resolvedAbsolute).join('/');\n\n  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n};\n\n// path.normalize(path)\n// posix version\nexports.normalize = function(path) {\n  var isAbsolute = exports.isAbsolute(path),\n      trailingSlash = substr(path, -1) === '/';\n\n  // Normalize the path\n  path = normalizeArray(filter(path.split('/'), function(p) {\n    return !!p;\n  }), !isAbsolute).join('/');\n\n  if (!path && !isAbsolute) {\n    path = '.';\n  }\n  if (path && trailingSlash) {\n    path += '/';\n  }\n\n  return (isAbsolute ? '/' : '') + path;\n};\n\n// posix version\nexports.isAbsolute = function(path) {\n  return path.charAt(0) === '/';\n};\n\n// posix version\nexports.join = function() {\n  var paths = Array.prototype.slice.call(arguments, 0);\n  return exports.normalize(filter(paths, function(p, index) {\n    if (typeof p !== 'string') {\n      throw new TypeError('Arguments to path.join must be strings');\n    }\n    return p;\n  }).join('/'));\n};\n\n\n// path.relative(from, to)\n// posix version\nexports.relative = function(from, to) {\n  from = exports.resolve(from).substr(1);\n  to = exports.resolve(to).substr(1);\n\n  function trim(arr) {\n    var start = 0;\n    for (; start < arr.length; start++) {\n      if (arr[start] !== '') break;\n    }\n\n    var end = arr.length - 1;\n    for (; end >= 0; end--) {\n      if (arr[end] !== '') break;\n    }\n\n    if (start > end) return [];\n    return arr.slice(start, end - start + 1);\n  }\n\n  var fromParts = trim(from.split('/'));\n  var toParts = trim(to.split('/'));\n\n  var length = Math.min(fromParts.length, toParts.length);\n  var samePartsLength = length;\n  for (var i = 0; i < length; i++) {\n    if (fromParts[i] !== toParts[i]) {\n      samePartsLength = i;\n      break;\n    }\n  }\n\n  var outputParts = [];\n  for (var i = samePartsLength; i < fromParts.length; i++) {\n    outputParts.push('..');\n  }\n\n  outputParts = outputParts.concat(toParts.slice(samePartsLength));\n\n  return outputParts.join('/');\n};\n\nexports.sep = '/';\nexports.delimiter = ':';\n\nexports.dirname = function(path) {\n  var result = splitPath(path),\n      root = result[0],\n      dir = result[1];\n\n  if (!root && !dir) {\n    // No dirname whatsoever\n    return '.';\n  }\n\n  if (dir) {\n    // It has a dirname, strip trailing slash\n    dir = dir.substr(0, dir.length - 1);\n  }\n\n  return root + dir;\n};\n\n\nexports.basename = function(path, ext) {\n  var f = splitPath(path)[2];\n  // TODO: make this comparison case-insensitive on windows?\n  if (ext && f.substr(-1 * ext.length) === ext) {\n    f = f.substr(0, f.length - ext.length);\n  }\n  return f;\n};\n\n\nexports.extname = function(path) {\n  return splitPath(path)[3];\n};\n\nfunction filter (xs, f) {\n    if (xs.filter) return xs.filter(f);\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        if (f(xs[i], i, xs)) res.push(xs[i]);\n    }\n    return res;\n}\n\n// String.prototype.substr - negative index don't work in IE8\nvar substr = 'ab'.substr(-1) === 'b'\n    ? function (str, start, len) { return str.substr(start, len) }\n    : function (str, start, len) {\n        if (start < 0) start = str.length + start;\n        return str.substr(start, len);\n    }\n;\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(26)))\n\n/***/ }),\n/* 26 */\n/***/ (function(module, exports) {\n\n// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n/***/ }),\n/* 27 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(global) {var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*! smooth-scroll v14.2.0 | (c) 2018 Chris Ferdinandi | MIT License | http://github.com/cferdinandi/smooth-scroll */\n!(function(e,t){ true?!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function(){return t(e)}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)):\"object\"==typeof exports?module.exports=t(e):e.SmoothScroll=t(e)})(\"undefined\"!=typeof global?global:\"undefined\"!=typeof window?window:this,(function(e){\"use strict\";var t={ignore:\"[data-scroll-ignore]\",header:null,topOnEmptyHash:!0,speed:500,clip:!0,offset:0,easing:\"easeInOutCubic\",customEasing:null,updateURL:!0,popstate:!0,emitEvents:!0},n=function(){return\"querySelector\"in document&&\"addEventListener\"in e&&\"requestAnimationFrame\"in e&&\"closest\"in e.Element.prototype},o=function(){for(var e={},t=0;t<arguments.length;t++)!(function(t){for(var n in t)t.hasOwnProperty(n)&&(e[n]=t[n])})(arguments[t]);return e},r=function(t){return!!(\"matchMedia\"in e&&e.matchMedia(\"(prefers-reduced-motion)\").matches)},a=function(t){return parseInt(e.getComputedStyle(t).height,10)},i=function(e){var t;try{t=decodeURIComponent(e)}catch(n){t=e}return t},c=function(e){\"#\"===e.charAt(0)&&(e=e.substr(1));for(var t,n=String(e),o=n.length,r=-1,a=\"\",i=n.charCodeAt(0);++r<o;){if(0===(t=n.charCodeAt(r)))throw new InvalidCharacterError(\"Invalid character: the input contains U+0000.\");t>=1&&t<=31||127==t||0===r&&t>=48&&t<=57||1===r&&t>=48&&t<=57&&45===i?a+=\"\\\\\"+t.toString(16)+\" \":a+=t>=128||45===t||95===t||t>=48&&t<=57||t>=65&&t<=90||t>=97&&t<=122?n.charAt(r):\"\\\\\"+n.charAt(r)}var c;try{c=decodeURIComponent(\"#\"+a)}catch(e){c=\"#\"+a}return c},u=function(e,t){var n;return\"easeInQuad\"===e.easing&&(n=t*t),\"easeOutQuad\"===e.easing&&(n=t*(2-t)),\"easeInOutQuad\"===e.easing&&(n=t<.5?2*t*t:(4-2*t)*t-1),\"easeInCubic\"===e.easing&&(n=t*t*t),\"easeOutCubic\"===e.easing&&(n=--t*t*t+1),\"easeInOutCubic\"===e.easing&&(n=t<.5?4*t*t*t:(t-1)*(2*t-2)*(2*t-2)+1),\"easeInQuart\"===e.easing&&(n=t*t*t*t),\"easeOutQuart\"===e.easing&&(n=1- --t*t*t*t),\"easeInOutQuart\"===e.easing&&(n=t<.5?8*t*t*t*t:1-8*--t*t*t*t),\"easeInQuint\"===e.easing&&(n=t*t*t*t*t),\"easeOutQuint\"===e.easing&&(n=1+--t*t*t*t*t),\"easeInOutQuint\"===e.easing&&(n=t<.5?16*t*t*t*t*t:1+16*--t*t*t*t*t),e.customEasing&&(n=e.customEasing(t)),n||t},s=function(){return Math.max(document.body.scrollHeight,document.documentElement.scrollHeight,document.body.offsetHeight,document.documentElement.offsetHeight,document.body.clientHeight,document.documentElement.clientHeight)},l=function(t,n,o,r){var a=0;if(t.offsetParent)do{a+=t.offsetTop,t=t.offsetParent}while(t);return a=Math.max(a-n-o,0),r&&(a=Math.min(a,s()-e.innerHeight)),a},d=function(e){return e?a(e)+e.offsetTop:0},f=function(e,t,n){t||history.pushState&&n.updateURL&&history.pushState({smoothScroll:JSON.stringify(n),anchor:e.id},document.title,e===document.documentElement?\"#top\":\"#\"+e.id)},m=function(t,n,o){0===t&&document.body.focus(),o||(t.focus(),document.activeElement!==t&&(t.setAttribute(\"tabindex\",\"-1\"),t.focus(),t.style.outline=\"none\"),e.scrollTo(0,n))},h=function(t,n,o,r){if(n.emitEvents&&\"function\"==typeof e.CustomEvent){var a=new CustomEvent(t,{bubbles:!0,detail:{anchor:o,toggle:r}});document.dispatchEvent(a)}};return function(a,p){var g,v,y,S,E,b,O,I={};I.cancelScroll=function(e){cancelAnimationFrame(O),O=null,e||h(\"scrollCancel\",g)},I.animateScroll=function(n,r,a){var i=o(g||t,a||{}),c=\"[object Number]\"===Object.prototype.toString.call(n),p=c||!n.tagName?null:n;if(c||p){var v=e.pageYOffset;i.header&&!S&&(S=document.querySelector(i.header)),E||(E=d(S));var y,b,C,w=c?n:l(p,E,parseInt(\"function\"==typeof i.offset?i.offset(n,r):i.offset,10),i.clip),L=w-v,A=s(),H=0,q=function(t,o){var a=e.pageYOffset;if(t==o||a==o||(v<o&&e.innerHeight+a)>=A)return I.cancelScroll(!0),m(n,o,c),h(\"scrollStop\",i,n,r),y=null,O=null,!0},Q=function(t){y||(y=t),H+=t-y,b=H/parseInt(i.speed,10),b=b>1?1:b,C=v+L*u(i,b),e.scrollTo(0,Math.floor(C)),q(C,w)||(O=e.requestAnimationFrame(Q),y=t)};0===e.pageYOffset&&e.scrollTo(0,0),f(n,c,i),h(\"scrollStart\",i,n,r),I.cancelScroll(!0),e.requestAnimationFrame(Q)}};var C=function(t){if(!r()&&0===t.button&&!t.metaKey&&!t.ctrlKey&&\"closest\"in t.target&&(y=t.target.closest(a))&&\"a\"===y.tagName.toLowerCase()&&!t.target.closest(g.ignore)&&y.hostname===e.location.hostname&&y.pathname===e.location.pathname&&/#/.test(y.href)){var n=c(i(y.hash)),o=g.topOnEmptyHash&&\"#\"===n?document.documentElement:document.querySelector(n);o=o||\"#top\"!==n?o:document.documentElement,o&&(t.preventDefault(),I.animateScroll(o,y))}},w=function(e){if(history.state.smoothScroll&&history.state.smoothScroll===JSON.stringify(g)&&history.state.anchor){var t=document.querySelector(c(i(history.state.anchor)));t&&I.animateScroll(t,null,{updateURL:!1})}},L=function(e){b||(b=setTimeout((function(){b=null,E=d(S)}),66))};return I.destroy=function(){g&&(document.removeEventListener(\"click\",C,!1),e.removeEventListener(\"resize\",L,!1),e.removeEventListener(\"popstate\",w,!1),I.cancelScroll(),g=null,v=null,y=null,S=null,E=null,b=null,O=null)},I.init=function(r){if(!n())throw\"Smooth Scroll: This browser does not support the required JavaScript methods and browser APIs.\";I.destroy(),g=o(t,r||{}),S=g.header?document.querySelector(g.header):null,E=d(S),document.addEventListener(\"click\",C,!1),S&&e.addEventListener(\"resize\",L,!1),g.updateURL&&g.popstate&&e.addEventListener(\"popstate\",w,!1)},I.init(p),I}}));\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))\n\n/***/ }),\n/* 28 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar map = {\n\t\"./icon-cfpb.png\": 29,\n\t\"./icon-lender.png\": 30,\n\t\"./logo.png\": 31\n};\nfunction webpackContext(req) {\n\treturn __webpack_require__(webpackContextResolve(req));\n};\nfunction webpackContextResolve(req) {\n\tvar id = map[req];\n\tif(!(id + 1)) // check for number or string\n\t\tthrow new Error(\"Cannot find module '\" + req + \"'.\");\n\treturn id;\n};\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = 28;\n\n/***/ }),\n/* 29 */\n/***/ (function(module, exports) {\n\nmodule.exports = \"../img/icon-cfpb.png\";\n\n/***/ }),\n/* 30 */\n/***/ (function(module, exports) {\n\nmodule.exports = \"../img/icon-lender.png\";\n\n/***/ }),\n/* 31 */\n/***/ (function(module, exports) {\n\nmodule.exports = \"../img/logo.png\";\n\n/***/ }),\n/* 32 */\n/***/ (function(module, exports) {\n\nfunction webpackEmptyContext(req) {\n\tthrow new Error(\"Cannot find module '\" + req + \"'.\");\n}\nwebpackEmptyContext.keys = function() { return []; };\nwebpackEmptyContext.resolve = webpackEmptyContext;\nmodule.exports = webpackEmptyContext;\nwebpackEmptyContext.id = 32;\n\n/***/ })\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// js/app.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"app/client/dist/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 6);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap bf4e87ea9ffc4b0f0978","module.exports = jQuery;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"jQuery\"\n// module id = 0\n// module chunks = 0","/**\n * --------------------------------------------------------------------------\n * Bootstrap (v4.1.1): util.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n * --------------------------------------------------------------------------\n */\nvar Util = function ($) {\n  /**\n   * ------------------------------------------------------------------------\n   * Private TransitionEnd Helpers\n   * ------------------------------------------------------------------------\n   */\n  var TRANSITION_END = 'transitionend';\n  var MAX_UID = 1000000;\n  var MILLISECONDS_MULTIPLIER = 1000; // Shoutout AngusCroll (https://goo.gl/pxwQGp)\n\n  function toType(obj) {\n    return {}.toString.call(obj).match(/\\s([a-z]+)/i)[1].toLowerCase();\n  }\n\n  function getSpecialTransitionEndEvent() {\n    return {\n      bindType: TRANSITION_END,\n      delegateType: TRANSITION_END,\n      handle: function handle(event) {\n        if ($(event.target).is(this)) {\n          return event.handleObj.handler.apply(this, arguments); // eslint-disable-line prefer-rest-params\n        }\n\n        return undefined; // eslint-disable-line no-undefined\n      }\n    };\n  }\n\n  function transitionEndEmulator(duration) {\n    var _this = this;\n\n    var called = false;\n    $(this).one(Util.TRANSITION_END, function () {\n      called = true;\n    });\n    setTimeout(function () {\n      if (!called) {\n        Util.triggerTransitionEnd(_this);\n      }\n    }, duration);\n    return this;\n  }\n\n  function setTransitionEndSupport() {\n    $.fn.emulateTransitionEnd = transitionEndEmulator;\n    $.event.special[Util.TRANSITION_END] = getSpecialTransitionEndEvent();\n  }\n  /**\n   * --------------------------------------------------------------------------\n   * Public Util Api\n   * --------------------------------------------------------------------------\n   */\n\n\n  var Util = {\n    TRANSITION_END: 'bsTransitionEnd',\n    getUID: function getUID(prefix) {\n      do {\n        // eslint-disable-next-line no-bitwise\n        prefix += ~~(Math.random() * MAX_UID); // \"~~\" acts like a faster Math.floor() here\n      } while (document.getElementById(prefix));\n\n      return prefix;\n    },\n    getSelectorFromElement: function getSelectorFromElement(element) {\n      var selector = element.getAttribute('data-target');\n\n      if (!selector || selector === '#') {\n        selector = element.getAttribute('href') || '';\n      }\n\n      try {\n        var $selector = $(document).find(selector);\n        return $selector.length > 0 ? selector : null;\n      } catch (err) {\n        return null;\n      }\n    },\n    getTransitionDurationFromElement: function getTransitionDurationFromElement(element) {\n      if (!element) {\n        return 0;\n      } // Get transition-duration of the element\n\n\n      var transitionDuration = $(element).css('transition-duration');\n      var floatTransitionDuration = parseFloat(transitionDuration); // Return 0 if element or transition duration is not found\n\n      if (!floatTransitionDuration) {\n        return 0;\n      } // If multiple durations are defined, take the first\n\n\n      transitionDuration = transitionDuration.split(',')[0];\n      return parseFloat(transitionDuration) * MILLISECONDS_MULTIPLIER;\n    },\n    reflow: function reflow(element) {\n      return element.offsetHeight;\n    },\n    triggerTransitionEnd: function triggerTransitionEnd(element) {\n      $(element).trigger(TRANSITION_END);\n    },\n    // TODO: Remove in v5\n    supportsTransitionEnd: function supportsTransitionEnd() {\n      return Boolean(TRANSITION_END);\n    },\n    isElement: function isElement(obj) {\n      return (obj[0] || obj).nodeType;\n    },\n    typeCheckConfig: function typeCheckConfig(componentName, config, configTypes) {\n      for (var property in configTypes) {\n        if (Object.prototype.hasOwnProperty.call(configTypes, property)) {\n          var expectedTypes = configTypes[property];\n          var value = config[property];\n          var valueType = value && Util.isElement(value) ? 'element' : toType(value);\n\n          if (!new RegExp(expectedTypes).test(valueType)) {\n            throw new Error(componentName.toUpperCase() + \": \" + (\"Option \\\"\" + property + \"\\\" provided type \\\"\" + valueType + \"\\\" \") + (\"but expected type \\\"\" + expectedTypes + \"\\\".\"));\n          }\n        }\n      }\n    }\n  };\n  setTransitionEndSupport();\n  return Util;\n}($);\n//# sourceMappingURL=util.js.map\n\n/*** EXPORTS FROM exports-loader ***/\nmodule.exports = Util;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/exports-loader?Util!./node_modules/bootstrap/js/dist/util.js\n// module id = 1\n// module chunks = 0","/**\n * Add your global events here\n */\n\nmodule.exports = {\n  AJAX: 'ajax-load',\n  LOADED: 'load',\n};\n\n\n\n// WEBPACK FOOTER //\n// ./app/client/src/js/_events.js","/**!\n * @fileOverview Kickass library to create and place poppers near their reference elements.\n * @version 1.14.3\n * @license\n * Copyright (c) 2016 Federico Zivolo and contributors\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\nvar isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined';\n\nvar longerTimeoutBrowsers = ['Edge', 'Trident', 'Firefox'];\nvar timeoutDuration = 0;\nfor (var i = 0; i < longerTimeoutBrowsers.length; i += 1) {\n  if (isBrowser && navigator.userAgent.indexOf(longerTimeoutBrowsers[i]) >= 0) {\n    timeoutDuration = 1;\n    break;\n  }\n}\n\nfunction microtaskDebounce(fn) {\n  var called = false;\n  return function () {\n    if (called) {\n      return;\n    }\n    called = true;\n    window.Promise.resolve().then(function () {\n      called = false;\n      fn();\n    });\n  };\n}\n\nfunction taskDebounce(fn) {\n  var scheduled = false;\n  return function () {\n    if (!scheduled) {\n      scheduled = true;\n      setTimeout(function () {\n        scheduled = false;\n        fn();\n      }, timeoutDuration);\n    }\n  };\n}\n\nvar supportsMicroTasks = isBrowser && window.Promise;\n\n/**\n* Create a debounced version of a method, that's asynchronously deferred\n* but called in the minimum time possible.\n*\n* @method\n* @memberof Popper.Utils\n* @argument {Function} fn\n* @returns {Function}\n*/\nvar debounce = supportsMicroTasks ? microtaskDebounce : taskDebounce;\n\n/**\n * Check if the given variable is a function\n * @method\n * @memberof Popper.Utils\n * @argument {Any} functionToCheck - variable to check\n * @returns {Boolean} answer to: is a function?\n */\nfunction isFunction(functionToCheck) {\n  var getType = {};\n  return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';\n}\n\n/**\n * Get CSS computed property of the given element\n * @method\n * @memberof Popper.Utils\n * @argument {Eement} element\n * @argument {String} property\n */\nfunction getStyleComputedProperty(element, property) {\n  if (element.nodeType !== 1) {\n    return [];\n  }\n  // NOTE: 1 DOM access here\n  var css = getComputedStyle(element, null);\n  return property ? css[property] : css;\n}\n\n/**\n * Returns the parentNode or the host of the element\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @returns {Element} parent\n */\nfunction getParentNode(element) {\n  if (element.nodeName === 'HTML') {\n    return element;\n  }\n  return element.parentNode || element.host;\n}\n\n/**\n * Returns the scrolling parent of the given element\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @returns {Element} scroll parent\n */\nfunction getScrollParent(element) {\n  // Return body, `getScroll` will take care to get the correct `scrollTop` from it\n  if (!element) {\n    return document.body;\n  }\n\n  switch (element.nodeName) {\n    case 'HTML':\n    case 'BODY':\n      return element.ownerDocument.body;\n    case '#document':\n      return element.body;\n  }\n\n  // Firefox want us to check `-x` and `-y` variations as well\n\n  var _getStyleComputedProp = getStyleComputedProperty(element),\n      overflow = _getStyleComputedProp.overflow,\n      overflowX = _getStyleComputedProp.overflowX,\n      overflowY = _getStyleComputedProp.overflowY;\n\n  if (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {\n    return element;\n  }\n\n  return getScrollParent(getParentNode(element));\n}\n\nvar isIE11 = isBrowser && !!(window.MSInputMethodContext && document.documentMode);\nvar isIE10 = isBrowser && /MSIE 10/.test(navigator.userAgent);\n\n/**\n * Determines if the browser is Internet Explorer\n * @method\n * @memberof Popper.Utils\n * @param {Number} version to check\n * @returns {Boolean} isIE\n */\nfunction isIE(version) {\n  if (version === 11) {\n    return isIE11;\n  }\n  if (version === 10) {\n    return isIE10;\n  }\n  return isIE11 || isIE10;\n}\n\n/**\n * Returns the offset parent of the given element\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @returns {Element} offset parent\n */\nfunction getOffsetParent(element) {\n  if (!element) {\n    return document.documentElement;\n  }\n\n  var noOffsetParent = isIE(10) ? document.body : null;\n\n  // NOTE: 1 DOM access here\n  var offsetParent = element.offsetParent;\n  // Skip hidden elements which don't have an offsetParent\n  while (offsetParent === noOffsetParent && element.nextElementSibling) {\n    offsetParent = (element = element.nextElementSibling).offsetParent;\n  }\n\n  var nodeName = offsetParent && offsetParent.nodeName;\n\n  if (!nodeName || nodeName === 'BODY' || nodeName === 'HTML') {\n    return element ? element.ownerDocument.documentElement : document.documentElement;\n  }\n\n  // .offsetParent will return the closest TD or TABLE in case\n  // no offsetParent is present, I hate this job...\n  if (['TD', 'TABLE'].indexOf(offsetParent.nodeName) !== -1 && getStyleComputedProperty(offsetParent, 'position') === 'static') {\n    return getOffsetParent(offsetParent);\n  }\n\n  return offsetParent;\n}\n\nfunction isOffsetContainer(element) {\n  var nodeName = element.nodeName;\n\n  if (nodeName === 'BODY') {\n    return false;\n  }\n  return nodeName === 'HTML' || getOffsetParent(element.firstElementChild) === element;\n}\n\n/**\n * Finds the root node (document, shadowDOM root) of the given element\n * @method\n * @memberof Popper.Utils\n * @argument {Element} node\n * @returns {Element} root node\n */\nfunction getRoot(node) {\n  if (node.parentNode !== null) {\n    return getRoot(node.parentNode);\n  }\n\n  return node;\n}\n\n/**\n * Finds the offset parent common to the two provided nodes\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element1\n * @argument {Element} element2\n * @returns {Element} common offset parent\n */\nfunction findCommonOffsetParent(element1, element2) {\n  // This check is needed to avoid errors in case one of the elements isn't defined for any reason\n  if (!element1 || !element1.nodeType || !element2 || !element2.nodeType) {\n    return document.documentElement;\n  }\n\n  // Here we make sure to give as \"start\" the element that comes first in the DOM\n  var order = element1.compareDocumentPosition(element2) & Node.DOCUMENT_POSITION_FOLLOWING;\n  var start = order ? element1 : element2;\n  var end = order ? element2 : element1;\n\n  // Get common ancestor container\n  var range = document.createRange();\n  range.setStart(start, 0);\n  range.setEnd(end, 0);\n  var commonAncestorContainer = range.commonAncestorContainer;\n\n  // Both nodes are inside #document\n\n  if (element1 !== commonAncestorContainer && element2 !== commonAncestorContainer || start.contains(end)) {\n    if (isOffsetContainer(commonAncestorContainer)) {\n      return commonAncestorContainer;\n    }\n\n    return getOffsetParent(commonAncestorContainer);\n  }\n\n  // one of the nodes is inside shadowDOM, find which one\n  var element1root = getRoot(element1);\n  if (element1root.host) {\n    return findCommonOffsetParent(element1root.host, element2);\n  } else {\n    return findCommonOffsetParent(element1, getRoot(element2).host);\n  }\n}\n\n/**\n * Gets the scroll value of the given element in the given side (top and left)\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @argument {String} side `top` or `left`\n * @returns {number} amount of scrolled pixels\n */\nfunction getScroll(element) {\n  var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'top';\n\n  var upperSide = side === 'top' ? 'scrollTop' : 'scrollLeft';\n  var nodeName = element.nodeName;\n\n  if (nodeName === 'BODY' || nodeName === 'HTML') {\n    var html = element.ownerDocument.documentElement;\n    var scrollingElement = element.ownerDocument.scrollingElement || html;\n    return scrollingElement[upperSide];\n  }\n\n  return element[upperSide];\n}\n\n/*\n * Sum or subtract the element scroll values (left and top) from a given rect object\n * @method\n * @memberof Popper.Utils\n * @param {Object} rect - Rect object you want to change\n * @param {HTMLElement} element - The element from the function reads the scroll values\n * @param {Boolean} subtract - set to true if you want to subtract the scroll values\n * @return {Object} rect - The modifier rect object\n */\nfunction includeScroll(rect, element) {\n  var subtract = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n  var scrollTop = getScroll(element, 'top');\n  var scrollLeft = getScroll(element, 'left');\n  var modifier = subtract ? -1 : 1;\n  rect.top += scrollTop * modifier;\n  rect.bottom += scrollTop * modifier;\n  rect.left += scrollLeft * modifier;\n  rect.right += scrollLeft * modifier;\n  return rect;\n}\n\n/*\n * Helper to detect borders of a given element\n * @method\n * @memberof Popper.Utils\n * @param {CSSStyleDeclaration} styles\n * Result of `getStyleComputedProperty` on the given element\n * @param {String} axis - `x` or `y`\n * @return {number} borders - The borders size of the given axis\n */\n\nfunction getBordersSize(styles, axis) {\n  var sideA = axis === 'x' ? 'Left' : 'Top';\n  var sideB = sideA === 'Left' ? 'Right' : 'Bottom';\n\n  return parseFloat(styles['border' + sideA + 'Width'], 10) + parseFloat(styles['border' + sideB + 'Width'], 10);\n}\n\nfunction getSize(axis, body, html, computedStyle) {\n  return Math.max(body['offset' + axis], body['scroll' + axis], html['client' + axis], html['offset' + axis], html['scroll' + axis], isIE(10) ? html['offset' + axis] + computedStyle['margin' + (axis === 'Height' ? 'Top' : 'Left')] + computedStyle['margin' + (axis === 'Height' ? 'Bottom' : 'Right')] : 0);\n}\n\nfunction getWindowSizes() {\n  var body = document.body;\n  var html = document.documentElement;\n  var computedStyle = isIE(10) && getComputedStyle(html);\n\n  return {\n    height: getSize('Height', body, html, computedStyle),\n    width: getSize('Width', body, html, computedStyle)\n  };\n}\n\nvar classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\n\n\n\n\nvar defineProperty = function (obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n};\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\n/**\n * Given element offsets, generate an output similar to getBoundingClientRect\n * @method\n * @memberof Popper.Utils\n * @argument {Object} offsets\n * @returns {Object} ClientRect like output\n */\nfunction getClientRect(offsets) {\n  return _extends({}, offsets, {\n    right: offsets.left + offsets.width,\n    bottom: offsets.top + offsets.height\n  });\n}\n\n/**\n * Get bounding client rect of given element\n * @method\n * @memberof Popper.Utils\n * @param {HTMLElement} element\n * @return {Object} client rect\n */\nfunction getBoundingClientRect(element) {\n  var rect = {};\n\n  // IE10 10 FIX: Please, don't ask, the element isn't\n  // considered in DOM in some circumstances...\n  // This isn't reproducible in IE10 compatibility mode of IE11\n  try {\n    if (isIE(10)) {\n      rect = element.getBoundingClientRect();\n      var scrollTop = getScroll(element, 'top');\n      var scrollLeft = getScroll(element, 'left');\n      rect.top += scrollTop;\n      rect.left += scrollLeft;\n      rect.bottom += scrollTop;\n      rect.right += scrollLeft;\n    } else {\n      rect = element.getBoundingClientRect();\n    }\n  } catch (e) {}\n\n  var result = {\n    left: rect.left,\n    top: rect.top,\n    width: rect.right - rect.left,\n    height: rect.bottom - rect.top\n  };\n\n  // subtract scrollbar size from sizes\n  var sizes = element.nodeName === 'HTML' ? getWindowSizes() : {};\n  var width = sizes.width || element.clientWidth || result.right - result.left;\n  var height = sizes.height || element.clientHeight || result.bottom - result.top;\n\n  var horizScrollbar = element.offsetWidth - width;\n  var vertScrollbar = element.offsetHeight - height;\n\n  // if an hypothetical scrollbar is detected, we must be sure it's not a `border`\n  // we make this check conditional for performance reasons\n  if (horizScrollbar || vertScrollbar) {\n    var styles = getStyleComputedProperty(element);\n    horizScrollbar -= getBordersSize(styles, 'x');\n    vertScrollbar -= getBordersSize(styles, 'y');\n\n    result.width -= horizScrollbar;\n    result.height -= vertScrollbar;\n  }\n\n  return getClientRect(result);\n}\n\nfunction getOffsetRectRelativeToArbitraryNode(children, parent) {\n  var fixedPosition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n  var isIE10 = isIE(10);\n  var isHTML = parent.nodeName === 'HTML';\n  var childrenRect = getBoundingClientRect(children);\n  var parentRect = getBoundingClientRect(parent);\n  var scrollParent = getScrollParent(children);\n\n  var styles = getStyleComputedProperty(parent);\n  var borderTopWidth = parseFloat(styles.borderTopWidth, 10);\n  var borderLeftWidth = parseFloat(styles.borderLeftWidth, 10);\n\n  // In cases where the parent is fixed, we must ignore negative scroll in offset calc\n  if (fixedPosition && parent.nodeName === 'HTML') {\n    parentRect.top = Math.max(parentRect.top, 0);\n    parentRect.left = Math.max(parentRect.left, 0);\n  }\n  var offsets = getClientRect({\n    top: childrenRect.top - parentRect.top - borderTopWidth,\n    left: childrenRect.left - parentRect.left - borderLeftWidth,\n    width: childrenRect.width,\n    height: childrenRect.height\n  });\n  offsets.marginTop = 0;\n  offsets.marginLeft = 0;\n\n  // Subtract margins of documentElement in case it's being used as parent\n  // we do this only on HTML because it's the only element that behaves\n  // differently when margins are applied to it. The margins are included in\n  // the box of the documentElement, in the other cases not.\n  if (!isIE10 && isHTML) {\n    var marginTop = parseFloat(styles.marginTop, 10);\n    var marginLeft = parseFloat(styles.marginLeft, 10);\n\n    offsets.top -= borderTopWidth - marginTop;\n    offsets.bottom -= borderTopWidth - marginTop;\n    offsets.left -= borderLeftWidth - marginLeft;\n    offsets.right -= borderLeftWidth - marginLeft;\n\n    // Attach marginTop and marginLeft because in some circumstances we may need them\n    offsets.marginTop = marginTop;\n    offsets.marginLeft = marginLeft;\n  }\n\n  if (isIE10 && !fixedPosition ? parent.contains(scrollParent) : parent === scrollParent && scrollParent.nodeName !== 'BODY') {\n    offsets = includeScroll(offsets, parent);\n  }\n\n  return offsets;\n}\n\nfunction getViewportOffsetRectRelativeToArtbitraryNode(element) {\n  var excludeScroll = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n  var html = element.ownerDocument.documentElement;\n  var relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);\n  var width = Math.max(html.clientWidth, window.innerWidth || 0);\n  var height = Math.max(html.clientHeight, window.innerHeight || 0);\n\n  var scrollTop = !excludeScroll ? getScroll(html) : 0;\n  var scrollLeft = !excludeScroll ? getScroll(html, 'left') : 0;\n\n  var offset = {\n    top: scrollTop - relativeOffset.top + relativeOffset.marginTop,\n    left: scrollLeft - relativeOffset.left + relativeOffset.marginLeft,\n    width: width,\n    height: height\n  };\n\n  return getClientRect(offset);\n}\n\n/**\n * Check if the given element is fixed or is inside a fixed parent\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @argument {Element} customContainer\n * @returns {Boolean} answer to \"isFixed?\"\n */\nfunction isFixed(element) {\n  var nodeName = element.nodeName;\n  if (nodeName === 'BODY' || nodeName === 'HTML') {\n    return false;\n  }\n  if (getStyleComputedProperty(element, 'position') === 'fixed') {\n    return true;\n  }\n  return isFixed(getParentNode(element));\n}\n\n/**\n * Finds the first parent of an element that has a transformed property defined\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @returns {Element} first transformed parent or documentElement\n */\n\nfunction getFixedPositionOffsetParent(element) {\n  // This check is needed to avoid errors in case one of the elements isn't defined for any reason\n  if (!element || !element.parentElement || isIE()) {\n    return document.documentElement;\n  }\n  var el = element.parentElement;\n  while (el && getStyleComputedProperty(el, 'transform') === 'none') {\n    el = el.parentElement;\n  }\n  return el || document.documentElement;\n}\n\n/**\n * Computed the boundaries limits and return them\n * @method\n * @memberof Popper.Utils\n * @param {HTMLElement} popper\n * @param {HTMLElement} reference\n * @param {number} padding\n * @param {HTMLElement} boundariesElement - Element used to define the boundaries\n * @param {Boolean} fixedPosition - Is in fixed position mode\n * @returns {Object} Coordinates of the boundaries\n */\nfunction getBoundaries(popper, reference, padding, boundariesElement) {\n  var fixedPosition = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n\n  // NOTE: 1 DOM access here\n\n  var boundaries = { top: 0, left: 0 };\n  var offsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, reference);\n\n  // Handle viewport case\n  if (boundariesElement === 'viewport') {\n    boundaries = getViewportOffsetRectRelativeToArtbitraryNode(offsetParent, fixedPosition);\n  } else {\n    // Handle other cases based on DOM element used as boundaries\n    var boundariesNode = void 0;\n    if (boundariesElement === 'scrollParent') {\n      boundariesNode = getScrollParent(getParentNode(reference));\n      if (boundariesNode.nodeName === 'BODY') {\n        boundariesNode = popper.ownerDocument.documentElement;\n      }\n    } else if (boundariesElement === 'window') {\n      boundariesNode = popper.ownerDocument.documentElement;\n    } else {\n      boundariesNode = boundariesElement;\n    }\n\n    var offsets = getOffsetRectRelativeToArbitraryNode(boundariesNode, offsetParent, fixedPosition);\n\n    // In case of HTML, we need a different computation\n    if (boundariesNode.nodeName === 'HTML' && !isFixed(offsetParent)) {\n      var _getWindowSizes = getWindowSizes(),\n          height = _getWindowSizes.height,\n          width = _getWindowSizes.width;\n\n      boundaries.top += offsets.top - offsets.marginTop;\n      boundaries.bottom = height + offsets.top;\n      boundaries.left += offsets.left - offsets.marginLeft;\n      boundaries.right = width + offsets.left;\n    } else {\n      // for all the other DOM elements, this one is good\n      boundaries = offsets;\n    }\n  }\n\n  // Add paddings\n  boundaries.left += padding;\n  boundaries.top += padding;\n  boundaries.right -= padding;\n  boundaries.bottom -= padding;\n\n  return boundaries;\n}\n\nfunction getArea(_ref) {\n  var width = _ref.width,\n      height = _ref.height;\n\n  return width * height;\n}\n\n/**\n * Utility used to transform the `auto` placement to the placement with more\n * available space.\n * @method\n * @memberof Popper.Utils\n * @argument {Object} data - The data object generated by update method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction computeAutoPlacement(placement, refRect, popper, reference, boundariesElement) {\n  var padding = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;\n\n  if (placement.indexOf('auto') === -1) {\n    return placement;\n  }\n\n  var boundaries = getBoundaries(popper, reference, padding, boundariesElement);\n\n  var rects = {\n    top: {\n      width: boundaries.width,\n      height: refRect.top - boundaries.top\n    },\n    right: {\n      width: boundaries.right - refRect.right,\n      height: boundaries.height\n    },\n    bottom: {\n      width: boundaries.width,\n      height: boundaries.bottom - refRect.bottom\n    },\n    left: {\n      width: refRect.left - boundaries.left,\n      height: boundaries.height\n    }\n  };\n\n  var sortedAreas = Object.keys(rects).map(function (key) {\n    return _extends({\n      key: key\n    }, rects[key], {\n      area: getArea(rects[key])\n    });\n  }).sort(function (a, b) {\n    return b.area - a.area;\n  });\n\n  var filteredAreas = sortedAreas.filter(function (_ref2) {\n    var width = _ref2.width,\n        height = _ref2.height;\n    return width >= popper.clientWidth && height >= popper.clientHeight;\n  });\n\n  var computedPlacement = filteredAreas.length > 0 ? filteredAreas[0].key : sortedAreas[0].key;\n\n  var variation = placement.split('-')[1];\n\n  return computedPlacement + (variation ? '-' + variation : '');\n}\n\n/**\n * Get offsets to the reference element\n * @method\n * @memberof Popper.Utils\n * @param {Object} state\n * @param {Element} popper - the popper element\n * @param {Element} reference - the reference element (the popper will be relative to this)\n * @param {Element} fixedPosition - is in fixed position mode\n * @returns {Object} An object containing the offsets which will be applied to the popper\n */\nfunction getReferenceOffsets(state, popper, reference) {\n  var fixedPosition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n\n  var commonOffsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, reference);\n  return getOffsetRectRelativeToArbitraryNode(reference, commonOffsetParent, fixedPosition);\n}\n\n/**\n * Get the outer sizes of the given element (offset size + margins)\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @returns {Object} object containing width and height properties\n */\nfunction getOuterSizes(element) {\n  var styles = getComputedStyle(element);\n  var x = parseFloat(styles.marginTop) + parseFloat(styles.marginBottom);\n  var y = parseFloat(styles.marginLeft) + parseFloat(styles.marginRight);\n  var result = {\n    width: element.offsetWidth + y,\n    height: element.offsetHeight + x\n  };\n  return result;\n}\n\n/**\n * Get the opposite placement of the given one\n * @method\n * @memberof Popper.Utils\n * @argument {String} placement\n * @returns {String} flipped placement\n */\nfunction getOppositePlacement(placement) {\n  var hash = { left: 'right', right: 'left', bottom: 'top', top: 'bottom' };\n  return placement.replace(/left|right|bottom|top/g, function (matched) {\n    return hash[matched];\n  });\n}\n\n/**\n * Get offsets to the popper\n * @method\n * @memberof Popper.Utils\n * @param {Object} position - CSS position the Popper will get applied\n * @param {HTMLElement} popper - the popper element\n * @param {Object} referenceOffsets - the reference offsets (the popper will be relative to this)\n * @param {String} placement - one of the valid placement options\n * @returns {Object} popperOffsets - An object containing the offsets which will be applied to the popper\n */\nfunction getPopperOffsets(popper, referenceOffsets, placement) {\n  placement = placement.split('-')[0];\n\n  // Get popper node sizes\n  var popperRect = getOuterSizes(popper);\n\n  // Add position, width and height to our offsets object\n  var popperOffsets = {\n    width: popperRect.width,\n    height: popperRect.height\n  };\n\n  // depending by the popper placement we have to compute its offsets slightly differently\n  var isHoriz = ['right', 'left'].indexOf(placement) !== -1;\n  var mainSide = isHoriz ? 'top' : 'left';\n  var secondarySide = isHoriz ? 'left' : 'top';\n  var measurement = isHoriz ? 'height' : 'width';\n  var secondaryMeasurement = !isHoriz ? 'height' : 'width';\n\n  popperOffsets[mainSide] = referenceOffsets[mainSide] + referenceOffsets[measurement] / 2 - popperRect[measurement] / 2;\n  if (placement === secondarySide) {\n    popperOffsets[secondarySide] = referenceOffsets[secondarySide] - popperRect[secondaryMeasurement];\n  } else {\n    popperOffsets[secondarySide] = referenceOffsets[getOppositePlacement(secondarySide)];\n  }\n\n  return popperOffsets;\n}\n\n/**\n * Mimics the `find` method of Array\n * @method\n * @memberof Popper.Utils\n * @argument {Array} arr\n * @argument prop\n * @argument value\n * @returns index or -1\n */\nfunction find(arr, check) {\n  // use native find if supported\n  if (Array.prototype.find) {\n    return arr.find(check);\n  }\n\n  // use `filter` to obtain the same behavior of `find`\n  return arr.filter(check)[0];\n}\n\n/**\n * Return the index of the matching object\n * @method\n * @memberof Popper.Utils\n * @argument {Array} arr\n * @argument prop\n * @argument value\n * @returns index or -1\n */\nfunction findIndex(arr, prop, value) {\n  // use native findIndex if supported\n  if (Array.prototype.findIndex) {\n    return arr.findIndex(function (cur) {\n      return cur[prop] === value;\n    });\n  }\n\n  // use `find` + `indexOf` if `findIndex` isn't supported\n  var match = find(arr, function (obj) {\n    return obj[prop] === value;\n  });\n  return arr.indexOf(match);\n}\n\n/**\n * Loop trough the list of modifiers and run them in order,\n * each of them will then edit the data object.\n * @method\n * @memberof Popper.Utils\n * @param {dataObject} data\n * @param {Array} modifiers\n * @param {String} ends - Optional modifier name used as stopper\n * @returns {dataObject}\n */\nfunction runModifiers(modifiers, data, ends) {\n  var modifiersToRun = ends === undefined ? modifiers : modifiers.slice(0, findIndex(modifiers, 'name', ends));\n\n  modifiersToRun.forEach(function (modifier) {\n    if (modifier['function']) {\n      // eslint-disable-line dot-notation\n      console.warn('`modifier.function` is deprecated, use `modifier.fn`!');\n    }\n    var fn = modifier['function'] || modifier.fn; // eslint-disable-line dot-notation\n    if (modifier.enabled && isFunction(fn)) {\n      // Add properties to offsets to make them a complete clientRect object\n      // we do this before each modifier to make sure the previous one doesn't\n      // mess with these values\n      data.offsets.popper = getClientRect(data.offsets.popper);\n      data.offsets.reference = getClientRect(data.offsets.reference);\n\n      data = fn(data, modifier);\n    }\n  });\n\n  return data;\n}\n\n/**\n * Updates the position of the popper, computing the new offsets and applying\n * the new style.<br />\n * Prefer `scheduleUpdate` over `update` because of performance reasons.\n * @method\n * @memberof Popper\n */\nfunction update() {\n  // if popper is destroyed, don't perform any further update\n  if (this.state.isDestroyed) {\n    return;\n  }\n\n  var data = {\n    instance: this,\n    styles: {},\n    arrowStyles: {},\n    attributes: {},\n    flipped: false,\n    offsets: {}\n  };\n\n  // compute reference element offsets\n  data.offsets.reference = getReferenceOffsets(this.state, this.popper, this.reference, this.options.positionFixed);\n\n  // compute auto placement, store placement inside the data object,\n  // modifiers will be able to edit `placement` if needed\n  // and refer to originalPlacement to know the original value\n  data.placement = computeAutoPlacement(this.options.placement, data.offsets.reference, this.popper, this.reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding);\n\n  // store the computed placement inside `originalPlacement`\n  data.originalPlacement = data.placement;\n\n  data.positionFixed = this.options.positionFixed;\n\n  // compute the popper offsets\n  data.offsets.popper = getPopperOffsets(this.popper, data.offsets.reference, data.placement);\n\n  data.offsets.popper.position = this.options.positionFixed ? 'fixed' : 'absolute';\n\n  // run the modifiers\n  data = runModifiers(this.modifiers, data);\n\n  // the first `update` will call `onCreate` callback\n  // the other ones will call `onUpdate` callback\n  if (!this.state.isCreated) {\n    this.state.isCreated = true;\n    this.options.onCreate(data);\n  } else {\n    this.options.onUpdate(data);\n  }\n}\n\n/**\n * Helper used to know if the given modifier is enabled.\n * @method\n * @memberof Popper.Utils\n * @returns {Boolean}\n */\nfunction isModifierEnabled(modifiers, modifierName) {\n  return modifiers.some(function (_ref) {\n    var name = _ref.name,\n        enabled = _ref.enabled;\n    return enabled && name === modifierName;\n  });\n}\n\n/**\n * Get the prefixed supported property name\n * @method\n * @memberof Popper.Utils\n * @argument {String} property (camelCase)\n * @returns {String} prefixed property (camelCase or PascalCase, depending on the vendor prefix)\n */\nfunction getSupportedPropertyName(property) {\n  var prefixes = [false, 'ms', 'Webkit', 'Moz', 'O'];\n  var upperProp = property.charAt(0).toUpperCase() + property.slice(1);\n\n  for (var i = 0; i < prefixes.length; i++) {\n    var prefix = prefixes[i];\n    var toCheck = prefix ? '' + prefix + upperProp : property;\n    if (typeof document.body.style[toCheck] !== 'undefined') {\n      return toCheck;\n    }\n  }\n  return null;\n}\n\n/**\n * Destroy the popper\n * @method\n * @memberof Popper\n */\nfunction destroy() {\n  this.state.isDestroyed = true;\n\n  // touch DOM only if `applyStyle` modifier is enabled\n  if (isModifierEnabled(this.modifiers, 'applyStyle')) {\n    this.popper.removeAttribute('x-placement');\n    this.popper.style.position = '';\n    this.popper.style.top = '';\n    this.popper.style.left = '';\n    this.popper.style.right = '';\n    this.popper.style.bottom = '';\n    this.popper.style.willChange = '';\n    this.popper.style[getSupportedPropertyName('transform')] = '';\n  }\n\n  this.disableEventListeners();\n\n  // remove the popper if user explicity asked for the deletion on destroy\n  // do not use `remove` because IE11 doesn't support it\n  if (this.options.removeOnDestroy) {\n    this.popper.parentNode.removeChild(this.popper);\n  }\n  return this;\n}\n\n/**\n * Get the window associated with the element\n * @argument {Element} element\n * @returns {Window}\n */\nfunction getWindow(element) {\n  var ownerDocument = element.ownerDocument;\n  return ownerDocument ? ownerDocument.defaultView : window;\n}\n\nfunction attachToScrollParents(scrollParent, event, callback, scrollParents) {\n  var isBody = scrollParent.nodeName === 'BODY';\n  var target = isBody ? scrollParent.ownerDocument.defaultView : scrollParent;\n  target.addEventListener(event, callback, { passive: true });\n\n  if (!isBody) {\n    attachToScrollParents(getScrollParent(target.parentNode), event, callback, scrollParents);\n  }\n  scrollParents.push(target);\n}\n\n/**\n * Setup needed event listeners used to update the popper position\n * @method\n * @memberof Popper.Utils\n * @private\n */\nfunction setupEventListeners(reference, options, state, updateBound) {\n  // Resize event listener on window\n  state.updateBound = updateBound;\n  getWindow(reference).addEventListener('resize', state.updateBound, { passive: true });\n\n  // Scroll event listener on scroll parents\n  var scrollElement = getScrollParent(reference);\n  attachToScrollParents(scrollElement, 'scroll', state.updateBound, state.scrollParents);\n  state.scrollElement = scrollElement;\n  state.eventsEnabled = true;\n\n  return state;\n}\n\n/**\n * It will add resize/scroll events and start recalculating\n * position of the popper element when they are triggered.\n * @method\n * @memberof Popper\n */\nfunction enableEventListeners() {\n  if (!this.state.eventsEnabled) {\n    this.state = setupEventListeners(this.reference, this.options, this.state, this.scheduleUpdate);\n  }\n}\n\n/**\n * Remove event listeners used to update the popper position\n * @method\n * @memberof Popper.Utils\n * @private\n */\nfunction removeEventListeners(reference, state) {\n  // Remove resize event listener on window\n  getWindow(reference).removeEventListener('resize', state.updateBound);\n\n  // Remove scroll event listener on scroll parents\n  state.scrollParents.forEach(function (target) {\n    target.removeEventListener('scroll', state.updateBound);\n  });\n\n  // Reset state\n  state.updateBound = null;\n  state.scrollParents = [];\n  state.scrollElement = null;\n  state.eventsEnabled = false;\n  return state;\n}\n\n/**\n * It will remove resize/scroll events and won't recalculate popper position\n * when they are triggered. It also won't trigger onUpdate callback anymore,\n * unless you call `update` method manually.\n * @method\n * @memberof Popper\n */\nfunction disableEventListeners() {\n  if (this.state.eventsEnabled) {\n    cancelAnimationFrame(this.scheduleUpdate);\n    this.state = removeEventListeners(this.reference, this.state);\n  }\n}\n\n/**\n * Tells if a given input is a number\n * @method\n * @memberof Popper.Utils\n * @param {*} input to check\n * @return {Boolean}\n */\nfunction isNumeric(n) {\n  return n !== '' && !isNaN(parseFloat(n)) && isFinite(n);\n}\n\n/**\n * Set the style to the given popper\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element - Element to apply the style to\n * @argument {Object} styles\n * Object with a list of properties and values which will be applied to the element\n */\nfunction setStyles(element, styles) {\n  Object.keys(styles).forEach(function (prop) {\n    var unit = '';\n    // add unit if the value is numeric and is one of the following\n    if (['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop) !== -1 && isNumeric(styles[prop])) {\n      unit = 'px';\n    }\n    element.style[prop] = styles[prop] + unit;\n  });\n}\n\n/**\n * Set the attributes to the given popper\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element - Element to apply the attributes to\n * @argument {Object} styles\n * Object with a list of properties and values which will be applied to the element\n */\nfunction setAttributes(element, attributes) {\n  Object.keys(attributes).forEach(function (prop) {\n    var value = attributes[prop];\n    if (value !== false) {\n      element.setAttribute(prop, attributes[prop]);\n    } else {\n      element.removeAttribute(prop);\n    }\n  });\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by `update` method\n * @argument {Object} data.styles - List of style properties - values to apply to popper element\n * @argument {Object} data.attributes - List of attribute properties - values to apply to popper element\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The same data object\n */\nfunction applyStyle(data) {\n  // any property present in `data.styles` will be applied to the popper,\n  // in this way we can make the 3rd party modifiers add custom styles to it\n  // Be aware, modifiers could override the properties defined in the previous\n  // lines of this modifier!\n  setStyles(data.instance.popper, data.styles);\n\n  // any property present in `data.attributes` will be applied to the popper,\n  // they will be set as HTML attributes of the element\n  setAttributes(data.instance.popper, data.attributes);\n\n  // if arrowElement is defined and arrowStyles has some properties\n  if (data.arrowElement && Object.keys(data.arrowStyles).length) {\n    setStyles(data.arrowElement, data.arrowStyles);\n  }\n\n  return data;\n}\n\n/**\n * Set the x-placement attribute before everything else because it could be used\n * to add margins to the popper margins needs to be calculated to get the\n * correct popper offsets.\n * @method\n * @memberof Popper.modifiers\n * @param {HTMLElement} reference - The reference element used to position the popper\n * @param {HTMLElement} popper - The HTML element used as popper\n * @param {Object} options - Popper.js options\n */\nfunction applyStyleOnLoad(reference, popper, options, modifierOptions, state) {\n  // compute reference element offsets\n  var referenceOffsets = getReferenceOffsets(state, popper, reference, options.positionFixed);\n\n  // compute auto placement, store placement inside the data object,\n  // modifiers will be able to edit `placement` if needed\n  // and refer to originalPlacement to know the original value\n  var placement = computeAutoPlacement(options.placement, referenceOffsets, popper, reference, options.modifiers.flip.boundariesElement, options.modifiers.flip.padding);\n\n  popper.setAttribute('x-placement', placement);\n\n  // Apply `position` to popper before anything else because\n  // without the position applied we can't guarantee correct computations\n  setStyles(popper, { position: options.positionFixed ? 'fixed' : 'absolute' });\n\n  return options;\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by `update` method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction computeStyle(data, options) {\n  var x = options.x,\n      y = options.y;\n  var popper = data.offsets.popper;\n\n  // Remove this legacy support in Popper.js v2\n\n  var legacyGpuAccelerationOption = find(data.instance.modifiers, function (modifier) {\n    return modifier.name === 'applyStyle';\n  }).gpuAcceleration;\n  if (legacyGpuAccelerationOption !== undefined) {\n    console.warn('WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!');\n  }\n  var gpuAcceleration = legacyGpuAccelerationOption !== undefined ? legacyGpuAccelerationOption : options.gpuAcceleration;\n\n  var offsetParent = getOffsetParent(data.instance.popper);\n  var offsetParentRect = getBoundingClientRect(offsetParent);\n\n  // Styles\n  var styles = {\n    position: popper.position\n  };\n\n  // Avoid blurry text by using full pixel integers.\n  // For pixel-perfect positioning, top/bottom prefers rounded\n  // values, while left/right prefers floored values.\n  var offsets = {\n    left: Math.floor(popper.left),\n    top: Math.round(popper.top),\n    bottom: Math.round(popper.bottom),\n    right: Math.floor(popper.right)\n  };\n\n  var sideA = x === 'bottom' ? 'top' : 'bottom';\n  var sideB = y === 'right' ? 'left' : 'right';\n\n  // if gpuAcceleration is set to `true` and transform is supported,\n  //  we use `translate3d` to apply the position to the popper we\n  // automatically use the supported prefixed version if needed\n  var prefixedProperty = getSupportedPropertyName('transform');\n\n  // now, let's make a step back and look at this code closely (wtf?)\n  // If the content of the popper grows once it's been positioned, it\n  // may happen that the popper gets misplaced because of the new content\n  // overflowing its reference element\n  // To avoid this problem, we provide two options (x and y), which allow\n  // the consumer to define the offset origin.\n  // If we position a popper on top of a reference element, we can set\n  // `x` to `top` to make the popper grow towards its top instead of\n  // its bottom.\n  var left = void 0,\n      top = void 0;\n  if (sideA === 'bottom') {\n    top = -offsetParentRect.height + offsets.bottom;\n  } else {\n    top = offsets.top;\n  }\n  if (sideB === 'right') {\n    left = -offsetParentRect.width + offsets.right;\n  } else {\n    left = offsets.left;\n  }\n  if (gpuAcceleration && prefixedProperty) {\n    styles[prefixedProperty] = 'translate3d(' + left + 'px, ' + top + 'px, 0)';\n    styles[sideA] = 0;\n    styles[sideB] = 0;\n    styles.willChange = 'transform';\n  } else {\n    // othwerise, we use the standard `top`, `left`, `bottom` and `right` properties\n    var invertTop = sideA === 'bottom' ? -1 : 1;\n    var invertLeft = sideB === 'right' ? -1 : 1;\n    styles[sideA] = top * invertTop;\n    styles[sideB] = left * invertLeft;\n    styles.willChange = sideA + ', ' + sideB;\n  }\n\n  // Attributes\n  var attributes = {\n    'x-placement': data.placement\n  };\n\n  // Update `data` attributes, styles and arrowStyles\n  data.attributes = _extends({}, attributes, data.attributes);\n  data.styles = _extends({}, styles, data.styles);\n  data.arrowStyles = _extends({}, data.offsets.arrow, data.arrowStyles);\n\n  return data;\n}\n\n/**\n * Helper used to know if the given modifier depends from another one.<br />\n * It checks if the needed modifier is listed and enabled.\n * @method\n * @memberof Popper.Utils\n * @param {Array} modifiers - list of modifiers\n * @param {String} requestingName - name of requesting modifier\n * @param {String} requestedName - name of requested modifier\n * @returns {Boolean}\n */\nfunction isModifierRequired(modifiers, requestingName, requestedName) {\n  var requesting = find(modifiers, function (_ref) {\n    var name = _ref.name;\n    return name === requestingName;\n  });\n\n  var isRequired = !!requesting && modifiers.some(function (modifier) {\n    return modifier.name === requestedName && modifier.enabled && modifier.order < requesting.order;\n  });\n\n  if (!isRequired) {\n    var _requesting = '`' + requestingName + '`';\n    var requested = '`' + requestedName + '`';\n    console.warn(requested + ' modifier is required by ' + _requesting + ' modifier in order to work, be sure to include it before ' + _requesting + '!');\n  }\n  return isRequired;\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by update method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction arrow(data, options) {\n  var _data$offsets$arrow;\n\n  // arrow depends on keepTogether in order to work\n  if (!isModifierRequired(data.instance.modifiers, 'arrow', 'keepTogether')) {\n    return data;\n  }\n\n  var arrowElement = options.element;\n\n  // if arrowElement is a string, suppose it's a CSS selector\n  if (typeof arrowElement === 'string') {\n    arrowElement = data.instance.popper.querySelector(arrowElement);\n\n    // if arrowElement is not found, don't run the modifier\n    if (!arrowElement) {\n      return data;\n    }\n  } else {\n    // if the arrowElement isn't a query selector we must check that the\n    // provided DOM node is child of its popper node\n    if (!data.instance.popper.contains(arrowElement)) {\n      console.warn('WARNING: `arrow.element` must be child of its popper element!');\n      return data;\n    }\n  }\n\n  var placement = data.placement.split('-')[0];\n  var _data$offsets = data.offsets,\n      popper = _data$offsets.popper,\n      reference = _data$offsets.reference;\n\n  var isVertical = ['left', 'right'].indexOf(placement) !== -1;\n\n  var len = isVertical ? 'height' : 'width';\n  var sideCapitalized = isVertical ? 'Top' : 'Left';\n  var side = sideCapitalized.toLowerCase();\n  var altSide = isVertical ? 'left' : 'top';\n  var opSide = isVertical ? 'bottom' : 'right';\n  var arrowElementSize = getOuterSizes(arrowElement)[len];\n\n  //\n  // extends keepTogether behavior making sure the popper and its\n  // reference have enough pixels in conjuction\n  //\n\n  // top/left side\n  if (reference[opSide] - arrowElementSize < popper[side]) {\n    data.offsets.popper[side] -= popper[side] - (reference[opSide] - arrowElementSize);\n  }\n  // bottom/right side\n  if (reference[side] + arrowElementSize > popper[opSide]) {\n    data.offsets.popper[side] += reference[side] + arrowElementSize - popper[opSide];\n  }\n  data.offsets.popper = getClientRect(data.offsets.popper);\n\n  // compute center of the popper\n  var center = reference[side] + reference[len] / 2 - arrowElementSize / 2;\n\n  // Compute the sideValue using the updated popper offsets\n  // take popper margin in account because we don't have this info available\n  var css = getStyleComputedProperty(data.instance.popper);\n  var popperMarginSide = parseFloat(css['margin' + sideCapitalized], 10);\n  var popperBorderSide = parseFloat(css['border' + sideCapitalized + 'Width'], 10);\n  var sideValue = center - data.offsets.popper[side] - popperMarginSide - popperBorderSide;\n\n  // prevent arrowElement from being placed not contiguously to its popper\n  sideValue = Math.max(Math.min(popper[len] - arrowElementSize, sideValue), 0);\n\n  data.arrowElement = arrowElement;\n  data.offsets.arrow = (_data$offsets$arrow = {}, defineProperty(_data$offsets$arrow, side, Math.round(sideValue)), defineProperty(_data$offsets$arrow, altSide, ''), _data$offsets$arrow);\n\n  return data;\n}\n\n/**\n * Get the opposite placement variation of the given one\n * @method\n * @memberof Popper.Utils\n * @argument {String} placement variation\n * @returns {String} flipped placement variation\n */\nfunction getOppositeVariation(variation) {\n  if (variation === 'end') {\n    return 'start';\n  } else if (variation === 'start') {\n    return 'end';\n  }\n  return variation;\n}\n\n/**\n * List of accepted placements to use as values of the `placement` option.<br />\n * Valid placements are:\n * - `auto`\n * - `top`\n * - `right`\n * - `bottom`\n * - `left`\n *\n * Each placement can have a variation from this list:\n * - `-start`\n * - `-end`\n *\n * Variations are interpreted easily if you think of them as the left to right\n * written languages. Horizontally (`top` and `bottom`), `start` is left and `end`\n * is right.<br />\n * Vertically (`left` and `right`), `start` is top and `end` is bottom.\n *\n * Some valid examples are:\n * - `top-end` (on top of reference, right aligned)\n * - `right-start` (on right of reference, top aligned)\n * - `bottom` (on bottom, centered)\n * - `auto-right` (on the side with more space available, alignment depends by placement)\n *\n * @static\n * @type {Array}\n * @enum {String}\n * @readonly\n * @method placements\n * @memberof Popper\n */\nvar placements = ['auto-start', 'auto', 'auto-end', 'top-start', 'top', 'top-end', 'right-start', 'right', 'right-end', 'bottom-end', 'bottom', 'bottom-start', 'left-end', 'left', 'left-start'];\n\n// Get rid of `auto` `auto-start` and `auto-end`\nvar validPlacements = placements.slice(3);\n\n/**\n * Given an initial placement, returns all the subsequent placements\n * clockwise (or counter-clockwise).\n *\n * @method\n * @memberof Popper.Utils\n * @argument {String} placement - A valid placement (it accepts variations)\n * @argument {Boolean} counter - Set to true to walk the placements counterclockwise\n * @returns {Array} placements including their variations\n */\nfunction clockwise(placement) {\n  var counter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n  var index = validPlacements.indexOf(placement);\n  var arr = validPlacements.slice(index + 1).concat(validPlacements.slice(0, index));\n  return counter ? arr.reverse() : arr;\n}\n\nvar BEHAVIORS = {\n  FLIP: 'flip',\n  CLOCKWISE: 'clockwise',\n  COUNTERCLOCKWISE: 'counterclockwise'\n};\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by update method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction flip(data, options) {\n  // if `inner` modifier is enabled, we can't use the `flip` modifier\n  if (isModifierEnabled(data.instance.modifiers, 'inner')) {\n    return data;\n  }\n\n  if (data.flipped && data.placement === data.originalPlacement) {\n    // seems like flip is trying to loop, probably there's not enough space on any of the flippable sides\n    return data;\n  }\n\n  var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, options.boundariesElement, data.positionFixed);\n\n  var placement = data.placement.split('-')[0];\n  var placementOpposite = getOppositePlacement(placement);\n  var variation = data.placement.split('-')[1] || '';\n\n  var flipOrder = [];\n\n  switch (options.behavior) {\n    case BEHAVIORS.FLIP:\n      flipOrder = [placement, placementOpposite];\n      break;\n    case BEHAVIORS.CLOCKWISE:\n      flipOrder = clockwise(placement);\n      break;\n    case BEHAVIORS.COUNTERCLOCKWISE:\n      flipOrder = clockwise(placement, true);\n      break;\n    default:\n      flipOrder = options.behavior;\n  }\n\n  flipOrder.forEach(function (step, index) {\n    if (placement !== step || flipOrder.length === index + 1) {\n      return data;\n    }\n\n    placement = data.placement.split('-')[0];\n    placementOpposite = getOppositePlacement(placement);\n\n    var popperOffsets = data.offsets.popper;\n    var refOffsets = data.offsets.reference;\n\n    // using floor because the reference offsets may contain decimals we are not going to consider here\n    var floor = Math.floor;\n    var overlapsRef = placement === 'left' && floor(popperOffsets.right) > floor(refOffsets.left) || placement === 'right' && floor(popperOffsets.left) < floor(refOffsets.right) || placement === 'top' && floor(popperOffsets.bottom) > floor(refOffsets.top) || placement === 'bottom' && floor(popperOffsets.top) < floor(refOffsets.bottom);\n\n    var overflowsLeft = floor(popperOffsets.left) < floor(boundaries.left);\n    var overflowsRight = floor(popperOffsets.right) > floor(boundaries.right);\n    var overflowsTop = floor(popperOffsets.top) < floor(boundaries.top);\n    var overflowsBottom = floor(popperOffsets.bottom) > floor(boundaries.bottom);\n\n    var overflowsBoundaries = placement === 'left' && overflowsLeft || placement === 'right' && overflowsRight || placement === 'top' && overflowsTop || placement === 'bottom' && overflowsBottom;\n\n    // flip the variation if required\n    var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;\n    var flippedVariation = !!options.flipVariations && (isVertical && variation === 'start' && overflowsLeft || isVertical && variation === 'end' && overflowsRight || !isVertical && variation === 'start' && overflowsTop || !isVertical && variation === 'end' && overflowsBottom);\n\n    if (overlapsRef || overflowsBoundaries || flippedVariation) {\n      // this boolean to detect any flip loop\n      data.flipped = true;\n\n      if (overlapsRef || overflowsBoundaries) {\n        placement = flipOrder[index + 1];\n      }\n\n      if (flippedVariation) {\n        variation = getOppositeVariation(variation);\n      }\n\n      data.placement = placement + (variation ? '-' + variation : '');\n\n      // this object contains `position`, we want to preserve it along with\n      // any additional property we may add in the future\n      data.offsets.popper = _extends({}, data.offsets.popper, getPopperOffsets(data.instance.popper, data.offsets.reference, data.placement));\n\n      data = runModifiers(data.instance.modifiers, data, 'flip');\n    }\n  });\n  return data;\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by update method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction keepTogether(data) {\n  var _data$offsets = data.offsets,\n      popper = _data$offsets.popper,\n      reference = _data$offsets.reference;\n\n  var placement = data.placement.split('-')[0];\n  var floor = Math.floor;\n  var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;\n  var side = isVertical ? 'right' : 'bottom';\n  var opSide = isVertical ? 'left' : 'top';\n  var measurement = isVertical ? 'width' : 'height';\n\n  if (popper[side] < floor(reference[opSide])) {\n    data.offsets.popper[opSide] = floor(reference[opSide]) - popper[measurement];\n  }\n  if (popper[opSide] > floor(reference[side])) {\n    data.offsets.popper[opSide] = floor(reference[side]);\n  }\n\n  return data;\n}\n\n/**\n * Converts a string containing value + unit into a px value number\n * @function\n * @memberof {modifiers~offset}\n * @private\n * @argument {String} str - Value + unit string\n * @argument {String} measurement - `height` or `width`\n * @argument {Object} popperOffsets\n * @argument {Object} referenceOffsets\n * @returns {Number|String}\n * Value in pixels, or original string if no values were extracted\n */\nfunction toValue(str, measurement, popperOffsets, referenceOffsets) {\n  // separate value from unit\n  var split = str.match(/((?:\\-|\\+)?\\d*\\.?\\d*)(.*)/);\n  var value = +split[1];\n  var unit = split[2];\n\n  // If it's not a number it's an operator, I guess\n  if (!value) {\n    return str;\n  }\n\n  if (unit.indexOf('%') === 0) {\n    var element = void 0;\n    switch (unit) {\n      case '%p':\n        element = popperOffsets;\n        break;\n      case '%':\n      case '%r':\n      default:\n        element = referenceOffsets;\n    }\n\n    var rect = getClientRect(element);\n    return rect[measurement] / 100 * value;\n  } else if (unit === 'vh' || unit === 'vw') {\n    // if is a vh or vw, we calculate the size based on the viewport\n    var size = void 0;\n    if (unit === 'vh') {\n      size = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);\n    } else {\n      size = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);\n    }\n    return size / 100 * value;\n  } else {\n    // if is an explicit pixel unit, we get rid of the unit and keep the value\n    // if is an implicit unit, it's px, and we return just the value\n    return value;\n  }\n}\n\n/**\n * Parse an `offset` string to extrapolate `x` and `y` numeric offsets.\n * @function\n * @memberof {modifiers~offset}\n * @private\n * @argument {String} offset\n * @argument {Object} popperOffsets\n * @argument {Object} referenceOffsets\n * @argument {String} basePlacement\n * @returns {Array} a two cells array with x and y offsets in numbers\n */\nfunction parseOffset(offset, popperOffsets, referenceOffsets, basePlacement) {\n  var offsets = [0, 0];\n\n  // Use height if placement is left or right and index is 0 otherwise use width\n  // in this way the first offset will use an axis and the second one\n  // will use the other one\n  var useHeight = ['right', 'left'].indexOf(basePlacement) !== -1;\n\n  // Split the offset string to obtain a list of values and operands\n  // The regex addresses values with the plus or minus sign in front (+10, -20, etc)\n  var fragments = offset.split(/(\\+|\\-)/).map(function (frag) {\n    return frag.trim();\n  });\n\n  // Detect if the offset string contains a pair of values or a single one\n  // they could be separated by comma or space\n  var divider = fragments.indexOf(find(fragments, function (frag) {\n    return frag.search(/,|\\s/) !== -1;\n  }));\n\n  if (fragments[divider] && fragments[divider].indexOf(',') === -1) {\n    console.warn('Offsets separated by white space(s) are deprecated, use a comma (,) instead.');\n  }\n\n  // If divider is found, we divide the list of values and operands to divide\n  // them by ofset X and Y.\n  var splitRegex = /\\s*,\\s*|\\s+/;\n  var ops = divider !== -1 ? [fragments.slice(0, divider).concat([fragments[divider].split(splitRegex)[0]]), [fragments[divider].split(splitRegex)[1]].concat(fragments.slice(divider + 1))] : [fragments];\n\n  // Convert the values with units to absolute pixels to allow our computations\n  ops = ops.map(function (op, index) {\n    // Most of the units rely on the orientation of the popper\n    var measurement = (index === 1 ? !useHeight : useHeight) ? 'height' : 'width';\n    var mergeWithPrevious = false;\n    return op\n    // This aggregates any `+` or `-` sign that aren't considered operators\n    // e.g.: 10 + +5 => [10, +, +5]\n    .reduce(function (a, b) {\n      if (a[a.length - 1] === '' && ['+', '-'].indexOf(b) !== -1) {\n        a[a.length - 1] = b;\n        mergeWithPrevious = true;\n        return a;\n      } else if (mergeWithPrevious) {\n        a[a.length - 1] += b;\n        mergeWithPrevious = false;\n        return a;\n      } else {\n        return a.concat(b);\n      }\n    }, [])\n    // Here we convert the string values into number values (in px)\n    .map(function (str) {\n      return toValue(str, measurement, popperOffsets, referenceOffsets);\n    });\n  });\n\n  // Loop trough the offsets arrays and execute the operations\n  ops.forEach(function (op, index) {\n    op.forEach(function (frag, index2) {\n      if (isNumeric(frag)) {\n        offsets[index] += frag * (op[index2 - 1] === '-' ? -1 : 1);\n      }\n    });\n  });\n  return offsets;\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by update method\n * @argument {Object} options - Modifiers configuration and options\n * @argument {Number|String} options.offset=0\n * The offset value as described in the modifier description\n * @returns {Object} The data object, properly modified\n */\nfunction offset(data, _ref) {\n  var offset = _ref.offset;\n  var placement = data.placement,\n      _data$offsets = data.offsets,\n      popper = _data$offsets.popper,\n      reference = _data$offsets.reference;\n\n  var basePlacement = placement.split('-')[0];\n\n  var offsets = void 0;\n  if (isNumeric(+offset)) {\n    offsets = [+offset, 0];\n  } else {\n    offsets = parseOffset(offset, popper, reference, basePlacement);\n  }\n\n  if (basePlacement === 'left') {\n    popper.top += offsets[0];\n    popper.left -= offsets[1];\n  } else if (basePlacement === 'right') {\n    popper.top += offsets[0];\n    popper.left += offsets[1];\n  } else if (basePlacement === 'top') {\n    popper.left += offsets[0];\n    popper.top -= offsets[1];\n  } else if (basePlacement === 'bottom') {\n    popper.left += offsets[0];\n    popper.top += offsets[1];\n  }\n\n  data.popper = popper;\n  return data;\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by `update` method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction preventOverflow(data, options) {\n  var boundariesElement = options.boundariesElement || getOffsetParent(data.instance.popper);\n\n  // If offsetParent is the reference element, we really want to\n  // go one step up and use the next offsetParent as reference to\n  // avoid to make this modifier completely useless and look like broken\n  if (data.instance.reference === boundariesElement) {\n    boundariesElement = getOffsetParent(boundariesElement);\n  }\n\n  // NOTE: DOM access here\n  // resets the popper's position so that the document size can be calculated excluding\n  // the size of the popper element itself\n  var transformProp = getSupportedPropertyName('transform');\n  var popperStyles = data.instance.popper.style; // assignment to help minification\n  var top = popperStyles.top,\n      left = popperStyles.left,\n      transform = popperStyles[transformProp];\n\n  popperStyles.top = '';\n  popperStyles.left = '';\n  popperStyles[transformProp] = '';\n\n  var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, boundariesElement, data.positionFixed);\n\n  // NOTE: DOM access here\n  // restores the original style properties after the offsets have been computed\n  popperStyles.top = top;\n  popperStyles.left = left;\n  popperStyles[transformProp] = transform;\n\n  options.boundaries = boundaries;\n\n  var order = options.priority;\n  var popper = data.offsets.popper;\n\n  var check = {\n    primary: function primary(placement) {\n      var value = popper[placement];\n      if (popper[placement] < boundaries[placement] && !options.escapeWithReference) {\n        value = Math.max(popper[placement], boundaries[placement]);\n      }\n      return defineProperty({}, placement, value);\n    },\n    secondary: function secondary(placement) {\n      var mainSide = placement === 'right' ? 'left' : 'top';\n      var value = popper[mainSide];\n      if (popper[placement] > boundaries[placement] && !options.escapeWithReference) {\n        value = Math.min(popper[mainSide], boundaries[placement] - (placement === 'right' ? popper.width : popper.height));\n      }\n      return defineProperty({}, mainSide, value);\n    }\n  };\n\n  order.forEach(function (placement) {\n    var side = ['left', 'top'].indexOf(placement) !== -1 ? 'primary' : 'secondary';\n    popper = _extends({}, popper, check[side](placement));\n  });\n\n  data.offsets.popper = popper;\n\n  return data;\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by `update` method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction shift(data) {\n  var placement = data.placement;\n  var basePlacement = placement.split('-')[0];\n  var shiftvariation = placement.split('-')[1];\n\n  // if shift shiftvariation is specified, run the modifier\n  if (shiftvariation) {\n    var _data$offsets = data.offsets,\n        reference = _data$offsets.reference,\n        popper = _data$offsets.popper;\n\n    var isVertical = ['bottom', 'top'].indexOf(basePlacement) !== -1;\n    var side = isVertical ? 'left' : 'top';\n    var measurement = isVertical ? 'width' : 'height';\n\n    var shiftOffsets = {\n      start: defineProperty({}, side, reference[side]),\n      end: defineProperty({}, side, reference[side] + reference[measurement] - popper[measurement])\n    };\n\n    data.offsets.popper = _extends({}, popper, shiftOffsets[shiftvariation]);\n  }\n\n  return data;\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by update method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction hide(data) {\n  if (!isModifierRequired(data.instance.modifiers, 'hide', 'preventOverflow')) {\n    return data;\n  }\n\n  var refRect = data.offsets.reference;\n  var bound = find(data.instance.modifiers, function (modifier) {\n    return modifier.name === 'preventOverflow';\n  }).boundaries;\n\n  if (refRect.bottom < bound.top || refRect.left > bound.right || refRect.top > bound.bottom || refRect.right < bound.left) {\n    // Avoid unnecessary DOM access if visibility hasn't changed\n    if (data.hide === true) {\n      return data;\n    }\n\n    data.hide = true;\n    data.attributes['x-out-of-boundaries'] = '';\n  } else {\n    // Avoid unnecessary DOM access if visibility hasn't changed\n    if (data.hide === false) {\n      return data;\n    }\n\n    data.hide = false;\n    data.attributes['x-out-of-boundaries'] = false;\n  }\n\n  return data;\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by `update` method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction inner(data) {\n  var placement = data.placement;\n  var basePlacement = placement.split('-')[0];\n  var _data$offsets = data.offsets,\n      popper = _data$offsets.popper,\n      reference = _data$offsets.reference;\n\n  var isHoriz = ['left', 'right'].indexOf(basePlacement) !== -1;\n\n  var subtractLength = ['top', 'left'].indexOf(basePlacement) === -1;\n\n  popper[isHoriz ? 'left' : 'top'] = reference[basePlacement] - (subtractLength ? popper[isHoriz ? 'width' : 'height'] : 0);\n\n  data.placement = getOppositePlacement(placement);\n  data.offsets.popper = getClientRect(popper);\n\n  return data;\n}\n\n/**\n * Modifier function, each modifier can have a function of this type assigned\n * to its `fn` property.<br />\n * These functions will be called on each update, this means that you must\n * make sure they are performant enough to avoid performance bottlenecks.\n *\n * @function ModifierFn\n * @argument {dataObject} data - The data object generated by `update` method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {dataObject} The data object, properly modified\n */\n\n/**\n * Modifiers are plugins used to alter the behavior of your poppers.<br />\n * Popper.js uses a set of 9 modifiers to provide all the basic functionalities\n * needed by the library.\n *\n * Usually you don't want to override the `order`, `fn` and `onLoad` props.\n * All the other properties are configurations that could be tweaked.\n * @namespace modifiers\n */\nvar modifiers = {\n  /**\n   * Modifier used to shift the popper on the start or end of its reference\n   * element.<br />\n   * It will read the variation of the `placement` property.<br />\n   * It can be one either `-end` or `-start`.\n   * @memberof modifiers\n   * @inner\n   */\n  shift: {\n    /** @prop {number} order=100 - Index used to define the order of execution */\n    order: 100,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: shift\n  },\n\n  /**\n   * The `offset` modifier can shift your popper on both its axis.\n   *\n   * It accepts the following units:\n   * - `px` or unitless, interpreted as pixels\n   * - `%` or `%r`, percentage relative to the length of the reference element\n   * - `%p`, percentage relative to the length of the popper element\n   * - `vw`, CSS viewport width unit\n   * - `vh`, CSS viewport height unit\n   *\n   * For length is intended the main axis relative to the placement of the popper.<br />\n   * This means that if the placement is `top` or `bottom`, the length will be the\n   * `width`. In case of `left` or `right`, it will be the height.\n   *\n   * You can provide a single value (as `Number` or `String`), or a pair of values\n   * as `String` divided by a comma or one (or more) white spaces.<br />\n   * The latter is a deprecated method because it leads to confusion and will be\n   * removed in v2.<br />\n   * Additionally, it accepts additions and subtractions between different units.\n   * Note that multiplications and divisions aren't supported.\n   *\n   * Valid examples are:\n   * ```\n   * 10\n   * '10%'\n   * '10, 10'\n   * '10%, 10'\n   * '10 + 10%'\n   * '10 - 5vh + 3%'\n   * '-10px + 5vh, 5px - 6%'\n   * ```\n   * > **NB**: If you desire to apply offsets to your poppers in a way that may make them overlap\n   * > with their reference element, unfortunately, you will have to disable the `flip` modifier.\n   * > More on this [reading this issue](https://github.com/FezVrasta/popper.js/issues/373)\n   *\n   * @memberof modifiers\n   * @inner\n   */\n  offset: {\n    /** @prop {number} order=200 - Index used to define the order of execution */\n    order: 200,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: offset,\n    /** @prop {Number|String} offset=0\n     * The offset value as described in the modifier description\n     */\n    offset: 0\n  },\n\n  /**\n   * Modifier used to prevent the popper from being positioned outside the boundary.\n   *\n   * An scenario exists where the reference itself is not within the boundaries.<br />\n   * We can say it has \"escaped the boundaries\" — or just \"escaped\".<br />\n   * In this case we need to decide whether the popper should either:\n   *\n   * - detach from the reference and remain \"trapped\" in the boundaries, or\n   * - if it should ignore the boundary and \"escape with its reference\"\n   *\n   * When `escapeWithReference` is set to`true` and reference is completely\n   * outside its boundaries, the popper will overflow (or completely leave)\n   * the boundaries in order to remain attached to the edge of the reference.\n   *\n   * @memberof modifiers\n   * @inner\n   */\n  preventOverflow: {\n    /** @prop {number} order=300 - Index used to define the order of execution */\n    order: 300,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: preventOverflow,\n    /**\n     * @prop {Array} [priority=['left','right','top','bottom']]\n     * Popper will try to prevent overflow following these priorities by default,\n     * then, it could overflow on the left and on top of the `boundariesElement`\n     */\n    priority: ['left', 'right', 'top', 'bottom'],\n    /**\n     * @prop {number} padding=5\n     * Amount of pixel used to define a minimum distance between the boundaries\n     * and the popper this makes sure the popper has always a little padding\n     * between the edges of its container\n     */\n    padding: 5,\n    /**\n     * @prop {String|HTMLElement} boundariesElement='scrollParent'\n     * Boundaries used by the modifier, can be `scrollParent`, `window`,\n     * `viewport` or any DOM element.\n     */\n    boundariesElement: 'scrollParent'\n  },\n\n  /**\n   * Modifier used to make sure the reference and its popper stay near eachothers\n   * without leaving any gap between the two. Expecially useful when the arrow is\n   * enabled and you want to assure it to point to its reference element.\n   * It cares only about the first axis, you can still have poppers with margin\n   * between the popper and its reference element.\n   * @memberof modifiers\n   * @inner\n   */\n  keepTogether: {\n    /** @prop {number} order=400 - Index used to define the order of execution */\n    order: 400,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: keepTogether\n  },\n\n  /**\n   * This modifier is used to move the `arrowElement` of the popper to make\n   * sure it is positioned between the reference element and its popper element.\n   * It will read the outer size of the `arrowElement` node to detect how many\n   * pixels of conjuction are needed.\n   *\n   * It has no effect if no `arrowElement` is provided.\n   * @memberof modifiers\n   * @inner\n   */\n  arrow: {\n    /** @prop {number} order=500 - Index used to define the order of execution */\n    order: 500,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: arrow,\n    /** @prop {String|HTMLElement} element='[x-arrow]' - Selector or node used as arrow */\n    element: '[x-arrow]'\n  },\n\n  /**\n   * Modifier used to flip the popper's placement when it starts to overlap its\n   * reference element.\n   *\n   * Requires the `preventOverflow` modifier before it in order to work.\n   *\n   * **NOTE:** this modifier will interrupt the current update cycle and will\n   * restart it if it detects the need to flip the placement.\n   * @memberof modifiers\n   * @inner\n   */\n  flip: {\n    /** @prop {number} order=600 - Index used to define the order of execution */\n    order: 600,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: flip,\n    /**\n     * @prop {String|Array} behavior='flip'\n     * The behavior used to change the popper's placement. It can be one of\n     * `flip`, `clockwise`, `counterclockwise` or an array with a list of valid\n     * placements (with optional variations).\n     */\n    behavior: 'flip',\n    /**\n     * @prop {number} padding=5\n     * The popper will flip if it hits the edges of the `boundariesElement`\n     */\n    padding: 5,\n    /**\n     * @prop {String|HTMLElement} boundariesElement='viewport'\n     * The element which will define the boundaries of the popper position,\n     * the popper will never be placed outside of the defined boundaries\n     * (except if keepTogether is enabled)\n     */\n    boundariesElement: 'viewport'\n  },\n\n  /**\n   * Modifier used to make the popper flow toward the inner of the reference element.\n   * By default, when this modifier is disabled, the popper will be placed outside\n   * the reference element.\n   * @memberof modifiers\n   * @inner\n   */\n  inner: {\n    /** @prop {number} order=700 - Index used to define the order of execution */\n    order: 700,\n    /** @prop {Boolean} enabled=false - Whether the modifier is enabled or not */\n    enabled: false,\n    /** @prop {ModifierFn} */\n    fn: inner\n  },\n\n  /**\n   * Modifier used to hide the popper when its reference element is outside of the\n   * popper boundaries. It will set a `x-out-of-boundaries` attribute which can\n   * be used to hide with a CSS selector the popper when its reference is\n   * out of boundaries.\n   *\n   * Requires the `preventOverflow` modifier before it in order to work.\n   * @memberof modifiers\n   * @inner\n   */\n  hide: {\n    /** @prop {number} order=800 - Index used to define the order of execution */\n    order: 800,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: hide\n  },\n\n  /**\n   * Computes the style that will be applied to the popper element to gets\n   * properly positioned.\n   *\n   * Note that this modifier will not touch the DOM, it just prepares the styles\n   * so that `applyStyle` modifier can apply it. This separation is useful\n   * in case you need to replace `applyStyle` with a custom implementation.\n   *\n   * This modifier has `850` as `order` value to maintain backward compatibility\n   * with previous versions of Popper.js. Expect the modifiers ordering method\n   * to change in future major versions of the library.\n   *\n   * @memberof modifiers\n   * @inner\n   */\n  computeStyle: {\n    /** @prop {number} order=850 - Index used to define the order of execution */\n    order: 850,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: computeStyle,\n    /**\n     * @prop {Boolean} gpuAcceleration=true\n     * If true, it uses the CSS 3d transformation to position the popper.\n     * Otherwise, it will use the `top` and `left` properties.\n     */\n    gpuAcceleration: true,\n    /**\n     * @prop {string} [x='bottom']\n     * Where to anchor the X axis (`bottom` or `top`). AKA X offset origin.\n     * Change this if your popper should grow in a direction different from `bottom`\n     */\n    x: 'bottom',\n    /**\n     * @prop {string} [x='left']\n     * Where to anchor the Y axis (`left` or `right`). AKA Y offset origin.\n     * Change this if your popper should grow in a direction different from `right`\n     */\n    y: 'right'\n  },\n\n  /**\n   * Applies the computed styles to the popper element.\n   *\n   * All the DOM manipulations are limited to this modifier. This is useful in case\n   * you want to integrate Popper.js inside a framework or view library and you\n   * want to delegate all the DOM manipulations to it.\n   *\n   * Note that if you disable this modifier, you must make sure the popper element\n   * has its position set to `absolute` before Popper.js can do its work!\n   *\n   * Just disable this modifier and define you own to achieve the desired effect.\n   *\n   * @memberof modifiers\n   * @inner\n   */\n  applyStyle: {\n    /** @prop {number} order=900 - Index used to define the order of execution */\n    order: 900,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: applyStyle,\n    /** @prop {Function} */\n    onLoad: applyStyleOnLoad,\n    /**\n     * @deprecated since version 1.10.0, the property moved to `computeStyle` modifier\n     * @prop {Boolean} gpuAcceleration=true\n     * If true, it uses the CSS 3d transformation to position the popper.\n     * Otherwise, it will use the `top` and `left` properties.\n     */\n    gpuAcceleration: undefined\n  }\n};\n\n/**\n * The `dataObject` is an object containing all the informations used by Popper.js\n * this object get passed to modifiers and to the `onCreate` and `onUpdate` callbacks.\n * @name dataObject\n * @property {Object} data.instance The Popper.js instance\n * @property {String} data.placement Placement applied to popper\n * @property {String} data.originalPlacement Placement originally defined on init\n * @property {Boolean} data.flipped True if popper has been flipped by flip modifier\n * @property {Boolean} data.hide True if the reference element is out of boundaries, useful to know when to hide the popper.\n * @property {HTMLElement} data.arrowElement Node used as arrow by arrow modifier\n * @property {Object} data.styles Any CSS property defined here will be applied to the popper, it expects the JavaScript nomenclature (eg. `marginBottom`)\n * @property {Object} data.arrowStyles Any CSS property defined here will be applied to the popper arrow, it expects the JavaScript nomenclature (eg. `marginBottom`)\n * @property {Object} data.boundaries Offsets of the popper boundaries\n * @property {Object} data.offsets The measurements of popper, reference and arrow elements.\n * @property {Object} data.offsets.popper `top`, `left`, `width`, `height` values\n * @property {Object} data.offsets.reference `top`, `left`, `width`, `height` values\n * @property {Object} data.offsets.arrow] `top` and `left` offsets, only one of them will be different from 0\n */\n\n/**\n * Default options provided to Popper.js constructor.<br />\n * These can be overriden using the `options` argument of Popper.js.<br />\n * To override an option, simply pass as 3rd argument an object with the same\n * structure of this object, example:\n * ```\n * new Popper(ref, pop, {\n *   modifiers: {\n *     preventOverflow: { enabled: false }\n *   }\n * })\n * ```\n * @type {Object}\n * @static\n * @memberof Popper\n */\nvar Defaults = {\n  /**\n   * Popper's placement\n   * @prop {Popper.placements} placement='bottom'\n   */\n  placement: 'bottom',\n\n  /**\n   * Set this to true if you want popper to position it self in 'fixed' mode\n   * @prop {Boolean} positionFixed=false\n   */\n  positionFixed: false,\n\n  /**\n   * Whether events (resize, scroll) are initially enabled\n   * @prop {Boolean} eventsEnabled=true\n   */\n  eventsEnabled: true,\n\n  /**\n   * Set to true if you want to automatically remove the popper when\n   * you call the `destroy` method.\n   * @prop {Boolean} removeOnDestroy=false\n   */\n  removeOnDestroy: false,\n\n  /**\n   * Callback called when the popper is created.<br />\n   * By default, is set to no-op.<br />\n   * Access Popper.js instance with `data.instance`.\n   * @prop {onCreate}\n   */\n  onCreate: function onCreate() {},\n\n  /**\n   * Callback called when the popper is updated, this callback is not called\n   * on the initialization/creation of the popper, but only on subsequent\n   * updates.<br />\n   * By default, is set to no-op.<br />\n   * Access Popper.js instance with `data.instance`.\n   * @prop {onUpdate}\n   */\n  onUpdate: function onUpdate() {},\n\n  /**\n   * List of modifiers used to modify the offsets before they are applied to the popper.\n   * They provide most of the functionalities of Popper.js\n   * @prop {modifiers}\n   */\n  modifiers: modifiers\n};\n\n/**\n * @callback onCreate\n * @param {dataObject} data\n */\n\n/**\n * @callback onUpdate\n * @param {dataObject} data\n */\n\n// Utils\n// Methods\nvar Popper = function () {\n  /**\n   * Create a new Popper.js instance\n   * @class Popper\n   * @param {HTMLElement|referenceObject} reference - The reference element used to position the popper\n   * @param {HTMLElement} popper - The HTML element used as popper.\n   * @param {Object} options - Your custom options to override the ones defined in [Defaults](#defaults)\n   * @return {Object} instance - The generated Popper.js instance\n   */\n  function Popper(reference, popper) {\n    var _this = this;\n\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    classCallCheck(this, Popper);\n\n    this.scheduleUpdate = function () {\n      return requestAnimationFrame(_this.update);\n    };\n\n    // make update() debounced, so that it only runs at most once-per-tick\n    this.update = debounce(this.update.bind(this));\n\n    // with {} we create a new object with the options inside it\n    this.options = _extends({}, Popper.Defaults, options);\n\n    // init state\n    this.state = {\n      isDestroyed: false,\n      isCreated: false,\n      scrollParents: []\n    };\n\n    // get reference and popper elements (allow jQuery wrappers)\n    this.reference = reference && reference.jquery ? reference[0] : reference;\n    this.popper = popper && popper.jquery ? popper[0] : popper;\n\n    // Deep merge modifiers options\n    this.options.modifiers = {};\n    Object.keys(_extends({}, Popper.Defaults.modifiers, options.modifiers)).forEach(function (name) {\n      _this.options.modifiers[name] = _extends({}, Popper.Defaults.modifiers[name] || {}, options.modifiers ? options.modifiers[name] : {});\n    });\n\n    // Refactoring modifiers' list (Object => Array)\n    this.modifiers = Object.keys(this.options.modifiers).map(function (name) {\n      return _extends({\n        name: name\n      }, _this.options.modifiers[name]);\n    })\n    // sort the modifiers by order\n    .sort(function (a, b) {\n      return a.order - b.order;\n    });\n\n    // modifiers have the ability to execute arbitrary code when Popper.js get inited\n    // such code is executed in the same order of its modifier\n    // they could add new properties to their options configuration\n    // BE AWARE: don't add options to `options.modifiers.name` but to `modifierOptions`!\n    this.modifiers.forEach(function (modifierOptions) {\n      if (modifierOptions.enabled && isFunction(modifierOptions.onLoad)) {\n        modifierOptions.onLoad(_this.reference, _this.popper, _this.options, modifierOptions, _this.state);\n      }\n    });\n\n    // fire the first update to position the popper in the right place\n    this.update();\n\n    var eventsEnabled = this.options.eventsEnabled;\n    if (eventsEnabled) {\n      // setup event listeners, they will take care of update the position in specific situations\n      this.enableEventListeners();\n    }\n\n    this.state.eventsEnabled = eventsEnabled;\n  }\n\n  // We can't use class properties because they don't get listed in the\n  // class prototype and break stuff like Sinon stubs\n\n\n  createClass(Popper, [{\n    key: 'update',\n    value: function update$$1() {\n      return update.call(this);\n    }\n  }, {\n    key: 'destroy',\n    value: function destroy$$1() {\n      return destroy.call(this);\n    }\n  }, {\n    key: 'enableEventListeners',\n    value: function enableEventListeners$$1() {\n      return enableEventListeners.call(this);\n    }\n  }, {\n    key: 'disableEventListeners',\n    value: function disableEventListeners$$1() {\n      return disableEventListeners.call(this);\n    }\n\n    /**\n     * Schedule an update, it will run on the next UI update available\n     * @method scheduleUpdate\n     * @memberof Popper\n     */\n\n\n    /**\n     * Collection of utilities useful when writing custom modifiers.\n     * Starting from version 1.7, this method is available only if you\n     * include `popper-utils.js` before `popper.js`.\n     *\n     * **DEPRECATION**: This way to access PopperUtils is deprecated\n     * and will be removed in v2! Use the PopperUtils module directly instead.\n     * Due to the high instability of the methods contained in Utils, we can't\n     * guarantee them to follow semver. Use them at your own risk!\n     * @static\n     * @private\n     * @type {Object}\n     * @deprecated since version 1.8\n     * @member Utils\n     * @memberof Popper\n     */\n\n  }]);\n  return Popper;\n}();\n\n/**\n * The `referenceObject` is an object that provides an interface compatible with Popper.js\n * and lets you use it as replacement of a real DOM node.<br />\n * You can use this method to position a popper relatively to a set of coordinates\n * in case you don't have a DOM node to use as reference.\n *\n * ```\n * new Popper(referenceObject, popperNode);\n * ```\n *\n * NB: This feature isn't supported in Internet Explorer 10\n * @name referenceObject\n * @property {Function} data.getBoundingClientRect\n * A function that returns a set of coordinates compatible with the native `getBoundingClientRect` method.\n * @property {number} data.clientWidth\n * An ES6 getter that will return the width of the virtual reference element.\n * @property {number} data.clientHeight\n * An ES6 getter that will return the height of the virtual reference element.\n */\n\n\nPopper.Utils = (typeof window !== 'undefined' ? window : global).PopperUtils;\nPopper.placements = placements;\nPopper.Defaults = Defaults;\n\nexport default Popper;\n//# sourceMappingURL=popper.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/popper.js/dist/esm/popper.js\n// module id = 3\n// module chunks = 0","var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/global.js\n// module id = 4\n// module chunks = 0","/*! Hammer.JS - v2.0.7 - 2016-04-22\n * http://hammerjs.github.io/\n *\n * Copyright (c) 2016 Jorik Tangelder;\n * Licensed under the MIT license */\n(function(window, document, exportName, undefined) {\n  'use strict';\n\nvar VENDOR_PREFIXES = ['', 'webkit', 'Moz', 'MS', 'ms', 'o'];\nvar TEST_ELEMENT = document.createElement('div');\n\nvar TYPE_FUNCTION = 'function';\n\nvar round = Math.round;\nvar abs = Math.abs;\nvar now = Date.now;\n\n/**\n * set a timeout with a given scope\n * @param {Function} fn\n * @param {Number} timeout\n * @param {Object} context\n * @returns {number}\n */\nfunction setTimeoutContext(fn, timeout, context) {\n    return setTimeout(bindFn(fn, context), timeout);\n}\n\n/**\n * if the argument is an array, we want to execute the fn on each entry\n * if it aint an array we don't want to do a thing.\n * this is used by all the methods that accept a single and array argument.\n * @param {*|Array} arg\n * @param {String} fn\n * @param {Object} [context]\n * @returns {Boolean}\n */\nfunction invokeArrayArg(arg, fn, context) {\n    if (Array.isArray(arg)) {\n        each(arg, context[fn], context);\n        return true;\n    }\n    return false;\n}\n\n/**\n * walk objects and arrays\n * @param {Object} obj\n * @param {Function} iterator\n * @param {Object} context\n */\nfunction each(obj, iterator, context) {\n    var i;\n\n    if (!obj) {\n        return;\n    }\n\n    if (obj.forEach) {\n        obj.forEach(iterator, context);\n    } else if (obj.length !== undefined) {\n        i = 0;\n        while (i < obj.length) {\n            iterator.call(context, obj[i], i, obj);\n            i++;\n        }\n    } else {\n        for (i in obj) {\n            obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);\n        }\n    }\n}\n\n/**\n * wrap a method with a deprecation warning and stack trace\n * @param {Function} method\n * @param {String} name\n * @param {String} message\n * @returns {Function} A new function wrapping the supplied method.\n */\nfunction deprecate(method, name, message) {\n    var deprecationMessage = 'DEPRECATED METHOD: ' + name + '\\n' + message + ' AT \\n';\n    return function() {\n        var e = new Error('get-stack-trace');\n        var stack = e && e.stack ? e.stack.replace(/^[^\\(]+?[\\n$]/gm, '')\n            .replace(/^\\s+at\\s+/gm, '')\n            .replace(/^Object.<anonymous>\\s*\\(/gm, '{anonymous}()@') : 'Unknown Stack Trace';\n\n        var log = window.console && (window.console.warn || window.console.log);\n        if (log) {\n            log.call(window.console, deprecationMessage, stack);\n        }\n        return method.apply(this, arguments);\n    };\n}\n\n/**\n * extend object.\n * means that properties in dest will be overwritten by the ones in src.\n * @param {Object} target\n * @param {...Object} objects_to_assign\n * @returns {Object} target\n */\nvar assign;\nif (typeof Object.assign !== 'function') {\n    assign = function assign(target) {\n        if (target === undefined || target === null) {\n            throw new TypeError('Cannot convert undefined or null to object');\n        }\n\n        var output = Object(target);\n        for (var index = 1; index < arguments.length; index++) {\n            var source = arguments[index];\n            if (source !== undefined && source !== null) {\n                for (var nextKey in source) {\n                    if (source.hasOwnProperty(nextKey)) {\n                        output[nextKey] = source[nextKey];\n                    }\n                }\n            }\n        }\n        return output;\n    };\n} else {\n    assign = Object.assign;\n}\n\n/**\n * extend object.\n * means that properties in dest will be overwritten by the ones in src.\n * @param {Object} dest\n * @param {Object} src\n * @param {Boolean} [merge=false]\n * @returns {Object} dest\n */\nvar extend = deprecate(function extend(dest, src, merge) {\n    var keys = Object.keys(src);\n    var i = 0;\n    while (i < keys.length) {\n        if (!merge || (merge && dest[keys[i]] === undefined)) {\n            dest[keys[i]] = src[keys[i]];\n        }\n        i++;\n    }\n    return dest;\n}, 'extend', 'Use `assign`.');\n\n/**\n * merge the values from src in the dest.\n * means that properties that exist in dest will not be overwritten by src\n * @param {Object} dest\n * @param {Object} src\n * @returns {Object} dest\n */\nvar merge = deprecate(function merge(dest, src) {\n    return extend(dest, src, true);\n}, 'merge', 'Use `assign`.');\n\n/**\n * simple class inheritance\n * @param {Function} child\n * @param {Function} base\n * @param {Object} [properties]\n */\nfunction inherit(child, base, properties) {\n    var baseP = base.prototype,\n        childP;\n\n    childP = child.prototype = Object.create(baseP);\n    childP.constructor = child;\n    childP._super = baseP;\n\n    if (properties) {\n        assign(childP, properties);\n    }\n}\n\n/**\n * simple function bind\n * @param {Function} fn\n * @param {Object} context\n * @returns {Function}\n */\nfunction bindFn(fn, context) {\n    return function boundFn() {\n        return fn.apply(context, arguments);\n    };\n}\n\n/**\n * let a boolean value also be a function that must return a boolean\n * this first item in args will be used as the context\n * @param {Boolean|Function} val\n * @param {Array} [args]\n * @returns {Boolean}\n */\nfunction boolOrFn(val, args) {\n    if (typeof val == TYPE_FUNCTION) {\n        return val.apply(args ? args[0] || undefined : undefined, args);\n    }\n    return val;\n}\n\n/**\n * use the val2 when val1 is undefined\n * @param {*} val1\n * @param {*} val2\n * @returns {*}\n */\nfunction ifUndefined(val1, val2) {\n    return (val1 === undefined) ? val2 : val1;\n}\n\n/**\n * addEventListener with multiple events at once\n * @param {EventTarget} target\n * @param {String} types\n * @param {Function} handler\n */\nfunction addEventListeners(target, types, handler) {\n    each(splitStr(types), function(type) {\n        target.addEventListener(type, handler, false);\n    });\n}\n\n/**\n * removeEventListener with multiple events at once\n * @param {EventTarget} target\n * @param {String} types\n * @param {Function} handler\n */\nfunction removeEventListeners(target, types, handler) {\n    each(splitStr(types), function(type) {\n        target.removeEventListener(type, handler, false);\n    });\n}\n\n/**\n * find if a node is in the given parent\n * @method hasParent\n * @param {HTMLElement} node\n * @param {HTMLElement} parent\n * @return {Boolean} found\n */\nfunction hasParent(node, parent) {\n    while (node) {\n        if (node == parent) {\n            return true;\n        }\n        node = node.parentNode;\n    }\n    return false;\n}\n\n/**\n * small indexOf wrapper\n * @param {String} str\n * @param {String} find\n * @returns {Boolean} found\n */\nfunction inStr(str, find) {\n    return str.indexOf(find) > -1;\n}\n\n/**\n * split string on whitespace\n * @param {String} str\n * @returns {Array} words\n */\nfunction splitStr(str) {\n    return str.trim().split(/\\s+/g);\n}\n\n/**\n * find if a array contains the object using indexOf or a simple polyFill\n * @param {Array} src\n * @param {String} find\n * @param {String} [findByKey]\n * @return {Boolean|Number} false when not found, or the index\n */\nfunction inArray(src, find, findByKey) {\n    if (src.indexOf && !findByKey) {\n        return src.indexOf(find);\n    } else {\n        var i = 0;\n        while (i < src.length) {\n            if ((findByKey && src[i][findByKey] == find) || (!findByKey && src[i] === find)) {\n                return i;\n            }\n            i++;\n        }\n        return -1;\n    }\n}\n\n/**\n * convert array-like objects to real arrays\n * @param {Object} obj\n * @returns {Array}\n */\nfunction toArray(obj) {\n    return Array.prototype.slice.call(obj, 0);\n}\n\n/**\n * unique array with objects based on a key (like 'id') or just by the array's value\n * @param {Array} src [{id:1},{id:2},{id:1}]\n * @param {String} [key]\n * @param {Boolean} [sort=False]\n * @returns {Array} [{id:1},{id:2}]\n */\nfunction uniqueArray(src, key, sort) {\n    var results = [];\n    var values = [];\n    var i = 0;\n\n    while (i < src.length) {\n        var val = key ? src[i][key] : src[i];\n        if (inArray(values, val) < 0) {\n            results.push(src[i]);\n        }\n        values[i] = val;\n        i++;\n    }\n\n    if (sort) {\n        if (!key) {\n            results = results.sort();\n        } else {\n            results = results.sort(function sortUniqueArray(a, b) {\n                return a[key] > b[key];\n            });\n        }\n    }\n\n    return results;\n}\n\n/**\n * get the prefixed property\n * @param {Object} obj\n * @param {String} property\n * @returns {String|Undefined} prefixed\n */\nfunction prefixed(obj, property) {\n    var prefix, prop;\n    var camelProp = property[0].toUpperCase() + property.slice(1);\n\n    var i = 0;\n    while (i < VENDOR_PREFIXES.length) {\n        prefix = VENDOR_PREFIXES[i];\n        prop = (prefix) ? prefix + camelProp : property;\n\n        if (prop in obj) {\n            return prop;\n        }\n        i++;\n    }\n    return undefined;\n}\n\n/**\n * get a unique id\n * @returns {number} uniqueId\n */\nvar _uniqueId = 1;\nfunction uniqueId() {\n    return _uniqueId++;\n}\n\n/**\n * get the window object of an element\n * @param {HTMLElement} element\n * @returns {DocumentView|Window}\n */\nfunction getWindowForElement(element) {\n    var doc = element.ownerDocument || element;\n    return (doc.defaultView || doc.parentWindow || window);\n}\n\nvar MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;\n\nvar SUPPORT_TOUCH = ('ontouchstart' in window);\nvar SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;\nvar SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);\n\nvar INPUT_TYPE_TOUCH = 'touch';\nvar INPUT_TYPE_PEN = 'pen';\nvar INPUT_TYPE_MOUSE = 'mouse';\nvar INPUT_TYPE_KINECT = 'kinect';\n\nvar COMPUTE_INTERVAL = 25;\n\nvar INPUT_START = 1;\nvar INPUT_MOVE = 2;\nvar INPUT_END = 4;\nvar INPUT_CANCEL = 8;\n\nvar DIRECTION_NONE = 1;\nvar DIRECTION_LEFT = 2;\nvar DIRECTION_RIGHT = 4;\nvar DIRECTION_UP = 8;\nvar DIRECTION_DOWN = 16;\n\nvar DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;\nvar DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;\nvar DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;\n\nvar PROPS_XY = ['x', 'y'];\nvar PROPS_CLIENT_XY = ['clientX', 'clientY'];\n\n/**\n * create new input type manager\n * @param {Manager} manager\n * @param {Function} callback\n * @returns {Input}\n * @constructor\n */\nfunction Input(manager, callback) {\n    var self = this;\n    this.manager = manager;\n    this.callback = callback;\n    this.element = manager.element;\n    this.target = manager.options.inputTarget;\n\n    // smaller wrapper around the handler, for the scope and the enabled state of the manager,\n    // so when disabled the input events are completely bypassed.\n    this.domHandler = function(ev) {\n        if (boolOrFn(manager.options.enable, [manager])) {\n            self.handler(ev);\n        }\n    };\n\n    this.init();\n\n}\n\nInput.prototype = {\n    /**\n     * should handle the inputEvent data and trigger the callback\n     * @virtual\n     */\n    handler: function() { },\n\n    /**\n     * bind the events\n     */\n    init: function() {\n        this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);\n        this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);\n        this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);\n    },\n\n    /**\n     * unbind the events\n     */\n    destroy: function() {\n        this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);\n        this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);\n        this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);\n    }\n};\n\n/**\n * create new input type manager\n * called by the Manager constructor\n * @param {Hammer} manager\n * @returns {Input}\n */\nfunction createInputInstance(manager) {\n    var Type;\n    var inputClass = manager.options.inputClass;\n\n    if (inputClass) {\n        Type = inputClass;\n    } else if (SUPPORT_POINTER_EVENTS) {\n        Type = PointerEventInput;\n    } else if (SUPPORT_ONLY_TOUCH) {\n        Type = TouchInput;\n    } else if (!SUPPORT_TOUCH) {\n        Type = MouseInput;\n    } else {\n        Type = TouchMouseInput;\n    }\n    return new (Type)(manager, inputHandler);\n}\n\n/**\n * handle input events\n * @param {Manager} manager\n * @param {String} eventType\n * @param {Object} input\n */\nfunction inputHandler(manager, eventType, input) {\n    var pointersLen = input.pointers.length;\n    var changedPointersLen = input.changedPointers.length;\n    var isFirst = (eventType & INPUT_START && (pointersLen - changedPointersLen === 0));\n    var isFinal = (eventType & (INPUT_END | INPUT_CANCEL) && (pointersLen - changedPointersLen === 0));\n\n    input.isFirst = !!isFirst;\n    input.isFinal = !!isFinal;\n\n    if (isFirst) {\n        manager.session = {};\n    }\n\n    // source event is the normalized value of the domEvents\n    // like 'touchstart, mouseup, pointerdown'\n    input.eventType = eventType;\n\n    // compute scale, rotation etc\n    computeInputData(manager, input);\n\n    // emit secret event\n    manager.emit('hammer.input', input);\n\n    manager.recognize(input);\n    manager.session.prevInput = input;\n}\n\n/**\n * extend the data with some usable properties like scale, rotate, velocity etc\n * @param {Object} manager\n * @param {Object} input\n */\nfunction computeInputData(manager, input) {\n    var session = manager.session;\n    var pointers = input.pointers;\n    var pointersLength = pointers.length;\n\n    // store the first input to calculate the distance and direction\n    if (!session.firstInput) {\n        session.firstInput = simpleCloneInputData(input);\n    }\n\n    // to compute scale and rotation we need to store the multiple touches\n    if (pointersLength > 1 && !session.firstMultiple) {\n        session.firstMultiple = simpleCloneInputData(input);\n    } else if (pointersLength === 1) {\n        session.firstMultiple = false;\n    }\n\n    var firstInput = session.firstInput;\n    var firstMultiple = session.firstMultiple;\n    var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;\n\n    var center = input.center = getCenter(pointers);\n    input.timeStamp = now();\n    input.deltaTime = input.timeStamp - firstInput.timeStamp;\n\n    input.angle = getAngle(offsetCenter, center);\n    input.distance = getDistance(offsetCenter, center);\n\n    computeDeltaXY(session, input);\n    input.offsetDirection = getDirection(input.deltaX, input.deltaY);\n\n    var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);\n    input.overallVelocityX = overallVelocity.x;\n    input.overallVelocityY = overallVelocity.y;\n    input.overallVelocity = (abs(overallVelocity.x) > abs(overallVelocity.y)) ? overallVelocity.x : overallVelocity.y;\n\n    input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;\n    input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;\n\n    input.maxPointers = !session.prevInput ? input.pointers.length : ((input.pointers.length >\n        session.prevInput.maxPointers) ? input.pointers.length : session.prevInput.maxPointers);\n\n    computeIntervalInputData(session, input);\n\n    // find the correct target\n    var target = manager.element;\n    if (hasParent(input.srcEvent.target, target)) {\n        target = input.srcEvent.target;\n    }\n    input.target = target;\n}\n\nfunction computeDeltaXY(session, input) {\n    var center = input.center;\n    var offset = session.offsetDelta || {};\n    var prevDelta = session.prevDelta || {};\n    var prevInput = session.prevInput || {};\n\n    if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {\n        prevDelta = session.prevDelta = {\n            x: prevInput.deltaX || 0,\n            y: prevInput.deltaY || 0\n        };\n\n        offset = session.offsetDelta = {\n            x: center.x,\n            y: center.y\n        };\n    }\n\n    input.deltaX = prevDelta.x + (center.x - offset.x);\n    input.deltaY = prevDelta.y + (center.y - offset.y);\n}\n\n/**\n * velocity is calculated every x ms\n * @param {Object} session\n * @param {Object} input\n */\nfunction computeIntervalInputData(session, input) {\n    var last = session.lastInterval || input,\n        deltaTime = input.timeStamp - last.timeStamp,\n        velocity, velocityX, velocityY, direction;\n\n    if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {\n        var deltaX = input.deltaX - last.deltaX;\n        var deltaY = input.deltaY - last.deltaY;\n\n        var v = getVelocity(deltaTime, deltaX, deltaY);\n        velocityX = v.x;\n        velocityY = v.y;\n        velocity = (abs(v.x) > abs(v.y)) ? v.x : v.y;\n        direction = getDirection(deltaX, deltaY);\n\n        session.lastInterval = input;\n    } else {\n        // use latest velocity info if it doesn't overtake a minimum period\n        velocity = last.velocity;\n        velocityX = last.velocityX;\n        velocityY = last.velocityY;\n        direction = last.direction;\n    }\n\n    input.velocity = velocity;\n    input.velocityX = velocityX;\n    input.velocityY = velocityY;\n    input.direction = direction;\n}\n\n/**\n * create a simple clone from the input used for storage of firstInput and firstMultiple\n * @param {Object} input\n * @returns {Object} clonedInputData\n */\nfunction simpleCloneInputData(input) {\n    // make a simple copy of the pointers because we will get a reference if we don't\n    // we only need clientXY for the calculations\n    var pointers = [];\n    var i = 0;\n    while (i < input.pointers.length) {\n        pointers[i] = {\n            clientX: round(input.pointers[i].clientX),\n            clientY: round(input.pointers[i].clientY)\n        };\n        i++;\n    }\n\n    return {\n        timeStamp: now(),\n        pointers: pointers,\n        center: getCenter(pointers),\n        deltaX: input.deltaX,\n        deltaY: input.deltaY\n    };\n}\n\n/**\n * get the center of all the pointers\n * @param {Array} pointers\n * @return {Object} center contains `x` and `y` properties\n */\nfunction getCenter(pointers) {\n    var pointersLength = pointers.length;\n\n    // no need to loop when only one touch\n    if (pointersLength === 1) {\n        return {\n            x: round(pointers[0].clientX),\n            y: round(pointers[0].clientY)\n        };\n    }\n\n    var x = 0, y = 0, i = 0;\n    while (i < pointersLength) {\n        x += pointers[i].clientX;\n        y += pointers[i].clientY;\n        i++;\n    }\n\n    return {\n        x: round(x / pointersLength),\n        y: round(y / pointersLength)\n    };\n}\n\n/**\n * calculate the velocity between two points. unit is in px per ms.\n * @param {Number} deltaTime\n * @param {Number} x\n * @param {Number} y\n * @return {Object} velocity `x` and `y`\n */\nfunction getVelocity(deltaTime, x, y) {\n    return {\n        x: x / deltaTime || 0,\n        y: y / deltaTime || 0\n    };\n}\n\n/**\n * get the direction between two points\n * @param {Number} x\n * @param {Number} y\n * @return {Number} direction\n */\nfunction getDirection(x, y) {\n    if (x === y) {\n        return DIRECTION_NONE;\n    }\n\n    if (abs(x) >= abs(y)) {\n        return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;\n    }\n    return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;\n}\n\n/**\n * calculate the absolute distance between two points\n * @param {Object} p1 {x, y}\n * @param {Object} p2 {x, y}\n * @param {Array} [props] containing x and y keys\n * @return {Number} distance\n */\nfunction getDistance(p1, p2, props) {\n    if (!props) {\n        props = PROPS_XY;\n    }\n    var x = p2[props[0]] - p1[props[0]],\n        y = p2[props[1]] - p1[props[1]];\n\n    return Math.sqrt((x * x) + (y * y));\n}\n\n/**\n * calculate the angle between two coordinates\n * @param {Object} p1\n * @param {Object} p2\n * @param {Array} [props] containing x and y keys\n * @return {Number} angle\n */\nfunction getAngle(p1, p2, props) {\n    if (!props) {\n        props = PROPS_XY;\n    }\n    var x = p2[props[0]] - p1[props[0]],\n        y = p2[props[1]] - p1[props[1]];\n    return Math.atan2(y, x) * 180 / Math.PI;\n}\n\n/**\n * calculate the rotation degrees between two pointersets\n * @param {Array} start array of pointers\n * @param {Array} end array of pointers\n * @return {Number} rotation\n */\nfunction getRotation(start, end) {\n    return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);\n}\n\n/**\n * calculate the scale factor between two pointersets\n * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out\n * @param {Array} start array of pointers\n * @param {Array} end array of pointers\n * @return {Number} scale\n */\nfunction getScale(start, end) {\n    return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);\n}\n\nvar MOUSE_INPUT_MAP = {\n    mousedown: INPUT_START,\n    mousemove: INPUT_MOVE,\n    mouseup: INPUT_END\n};\n\nvar MOUSE_ELEMENT_EVENTS = 'mousedown';\nvar MOUSE_WINDOW_EVENTS = 'mousemove mouseup';\n\n/**\n * Mouse events input\n * @constructor\n * @extends Input\n */\nfunction MouseInput() {\n    this.evEl = MOUSE_ELEMENT_EVENTS;\n    this.evWin = MOUSE_WINDOW_EVENTS;\n\n    this.pressed = false; // mousedown state\n\n    Input.apply(this, arguments);\n}\n\ninherit(MouseInput, Input, {\n    /**\n     * handle mouse events\n     * @param {Object} ev\n     */\n    handler: function MEhandler(ev) {\n        var eventType = MOUSE_INPUT_MAP[ev.type];\n\n        // on start we want to have the left mouse button down\n        if (eventType & INPUT_START && ev.button === 0) {\n            this.pressed = true;\n        }\n\n        if (eventType & INPUT_MOVE && ev.which !== 1) {\n            eventType = INPUT_END;\n        }\n\n        // mouse must be down\n        if (!this.pressed) {\n            return;\n        }\n\n        if (eventType & INPUT_END) {\n            this.pressed = false;\n        }\n\n        this.callback(this.manager, eventType, {\n            pointers: [ev],\n            changedPointers: [ev],\n            pointerType: INPUT_TYPE_MOUSE,\n            srcEvent: ev\n        });\n    }\n});\n\nvar POINTER_INPUT_MAP = {\n    pointerdown: INPUT_START,\n    pointermove: INPUT_MOVE,\n    pointerup: INPUT_END,\n    pointercancel: INPUT_CANCEL,\n    pointerout: INPUT_CANCEL\n};\n\n// in IE10 the pointer types is defined as an enum\nvar IE10_POINTER_TYPE_ENUM = {\n    2: INPUT_TYPE_TOUCH,\n    3: INPUT_TYPE_PEN,\n    4: INPUT_TYPE_MOUSE,\n    5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816\n};\n\nvar POINTER_ELEMENT_EVENTS = 'pointerdown';\nvar POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel';\n\n// IE10 has prefixed support, and case-sensitive\nif (window.MSPointerEvent && !window.PointerEvent) {\n    POINTER_ELEMENT_EVENTS = 'MSPointerDown';\n    POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';\n}\n\n/**\n * Pointer events input\n * @constructor\n * @extends Input\n */\nfunction PointerEventInput() {\n    this.evEl = POINTER_ELEMENT_EVENTS;\n    this.evWin = POINTER_WINDOW_EVENTS;\n\n    Input.apply(this, arguments);\n\n    this.store = (this.manager.session.pointerEvents = []);\n}\n\ninherit(PointerEventInput, Input, {\n    /**\n     * handle mouse events\n     * @param {Object} ev\n     */\n    handler: function PEhandler(ev) {\n        var store = this.store;\n        var removePointer = false;\n\n        var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');\n        var eventType = POINTER_INPUT_MAP[eventTypeNormalized];\n        var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;\n\n        var isTouch = (pointerType == INPUT_TYPE_TOUCH);\n\n        // get index of the event in the store\n        var storeIndex = inArray(store, ev.pointerId, 'pointerId');\n\n        // start and mouse must be down\n        if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {\n            if (storeIndex < 0) {\n                store.push(ev);\n                storeIndex = store.length - 1;\n            }\n        } else if (eventType & (INPUT_END | INPUT_CANCEL)) {\n            removePointer = true;\n        }\n\n        // it not found, so the pointer hasn't been down (so it's probably a hover)\n        if (storeIndex < 0) {\n            return;\n        }\n\n        // update the event in the store\n        store[storeIndex] = ev;\n\n        this.callback(this.manager, eventType, {\n            pointers: store,\n            changedPointers: [ev],\n            pointerType: pointerType,\n            srcEvent: ev\n        });\n\n        if (removePointer) {\n            // remove from the store\n            store.splice(storeIndex, 1);\n        }\n    }\n});\n\nvar SINGLE_TOUCH_INPUT_MAP = {\n    touchstart: INPUT_START,\n    touchmove: INPUT_MOVE,\n    touchend: INPUT_END,\n    touchcancel: INPUT_CANCEL\n};\n\nvar SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';\nvar SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';\n\n/**\n * Touch events input\n * @constructor\n * @extends Input\n */\nfunction SingleTouchInput() {\n    this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;\n    this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;\n    this.started = false;\n\n    Input.apply(this, arguments);\n}\n\ninherit(SingleTouchInput, Input, {\n    handler: function TEhandler(ev) {\n        var type = SINGLE_TOUCH_INPUT_MAP[ev.type];\n\n        // should we handle the touch events?\n        if (type === INPUT_START) {\n            this.started = true;\n        }\n\n        if (!this.started) {\n            return;\n        }\n\n        var touches = normalizeSingleTouches.call(this, ev, type);\n\n        // when done, reset the started state\n        if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {\n            this.started = false;\n        }\n\n        this.callback(this.manager, type, {\n            pointers: touches[0],\n            changedPointers: touches[1],\n            pointerType: INPUT_TYPE_TOUCH,\n            srcEvent: ev\n        });\n    }\n});\n\n/**\n * @this {TouchInput}\n * @param {Object} ev\n * @param {Number} type flag\n * @returns {undefined|Array} [all, changed]\n */\nfunction normalizeSingleTouches(ev, type) {\n    var all = toArray(ev.touches);\n    var changed = toArray(ev.changedTouches);\n\n    if (type & (INPUT_END | INPUT_CANCEL)) {\n        all = uniqueArray(all.concat(changed), 'identifier', true);\n    }\n\n    return [all, changed];\n}\n\nvar TOUCH_INPUT_MAP = {\n    touchstart: INPUT_START,\n    touchmove: INPUT_MOVE,\n    touchend: INPUT_END,\n    touchcancel: INPUT_CANCEL\n};\n\nvar TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';\n\n/**\n * Multi-user touch events input\n * @constructor\n * @extends Input\n */\nfunction TouchInput() {\n    this.evTarget = TOUCH_TARGET_EVENTS;\n    this.targetIds = {};\n\n    Input.apply(this, arguments);\n}\n\ninherit(TouchInput, Input, {\n    handler: function MTEhandler(ev) {\n        var type = TOUCH_INPUT_MAP[ev.type];\n        var touches = getTouches.call(this, ev, type);\n        if (!touches) {\n            return;\n        }\n\n        this.callback(this.manager, type, {\n            pointers: touches[0],\n            changedPointers: touches[1],\n            pointerType: INPUT_TYPE_TOUCH,\n            srcEvent: ev\n        });\n    }\n});\n\n/**\n * @this {TouchInput}\n * @param {Object} ev\n * @param {Number} type flag\n * @returns {undefined|Array} [all, changed]\n */\nfunction getTouches(ev, type) {\n    var allTouches = toArray(ev.touches);\n    var targetIds = this.targetIds;\n\n    // when there is only one touch, the process can be simplified\n    if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {\n        targetIds[allTouches[0].identifier] = true;\n        return [allTouches, allTouches];\n    }\n\n    var i,\n        targetTouches,\n        changedTouches = toArray(ev.changedTouches),\n        changedTargetTouches = [],\n        target = this.target;\n\n    // get target touches from touches\n    targetTouches = allTouches.filter(function(touch) {\n        return hasParent(touch.target, target);\n    });\n\n    // collect touches\n    if (type === INPUT_START) {\n        i = 0;\n        while (i < targetTouches.length) {\n            targetIds[targetTouches[i].identifier] = true;\n            i++;\n        }\n    }\n\n    // filter changed touches to only contain touches that exist in the collected target ids\n    i = 0;\n    while (i < changedTouches.length) {\n        if (targetIds[changedTouches[i].identifier]) {\n            changedTargetTouches.push(changedTouches[i]);\n        }\n\n        // cleanup removed touches\n        if (type & (INPUT_END | INPUT_CANCEL)) {\n            delete targetIds[changedTouches[i].identifier];\n        }\n        i++;\n    }\n\n    if (!changedTargetTouches.length) {\n        return;\n    }\n\n    return [\n        // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'\n        uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true),\n        changedTargetTouches\n    ];\n}\n\n/**\n * Combined touch and mouse input\n *\n * Touch has a higher priority then mouse, and while touching no mouse events are allowed.\n * This because touch devices also emit mouse events while doing a touch.\n *\n * @constructor\n * @extends Input\n */\n\nvar DEDUP_TIMEOUT = 2500;\nvar DEDUP_DISTANCE = 25;\n\nfunction TouchMouseInput() {\n    Input.apply(this, arguments);\n\n    var handler = bindFn(this.handler, this);\n    this.touch = new TouchInput(this.manager, handler);\n    this.mouse = new MouseInput(this.manager, handler);\n\n    this.primaryTouch = null;\n    this.lastTouches = [];\n}\n\ninherit(TouchMouseInput, Input, {\n    /**\n     * handle mouse and touch events\n     * @param {Hammer} manager\n     * @param {String} inputEvent\n     * @param {Object} inputData\n     */\n    handler: function TMEhandler(manager, inputEvent, inputData) {\n        var isTouch = (inputData.pointerType == INPUT_TYPE_TOUCH),\n            isMouse = (inputData.pointerType == INPUT_TYPE_MOUSE);\n\n        if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {\n            return;\n        }\n\n        // when we're in a touch event, record touches to  de-dupe synthetic mouse event\n        if (isTouch) {\n            recordTouches.call(this, inputEvent, inputData);\n        } else if (isMouse && isSyntheticEvent.call(this, inputData)) {\n            return;\n        }\n\n        this.callback(manager, inputEvent, inputData);\n    },\n\n    /**\n     * remove the event listeners\n     */\n    destroy: function destroy() {\n        this.touch.destroy();\n        this.mouse.destroy();\n    }\n});\n\nfunction recordTouches(eventType, eventData) {\n    if (eventType & INPUT_START) {\n        this.primaryTouch = eventData.changedPointers[0].identifier;\n        setLastTouch.call(this, eventData);\n    } else if (eventType & (INPUT_END | INPUT_CANCEL)) {\n        setLastTouch.call(this, eventData);\n    }\n}\n\nfunction setLastTouch(eventData) {\n    var touch = eventData.changedPointers[0];\n\n    if (touch.identifier === this.primaryTouch) {\n        var lastTouch = {x: touch.clientX, y: touch.clientY};\n        this.lastTouches.push(lastTouch);\n        var lts = this.lastTouches;\n        var removeLastTouch = function() {\n            var i = lts.indexOf(lastTouch);\n            if (i > -1) {\n                lts.splice(i, 1);\n            }\n        };\n        setTimeout(removeLastTouch, DEDUP_TIMEOUT);\n    }\n}\n\nfunction isSyntheticEvent(eventData) {\n    var x = eventData.srcEvent.clientX, y = eventData.srcEvent.clientY;\n    for (var i = 0; i < this.lastTouches.length; i++) {\n        var t = this.lastTouches[i];\n        var dx = Math.abs(x - t.x), dy = Math.abs(y - t.y);\n        if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) {\n            return true;\n        }\n    }\n    return false;\n}\n\nvar PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');\nvar NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;\n\n// magical touchAction value\nvar TOUCH_ACTION_COMPUTE = 'compute';\nvar TOUCH_ACTION_AUTO = 'auto';\nvar TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented\nvar TOUCH_ACTION_NONE = 'none';\nvar TOUCH_ACTION_PAN_X = 'pan-x';\nvar TOUCH_ACTION_PAN_Y = 'pan-y';\nvar TOUCH_ACTION_MAP = getTouchActionProps();\n\n/**\n * Touch Action\n * sets the touchAction property or uses the js alternative\n * @param {Manager} manager\n * @param {String} value\n * @constructor\n */\nfunction TouchAction(manager, value) {\n    this.manager = manager;\n    this.set(value);\n}\n\nTouchAction.prototype = {\n    /**\n     * set the touchAction value on the element or enable the polyfill\n     * @param {String} value\n     */\n    set: function(value) {\n        // find out the touch-action by the event handlers\n        if (value == TOUCH_ACTION_COMPUTE) {\n            value = this.compute();\n        }\n\n        if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) {\n            this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;\n        }\n        this.actions = value.toLowerCase().trim();\n    },\n\n    /**\n     * just re-set the touchAction value\n     */\n    update: function() {\n        this.set(this.manager.options.touchAction);\n    },\n\n    /**\n     * compute the value for the touchAction property based on the recognizer's settings\n     * @returns {String} value\n     */\n    compute: function() {\n        var actions = [];\n        each(this.manager.recognizers, function(recognizer) {\n            if (boolOrFn(recognizer.options.enable, [recognizer])) {\n                actions = actions.concat(recognizer.getTouchAction());\n            }\n        });\n        return cleanTouchActions(actions.join(' '));\n    },\n\n    /**\n     * this method is called on each input cycle and provides the preventing of the browser behavior\n     * @param {Object} input\n     */\n    preventDefaults: function(input) {\n        var srcEvent = input.srcEvent;\n        var direction = input.offsetDirection;\n\n        // if the touch action did prevented once this session\n        if (this.manager.session.prevented) {\n            srcEvent.preventDefault();\n            return;\n        }\n\n        var actions = this.actions;\n        var hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];\n        var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];\n        var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];\n\n        if (hasNone) {\n            //do not prevent defaults if this is a tap gesture\n\n            var isTapPointer = input.pointers.length === 1;\n            var isTapMovement = input.distance < 2;\n            var isTapTouchTime = input.deltaTime < 250;\n\n            if (isTapPointer && isTapMovement && isTapTouchTime) {\n                return;\n            }\n        }\n\n        if (hasPanX && hasPanY) {\n            // `pan-x pan-y` means browser handles all scrolling/panning, do not prevent\n            return;\n        }\n\n        if (hasNone ||\n            (hasPanY && direction & DIRECTION_HORIZONTAL) ||\n            (hasPanX && direction & DIRECTION_VERTICAL)) {\n            return this.preventSrc(srcEvent);\n        }\n    },\n\n    /**\n     * call preventDefault to prevent the browser's default behavior (scrolling in most cases)\n     * @param {Object} srcEvent\n     */\n    preventSrc: function(srcEvent) {\n        this.manager.session.prevented = true;\n        srcEvent.preventDefault();\n    }\n};\n\n/**\n * when the touchActions are collected they are not a valid value, so we need to clean things up. *\n * @param {String} actions\n * @returns {*}\n */\nfunction cleanTouchActions(actions) {\n    // none\n    if (inStr(actions, TOUCH_ACTION_NONE)) {\n        return TOUCH_ACTION_NONE;\n    }\n\n    var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);\n    var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);\n\n    // if both pan-x and pan-y are set (different recognizers\n    // for different directions, e.g. horizontal pan but vertical swipe?)\n    // we need none (as otherwise with pan-x pan-y combined none of these\n    // recognizers will work, since the browser would handle all panning\n    if (hasPanX && hasPanY) {\n        return TOUCH_ACTION_NONE;\n    }\n\n    // pan-x OR pan-y\n    if (hasPanX || hasPanY) {\n        return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;\n    }\n\n    // manipulation\n    if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {\n        return TOUCH_ACTION_MANIPULATION;\n    }\n\n    return TOUCH_ACTION_AUTO;\n}\n\nfunction getTouchActionProps() {\n    if (!NATIVE_TOUCH_ACTION) {\n        return false;\n    }\n    var touchMap = {};\n    var cssSupports = window.CSS && window.CSS.supports;\n    ['auto', 'manipulation', 'pan-y', 'pan-x', 'pan-x pan-y', 'none'].forEach(function(val) {\n\n        // If css.supports is not supported but there is native touch-action assume it supports\n        // all values. This is the case for IE 10 and 11.\n        touchMap[val] = cssSupports ? window.CSS.supports('touch-action', val) : true;\n    });\n    return touchMap;\n}\n\n/**\n * Recognizer flow explained; *\n * All recognizers have the initial state of POSSIBLE when a input session starts.\n * The definition of a input session is from the first input until the last input, with all it's movement in it. *\n * Example session for mouse-input: mousedown -> mousemove -> mouseup\n *\n * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed\n * which determines with state it should be.\n *\n * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to\n * POSSIBLE to give it another change on the next cycle.\n *\n *               Possible\n *                  |\n *            +-----+---------------+\n *            |                     |\n *      +-----+-----+               |\n *      |           |               |\n *   Failed      Cancelled          |\n *                          +-------+------+\n *                          |              |\n *                      Recognized       Began\n *                                         |\n *                                      Changed\n *                                         |\n *                                  Ended/Recognized\n */\nvar STATE_POSSIBLE = 1;\nvar STATE_BEGAN = 2;\nvar STATE_CHANGED = 4;\nvar STATE_ENDED = 8;\nvar STATE_RECOGNIZED = STATE_ENDED;\nvar STATE_CANCELLED = 16;\nvar STATE_FAILED = 32;\n\n/**\n * Recognizer\n * Every recognizer needs to extend from this class.\n * @constructor\n * @param {Object} options\n */\nfunction Recognizer(options) {\n    this.options = assign({}, this.defaults, options || {});\n\n    this.id = uniqueId();\n\n    this.manager = null;\n\n    // default is enable true\n    this.options.enable = ifUndefined(this.options.enable, true);\n\n    this.state = STATE_POSSIBLE;\n\n    this.simultaneous = {};\n    this.requireFail = [];\n}\n\nRecognizer.prototype = {\n    /**\n     * @virtual\n     * @type {Object}\n     */\n    defaults: {},\n\n    /**\n     * set options\n     * @param {Object} options\n     * @return {Recognizer}\n     */\n    set: function(options) {\n        assign(this.options, options);\n\n        // also update the touchAction, in case something changed about the directions/enabled state\n        this.manager && this.manager.touchAction.update();\n        return this;\n    },\n\n    /**\n     * recognize simultaneous with an other recognizer.\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n    recognizeWith: function(otherRecognizer) {\n        if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {\n            return this;\n        }\n\n        var simultaneous = this.simultaneous;\n        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n        if (!simultaneous[otherRecognizer.id]) {\n            simultaneous[otherRecognizer.id] = otherRecognizer;\n            otherRecognizer.recognizeWith(this);\n        }\n        return this;\n    },\n\n    /**\n     * drop the simultaneous link. it doesnt remove the link on the other recognizer.\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n    dropRecognizeWith: function(otherRecognizer) {\n        if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {\n            return this;\n        }\n\n        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n        delete this.simultaneous[otherRecognizer.id];\n        return this;\n    },\n\n    /**\n     * recognizer can only run when an other is failing\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n    requireFailure: function(otherRecognizer) {\n        if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {\n            return this;\n        }\n\n        var requireFail = this.requireFail;\n        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n        if (inArray(requireFail, otherRecognizer) === -1) {\n            requireFail.push(otherRecognizer);\n            otherRecognizer.requireFailure(this);\n        }\n        return this;\n    },\n\n    /**\n     * drop the requireFailure link. it does not remove the link on the other recognizer.\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n    dropRequireFailure: function(otherRecognizer) {\n        if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {\n            return this;\n        }\n\n        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n        var index = inArray(this.requireFail, otherRecognizer);\n        if (index > -1) {\n            this.requireFail.splice(index, 1);\n        }\n        return this;\n    },\n\n    /**\n     * has require failures boolean\n     * @returns {boolean}\n     */\n    hasRequireFailures: function() {\n        return this.requireFail.length > 0;\n    },\n\n    /**\n     * if the recognizer can recognize simultaneous with an other recognizer\n     * @param {Recognizer} otherRecognizer\n     * @returns {Boolean}\n     */\n    canRecognizeWith: function(otherRecognizer) {\n        return !!this.simultaneous[otherRecognizer.id];\n    },\n\n    /**\n     * You should use `tryEmit` instead of `emit` directly to check\n     * that all the needed recognizers has failed before emitting.\n     * @param {Object} input\n     */\n    emit: function(input) {\n        var self = this;\n        var state = this.state;\n\n        function emit(event) {\n            self.manager.emit(event, input);\n        }\n\n        // 'panstart' and 'panmove'\n        if (state < STATE_ENDED) {\n            emit(self.options.event + stateStr(state));\n        }\n\n        emit(self.options.event); // simple 'eventName' events\n\n        if (input.additionalEvent) { // additional event(panleft, panright, pinchin, pinchout...)\n            emit(input.additionalEvent);\n        }\n\n        // panend and pancancel\n        if (state >= STATE_ENDED) {\n            emit(self.options.event + stateStr(state));\n        }\n    },\n\n    /**\n     * Check that all the require failure recognizers has failed,\n     * if true, it emits a gesture event,\n     * otherwise, setup the state to FAILED.\n     * @param {Object} input\n     */\n    tryEmit: function(input) {\n        if (this.canEmit()) {\n            return this.emit(input);\n        }\n        // it's failing anyway\n        this.state = STATE_FAILED;\n    },\n\n    /**\n     * can we emit?\n     * @returns {boolean}\n     */\n    canEmit: function() {\n        var i = 0;\n        while (i < this.requireFail.length) {\n            if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {\n                return false;\n            }\n            i++;\n        }\n        return true;\n    },\n\n    /**\n     * update the recognizer\n     * @param {Object} inputData\n     */\n    recognize: function(inputData) {\n        // make a new copy of the inputData\n        // so we can change the inputData without messing up the other recognizers\n        var inputDataClone = assign({}, inputData);\n\n        // is is enabled and allow recognizing?\n        if (!boolOrFn(this.options.enable, [this, inputDataClone])) {\n            this.reset();\n            this.state = STATE_FAILED;\n            return;\n        }\n\n        // reset when we've reached the end\n        if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {\n            this.state = STATE_POSSIBLE;\n        }\n\n        this.state = this.process(inputDataClone);\n\n        // the recognizer has recognized a gesture\n        // so trigger an event\n        if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {\n            this.tryEmit(inputDataClone);\n        }\n    },\n\n    /**\n     * return the state of the recognizer\n     * the actual recognizing happens in this method\n     * @virtual\n     * @param {Object} inputData\n     * @returns {Const} STATE\n     */\n    process: function(inputData) { }, // jshint ignore:line\n\n    /**\n     * return the preferred touch-action\n     * @virtual\n     * @returns {Array}\n     */\n    getTouchAction: function() { },\n\n    /**\n     * called when the gesture isn't allowed to recognize\n     * like when another is being recognized or it is disabled\n     * @virtual\n     */\n    reset: function() { }\n};\n\n/**\n * get a usable string, used as event postfix\n * @param {Const} state\n * @returns {String} state\n */\nfunction stateStr(state) {\n    if (state & STATE_CANCELLED) {\n        return 'cancel';\n    } else if (state & STATE_ENDED) {\n        return 'end';\n    } else if (state & STATE_CHANGED) {\n        return 'move';\n    } else if (state & STATE_BEGAN) {\n        return 'start';\n    }\n    return '';\n}\n\n/**\n * direction cons to string\n * @param {Const} direction\n * @returns {String}\n */\nfunction directionStr(direction) {\n    if (direction == DIRECTION_DOWN) {\n        return 'down';\n    } else if (direction == DIRECTION_UP) {\n        return 'up';\n    } else if (direction == DIRECTION_LEFT) {\n        return 'left';\n    } else if (direction == DIRECTION_RIGHT) {\n        return 'right';\n    }\n    return '';\n}\n\n/**\n * get a recognizer by name if it is bound to a manager\n * @param {Recognizer|String} otherRecognizer\n * @param {Recognizer} recognizer\n * @returns {Recognizer}\n */\nfunction getRecognizerByNameIfManager(otherRecognizer, recognizer) {\n    var manager = recognizer.manager;\n    if (manager) {\n        return manager.get(otherRecognizer);\n    }\n    return otherRecognizer;\n}\n\n/**\n * This recognizer is just used as a base for the simple attribute recognizers.\n * @constructor\n * @extends Recognizer\n */\nfunction AttrRecognizer() {\n    Recognizer.apply(this, arguments);\n}\n\ninherit(AttrRecognizer, Recognizer, {\n    /**\n     * @namespace\n     * @memberof AttrRecognizer\n     */\n    defaults: {\n        /**\n         * @type {Number}\n         * @default 1\n         */\n        pointers: 1\n    },\n\n    /**\n     * Used to check if it the recognizer receives valid input, like input.distance > 10.\n     * @memberof AttrRecognizer\n     * @param {Object} input\n     * @returns {Boolean} recognized\n     */\n    attrTest: function(input) {\n        var optionPointers = this.options.pointers;\n        return optionPointers === 0 || input.pointers.length === optionPointers;\n    },\n\n    /**\n     * Process the input and return the state for the recognizer\n     * @memberof AttrRecognizer\n     * @param {Object} input\n     * @returns {*} State\n     */\n    process: function(input) {\n        var state = this.state;\n        var eventType = input.eventType;\n\n        var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);\n        var isValid = this.attrTest(input);\n\n        // on cancel input and we've recognized before, return STATE_CANCELLED\n        if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {\n            return state | STATE_CANCELLED;\n        } else if (isRecognized || isValid) {\n            if (eventType & INPUT_END) {\n                return state | STATE_ENDED;\n            } else if (!(state & STATE_BEGAN)) {\n                return STATE_BEGAN;\n            }\n            return state | STATE_CHANGED;\n        }\n        return STATE_FAILED;\n    }\n});\n\n/**\n * Pan\n * Recognized when the pointer is down and moved in the allowed direction.\n * @constructor\n * @extends AttrRecognizer\n */\nfunction PanRecognizer() {\n    AttrRecognizer.apply(this, arguments);\n\n    this.pX = null;\n    this.pY = null;\n}\n\ninherit(PanRecognizer, AttrRecognizer, {\n    /**\n     * @namespace\n     * @memberof PanRecognizer\n     */\n    defaults: {\n        event: 'pan',\n        threshold: 10,\n        pointers: 1,\n        direction: DIRECTION_ALL\n    },\n\n    getTouchAction: function() {\n        var direction = this.options.direction;\n        var actions = [];\n        if (direction & DIRECTION_HORIZONTAL) {\n            actions.push(TOUCH_ACTION_PAN_Y);\n        }\n        if (direction & DIRECTION_VERTICAL) {\n            actions.push(TOUCH_ACTION_PAN_X);\n        }\n        return actions;\n    },\n\n    directionTest: function(input) {\n        var options = this.options;\n        var hasMoved = true;\n        var distance = input.distance;\n        var direction = input.direction;\n        var x = input.deltaX;\n        var y = input.deltaY;\n\n        // lock to axis?\n        if (!(direction & options.direction)) {\n            if (options.direction & DIRECTION_HORIZONTAL) {\n                direction = (x === 0) ? DIRECTION_NONE : (x < 0) ? DIRECTION_LEFT : DIRECTION_RIGHT;\n                hasMoved = x != this.pX;\n                distance = Math.abs(input.deltaX);\n            } else {\n                direction = (y === 0) ? DIRECTION_NONE : (y < 0) ? DIRECTION_UP : DIRECTION_DOWN;\n                hasMoved = y != this.pY;\n                distance = Math.abs(input.deltaY);\n            }\n        }\n        input.direction = direction;\n        return hasMoved && distance > options.threshold && direction & options.direction;\n    },\n\n    attrTest: function(input) {\n        return AttrRecognizer.prototype.attrTest.call(this, input) &&\n            (this.state & STATE_BEGAN || (!(this.state & STATE_BEGAN) && this.directionTest(input)));\n    },\n\n    emit: function(input) {\n\n        this.pX = input.deltaX;\n        this.pY = input.deltaY;\n\n        var direction = directionStr(input.direction);\n\n        if (direction) {\n            input.additionalEvent = this.options.event + direction;\n        }\n        this._super.emit.call(this, input);\n    }\n});\n\n/**\n * Pinch\n * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).\n * @constructor\n * @extends AttrRecognizer\n */\nfunction PinchRecognizer() {\n    AttrRecognizer.apply(this, arguments);\n}\n\ninherit(PinchRecognizer, AttrRecognizer, {\n    /**\n     * @namespace\n     * @memberof PinchRecognizer\n     */\n    defaults: {\n        event: 'pinch',\n        threshold: 0,\n        pointers: 2\n    },\n\n    getTouchAction: function() {\n        return [TOUCH_ACTION_NONE];\n    },\n\n    attrTest: function(input) {\n        return this._super.attrTest.call(this, input) &&\n            (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);\n    },\n\n    emit: function(input) {\n        if (input.scale !== 1) {\n            var inOut = input.scale < 1 ? 'in' : 'out';\n            input.additionalEvent = this.options.event + inOut;\n        }\n        this._super.emit.call(this, input);\n    }\n});\n\n/**\n * Press\n * Recognized when the pointer is down for x ms without any movement.\n * @constructor\n * @extends Recognizer\n */\nfunction PressRecognizer() {\n    Recognizer.apply(this, arguments);\n\n    this._timer = null;\n    this._input = null;\n}\n\ninherit(PressRecognizer, Recognizer, {\n    /**\n     * @namespace\n     * @memberof PressRecognizer\n     */\n    defaults: {\n        event: 'press',\n        pointers: 1,\n        time: 251, // minimal time of the pointer to be pressed\n        threshold: 9 // a minimal movement is ok, but keep it low\n    },\n\n    getTouchAction: function() {\n        return [TOUCH_ACTION_AUTO];\n    },\n\n    process: function(input) {\n        var options = this.options;\n        var validPointers = input.pointers.length === options.pointers;\n        var validMovement = input.distance < options.threshold;\n        var validTime = input.deltaTime > options.time;\n\n        this._input = input;\n\n        // we only allow little movement\n        // and we've reached an end event, so a tap is possible\n        if (!validMovement || !validPointers || (input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime)) {\n            this.reset();\n        } else if (input.eventType & INPUT_START) {\n            this.reset();\n            this._timer = setTimeoutContext(function() {\n                this.state = STATE_RECOGNIZED;\n                this.tryEmit();\n            }, options.time, this);\n        } else if (input.eventType & INPUT_END) {\n            return STATE_RECOGNIZED;\n        }\n        return STATE_FAILED;\n    },\n\n    reset: function() {\n        clearTimeout(this._timer);\n    },\n\n    emit: function(input) {\n        if (this.state !== STATE_RECOGNIZED) {\n            return;\n        }\n\n        if (input && (input.eventType & INPUT_END)) {\n            this.manager.emit(this.options.event + 'up', input);\n        } else {\n            this._input.timeStamp = now();\n            this.manager.emit(this.options.event, this._input);\n        }\n    }\n});\n\n/**\n * Rotate\n * Recognized when two or more pointer are moving in a circular motion.\n * @constructor\n * @extends AttrRecognizer\n */\nfunction RotateRecognizer() {\n    AttrRecognizer.apply(this, arguments);\n}\n\ninherit(RotateRecognizer, AttrRecognizer, {\n    /**\n     * @namespace\n     * @memberof RotateRecognizer\n     */\n    defaults: {\n        event: 'rotate',\n        threshold: 0,\n        pointers: 2\n    },\n\n    getTouchAction: function() {\n        return [TOUCH_ACTION_NONE];\n    },\n\n    attrTest: function(input) {\n        return this._super.attrTest.call(this, input) &&\n            (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);\n    }\n});\n\n/**\n * Swipe\n * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.\n * @constructor\n * @extends AttrRecognizer\n */\nfunction SwipeRecognizer() {\n    AttrRecognizer.apply(this, arguments);\n}\n\ninherit(SwipeRecognizer, AttrRecognizer, {\n    /**\n     * @namespace\n     * @memberof SwipeRecognizer\n     */\n    defaults: {\n        event: 'swipe',\n        threshold: 10,\n        velocity: 0.3,\n        direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,\n        pointers: 1\n    },\n\n    getTouchAction: function() {\n        return PanRecognizer.prototype.getTouchAction.call(this);\n    },\n\n    attrTest: function(input) {\n        var direction = this.options.direction;\n        var velocity;\n\n        if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {\n            velocity = input.overallVelocity;\n        } else if (direction & DIRECTION_HORIZONTAL) {\n            velocity = input.overallVelocityX;\n        } else if (direction & DIRECTION_VERTICAL) {\n            velocity = input.overallVelocityY;\n        }\n\n        return this._super.attrTest.call(this, input) &&\n            direction & input.offsetDirection &&\n            input.distance > this.options.threshold &&\n            input.maxPointers == this.options.pointers &&\n            abs(velocity) > this.options.velocity && input.eventType & INPUT_END;\n    },\n\n    emit: function(input) {\n        var direction = directionStr(input.offsetDirection);\n        if (direction) {\n            this.manager.emit(this.options.event + direction, input);\n        }\n\n        this.manager.emit(this.options.event, input);\n    }\n});\n\n/**\n * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur\n * between the given interval and position. The delay option can be used to recognize multi-taps without firing\n * a single tap.\n *\n * The eventData from the emitted event contains the property `tapCount`, which contains the amount of\n * multi-taps being recognized.\n * @constructor\n * @extends Recognizer\n */\nfunction TapRecognizer() {\n    Recognizer.apply(this, arguments);\n\n    // previous time and center,\n    // used for tap counting\n    this.pTime = false;\n    this.pCenter = false;\n\n    this._timer = null;\n    this._input = null;\n    this.count = 0;\n}\n\ninherit(TapRecognizer, Recognizer, {\n    /**\n     * @namespace\n     * @memberof PinchRecognizer\n     */\n    defaults: {\n        event: 'tap',\n        pointers: 1,\n        taps: 1,\n        interval: 300, // max time between the multi-tap taps\n        time: 250, // max time of the pointer to be down (like finger on the screen)\n        threshold: 9, // a minimal movement is ok, but keep it low\n        posThreshold: 10 // a multi-tap can be a bit off the initial position\n    },\n\n    getTouchAction: function() {\n        return [TOUCH_ACTION_MANIPULATION];\n    },\n\n    process: function(input) {\n        var options = this.options;\n\n        var validPointers = input.pointers.length === options.pointers;\n        var validMovement = input.distance < options.threshold;\n        var validTouchTime = input.deltaTime < options.time;\n\n        this.reset();\n\n        if ((input.eventType & INPUT_START) && (this.count === 0)) {\n            return this.failTimeout();\n        }\n\n        // we only allow little movement\n        // and we've reached an end event, so a tap is possible\n        if (validMovement && validTouchTime && validPointers) {\n            if (input.eventType != INPUT_END) {\n                return this.failTimeout();\n            }\n\n            var validInterval = this.pTime ? (input.timeStamp - this.pTime < options.interval) : true;\n            var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;\n\n            this.pTime = input.timeStamp;\n            this.pCenter = input.center;\n\n            if (!validMultiTap || !validInterval) {\n                this.count = 1;\n            } else {\n                this.count += 1;\n            }\n\n            this._input = input;\n\n            // if tap count matches we have recognized it,\n            // else it has began recognizing...\n            var tapCount = this.count % options.taps;\n            if (tapCount === 0) {\n                // no failing requirements, immediately trigger the tap event\n                // or wait as long as the multitap interval to trigger\n                if (!this.hasRequireFailures()) {\n                    return STATE_RECOGNIZED;\n                } else {\n                    this._timer = setTimeoutContext(function() {\n                        this.state = STATE_RECOGNIZED;\n                        this.tryEmit();\n                    }, options.interval, this);\n                    return STATE_BEGAN;\n                }\n            }\n        }\n        return STATE_FAILED;\n    },\n\n    failTimeout: function() {\n        this._timer = setTimeoutContext(function() {\n            this.state = STATE_FAILED;\n        }, this.options.interval, this);\n        return STATE_FAILED;\n    },\n\n    reset: function() {\n        clearTimeout(this._timer);\n    },\n\n    emit: function() {\n        if (this.state == STATE_RECOGNIZED) {\n            this._input.tapCount = this.count;\n            this.manager.emit(this.options.event, this._input);\n        }\n    }\n});\n\n/**\n * Simple way to create a manager with a default set of recognizers.\n * @param {HTMLElement} element\n * @param {Object} [options]\n * @constructor\n */\nfunction Hammer(element, options) {\n    options = options || {};\n    options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);\n    return new Manager(element, options);\n}\n\n/**\n * @const {string}\n */\nHammer.VERSION = '2.0.7';\n\n/**\n * default settings\n * @namespace\n */\nHammer.defaults = {\n    /**\n     * set if DOM events are being triggered.\n     * But this is slower and unused by simple implementations, so disabled by default.\n     * @type {Boolean}\n     * @default false\n     */\n    domEvents: false,\n\n    /**\n     * The value for the touchAction property/fallback.\n     * When set to `compute` it will magically set the correct value based on the added recognizers.\n     * @type {String}\n     * @default compute\n     */\n    touchAction: TOUCH_ACTION_COMPUTE,\n\n    /**\n     * @type {Boolean}\n     * @default true\n     */\n    enable: true,\n\n    /**\n     * EXPERIMENTAL FEATURE -- can be removed/changed\n     * Change the parent input target element.\n     * If Null, then it is being set the to main element.\n     * @type {Null|EventTarget}\n     * @default null\n     */\n    inputTarget: null,\n\n    /**\n     * force an input class\n     * @type {Null|Function}\n     * @default null\n     */\n    inputClass: null,\n\n    /**\n     * Default recognizer setup when calling `Hammer()`\n     * When creating a new Manager these will be skipped.\n     * @type {Array}\n     */\n    preset: [\n        // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]\n        [RotateRecognizer, {enable: false}],\n        [PinchRecognizer, {enable: false}, ['rotate']],\n        [SwipeRecognizer, {direction: DIRECTION_HORIZONTAL}],\n        [PanRecognizer, {direction: DIRECTION_HORIZONTAL}, ['swipe']],\n        [TapRecognizer],\n        [TapRecognizer, {event: 'doubletap', taps: 2}, ['tap']],\n        [PressRecognizer]\n    ],\n\n    /**\n     * Some CSS properties can be used to improve the working of Hammer.\n     * Add them to this method and they will be set when creating a new Manager.\n     * @namespace\n     */\n    cssProps: {\n        /**\n         * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.\n         * @type {String}\n         * @default 'none'\n         */\n        userSelect: 'none',\n\n        /**\n         * Disable the Windows Phone grippers when pressing an element.\n         * @type {String}\n         * @default 'none'\n         */\n        touchSelect: 'none',\n\n        /**\n         * Disables the default callout shown when you touch and hold a touch target.\n         * On iOS, when you touch and hold a touch target such as a link, Safari displays\n         * a callout containing information about the link. This property allows you to disable that callout.\n         * @type {String}\n         * @default 'none'\n         */\n        touchCallout: 'none',\n\n        /**\n         * Specifies whether zooming is enabled. Used by IE10>\n         * @type {String}\n         * @default 'none'\n         */\n        contentZooming: 'none',\n\n        /**\n         * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.\n         * @type {String}\n         * @default 'none'\n         */\n        userDrag: 'none',\n\n        /**\n         * Overrides the highlight color shown when the user taps a link or a JavaScript\n         * clickable element in iOS. This property obeys the alpha value, if specified.\n         * @type {String}\n         * @default 'rgba(0,0,0,0)'\n         */\n        tapHighlightColor: 'rgba(0,0,0,0)'\n    }\n};\n\nvar STOP = 1;\nvar FORCED_STOP = 2;\n\n/**\n * Manager\n * @param {HTMLElement} element\n * @param {Object} [options]\n * @constructor\n */\nfunction Manager(element, options) {\n    this.options = assign({}, Hammer.defaults, options || {});\n\n    this.options.inputTarget = this.options.inputTarget || element;\n\n    this.handlers = {};\n    this.session = {};\n    this.recognizers = [];\n    this.oldCssProps = {};\n\n    this.element = element;\n    this.input = createInputInstance(this);\n    this.touchAction = new TouchAction(this, this.options.touchAction);\n\n    toggleCssProps(this, true);\n\n    each(this.options.recognizers, function(item) {\n        var recognizer = this.add(new (item[0])(item[1]));\n        item[2] && recognizer.recognizeWith(item[2]);\n        item[3] && recognizer.requireFailure(item[3]);\n    }, this);\n}\n\nManager.prototype = {\n    /**\n     * set options\n     * @param {Object} options\n     * @returns {Manager}\n     */\n    set: function(options) {\n        assign(this.options, options);\n\n        // Options that need a little more setup\n        if (options.touchAction) {\n            this.touchAction.update();\n        }\n        if (options.inputTarget) {\n            // Clean up existing event listeners and reinitialize\n            this.input.destroy();\n            this.input.target = options.inputTarget;\n            this.input.init();\n        }\n        return this;\n    },\n\n    /**\n     * stop recognizing for this session.\n     * This session will be discarded, when a new [input]start event is fired.\n     * When forced, the recognizer cycle is stopped immediately.\n     * @param {Boolean} [force]\n     */\n    stop: function(force) {\n        this.session.stopped = force ? FORCED_STOP : STOP;\n    },\n\n    /**\n     * run the recognizers!\n     * called by the inputHandler function on every movement of the pointers (touches)\n     * it walks through all the recognizers and tries to detect the gesture that is being made\n     * @param {Object} inputData\n     */\n    recognize: function(inputData) {\n        var session = this.session;\n        if (session.stopped) {\n            return;\n        }\n\n        // run the touch-action polyfill\n        this.touchAction.preventDefaults(inputData);\n\n        var recognizer;\n        var recognizers = this.recognizers;\n\n        // this holds the recognizer that is being recognized.\n        // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED\n        // if no recognizer is detecting a thing, it is set to `null`\n        var curRecognizer = session.curRecognizer;\n\n        // reset when the last recognizer is recognized\n        // or when we're in a new session\n        if (!curRecognizer || (curRecognizer && curRecognizer.state & STATE_RECOGNIZED)) {\n            curRecognizer = session.curRecognizer = null;\n        }\n\n        var i = 0;\n        while (i < recognizers.length) {\n            recognizer = recognizers[i];\n\n            // find out if we are allowed try to recognize the input for this one.\n            // 1.   allow if the session is NOT forced stopped (see the .stop() method)\n            // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one\n            //      that is being recognized.\n            // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.\n            //      this can be setup with the `recognizeWith()` method on the recognizer.\n            if (session.stopped !== FORCED_STOP && ( // 1\n                    !curRecognizer || recognizer == curRecognizer || // 2\n                    recognizer.canRecognizeWith(curRecognizer))) { // 3\n                recognizer.recognize(inputData);\n            } else {\n                recognizer.reset();\n            }\n\n            // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the\n            // current active recognizer. but only if we don't already have an active recognizer\n            if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {\n                curRecognizer = session.curRecognizer = recognizer;\n            }\n            i++;\n        }\n    },\n\n    /**\n     * get a recognizer by its event name.\n     * @param {Recognizer|String} recognizer\n     * @returns {Recognizer|Null}\n     */\n    get: function(recognizer) {\n        if (recognizer instanceof Recognizer) {\n            return recognizer;\n        }\n\n        var recognizers = this.recognizers;\n        for (var i = 0; i < recognizers.length; i++) {\n            if (recognizers[i].options.event == recognizer) {\n                return recognizers[i];\n            }\n        }\n        return null;\n    },\n\n    /**\n     * add a recognizer to the manager\n     * existing recognizers with the same event name will be removed\n     * @param {Recognizer} recognizer\n     * @returns {Recognizer|Manager}\n     */\n    add: function(recognizer) {\n        if (invokeArrayArg(recognizer, 'add', this)) {\n            return this;\n        }\n\n        // remove existing\n        var existing = this.get(recognizer.options.event);\n        if (existing) {\n            this.remove(existing);\n        }\n\n        this.recognizers.push(recognizer);\n        recognizer.manager = this;\n\n        this.touchAction.update();\n        return recognizer;\n    },\n\n    /**\n     * remove a recognizer by name or instance\n     * @param {Recognizer|String} recognizer\n     * @returns {Manager}\n     */\n    remove: function(recognizer) {\n        if (invokeArrayArg(recognizer, 'remove', this)) {\n            return this;\n        }\n\n        recognizer = this.get(recognizer);\n\n        // let's make sure this recognizer exists\n        if (recognizer) {\n            var recognizers = this.recognizers;\n            var index = inArray(recognizers, recognizer);\n\n            if (index !== -1) {\n                recognizers.splice(index, 1);\n                this.touchAction.update();\n            }\n        }\n\n        return this;\n    },\n\n    /**\n     * bind event\n     * @param {String} events\n     * @param {Function} handler\n     * @returns {EventEmitter} this\n     */\n    on: function(events, handler) {\n        if (events === undefined) {\n            return;\n        }\n        if (handler === undefined) {\n            return;\n        }\n\n        var handlers = this.handlers;\n        each(splitStr(events), function(event) {\n            handlers[event] = handlers[event] || [];\n            handlers[event].push(handler);\n        });\n        return this;\n    },\n\n    /**\n     * unbind event, leave emit blank to remove all handlers\n     * @param {String} events\n     * @param {Function} [handler]\n     * @returns {EventEmitter} this\n     */\n    off: function(events, handler) {\n        if (events === undefined) {\n            return;\n        }\n\n        var handlers = this.handlers;\n        each(splitStr(events), function(event) {\n            if (!handler) {\n                delete handlers[event];\n            } else {\n                handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);\n            }\n        });\n        return this;\n    },\n\n    /**\n     * emit event to the listeners\n     * @param {String} event\n     * @param {Object} data\n     */\n    emit: function(event, data) {\n        // we also want to trigger dom events\n        if (this.options.domEvents) {\n            triggerDomEvent(event, data);\n        }\n\n        // no handlers, so skip it all\n        var handlers = this.handlers[event] && this.handlers[event].slice();\n        if (!handlers || !handlers.length) {\n            return;\n        }\n\n        data.type = event;\n        data.preventDefault = function() {\n            data.srcEvent.preventDefault();\n        };\n\n        var i = 0;\n        while (i < handlers.length) {\n            handlers[i](data);\n            i++;\n        }\n    },\n\n    /**\n     * destroy the manager and unbinds all events\n     * it doesn't unbind dom events, that is the user own responsibility\n     */\n    destroy: function() {\n        this.element && toggleCssProps(this, false);\n\n        this.handlers = {};\n        this.session = {};\n        this.input.destroy();\n        this.element = null;\n    }\n};\n\n/**\n * add/remove the css properties as defined in manager.options.cssProps\n * @param {Manager} manager\n * @param {Boolean} add\n */\nfunction toggleCssProps(manager, add) {\n    var element = manager.element;\n    if (!element.style) {\n        return;\n    }\n    var prop;\n    each(manager.options.cssProps, function(value, name) {\n        prop = prefixed(element.style, name);\n        if (add) {\n            manager.oldCssProps[prop] = element.style[prop];\n            element.style[prop] = value;\n        } else {\n            element.style[prop] = manager.oldCssProps[prop] || '';\n        }\n    });\n    if (!add) {\n        manager.oldCssProps = {};\n    }\n}\n\n/**\n * trigger dom event\n * @param {String} event\n * @param {Object} data\n */\nfunction triggerDomEvent(event, data) {\n    var gestureEvent = document.createEvent('Event');\n    gestureEvent.initEvent(event, true, true);\n    gestureEvent.gesture = data;\n    data.target.dispatchEvent(gestureEvent);\n}\n\nassign(Hammer, {\n    INPUT_START: INPUT_START,\n    INPUT_MOVE: INPUT_MOVE,\n    INPUT_END: INPUT_END,\n    INPUT_CANCEL: INPUT_CANCEL,\n\n    STATE_POSSIBLE: STATE_POSSIBLE,\n    STATE_BEGAN: STATE_BEGAN,\n    STATE_CHANGED: STATE_CHANGED,\n    STATE_ENDED: STATE_ENDED,\n    STATE_RECOGNIZED: STATE_RECOGNIZED,\n    STATE_CANCELLED: STATE_CANCELLED,\n    STATE_FAILED: STATE_FAILED,\n\n    DIRECTION_NONE: DIRECTION_NONE,\n    DIRECTION_LEFT: DIRECTION_LEFT,\n    DIRECTION_RIGHT: DIRECTION_RIGHT,\n    DIRECTION_UP: DIRECTION_UP,\n    DIRECTION_DOWN: DIRECTION_DOWN,\n    DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,\n    DIRECTION_VERTICAL: DIRECTION_VERTICAL,\n    DIRECTION_ALL: DIRECTION_ALL,\n\n    Manager: Manager,\n    Input: Input,\n    TouchAction: TouchAction,\n\n    TouchInput: TouchInput,\n    MouseInput: MouseInput,\n    PointerEventInput: PointerEventInput,\n    TouchMouseInput: TouchMouseInput,\n    SingleTouchInput: SingleTouchInput,\n\n    Recognizer: Recognizer,\n    AttrRecognizer: AttrRecognizer,\n    Tap: TapRecognizer,\n    Pan: PanRecognizer,\n    Swipe: SwipeRecognizer,\n    Pinch: PinchRecognizer,\n    Rotate: RotateRecognizer,\n    Press: PressRecognizer,\n\n    on: addEventListeners,\n    off: removeEventListeners,\n    each: each,\n    merge: merge,\n    extend: extend,\n    assign: assign,\n    inherit: inherit,\n    bindFn: bindFn,\n    prefixed: prefixed\n});\n\n// this prevents errors when Hammer is loaded in the presence of an AMD\n//  style loader but by script tag, not by the loader.\nvar freeGlobal = (typeof window !== 'undefined' ? window : (typeof self !== 'undefined' ? self : {})); // jshint ignore:line\nfreeGlobal.Hammer = Hammer;\n\nif (typeof define === 'function' && define.amd) {\n    define(function() {\n        return Hammer;\n    });\n} else if (typeof module != 'undefined' && module.exports) {\n    module.exports = Hammer;\n} else {\n    window[exportName] = Hammer;\n}\n\n})(window, document, 'Hammer');\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/hammerjs/hammer.js\n// module id = 5\n// module chunks = 0","import '../scss/app.scss';\n\n// import Bootstrap\nimport 'popper.js';\nimport 'bootstrap/js/dist/util';\nimport 'bootstrap/js/dist/alert';\nimport 'bootstrap/js/dist/button';\nimport 'bootstrap/js/dist/carousel';\nimport 'bootstrap/js/dist/collapse';\nimport 'bootstrap/js/dist/dropdown';\nimport 'bootstrap/js/dist/modal';\nimport 'bootstrap/js/dist/tooltip';\nimport 'bootstrap/js/dist/popover';\nimport 'bootstrap/js/dist/scrollspy';\nimport 'bootstrap/js/dist/tab';\n//\n\n//import Vue from 'vue/dist/vue.esm.js';\n\n// import Bootstrap-Vue\n/*import { Carousel } from 'bootstrap-vue/es/components';\nVue.use(Carousel);*/\n\nimport 'offcanvas-bootstrap/dist/js/bootstrap.offcanvas';\n\n// import your custom UI components\nimport './main';\n\nfunction importAll(r) {\n    return r.keys().map(r);\n}\n\nconst images = importAll(require.context('../img/', false, /\\.(png|jpe?g|svg)$/));\nconst fontAwesome = importAll(require.context('font-awesome', false, /\\.(otf|eot|svg|ttf|woff|woff2)$/));\n\n\n// WEBPACK FOOTER //\n// ./app/client/src/js/app.js","import $ from 'jquery';\n\nconst SpinnerUI = (($) => {\n  class SpinnerUI {\n    static show(callback) {\n      $('#PageLoading').show(0, callback);\n    }\n\n    static hide(callback) {\n      $('#PageLoading').hide('slow', callback);\n    }\n  }\n\n  return SpinnerUI;\n})($);\n\nexport default SpinnerUI;\n\n\n\n// WEBPACK FOOTER //\n// ./app/client/src/js/_components/_ui.spinner.js","import $ from 'jquery';\n\nimport Events from '../_events';\n\nconst CarouselUI = (($) => {\n    // Constants\n    const NAME = 'CarouselUI';\n\n    class CarouselUI {\n        // Static methods\n\n        static each(callback) {\n            $('.js-carousel').each(function(i, e) {\n                callback(i, $(e));\n            });\n        }\n\n        static init() {\n            this.dispose();\n\n            this.each((i, e) => {\n                const $e = $(e),\n                    id = `Carousel${i}`;\n\n                $e.attr('id', id);\n                $e.data('id', i);\n\n                const $items = $(e).find('.carousel-item'),\n                    count = $items.length;\n                if (!count) {\n                    return;\n                }\n\n                // create carousel-controls\n                if ($e.data('indicators')) {\n                    const $indicators = $('<ol class=\"carousel-indicators\"></ol>');\n                    $indicators.append('<li data-target=\"#' + id + '\" data-slide-to=\"0\" class=\"active\"></li>');\n                    for (let i = 1; i < count; i++) {\n                        $indicators.append('<li data-target=\"#' + id + '\" data-slide-to=\"' + i + '\"></li>');\n                    }\n                    $e.prepend($indicators);\n                }\n\n                // create arrows\n                if ($e.data('arrows')) {\n                    $e.prepend('<i class=\"carousel-control-prev\" data-target=\"#' + id + '\" role=\"button\" data-slide=\"prev\"><i class=\"fas fa-chevron-left\" aria-hidden=\"true\"></i><i class=\"sr-only\">Previous</i></i>');\n                    $e.prepend('<i class=\"carousel-control-next\" data-target=\"#' + id + '\" role=\"button\" data-slide=\"next\"><i class=\"fas fa-chevron-right\" aria-hidden=\"true\"></i><i class=\"sr-only\">Next</i></i>');\n                }\n\n                // init carousel\n                $e.carousel();\n\n                // init touch swipes\n                $e.hammer().bind('swipeleft', (event) => {\n                    $(event.target).carousel('next');\n                });\n\n                $e.hammer().bind('swiperight', (event) => {\n                    $(event.target).carousel('prev');\n                });\n\n                $e.hammer().bind('panleft', (event) => {\n                    $(event.target).carousel('next');\n                });\n\n                $e.hammer().bind('panright', (event) => {\n                    $(event.target).carousel('prev');\n                });\n\n                $e.hammer().bind('tap', (event) => {\n                    $(event.target).carousel('next');\n                });\n            });\n        }\n\n        static dispose() {\n            this.each((i, e) => {\n                $(e).carousel('dispose');\n            });\n        }\n    }\n\n    $(window).on(`${Events.AJAX} ${Events.LOADED}`, () => {\n        CarouselUI.init();\n    });\n\n    return CarouselUI;\n})($);\n\nexport default CarouselUI;\n\n\n// WEBPACK FOOTER //\n// ./app/client/src/js/_components/_ui.carousel.js","import $ from 'jquery';\n\nconst SlidingMenu = (($) => {\n  // Constants\n  const NAME = 'jsSlidingMenu';\n  const DATA_KEY = NAME;\n\n  class SlidingMenu {\n    // Constructor\n    constructor(element) {\n      this._element = element;\n      const $element = $(this._element);\n      $element.addClass(`${NAME}-active`);\n\n      // esc button\n      $(window).on('keyup',((e) => {\n        if (e.which === 27) {\n          $element.find('.is-open[data-toggle=\"offcanvas\"]').click();\n        }\n      }));\n    }\n\n    // Public methods\n    dispose() {\n      console.log(`Disposing: ${NAME} elements`);\n\n      $(this._element).removeClass(`${NAME}-active`);\n      $.removeData(this._element, DATA_KEY);\n      this._element = null;\n    }\n\n    static _jQueryInterface() {\n      return this.each(function () {\n        // attach functionality to element\n        const $element = $(this);\n        let data = $element.data(DATA_KEY);\n\n        if (!data) {\n          data = new SlidingMenu(this);\n          $element.data(DATA_KEY, data);\n        }\n      });\n    }\n  }\n\n  // jQuery interface\n  $.fn[NAME] = SlidingMenu._jQueryInterface;\n  $.fn[NAME].Constructor = SlidingMenu;\n  $.fn[NAME].noConflict = function () {\n    $.fn[NAME] = JQUERY_NO_CONFLICT;\n    return SlidingMenu._jQueryInterface;\n  };\n\n  // auto-apply\n  $(`.ui.${NAME}`).ready(() => {\n    $(`.ui.${NAME}`).jsSlidingMenu();\n  });\n\n  return SlidingMenu;\n})($);\n\nexport default SlidingMenu;\n\n\n\n// WEBPACK FOOTER //\n// ./app/client/src/js/_components/_ui.menu.js","import $ from 'jquery';\nimport Events from \"../_events\";\n\nconst FormStorage = (($) => {\n  // Constants\n  const NAME = 'jsFormStorage';\n  const DATA_KEY = NAME;\n  const STORAGE = window.localStorage;\n\n  class FormStorage {\n    // Constructor\n    constructor(element) {\n      this._element = element;\n      const $element = $(this._element);\n      const $elements = $element.find('input,textarea');\n\n      $element.addClass(`${NAME}-active`);\n\n      // restore form data from localStorage\n      $elements.each(function () {\n        const id = $(this).attr('id');\n        const type = $(this).attr('type');\n        const val = STORAGE.getItem(NAME + id);\n\n        if (id && val && type) {\n          if (type && (type === 'checkbox' || type === 'radio')) {\n            $(this).prop('checked', val);\n          } else {\n            $(this).val(val);\n          }\n        }\n      });\n\n      // store form data into localStorage\n      $elements.change(function () {\n        const id = $(this).attr('id');\n        const type = $(this).attr('type');\n        let val = $(this).val();\n\n        if (type && (type === 'checkbox' || type === 'radio')) {\n          val = !!$(this).is(':checked');\n        }\n\n        if (id && type && type !== 'password') {\n          STORAGE.setItem(NAME + id, val);\n        }\n      });\n\n      $element.submit(() => {\n        $element.data(DATA_KEY).clear();\n      });\n\n      $element.find('button,[type=\"submit\"],[type=\"clear\"]').click(() => {\n        $element.data(DATA_KEY).clear();\n      });\n    }\n\n    // Public methods\n    dispose() {\n      const $element = $(this._element);\n\n      $element.removeClass(`${NAME}-active`);\n      $.removeData(this._element, DATA_KEY);\n      this._element = null;\n    }\n\n    clear() {\n      STORAGE.clear();\n    }\n\n    static _jQueryInterface() {\n      if (typeof window.localStorage !== 'undefined') {\n        return this.each(function () {\n          // attach functionality to element\n          const $element = $(this);\n          let data = $element.data(DATA_KEY);\n\n          if (!data) {\n            data = new FormStorage(this);\n            $element.data(DATA_KEY, data);\n          }\n        });\n      }\n    }\n  }\n\n  // jQuery interface\n  $.fn[NAME] = FormStorage._jQueryInterface;\n  $.fn[NAME].Constructor = FormStorage;\n  $.fn[NAME].noConflict = function () {\n    $.fn[NAME] = JQUERY_NO_CONFLICT;\n    return FormStorage._jQueryInterface;\n  };\n\n  // auto-apply\n  $(window).on(`${Events.AJAX} ${Events.LOADED}`, () => {\n    $('form').jsFormStorage();\n  });\n\n  return FormStorage;\n})($);\n\nexport default FormStorage;\n\n\n\n// WEBPACK FOOTER //\n// ./app/client/src/js/_components/_ui.form.storage.js","\"use strict\";\n\nimport $ from 'jquery';\nimport Events from '../_events';\nimport Spinner from './_ui.spinner';\n\nconst AjaxUI = (($) => {\n  // Constants\n  const G = window;\n  const D = document;\n  const $Html = $('html');\n  const $Body = $('body');\n\n  const NAME = 'jsAjaxUI';\n  const DATA_KEY = NAME;\n\n  class AjaxUI {\n    // Constructor\n    constructor(element) {\n      this._element = element;\n      const $element = $(this._element);\n      $element.addClass(`${NAME}-active`);\n\n      $element.bind('click', function (e) {\n        e.preventDefault();\n\n        const $this = $(this);\n\n        $('.ajax').each(function () {\n          const $this = $(this);\n          $this.removeClass('active');\n          $this.parents('.nav-item').removeClass('active');\n        });\n\n        $this.addClass('loading');\n\n        AjaxUI.load($this.attr('href'), () => {\n          $this.removeClass('loading');\n          $this.parents('.nav-item').addClass('active');\n          $this.addClass('active');\n        });\n      });\n    }\n\n    // Public methods\n    static load(url, callback) {\n      // show spinner\n      Spinner.show(() => {\n        $Body.removeClass('loaded');\n      });\n\n      // update document location\n      G.MainUI.updateLocation(url);\n\n      const absoluteLocation = G.URLDetails['base'] + G.URLDetails['relative'].substring(1);\n      if (absoluteLocation !== G.location.href) {\n        G.history.pushState({\n          ajax: true,\n          page: absoluteLocation,\n        }, document.title, absoluteLocation);\n      }\n\n      $.ajax({\n        sync: false,\n        async: true,\n        url,\n        dataType: 'json',\n        method: 'GET',\n        cache: false,\n        error(jqXHR) {\n          console.warn(`AJAX request failure: ${jqXHR.statusText}`);\n          G.location.href = url;\n\n          // google analytics\n          if (typeof G.ga === 'function') {\n            G.ga('send', 'event', 'error', 'AJAX ERROR', jqXHR.statusText);\n          }\n        },\n        success(data, status, jqXHR) {\n          AjaxUI.process(data,jqXHR, callback);\n\n          // google analytics\n          if (typeof G.ga === 'function') {\n            G.ga('set', {\n              page: G.URLDetails['relative'] + G.URLDetails['hash'],\n              title: jqXHR.getResponseHeader('X-Title'),\n            });\n            G.ga('send', 'pageview');\n          }\n        },\n      });\n    }\n\n    static process(data, jqXHR, callback) {\n      const css = jqXHR.getResponseHeader('X-Include-CSS').split(',') || [];\n      const js = jqXHR.getResponseHeader('X-Include-JS').split(',') || [];\n\n      // Replace HTML regions\n      if (typeof (data.regions) === 'object') {\n        for (const key in data.regions) {\n          if (typeof (data.regions[key]) === 'string') {\n            AjaxUI.replaceRegion(data.regions[key], key);\n          }\n        }\n      }\n\n      // remove already loaded scripts\n      $('link[type=\"text/css\"]').each(function () {\n        const i = css.indexOf($(this).attr('href'));\n        if (i > -1) {\n          css.splice(i, 1);\n        }else if(!$Body.data('unload-blocked')) {\n          console.log(`Unloading: ${  $(this).attr('href')}`);\n          $(this).remove();\n        }\n      });\n\n      $('script[type=\"text/javascript\"]').each(function () {\n        const i = js.indexOf($(this).attr('src'));\n        if (i > -1) {\n          js.splice(i, 1);\n        }else if(!$Body.data('unload-blocked')) {\n          console.log(`Unloading: ${  $(this).attr('src')}`);\n          $(this).remove();\n        }\n      });\n\n      // preload CSS\n      this.preload(css).then(() => {\n        const $head = $('head');\n        css.forEach((el) => {\n          $head.append(`<link rel=\"stylesheet\" type=\"text/css\" href=\"${el}\" />`);\n        });\n\n        // preload JS\n        this.preload(js, 'script').then(() => {\n\n          js.forEach((el) => {\n            $Body.append(`<script type=\"text/javascript\" charset=\"UTF-8\" src=\"${el}\"></script>`);\n          });\n\n          console.log('New page is loaded!');\n\n          // trigger events\n          if (typeof (data.events) === 'object') {\n            for (const eventName in data.events) {\n              $(D).trigger(eventName, [data.events[eventName]]);\n            }\n          }\n\n          if (typeof callback !== 'undefined') {\n            callback();\n          }\n\n          $(G).trigger(Events.AJAX);\n        });\n      });\n    }\n\n    static preload(items, type = 'text', cache = true) {\n      if (!items.length) {\n        return $.Deferred().resolve().promise();\n      }\n\n      const dfds = [];\n      items.forEach((url) => {\n        const dfd = $.Deferred();\n\n        $.ajax({\n          dataType: type,\n          cache,\n          url,\n        }).always(() => {\n          dfd.resolve();\n        });\n\n        dfds.push(dfd);\n      });\n\n      // return a master promise object which will resolve when all the deferred objects have resolved\n      return $.when(...dfds);\n    }\n\n    static replaceRegion(html, key) {\n      const $region = $(`[data-ajax-region=\"${key}\"]`);\n\n      if ($region.length) {\n        $region.empty().append(html);\n      } else {\n        console.warn('Region returned without class or id!');\n      }\n    }\n\n    dispose() {\n      const $element = $(this._element);\n\n      $element.removeClass(`${NAME}-active`);\n      $.removeData(this._element, DATA_KEY);\n      this._element = null;\n    }\n\n    static _jQueryInterface() {\n      return this.each(function () {\n        // attach functionality to element\n        const $element = $(this);\n        let data = $element.data(DATA_KEY);\n\n        if (!data) {\n          data = new AjaxUI(this);\n          $element.data(DATA_KEY, data);\n        }\n      });\n    }\n  }\n\n  // jQuery interface\n  $.fn[NAME] = AjaxUI._jQueryInterface;\n  $.fn[NAME].Constructor = AjaxUI;\n  $.fn[NAME].noConflict = function () {\n    $.fn[NAME] = JQUERY_NO_CONFLICT;\n    return AjaxUI._jQueryInterface;\n  };\n\n  // auto-apply\n  $('.ajax').ready(() => {\n    $('.ajax').jsAjaxUI();\n  });\n\n  // AJAX update browser title\n  $(D).on('layoutRefresh', (e, data) => {\n    D.title = data.Title;\n\n    $Html.attr('class','');\n    if(data.ClassName){\n      $Html.addClass(data.ClassName);\n    }\n    //data.Link = (data.Link === '/home/') ? '/' : data.Link;\n  });\n\n  // Back/Forward functionality\n  G.onpopstate = function(event) {\n    const $existingLink = $(`a[href^=\"${  D.location  }\"]`);\n\n    if(event.state !== null && event.state.ajax){\n      console.log('GOBACK (AJAX state)');\n      AjaxUI.load(event.state.page);\n    }else if($existingLink.length && $existingLink.hasClass('ajax')){\n      console.log('GOBACK (AJAX link)');\n      $existingLink.trigger('click');\n    }else{\n      console.log('GOBACK (HTTP)');\n      G.location.href = D.location;\n    }\n  };\n\n  return AjaxUI;\n})($);\n\nexport default AjaxUI;\n\n\n\n// WEBPACK FOOTER //\n// ./app/client/src/js/_components/_ui.ajax.js","\"use strict\";\n\nimport $ from 'jquery';\n\nimport 'hammerjs/hammer';\nimport 'jquery-hammerjs/jquery.hammer';\n\n// Routie\nimport 'pouchdb/dist/pouchdb';\nimport './_components/routes/index';\n\nimport Events from './_events';\nimport Spinner from './_components/_ui.spinner';\n\nimport './_components/_ui.carousel';\nimport './_components/_ui.menu';\nimport './_components/_ui.form.storage';\nimport AjaxUI from './_components/_ui.ajax';\n\nimport SmoothScroll from 'smooth-scroll';\nconst smoothScroll = SmoothScroll();\n\nconst MainUI = (($) => {\n    // Constants\n    const W = window;\n    const D = document;\n    const $Body = $('body');\n\n    const NAME = 'MainUI';\n\n    // get browser locale\n    //const Locale = $('html').attr('lang').substring(0, 2);\n\n    const $AlertNotify = $('#AlertNotify');\n    const $SiteWideMessage = $('#SiteWideMessage');\n\n    // get browser window visibility preferences\n    // Opera 12.10, Firefox >=18, Chrome >=31, IE11\n    const HiddenName = 'hidden';\n    const VisibilityChangeEvent = 'visibilitychange';\n\n    // update visibility state\n    D.addEventListener(VisibilityChangeEvent, () => {\n        if (D.visibilityState === HiddenName) {\n            console.log('Tab: hidden');\n            $Body.addClass('is-hidden');\n            $Body.trigger('tabHidden');\n        } else {\n            console.log('Tab: focused');\n            $Body.removeClass('is-hidden');\n            $Body.trigger('tabFocused');\n        }\n    });\n\n\n    // update online/offline state\n    const updateOnlineStatus = function() {\n        if (!navigator.onLine) {\n            console.log('Tab: offline');\n            $Body.addClass('is-offline');\n            $Body.trigger('offline');\n        } else {\n            console.log('Tab: online');\n            $Body.removeClass('is-offline');\n            $Body.trigger('online');\n        }\n    };\n\n    if (typeof navigator.onLine !== 'undefined') {\n        W.addEventListener('offline', () => {\n            updateOnlineStatus();\n        }, false);\n\n        W.addEventListener('online', () => {\n            updateOnlineStatus();\n        }, false);\n\n        W.addEventListener('load', () => {\n            updateOnlineStatus();\n        });\n    }\n\n    // scrollTo\n    const ScrollTo = function(trigger, selector) {\n        smoothScroll.animateScroll(\n            D.querySelector(selector),\n            trigger, {\n                speed: 500,\n                offset: -20,\n                //easing: 'easeInOutCubic',\n                // Callback API\n                //before: function (anchor, toggle) {}, // Callback to run before scroll\n                //`after: function (anchor, toggle) {} // Callback to run after scroll\n            }\n        );\n    };\n\n    // session ping\n    setInterval(() => {\n        if ($Body.hasClass('is-offline')) {\n            return;\n        }\n\n        $.ajax({\n            sync: false,\n            async: true,\n            cache: false,\n            url: '/Security/ping',\n            global: false,\n            type: 'POST',\n            complete(data, datastatus) {\n                if (datastatus !== 'success') {\n                    W.location.reload(false);\n                }\n            },\n        });\n    }, 300000); // 5 min in ms\n\n    W.URLDetails = {\n        'base': $('base').attr('href'),\n        'relative': '/',\n        'hash': '',\n    };\n\n    class MainUI {\n        // Static methods\n\n        static init() {\n            this.dispose();\n\n            console.log(`Initializing: ${NAME}`);\n\n            // update location details\n            this.updateLocation();\n\n            // mark available offline areas\n            if ('caches' in W) {\n                $('a.offline').addClass('offline-available');\n            }\n\n            this.loadImages();\n\n            // mark external links\n            $('a.external,a[rel=\"external\"]').attr('target', '_blank');\n\n            // show encoded emails\n            /*$(D).find('.obm').each(function () {\n              if ($(this).attr('data-val') !== undefined) {\n                const email = $(this).attr('data-val').split('')\n                  .reverse()\n                  .join('')\n                  .slice(0, -8)\n                  .replace(/[a-zA-Z]/g, (c) => String.fromCharCode((c <= 'Z' ? 90 : 122) >= (c = c.charCodeAt(0) + 13) ? c : c - 26))\n                  .replace('#AT#', '@');\n                const attr = $(this).attr('data-val-append');\n                if (attr !== undefined && attr !== false) {\n                  $(this).append(email);\n                }\n                if ($(this).find('.sr-only').length > 0) {\n                  $(this).find('.sr-only').append(email);\n                }\n                if ($(this).attr('href') !== undefined) {\n                  $(this).attr('href', `mailto:${email}`);\n                }\n              }\n            });*/\n            //\n\n            // scroll links\n            $(D).on('click', '.js-scrollTo', function(e) {\n                e.preventDefault();\n                ScrollTo(this, $(this).attr('data-target'));\n            });\n\n            // load external fonts\n            if ($('[data-extfont]').length) {\n                $.getScript('//ajax.googleapis.com/ajax/libs/webfont/1/webfont.js', () => {\n                    const fonts = [];\n                    $('[data-extfont]').each(function(i) {\n                        fonts[i] = $(this).attr('data-extfont');\n                    });\n                    W.WebFont.load({\n                        google: {\n                            families: fonts,\n                        },\n                    });\n                });\n            }\n\n            // hide spinner\n            Spinner.hide(() => {\n                $Body.addClass('loaded');\n            });\n\n            // fire page printing\n            if (W.URLDetails['hash'].indexOf('printpage') > -1) {\n                W.print();\n            }\n        }\n\n        static updateLocation(url) {\n            let location = url || W.location.href;\n            location = location.replace(W.URLDetails['base'], '/');\n            const hash = location.indexOf('#');\n\n            W.URLDetails.relative = location.split('#')[0];\n            W.URLDetails.hash = (hash >= 0) ? location.substr(location.indexOf('#')) : '';\n        }\n\n        // show site-wide alert\n        static alert(msg, cls) {\n            $SiteWideMessage.fadeOut('fast');\n\n            $SiteWideMessage.html(`<div class=\"page-alert\"><div class=\"alert alert-${cls}\"><i class=\"close\" data-dismiss=\"alert\">&times;</i>${msg}</div></div>`);\n            $SiteWideMessage.find('.page-alert').alert();\n\n            $SiteWideMessage.find('.close[data-dismiss=\"alert\"]').click(() => {\n                $SiteWideMessage.fadeOut('slow', () => {\n                    $SiteWideMessage.find('.page-alert').alert('close');\n                });\n            });\n\n            $SiteWideMessage.fadeIn('slow');\n\n            if ($AlertNotify.length) {\n                $AlertNotify[0].play();\n            }\n\n            $(W).trigger('alert-appeared');\n        }\n\n        // hide site-wide alert\n        static alertHide() {\n            if ($SiteWideMessage.length !== 0) {\n                $SiteWideMessage.fadeOut('slow', () => {\n                    $SiteWideMessage.find('.alert').alert('close');\n                });\n            }\n\n            if (\n                $AlertNotify.length &&\n                typeof $AlertNotify[0].stop !== 'undefined'\n            ) {\n                $AlertNotify[0].stop();\n            }\n\n            $(W).trigger('alert-removed');\n        }\n\n        // load all images\n        static loadImages() {\n            const $imgs = $Body.find('img');\n            const $imgUrls = [];\n            const $imgLazyUrls = [];\n\n            // collect image details\n            $imgs.each(function() {\n                const src = $(this).attr('src');\n                const lazySrc = $(this).data('lazy-src');\n                if (src.length) {\n                    $imgUrls.push(src);\n                }\n                if (lazySrc) {\n                    $imgLazyUrls.push(lazySrc);\n                }\n            });\n\n            // load defined images\n            AjaxUI.preload($imgUrls).then(() => {\n                $(W).trigger('images-loaded');\n\n                // load lazy images\n                AjaxUI.preload($imgLazyUrls).then(() => {\n                    // update lazy img src\n                    $('img[data-lazy-src]').each(function() {\n                        if (!$(this).attr('src')) {\n                            return;\n                        }\n                        $(this).attr('src', $(this).data('lazy-src'));\n                    });\n\n                    console.log('All images are loaded!');\n\n                    $(W).trigger('images-lazy-loaded');\n                });\n            });\n        }\n\n        static dispose() {\n            console.log(`Destroying: ${NAME}`);\n        }\n    }\n\n    $(W).on(`${Events.AJAX} ${Events.LOADED}`, () => {\n        MainUI.init();\n    });\n\n    W.MainUI = MainUI;\n\n    return MainUI;\n})($);\n\nexport default MainUI;\n\n\n// WEBPACK FOOTER //\n// ./app/client/src/js/main.js","/**\n * --------------------------------------------------------------------------\n * Bootstrap (v4.1.1): util.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n * --------------------------------------------------------------------------\n */\nvar Util = function ($) {\n  /**\n   * ------------------------------------------------------------------------\n   * Private TransitionEnd Helpers\n   * ------------------------------------------------------------------------\n   */\n  var TRANSITION_END = 'transitionend';\n  var MAX_UID = 1000000;\n  var MILLISECONDS_MULTIPLIER = 1000; // Shoutout AngusCroll (https://goo.gl/pxwQGp)\n\n  function toType(obj) {\n    return {}.toString.call(obj).match(/\\s([a-z]+)/i)[1].toLowerCase();\n  }\n\n  function getSpecialTransitionEndEvent() {\n    return {\n      bindType: TRANSITION_END,\n      delegateType: TRANSITION_END,\n      handle: function handle(event) {\n        if ($(event.target).is(this)) {\n          return event.handleObj.handler.apply(this, arguments); // eslint-disable-line prefer-rest-params\n        }\n\n        return undefined; // eslint-disable-line no-undefined\n      }\n    };\n  }\n\n  function transitionEndEmulator(duration) {\n    var _this = this;\n\n    var called = false;\n    $(this).one(Util.TRANSITION_END, function () {\n      called = true;\n    });\n    setTimeout(function () {\n      if (!called) {\n        Util.triggerTransitionEnd(_this);\n      }\n    }, duration);\n    return this;\n  }\n\n  function setTransitionEndSupport() {\n    $.fn.emulateTransitionEnd = transitionEndEmulator;\n    $.event.special[Util.TRANSITION_END] = getSpecialTransitionEndEvent();\n  }\n  /**\n   * --------------------------------------------------------------------------\n   * Public Util Api\n   * --------------------------------------------------------------------------\n   */\n\n\n  var Util = {\n    TRANSITION_END: 'bsTransitionEnd',\n    getUID: function getUID(prefix) {\n      do {\n        // eslint-disable-next-line no-bitwise\n        prefix += ~~(Math.random() * MAX_UID); // \"~~\" acts like a faster Math.floor() here\n      } while (document.getElementById(prefix));\n\n      return prefix;\n    },\n    getSelectorFromElement: function getSelectorFromElement(element) {\n      var selector = element.getAttribute('data-target');\n\n      if (!selector || selector === '#') {\n        selector = element.getAttribute('href') || '';\n      }\n\n      try {\n        var $selector = $(document).find(selector);\n        return $selector.length > 0 ? selector : null;\n      } catch (err) {\n        return null;\n      }\n    },\n    getTransitionDurationFromElement: function getTransitionDurationFromElement(element) {\n      if (!element) {\n        return 0;\n      } // Get transition-duration of the element\n\n\n      var transitionDuration = $(element).css('transition-duration');\n      var floatTransitionDuration = parseFloat(transitionDuration); // Return 0 if element or transition duration is not found\n\n      if (!floatTransitionDuration) {\n        return 0;\n      } // If multiple durations are defined, take the first\n\n\n      transitionDuration = transitionDuration.split(',')[0];\n      return parseFloat(transitionDuration) * MILLISECONDS_MULTIPLIER;\n    },\n    reflow: function reflow(element) {\n      return element.offsetHeight;\n    },\n    triggerTransitionEnd: function triggerTransitionEnd(element) {\n      $(element).trigger(TRANSITION_END);\n    },\n    // TODO: Remove in v5\n    supportsTransitionEnd: function supportsTransitionEnd() {\n      return Boolean(TRANSITION_END);\n    },\n    isElement: function isElement(obj) {\n      return (obj[0] || obj).nodeType;\n    },\n    typeCheckConfig: function typeCheckConfig(componentName, config, configTypes) {\n      for (var property in configTypes) {\n        if (Object.prototype.hasOwnProperty.call(configTypes, property)) {\n          var expectedTypes = configTypes[property];\n          var value = config[property];\n          var valueType = value && Util.isElement(value) ? 'element' : toType(value);\n\n          if (!new RegExp(expectedTypes).test(valueType)) {\n            throw new Error(componentName.toUpperCase() + \": \" + (\"Option \\\"\" + property + \"\\\" provided type \\\"\" + valueType + \"\\\" \") + (\"but expected type \\\"\" + expectedTypes + \"\\\".\"));\n          }\n        }\n      }\n    }\n  };\n  setTransitionEndSupport();\n  return Util;\n}($);\n//# sourceMappingURL=util.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/bootstrap/js/dist/util.js\n// module id = 8\n// module chunks = 0","function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\n * --------------------------------------------------------------------------\n * Bootstrap (v4.1.1): alert.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n * --------------------------------------------------------------------------\n */\nvar Alert = function ($) {\n  /**\n   * ------------------------------------------------------------------------\n   * Constants\n   * ------------------------------------------------------------------------\n   */\n  var NAME = 'alert';\n  var VERSION = '4.1.1';\n  var DATA_KEY = 'bs.alert';\n  var EVENT_KEY = \".\" + DATA_KEY;\n  var DATA_API_KEY = '.data-api';\n  var JQUERY_NO_CONFLICT = $.fn[NAME];\n  var Selector = {\n    DISMISS: '[data-dismiss=\"alert\"]'\n  };\n  var Event = {\n    CLOSE: \"close\" + EVENT_KEY,\n    CLOSED: \"closed\" + EVENT_KEY,\n    CLICK_DATA_API: \"click\" + EVENT_KEY + DATA_API_KEY\n  };\n  var ClassName = {\n    ALERT: 'alert',\n    FADE: 'fade',\n    SHOW: 'show'\n    /**\n     * ------------------------------------------------------------------------\n     * Class Definition\n     * ------------------------------------------------------------------------\n     */\n\n  };\n\n  var Alert =\n  /*#__PURE__*/\n  function () {\n    function Alert(element) {\n      this._element = element;\n    } // Getters\n\n\n    var _proto = Alert.prototype;\n\n    // Public\n    _proto.close = function close(element) {\n      var rootElement = this._element;\n\n      if (element) {\n        rootElement = this._getRootElement(element);\n      }\n\n      var customEvent = this._triggerCloseEvent(rootElement);\n\n      if (customEvent.isDefaultPrevented()) {\n        return;\n      }\n\n      this._removeElement(rootElement);\n    };\n\n    _proto.dispose = function dispose() {\n      $.removeData(this._element, DATA_KEY);\n      this._element = null;\n    }; // Private\n\n\n    _proto._getRootElement = function _getRootElement(element) {\n      var selector = Util.getSelectorFromElement(element);\n      var parent = false;\n\n      if (selector) {\n        parent = $(selector)[0];\n      }\n\n      if (!parent) {\n        parent = $(element).closest(\".\" + ClassName.ALERT)[0];\n      }\n\n      return parent;\n    };\n\n    _proto._triggerCloseEvent = function _triggerCloseEvent(element) {\n      var closeEvent = $.Event(Event.CLOSE);\n      $(element).trigger(closeEvent);\n      return closeEvent;\n    };\n\n    _proto._removeElement = function _removeElement(element) {\n      var _this = this;\n\n      $(element).removeClass(ClassName.SHOW);\n\n      if (!$(element).hasClass(ClassName.FADE)) {\n        this._destroyElement(element);\n\n        return;\n      }\n\n      var transitionDuration = Util.getTransitionDurationFromElement(element);\n      $(element).one(Util.TRANSITION_END, function (event) {\n        return _this._destroyElement(element, event);\n      }).emulateTransitionEnd(transitionDuration);\n    };\n\n    _proto._destroyElement = function _destroyElement(element) {\n      $(element).detach().trigger(Event.CLOSED).remove();\n    }; // Static\n\n\n    Alert._jQueryInterface = function _jQueryInterface(config) {\n      return this.each(function () {\n        var $element = $(this);\n        var data = $element.data(DATA_KEY);\n\n        if (!data) {\n          data = new Alert(this);\n          $element.data(DATA_KEY, data);\n        }\n\n        if (config === 'close') {\n          data[config](this);\n        }\n      });\n    };\n\n    Alert._handleDismiss = function _handleDismiss(alertInstance) {\n      return function (event) {\n        if (event) {\n          event.preventDefault();\n        }\n\n        alertInstance.close(this);\n      };\n    };\n\n    _createClass(Alert, null, [{\n      key: \"VERSION\",\n      get: function get() {\n        return VERSION;\n      }\n    }]);\n\n    return Alert;\n  }();\n  /**\n   * ------------------------------------------------------------------------\n   * Data Api implementation\n   * ------------------------------------------------------------------------\n   */\n\n\n  $(document).on(Event.CLICK_DATA_API, Selector.DISMISS, Alert._handleDismiss(new Alert()));\n  /**\n   * ------------------------------------------------------------------------\n   * jQuery\n   * ------------------------------------------------------------------------\n   */\n\n  $.fn[NAME] = Alert._jQueryInterface;\n  $.fn[NAME].Constructor = Alert;\n\n  $.fn[NAME].noConflict = function () {\n    $.fn[NAME] = JQUERY_NO_CONFLICT;\n    return Alert._jQueryInterface;\n  };\n\n  return Alert;\n}($);\n//# sourceMappingURL=alert.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/bootstrap/js/dist/alert.js\n// module id = 9\n// module chunks = 0","function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\n * --------------------------------------------------------------------------\n * Bootstrap (v4.1.1): button.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n * --------------------------------------------------------------------------\n */\nvar Button = function ($) {\n  /**\n   * ------------------------------------------------------------------------\n   * Constants\n   * ------------------------------------------------------------------------\n   */\n  var NAME = 'button';\n  var VERSION = '4.1.1';\n  var DATA_KEY = 'bs.button';\n  var EVENT_KEY = \".\" + DATA_KEY;\n  var DATA_API_KEY = '.data-api';\n  var JQUERY_NO_CONFLICT = $.fn[NAME];\n  var ClassName = {\n    ACTIVE: 'active',\n    BUTTON: 'btn',\n    FOCUS: 'focus'\n  };\n  var Selector = {\n    DATA_TOGGLE_CARROT: '[data-toggle^=\"button\"]',\n    DATA_TOGGLE: '[data-toggle=\"buttons\"]',\n    INPUT: 'input',\n    ACTIVE: '.active',\n    BUTTON: '.btn'\n  };\n  var Event = {\n    CLICK_DATA_API: \"click\" + EVENT_KEY + DATA_API_KEY,\n    FOCUS_BLUR_DATA_API: \"focus\" + EVENT_KEY + DATA_API_KEY + \" \" + (\"blur\" + EVENT_KEY + DATA_API_KEY)\n    /**\n     * ------------------------------------------------------------------------\n     * Class Definition\n     * ------------------------------------------------------------------------\n     */\n\n  };\n\n  var Button =\n  /*#__PURE__*/\n  function () {\n    function Button(element) {\n      this._element = element;\n    } // Getters\n\n\n    var _proto = Button.prototype;\n\n    // Public\n    _proto.toggle = function toggle() {\n      var triggerChangeEvent = true;\n      var addAriaPressed = true;\n      var rootElement = $(this._element).closest(Selector.DATA_TOGGLE)[0];\n\n      if (rootElement) {\n        var input = $(this._element).find(Selector.INPUT)[0];\n\n        if (input) {\n          if (input.type === 'radio') {\n            if (input.checked && $(this._element).hasClass(ClassName.ACTIVE)) {\n              triggerChangeEvent = false;\n            } else {\n              var activeElement = $(rootElement).find(Selector.ACTIVE)[0];\n\n              if (activeElement) {\n                $(activeElement).removeClass(ClassName.ACTIVE);\n              }\n            }\n          }\n\n          if (triggerChangeEvent) {\n            if (input.hasAttribute('disabled') || rootElement.hasAttribute('disabled') || input.classList.contains('disabled') || rootElement.classList.contains('disabled')) {\n              return;\n            }\n\n            input.checked = !$(this._element).hasClass(ClassName.ACTIVE);\n            $(input).trigger('change');\n          }\n\n          input.focus();\n          addAriaPressed = false;\n        }\n      }\n\n      if (addAriaPressed) {\n        this._element.setAttribute('aria-pressed', !$(this._element).hasClass(ClassName.ACTIVE));\n      }\n\n      if (triggerChangeEvent) {\n        $(this._element).toggleClass(ClassName.ACTIVE);\n      }\n    };\n\n    _proto.dispose = function dispose() {\n      $.removeData(this._element, DATA_KEY);\n      this._element = null;\n    }; // Static\n\n\n    Button._jQueryInterface = function _jQueryInterface(config) {\n      return this.each(function () {\n        var data = $(this).data(DATA_KEY);\n\n        if (!data) {\n          data = new Button(this);\n          $(this).data(DATA_KEY, data);\n        }\n\n        if (config === 'toggle') {\n          data[config]();\n        }\n      });\n    };\n\n    _createClass(Button, null, [{\n      key: \"VERSION\",\n      get: function get() {\n        return VERSION;\n      }\n    }]);\n\n    return Button;\n  }();\n  /**\n   * ------------------------------------------------------------------------\n   * Data Api implementation\n   * ------------------------------------------------------------------------\n   */\n\n\n  $(document).on(Event.CLICK_DATA_API, Selector.DATA_TOGGLE_CARROT, function (event) {\n    event.preventDefault();\n    var button = event.target;\n\n    if (!$(button).hasClass(ClassName.BUTTON)) {\n      button = $(button).closest(Selector.BUTTON);\n    }\n\n    Button._jQueryInterface.call($(button), 'toggle');\n  }).on(Event.FOCUS_BLUR_DATA_API, Selector.DATA_TOGGLE_CARROT, function (event) {\n    var button = $(event.target).closest(Selector.BUTTON)[0];\n    $(button).toggleClass(ClassName.FOCUS, /^focus(in)?$/.test(event.type));\n  });\n  /**\n   * ------------------------------------------------------------------------\n   * jQuery\n   * ------------------------------------------------------------------------\n   */\n\n  $.fn[NAME] = Button._jQueryInterface;\n  $.fn[NAME].Constructor = Button;\n\n  $.fn[NAME].noConflict = function () {\n    $.fn[NAME] = JQUERY_NO_CONFLICT;\n    return Button._jQueryInterface;\n  };\n\n  return Button;\n}($);\n//# sourceMappingURL=button.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/bootstrap/js/dist/button.js\n// module id = 10\n// module chunks = 0","function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\n * --------------------------------------------------------------------------\n * Bootstrap (v4.1.1): carousel.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n * --------------------------------------------------------------------------\n */\nvar Carousel = function ($) {\n  /**\n   * ------------------------------------------------------------------------\n   * Constants\n   * ------------------------------------------------------------------------\n   */\n  var NAME = 'carousel';\n  var VERSION = '4.1.1';\n  var DATA_KEY = 'bs.carousel';\n  var EVENT_KEY = \".\" + DATA_KEY;\n  var DATA_API_KEY = '.data-api';\n  var JQUERY_NO_CONFLICT = $.fn[NAME];\n  var ARROW_LEFT_KEYCODE = 37; // KeyboardEvent.which value for left arrow key\n\n  var ARROW_RIGHT_KEYCODE = 39; // KeyboardEvent.which value for right arrow key\n\n  var TOUCHEVENT_COMPAT_WAIT = 500; // Time for mouse compat events to fire after touch\n\n  var Default = {\n    interval: 5000,\n    keyboard: true,\n    slide: false,\n    pause: 'hover',\n    wrap: true\n  };\n  var DefaultType = {\n    interval: '(number|boolean)',\n    keyboard: 'boolean',\n    slide: '(boolean|string)',\n    pause: '(string|boolean)',\n    wrap: 'boolean'\n  };\n  var Direction = {\n    NEXT: 'next',\n    PREV: 'prev',\n    LEFT: 'left',\n    RIGHT: 'right'\n  };\n  var Event = {\n    SLIDE: \"slide\" + EVENT_KEY,\n    SLID: \"slid\" + EVENT_KEY,\n    KEYDOWN: \"keydown\" + EVENT_KEY,\n    MOUSEENTER: \"mouseenter\" + EVENT_KEY,\n    MOUSELEAVE: \"mouseleave\" + EVENT_KEY,\n    TOUCHEND: \"touchend\" + EVENT_KEY,\n    LOAD_DATA_API: \"load\" + EVENT_KEY + DATA_API_KEY,\n    CLICK_DATA_API: \"click\" + EVENT_KEY + DATA_API_KEY\n  };\n  var ClassName = {\n    CAROUSEL: 'carousel',\n    ACTIVE: 'active',\n    SLIDE: 'slide',\n    RIGHT: 'carousel-item-right',\n    LEFT: 'carousel-item-left',\n    NEXT: 'carousel-item-next',\n    PREV: 'carousel-item-prev',\n    ITEM: 'carousel-item'\n  };\n  var Selector = {\n    ACTIVE: '.active',\n    ACTIVE_ITEM: '.active.carousel-item',\n    ITEM: '.carousel-item',\n    NEXT_PREV: '.carousel-item-next, .carousel-item-prev',\n    INDICATORS: '.carousel-indicators',\n    DATA_SLIDE: '[data-slide], [data-slide-to]',\n    DATA_RIDE: '[data-ride=\"carousel\"]'\n    /**\n     * ------------------------------------------------------------------------\n     * Class Definition\n     * ------------------------------------------------------------------------\n     */\n\n  };\n\n  var Carousel =\n  /*#__PURE__*/\n  function () {\n    function Carousel(element, config) {\n      this._items = null;\n      this._interval = null;\n      this._activeElement = null;\n      this._isPaused = false;\n      this._isSliding = false;\n      this.touchTimeout = null;\n      this._config = this._getConfig(config);\n      this._element = $(element)[0];\n      this._indicatorsElement = $(this._element).find(Selector.INDICATORS)[0];\n\n      this._addEventListeners();\n    } // Getters\n\n\n    var _proto = Carousel.prototype;\n\n    // Public\n    _proto.next = function next() {\n      if (!this._isSliding) {\n        this._slide(Direction.NEXT);\n      }\n    };\n\n    _proto.nextWhenVisible = function nextWhenVisible() {\n      // Don't call next when the page isn't visible\n      // or the carousel or its parent isn't visible\n      if (!document.hidden && $(this._element).is(':visible') && $(this._element).css('visibility') !== 'hidden') {\n        this.next();\n      }\n    };\n\n    _proto.prev = function prev() {\n      if (!this._isSliding) {\n        this._slide(Direction.PREV);\n      }\n    };\n\n    _proto.pause = function pause(event) {\n      if (!event) {\n        this._isPaused = true;\n      }\n\n      if ($(this._element).find(Selector.NEXT_PREV)[0]) {\n        Util.triggerTransitionEnd(this._element);\n        this.cycle(true);\n      }\n\n      clearInterval(this._interval);\n      this._interval = null;\n    };\n\n    _proto.cycle = function cycle(event) {\n      if (!event) {\n        this._isPaused = false;\n      }\n\n      if (this._interval) {\n        clearInterval(this._interval);\n        this._interval = null;\n      }\n\n      if (this._config.interval && !this._isPaused) {\n        this._interval = setInterval((document.visibilityState ? this.nextWhenVisible : this.next).bind(this), this._config.interval);\n      }\n    };\n\n    _proto.to = function to(index) {\n      var _this = this;\n\n      this._activeElement = $(this._element).find(Selector.ACTIVE_ITEM)[0];\n\n      var activeIndex = this._getItemIndex(this._activeElement);\n\n      if (index > this._items.length - 1 || index < 0) {\n        return;\n      }\n\n      if (this._isSliding) {\n        $(this._element).one(Event.SLID, function () {\n          return _this.to(index);\n        });\n        return;\n      }\n\n      if (activeIndex === index) {\n        this.pause();\n        this.cycle();\n        return;\n      }\n\n      var direction = index > activeIndex ? Direction.NEXT : Direction.PREV;\n\n      this._slide(direction, this._items[index]);\n    };\n\n    _proto.dispose = function dispose() {\n      $(this._element).off(EVENT_KEY);\n      $.removeData(this._element, DATA_KEY);\n      this._items = null;\n      this._config = null;\n      this._element = null;\n      this._interval = null;\n      this._isPaused = null;\n      this._isSliding = null;\n      this._activeElement = null;\n      this._indicatorsElement = null;\n    }; // Private\n\n\n    _proto._getConfig = function _getConfig(config) {\n      config = _objectSpread({}, Default, config);\n      Util.typeCheckConfig(NAME, config, DefaultType);\n      return config;\n    };\n\n    _proto._addEventListeners = function _addEventListeners() {\n      var _this2 = this;\n\n      if (this._config.keyboard) {\n        $(this._element).on(Event.KEYDOWN, function (event) {\n          return _this2._keydown(event);\n        });\n      }\n\n      if (this._config.pause === 'hover') {\n        $(this._element).on(Event.MOUSEENTER, function (event) {\n          return _this2.pause(event);\n        }).on(Event.MOUSELEAVE, function (event) {\n          return _this2.cycle(event);\n        });\n\n        if ('ontouchstart' in document.documentElement) {\n          // If it's a touch-enabled device, mouseenter/leave are fired as\n          // part of the mouse compatibility events on first tap - the carousel\n          // would stop cycling until user tapped out of it;\n          // here, we listen for touchend, explicitly pause the carousel\n          // (as if it's the second time we tap on it, mouseenter compat event\n          // is NOT fired) and after a timeout (to allow for mouse compatibility\n          // events to fire) we explicitly restart cycling\n          $(this._element).on(Event.TOUCHEND, function () {\n            _this2.pause();\n\n            if (_this2.touchTimeout) {\n              clearTimeout(_this2.touchTimeout);\n            }\n\n            _this2.touchTimeout = setTimeout(function (event) {\n              return _this2.cycle(event);\n            }, TOUCHEVENT_COMPAT_WAIT + _this2._config.interval);\n          });\n        }\n      }\n    };\n\n    _proto._keydown = function _keydown(event) {\n      if (/input|textarea/i.test(event.target.tagName)) {\n        return;\n      }\n\n      switch (event.which) {\n        case ARROW_LEFT_KEYCODE:\n          event.preventDefault();\n          this.prev();\n          break;\n\n        case ARROW_RIGHT_KEYCODE:\n          event.preventDefault();\n          this.next();\n          break;\n\n        default:\n      }\n    };\n\n    _proto._getItemIndex = function _getItemIndex(element) {\n      this._items = $.makeArray($(element).parent().find(Selector.ITEM));\n      return this._items.indexOf(element);\n    };\n\n    _proto._getItemByDirection = function _getItemByDirection(direction, activeElement) {\n      var isNextDirection = direction === Direction.NEXT;\n      var isPrevDirection = direction === Direction.PREV;\n\n      var activeIndex = this._getItemIndex(activeElement);\n\n      var lastItemIndex = this._items.length - 1;\n      var isGoingToWrap = isPrevDirection && activeIndex === 0 || isNextDirection && activeIndex === lastItemIndex;\n\n      if (isGoingToWrap && !this._config.wrap) {\n        return activeElement;\n      }\n\n      var delta = direction === Direction.PREV ? -1 : 1;\n      var itemIndex = (activeIndex + delta) % this._items.length;\n      return itemIndex === -1 ? this._items[this._items.length - 1] : this._items[itemIndex];\n    };\n\n    _proto._triggerSlideEvent = function _triggerSlideEvent(relatedTarget, eventDirectionName) {\n      var targetIndex = this._getItemIndex(relatedTarget);\n\n      var fromIndex = this._getItemIndex($(this._element).find(Selector.ACTIVE_ITEM)[0]);\n\n      var slideEvent = $.Event(Event.SLIDE, {\n        relatedTarget: relatedTarget,\n        direction: eventDirectionName,\n        from: fromIndex,\n        to: targetIndex\n      });\n      $(this._element).trigger(slideEvent);\n      return slideEvent;\n    };\n\n    _proto._setActiveIndicatorElement = function _setActiveIndicatorElement(element) {\n      if (this._indicatorsElement) {\n        $(this._indicatorsElement).find(Selector.ACTIVE).removeClass(ClassName.ACTIVE);\n\n        var nextIndicator = this._indicatorsElement.children[this._getItemIndex(element)];\n\n        if (nextIndicator) {\n          $(nextIndicator).addClass(ClassName.ACTIVE);\n        }\n      }\n    };\n\n    _proto._slide = function _slide(direction, element) {\n      var _this3 = this;\n\n      var activeElement = $(this._element).find(Selector.ACTIVE_ITEM)[0];\n\n      var activeElementIndex = this._getItemIndex(activeElement);\n\n      var nextElement = element || activeElement && this._getItemByDirection(direction, activeElement);\n\n      var nextElementIndex = this._getItemIndex(nextElement);\n\n      var isCycling = Boolean(this._interval);\n      var directionalClassName;\n      var orderClassName;\n      var eventDirectionName;\n\n      if (direction === Direction.NEXT) {\n        directionalClassName = ClassName.LEFT;\n        orderClassName = ClassName.NEXT;\n        eventDirectionName = Direction.LEFT;\n      } else {\n        directionalClassName = ClassName.RIGHT;\n        orderClassName = ClassName.PREV;\n        eventDirectionName = Direction.RIGHT;\n      }\n\n      if (nextElement && $(nextElement).hasClass(ClassName.ACTIVE)) {\n        this._isSliding = false;\n        return;\n      }\n\n      var slideEvent = this._triggerSlideEvent(nextElement, eventDirectionName);\n\n      if (slideEvent.isDefaultPrevented()) {\n        return;\n      }\n\n      if (!activeElement || !nextElement) {\n        // Some weirdness is happening, so we bail\n        return;\n      }\n\n      this._isSliding = true;\n\n      if (isCycling) {\n        this.pause();\n      }\n\n      this._setActiveIndicatorElement(nextElement);\n\n      var slidEvent = $.Event(Event.SLID, {\n        relatedTarget: nextElement,\n        direction: eventDirectionName,\n        from: activeElementIndex,\n        to: nextElementIndex\n      });\n\n      if ($(this._element).hasClass(ClassName.SLIDE)) {\n        $(nextElement).addClass(orderClassName);\n        Util.reflow(nextElement);\n        $(activeElement).addClass(directionalClassName);\n        $(nextElement).addClass(directionalClassName);\n        var transitionDuration = Util.getTransitionDurationFromElement(activeElement);\n        $(activeElement).one(Util.TRANSITION_END, function () {\n          $(nextElement).removeClass(directionalClassName + \" \" + orderClassName).addClass(ClassName.ACTIVE);\n          $(activeElement).removeClass(ClassName.ACTIVE + \" \" + orderClassName + \" \" + directionalClassName);\n          _this3._isSliding = false;\n          setTimeout(function () {\n            return $(_this3._element).trigger(slidEvent);\n          }, 0);\n        }).emulateTransitionEnd(transitionDuration);\n      } else {\n        $(activeElement).removeClass(ClassName.ACTIVE);\n        $(nextElement).addClass(ClassName.ACTIVE);\n        this._isSliding = false;\n        $(this._element).trigger(slidEvent);\n      }\n\n      if (isCycling) {\n        this.cycle();\n      }\n    }; // Static\n\n\n    Carousel._jQueryInterface = function _jQueryInterface(config) {\n      return this.each(function () {\n        var data = $(this).data(DATA_KEY);\n\n        var _config = _objectSpread({}, Default, $(this).data());\n\n        if (typeof config === 'object') {\n          _config = _objectSpread({}, _config, config);\n        }\n\n        var action = typeof config === 'string' ? config : _config.slide;\n\n        if (!data) {\n          data = new Carousel(this, _config);\n          $(this).data(DATA_KEY, data);\n        }\n\n        if (typeof config === 'number') {\n          data.to(config);\n        } else if (typeof action === 'string') {\n          if (typeof data[action] === 'undefined') {\n            throw new TypeError(\"No method named \\\"\" + action + \"\\\"\");\n          }\n\n          data[action]();\n        } else if (_config.interval) {\n          data.pause();\n          data.cycle();\n        }\n      });\n    };\n\n    Carousel._dataApiClickHandler = function _dataApiClickHandler(event) {\n      var selector = Util.getSelectorFromElement(this);\n\n      if (!selector) {\n        return;\n      }\n\n      var target = $(selector)[0];\n\n      if (!target || !$(target).hasClass(ClassName.CAROUSEL)) {\n        return;\n      }\n\n      var config = _objectSpread({}, $(target).data(), $(this).data());\n\n      var slideIndex = this.getAttribute('data-slide-to');\n\n      if (slideIndex) {\n        config.interval = false;\n      }\n\n      Carousel._jQueryInterface.call($(target), config);\n\n      if (slideIndex) {\n        $(target).data(DATA_KEY).to(slideIndex);\n      }\n\n      event.preventDefault();\n    };\n\n    _createClass(Carousel, null, [{\n      key: \"VERSION\",\n      get: function get() {\n        return VERSION;\n      }\n    }, {\n      key: \"Default\",\n      get: function get() {\n        return Default;\n      }\n    }]);\n\n    return Carousel;\n  }();\n  /**\n   * ------------------------------------------------------------------------\n   * Data Api implementation\n   * ------------------------------------------------------------------------\n   */\n\n\n  $(document).on(Event.CLICK_DATA_API, Selector.DATA_SLIDE, Carousel._dataApiClickHandler);\n  $(window).on(Event.LOAD_DATA_API, function () {\n    $(Selector.DATA_RIDE).each(function () {\n      var $carousel = $(this);\n\n      Carousel._jQueryInterface.call($carousel, $carousel.data());\n    });\n  });\n  /**\n   * ------------------------------------------------------------------------\n   * jQuery\n   * ------------------------------------------------------------------------\n   */\n\n  $.fn[NAME] = Carousel._jQueryInterface;\n  $.fn[NAME].Constructor = Carousel;\n\n  $.fn[NAME].noConflict = function () {\n    $.fn[NAME] = JQUERY_NO_CONFLICT;\n    return Carousel._jQueryInterface;\n  };\n\n  return Carousel;\n}($);\n//# sourceMappingURL=carousel.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/bootstrap/js/dist/carousel.js\n// module id = 11\n// module chunks = 0","function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\n * --------------------------------------------------------------------------\n * Bootstrap (v4.1.1): collapse.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n * --------------------------------------------------------------------------\n */\nvar Collapse = function ($) {\n  /**\n   * ------------------------------------------------------------------------\n   * Constants\n   * ------------------------------------------------------------------------\n   */\n  var NAME = 'collapse';\n  var VERSION = '4.1.1';\n  var DATA_KEY = 'bs.collapse';\n  var EVENT_KEY = \".\" + DATA_KEY;\n  var DATA_API_KEY = '.data-api';\n  var JQUERY_NO_CONFLICT = $.fn[NAME];\n  var Default = {\n    toggle: true,\n    parent: ''\n  };\n  var DefaultType = {\n    toggle: 'boolean',\n    parent: '(string|element)'\n  };\n  var Event = {\n    SHOW: \"show\" + EVENT_KEY,\n    SHOWN: \"shown\" + EVENT_KEY,\n    HIDE: \"hide\" + EVENT_KEY,\n    HIDDEN: \"hidden\" + EVENT_KEY,\n    CLICK_DATA_API: \"click\" + EVENT_KEY + DATA_API_KEY\n  };\n  var ClassName = {\n    SHOW: 'show',\n    COLLAPSE: 'collapse',\n    COLLAPSING: 'collapsing',\n    COLLAPSED: 'collapsed'\n  };\n  var Dimension = {\n    WIDTH: 'width',\n    HEIGHT: 'height'\n  };\n  var Selector = {\n    ACTIVES: '.show, .collapsing',\n    DATA_TOGGLE: '[data-toggle=\"collapse\"]'\n    /**\n     * ------------------------------------------------------------------------\n     * Class Definition\n     * ------------------------------------------------------------------------\n     */\n\n  };\n\n  var Collapse =\n  /*#__PURE__*/\n  function () {\n    function Collapse(element, config) {\n      this._isTransitioning = false;\n      this._element = element;\n      this._config = this._getConfig(config);\n      this._triggerArray = $.makeArray($(\"[data-toggle=\\\"collapse\\\"][href=\\\"#\" + element.id + \"\\\"],\" + (\"[data-toggle=\\\"collapse\\\"][data-target=\\\"#\" + element.id + \"\\\"]\")));\n      var tabToggles = $(Selector.DATA_TOGGLE);\n\n      for (var i = 0; i < tabToggles.length; i++) {\n        var elem = tabToggles[i];\n        var selector = Util.getSelectorFromElement(elem);\n\n        if (selector !== null && $(selector).filter(element).length > 0) {\n          this._selector = selector;\n\n          this._triggerArray.push(elem);\n        }\n      }\n\n      this._parent = this._config.parent ? this._getParent() : null;\n\n      if (!this._config.parent) {\n        this._addAriaAndCollapsedClass(this._element, this._triggerArray);\n      }\n\n      if (this._config.toggle) {\n        this.toggle();\n      }\n    } // Getters\n\n\n    var _proto = Collapse.prototype;\n\n    // Public\n    _proto.toggle = function toggle() {\n      if ($(this._element).hasClass(ClassName.SHOW)) {\n        this.hide();\n      } else {\n        this.show();\n      }\n    };\n\n    _proto.show = function show() {\n      var _this = this;\n\n      if (this._isTransitioning || $(this._element).hasClass(ClassName.SHOW)) {\n        return;\n      }\n\n      var actives;\n      var activesData;\n\n      if (this._parent) {\n        actives = $.makeArray($(this._parent).find(Selector.ACTIVES).filter(\"[data-parent=\\\"\" + this._config.parent + \"\\\"]\"));\n\n        if (actives.length === 0) {\n          actives = null;\n        }\n      }\n\n      if (actives) {\n        activesData = $(actives).not(this._selector).data(DATA_KEY);\n\n        if (activesData && activesData._isTransitioning) {\n          return;\n        }\n      }\n\n      var startEvent = $.Event(Event.SHOW);\n      $(this._element).trigger(startEvent);\n\n      if (startEvent.isDefaultPrevented()) {\n        return;\n      }\n\n      if (actives) {\n        Collapse._jQueryInterface.call($(actives).not(this._selector), 'hide');\n\n        if (!activesData) {\n          $(actives).data(DATA_KEY, null);\n        }\n      }\n\n      var dimension = this._getDimension();\n\n      $(this._element).removeClass(ClassName.COLLAPSE).addClass(ClassName.COLLAPSING);\n      this._element.style[dimension] = 0;\n\n      if (this._triggerArray.length > 0) {\n        $(this._triggerArray).removeClass(ClassName.COLLAPSED).attr('aria-expanded', true);\n      }\n\n      this.setTransitioning(true);\n\n      var complete = function complete() {\n        $(_this._element).removeClass(ClassName.COLLAPSING).addClass(ClassName.COLLAPSE).addClass(ClassName.SHOW);\n        _this._element.style[dimension] = '';\n\n        _this.setTransitioning(false);\n\n        $(_this._element).trigger(Event.SHOWN);\n      };\n\n      var capitalizedDimension = dimension[0].toUpperCase() + dimension.slice(1);\n      var scrollSize = \"scroll\" + capitalizedDimension;\n      var transitionDuration = Util.getTransitionDurationFromElement(this._element);\n      $(this._element).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);\n      this._element.style[dimension] = this._element[scrollSize] + \"px\";\n    };\n\n    _proto.hide = function hide() {\n      var _this2 = this;\n\n      if (this._isTransitioning || !$(this._element).hasClass(ClassName.SHOW)) {\n        return;\n      }\n\n      var startEvent = $.Event(Event.HIDE);\n      $(this._element).trigger(startEvent);\n\n      if (startEvent.isDefaultPrevented()) {\n        return;\n      }\n\n      var dimension = this._getDimension();\n\n      this._element.style[dimension] = this._element.getBoundingClientRect()[dimension] + \"px\";\n      Util.reflow(this._element);\n      $(this._element).addClass(ClassName.COLLAPSING).removeClass(ClassName.COLLAPSE).removeClass(ClassName.SHOW);\n\n      if (this._triggerArray.length > 0) {\n        for (var i = 0; i < this._triggerArray.length; i++) {\n          var trigger = this._triggerArray[i];\n          var selector = Util.getSelectorFromElement(trigger);\n\n          if (selector !== null) {\n            var $elem = $(selector);\n\n            if (!$elem.hasClass(ClassName.SHOW)) {\n              $(trigger).addClass(ClassName.COLLAPSED).attr('aria-expanded', false);\n            }\n          }\n        }\n      }\n\n      this.setTransitioning(true);\n\n      var complete = function complete() {\n        _this2.setTransitioning(false);\n\n        $(_this2._element).removeClass(ClassName.COLLAPSING).addClass(ClassName.COLLAPSE).trigger(Event.HIDDEN);\n      };\n\n      this._element.style[dimension] = '';\n      var transitionDuration = Util.getTransitionDurationFromElement(this._element);\n      $(this._element).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);\n    };\n\n    _proto.setTransitioning = function setTransitioning(isTransitioning) {\n      this._isTransitioning = isTransitioning;\n    };\n\n    _proto.dispose = function dispose() {\n      $.removeData(this._element, DATA_KEY);\n      this._config = null;\n      this._parent = null;\n      this._element = null;\n      this._triggerArray = null;\n      this._isTransitioning = null;\n    }; // Private\n\n\n    _proto._getConfig = function _getConfig(config) {\n      config = _objectSpread({}, Default, config);\n      config.toggle = Boolean(config.toggle); // Coerce string values\n\n      Util.typeCheckConfig(NAME, config, DefaultType);\n      return config;\n    };\n\n    _proto._getDimension = function _getDimension() {\n      var hasWidth = $(this._element).hasClass(Dimension.WIDTH);\n      return hasWidth ? Dimension.WIDTH : Dimension.HEIGHT;\n    };\n\n    _proto._getParent = function _getParent() {\n      var _this3 = this;\n\n      var parent = null;\n\n      if (Util.isElement(this._config.parent)) {\n        parent = this._config.parent; // It's a jQuery object\n\n        if (typeof this._config.parent.jquery !== 'undefined') {\n          parent = this._config.parent[0];\n        }\n      } else {\n        parent = $(this._config.parent)[0];\n      }\n\n      var selector = \"[data-toggle=\\\"collapse\\\"][data-parent=\\\"\" + this._config.parent + \"\\\"]\";\n      $(parent).find(selector).each(function (i, element) {\n        _this3._addAriaAndCollapsedClass(Collapse._getTargetFromElement(element), [element]);\n      });\n      return parent;\n    };\n\n    _proto._addAriaAndCollapsedClass = function _addAriaAndCollapsedClass(element, triggerArray) {\n      if (element) {\n        var isOpen = $(element).hasClass(ClassName.SHOW);\n\n        if (triggerArray.length > 0) {\n          $(triggerArray).toggleClass(ClassName.COLLAPSED, !isOpen).attr('aria-expanded', isOpen);\n        }\n      }\n    }; // Static\n\n\n    Collapse._getTargetFromElement = function _getTargetFromElement(element) {\n      var selector = Util.getSelectorFromElement(element);\n      return selector ? $(selector)[0] : null;\n    };\n\n    Collapse._jQueryInterface = function _jQueryInterface(config) {\n      return this.each(function () {\n        var $this = $(this);\n        var data = $this.data(DATA_KEY);\n\n        var _config = _objectSpread({}, Default, $this.data(), typeof config === 'object' && config ? config : {});\n\n        if (!data && _config.toggle && /show|hide/.test(config)) {\n          _config.toggle = false;\n        }\n\n        if (!data) {\n          data = new Collapse(this, _config);\n          $this.data(DATA_KEY, data);\n        }\n\n        if (typeof config === 'string') {\n          if (typeof data[config] === 'undefined') {\n            throw new TypeError(\"No method named \\\"\" + config + \"\\\"\");\n          }\n\n          data[config]();\n        }\n      });\n    };\n\n    _createClass(Collapse, null, [{\n      key: \"VERSION\",\n      get: function get() {\n        return VERSION;\n      }\n    }, {\n      key: \"Default\",\n      get: function get() {\n        return Default;\n      }\n    }]);\n\n    return Collapse;\n  }();\n  /**\n   * ------------------------------------------------------------------------\n   * Data Api implementation\n   * ------------------------------------------------------------------------\n   */\n\n\n  $(document).on(Event.CLICK_DATA_API, Selector.DATA_TOGGLE, function (event) {\n    // preventDefault only for <a> elements (which change the URL) not inside the collapsible element\n    if (event.currentTarget.tagName === 'A') {\n      event.preventDefault();\n    }\n\n    var $trigger = $(this);\n    var selector = Util.getSelectorFromElement(this);\n    $(selector).each(function () {\n      var $target = $(this);\n      var data = $target.data(DATA_KEY);\n      var config = data ? 'toggle' : $trigger.data();\n\n      Collapse._jQueryInterface.call($target, config);\n    });\n  });\n  /**\n   * ------------------------------------------------------------------------\n   * jQuery\n   * ------------------------------------------------------------------------\n   */\n\n  $.fn[NAME] = Collapse._jQueryInterface;\n  $.fn[NAME].Constructor = Collapse;\n\n  $.fn[NAME].noConflict = function () {\n    $.fn[NAME] = JQUERY_NO_CONFLICT;\n    return Collapse._jQueryInterface;\n  };\n\n  return Collapse;\n}($);\n//# sourceMappingURL=collapse.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/bootstrap/js/dist/collapse.js\n// module id = 12\n// module chunks = 0","function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\n * --------------------------------------------------------------------------\n * Bootstrap (v4.1.1): dropdown.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n * --------------------------------------------------------------------------\n */\nvar Dropdown = function ($) {\n  /**\n   * ------------------------------------------------------------------------\n   * Constants\n   * ------------------------------------------------------------------------\n   */\n  var NAME = 'dropdown';\n  var VERSION = '4.1.1';\n  var DATA_KEY = 'bs.dropdown';\n  var EVENT_KEY = \".\" + DATA_KEY;\n  var DATA_API_KEY = '.data-api';\n  var JQUERY_NO_CONFLICT = $.fn[NAME];\n  var ESCAPE_KEYCODE = 27; // KeyboardEvent.which value for Escape (Esc) key\n\n  var SPACE_KEYCODE = 32; // KeyboardEvent.which value for space key\n\n  var TAB_KEYCODE = 9; // KeyboardEvent.which value for tab key\n\n  var ARROW_UP_KEYCODE = 38; // KeyboardEvent.which value for up arrow key\n\n  var ARROW_DOWN_KEYCODE = 40; // KeyboardEvent.which value for down arrow key\n\n  var RIGHT_MOUSE_BUTTON_WHICH = 3; // MouseEvent.which value for the right button (assuming a right-handed mouse)\n\n  var REGEXP_KEYDOWN = new RegExp(ARROW_UP_KEYCODE + \"|\" + ARROW_DOWN_KEYCODE + \"|\" + ESCAPE_KEYCODE);\n  var Event = {\n    HIDE: \"hide\" + EVENT_KEY,\n    HIDDEN: \"hidden\" + EVENT_KEY,\n    SHOW: \"show\" + EVENT_KEY,\n    SHOWN: \"shown\" + EVENT_KEY,\n    CLICK: \"click\" + EVENT_KEY,\n    CLICK_DATA_API: \"click\" + EVENT_KEY + DATA_API_KEY,\n    KEYDOWN_DATA_API: \"keydown\" + EVENT_KEY + DATA_API_KEY,\n    KEYUP_DATA_API: \"keyup\" + EVENT_KEY + DATA_API_KEY\n  };\n  var ClassName = {\n    DISABLED: 'disabled',\n    SHOW: 'show',\n    DROPUP: 'dropup',\n    DROPRIGHT: 'dropright',\n    DROPLEFT: 'dropleft',\n    MENURIGHT: 'dropdown-menu-right',\n    MENULEFT: 'dropdown-menu-left',\n    POSITION_STATIC: 'position-static'\n  };\n  var Selector = {\n    DATA_TOGGLE: '[data-toggle=\"dropdown\"]',\n    FORM_CHILD: '.dropdown form',\n    MENU: '.dropdown-menu',\n    NAVBAR_NAV: '.navbar-nav',\n    VISIBLE_ITEMS: '.dropdown-menu .dropdown-item:not(.disabled):not(:disabled)'\n  };\n  var AttachmentMap = {\n    TOP: 'top-start',\n    TOPEND: 'top-end',\n    BOTTOM: 'bottom-start',\n    BOTTOMEND: 'bottom-end',\n    RIGHT: 'right-start',\n    RIGHTEND: 'right-end',\n    LEFT: 'left-start',\n    LEFTEND: 'left-end'\n  };\n  var Default = {\n    offset: 0,\n    flip: true,\n    boundary: 'scrollParent',\n    reference: 'toggle',\n    display: 'dynamic'\n  };\n  var DefaultType = {\n    offset: '(number|string|function)',\n    flip: 'boolean',\n    boundary: '(string|element)',\n    reference: '(string|element)',\n    display: 'string'\n    /**\n     * ------------------------------------------------------------------------\n     * Class Definition\n     * ------------------------------------------------------------------------\n     */\n\n  };\n\n  var Dropdown =\n  /*#__PURE__*/\n  function () {\n    function Dropdown(element, config) {\n      this._element = element;\n      this._popper = null;\n      this._config = this._getConfig(config);\n      this._menu = this._getMenuElement();\n      this._inNavbar = this._detectNavbar();\n\n      this._addEventListeners();\n    } // Getters\n\n\n    var _proto = Dropdown.prototype;\n\n    // Public\n    _proto.toggle = function toggle() {\n      if (this._element.disabled || $(this._element).hasClass(ClassName.DISABLED)) {\n        return;\n      }\n\n      var parent = Dropdown._getParentFromElement(this._element);\n\n      var isActive = $(this._menu).hasClass(ClassName.SHOW);\n\n      Dropdown._clearMenus();\n\n      if (isActive) {\n        return;\n      }\n\n      var relatedTarget = {\n        relatedTarget: this._element\n      };\n      var showEvent = $.Event(Event.SHOW, relatedTarget);\n      $(parent).trigger(showEvent);\n\n      if (showEvent.isDefaultPrevented()) {\n        return;\n      } // Disable totally Popper.js for Dropdown in Navbar\n\n\n      if (!this._inNavbar) {\n        /**\n         * Check for Popper dependency\n         * Popper - https://popper.js.org\n         */\n        if (typeof Popper === 'undefined') {\n          throw new TypeError('Bootstrap dropdown require Popper.js (https://popper.js.org)');\n        }\n\n        var referenceElement = this._element;\n\n        if (this._config.reference === 'parent') {\n          referenceElement = parent;\n        } else if (Util.isElement(this._config.reference)) {\n          referenceElement = this._config.reference; // Check if it's jQuery element\n\n          if (typeof this._config.reference.jquery !== 'undefined') {\n            referenceElement = this._config.reference[0];\n          }\n        } // If boundary is not `scrollParent`, then set position to `static`\n        // to allow the menu to \"escape\" the scroll parent's boundaries\n        // https://github.com/twbs/bootstrap/issues/24251\n\n\n        if (this._config.boundary !== 'scrollParent') {\n          $(parent).addClass(ClassName.POSITION_STATIC);\n        }\n\n        this._popper = new Popper(referenceElement, this._menu, this._getPopperConfig());\n      } // If this is a touch-enabled device we add extra\n      // empty mouseover listeners to the body's immediate children;\n      // only needed because of broken event delegation on iOS\n      // https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html\n\n\n      if ('ontouchstart' in document.documentElement && $(parent).closest(Selector.NAVBAR_NAV).length === 0) {\n        $(document.body).children().on('mouseover', null, $.noop);\n      }\n\n      this._element.focus();\n\n      this._element.setAttribute('aria-expanded', true);\n\n      $(this._menu).toggleClass(ClassName.SHOW);\n      $(parent).toggleClass(ClassName.SHOW).trigger($.Event(Event.SHOWN, relatedTarget));\n    };\n\n    _proto.dispose = function dispose() {\n      $.removeData(this._element, DATA_KEY);\n      $(this._element).off(EVENT_KEY);\n      this._element = null;\n      this._menu = null;\n\n      if (this._popper !== null) {\n        this._popper.destroy();\n\n        this._popper = null;\n      }\n    };\n\n    _proto.update = function update() {\n      this._inNavbar = this._detectNavbar();\n\n      if (this._popper !== null) {\n        this._popper.scheduleUpdate();\n      }\n    }; // Private\n\n\n    _proto._addEventListeners = function _addEventListeners() {\n      var _this = this;\n\n      $(this._element).on(Event.CLICK, function (event) {\n        event.preventDefault();\n        event.stopPropagation();\n\n        _this.toggle();\n      });\n    };\n\n    _proto._getConfig = function _getConfig(config) {\n      config = _objectSpread({}, this.constructor.Default, $(this._element).data(), config);\n      Util.typeCheckConfig(NAME, config, this.constructor.DefaultType);\n      return config;\n    };\n\n    _proto._getMenuElement = function _getMenuElement() {\n      if (!this._menu) {\n        var parent = Dropdown._getParentFromElement(this._element);\n\n        this._menu = $(parent).find(Selector.MENU)[0];\n      }\n\n      return this._menu;\n    };\n\n    _proto._getPlacement = function _getPlacement() {\n      var $parentDropdown = $(this._element).parent();\n      var placement = AttachmentMap.BOTTOM; // Handle dropup\n\n      if ($parentDropdown.hasClass(ClassName.DROPUP)) {\n        placement = AttachmentMap.TOP;\n\n        if ($(this._menu).hasClass(ClassName.MENURIGHT)) {\n          placement = AttachmentMap.TOPEND;\n        }\n      } else if ($parentDropdown.hasClass(ClassName.DROPRIGHT)) {\n        placement = AttachmentMap.RIGHT;\n      } else if ($parentDropdown.hasClass(ClassName.DROPLEFT)) {\n        placement = AttachmentMap.LEFT;\n      } else if ($(this._menu).hasClass(ClassName.MENURIGHT)) {\n        placement = AttachmentMap.BOTTOMEND;\n      }\n\n      return placement;\n    };\n\n    _proto._detectNavbar = function _detectNavbar() {\n      return $(this._element).closest('.navbar').length > 0;\n    };\n\n    _proto._getPopperConfig = function _getPopperConfig() {\n      var _this2 = this;\n\n      var offsetConf = {};\n\n      if (typeof this._config.offset === 'function') {\n        offsetConf.fn = function (data) {\n          data.offsets = _objectSpread({}, data.offsets, _this2._config.offset(data.offsets) || {});\n          return data;\n        };\n      } else {\n        offsetConf.offset = this._config.offset;\n      }\n\n      var popperConfig = {\n        placement: this._getPlacement(),\n        modifiers: {\n          offset: offsetConf,\n          flip: {\n            enabled: this._config.flip\n          },\n          preventOverflow: {\n            boundariesElement: this._config.boundary\n          }\n        } // Disable Popper.js if we have a static display\n\n      };\n\n      if (this._config.display === 'static') {\n        popperConfig.modifiers.applyStyle = {\n          enabled: false\n        };\n      }\n\n      return popperConfig;\n    }; // Static\n\n\n    Dropdown._jQueryInterface = function _jQueryInterface(config) {\n      return this.each(function () {\n        var data = $(this).data(DATA_KEY);\n\n        var _config = typeof config === 'object' ? config : null;\n\n        if (!data) {\n          data = new Dropdown(this, _config);\n          $(this).data(DATA_KEY, data);\n        }\n\n        if (typeof config === 'string') {\n          if (typeof data[config] === 'undefined') {\n            throw new TypeError(\"No method named \\\"\" + config + \"\\\"\");\n          }\n\n          data[config]();\n        }\n      });\n    };\n\n    Dropdown._clearMenus = function _clearMenus(event) {\n      if (event && (event.which === RIGHT_MOUSE_BUTTON_WHICH || event.type === 'keyup' && event.which !== TAB_KEYCODE)) {\n        return;\n      }\n\n      var toggles = $.makeArray($(Selector.DATA_TOGGLE));\n\n      for (var i = 0; i < toggles.length; i++) {\n        var parent = Dropdown._getParentFromElement(toggles[i]);\n\n        var context = $(toggles[i]).data(DATA_KEY);\n        var relatedTarget = {\n          relatedTarget: toggles[i]\n        };\n\n        if (!context) {\n          continue;\n        }\n\n        var dropdownMenu = context._menu;\n\n        if (!$(parent).hasClass(ClassName.SHOW)) {\n          continue;\n        }\n\n        if (event && (event.type === 'click' && /input|textarea/i.test(event.target.tagName) || event.type === 'keyup' && event.which === TAB_KEYCODE) && $.contains(parent, event.target)) {\n          continue;\n        }\n\n        var hideEvent = $.Event(Event.HIDE, relatedTarget);\n        $(parent).trigger(hideEvent);\n\n        if (hideEvent.isDefaultPrevented()) {\n          continue;\n        } // If this is a touch-enabled device we remove the extra\n        // empty mouseover listeners we added for iOS support\n\n\n        if ('ontouchstart' in document.documentElement) {\n          $(document.body).children().off('mouseover', null, $.noop);\n        }\n\n        toggles[i].setAttribute('aria-expanded', 'false');\n        $(dropdownMenu).removeClass(ClassName.SHOW);\n        $(parent).removeClass(ClassName.SHOW).trigger($.Event(Event.HIDDEN, relatedTarget));\n      }\n    };\n\n    Dropdown._getParentFromElement = function _getParentFromElement(element) {\n      var parent;\n      var selector = Util.getSelectorFromElement(element);\n\n      if (selector) {\n        parent = $(selector)[0];\n      }\n\n      return parent || element.parentNode;\n    }; // eslint-disable-next-line complexity\n\n\n    Dropdown._dataApiKeydownHandler = function _dataApiKeydownHandler(event) {\n      // If not input/textarea:\n      //  - And not a key in REGEXP_KEYDOWN => not a dropdown command\n      // If input/textarea:\n      //  - If space key => not a dropdown command\n      //  - If key is other than escape\n      //    - If key is not up or down => not a dropdown command\n      //    - If trigger inside the menu => not a dropdown command\n      if (/input|textarea/i.test(event.target.tagName) ? event.which === SPACE_KEYCODE || event.which !== ESCAPE_KEYCODE && (event.which !== ARROW_DOWN_KEYCODE && event.which !== ARROW_UP_KEYCODE || $(event.target).closest(Selector.MENU).length) : !REGEXP_KEYDOWN.test(event.which)) {\n        return;\n      }\n\n      event.preventDefault();\n      event.stopPropagation();\n\n      if (this.disabled || $(this).hasClass(ClassName.DISABLED)) {\n        return;\n      }\n\n      var parent = Dropdown._getParentFromElement(this);\n\n      var isActive = $(parent).hasClass(ClassName.SHOW);\n\n      if (!isActive && (event.which !== ESCAPE_KEYCODE || event.which !== SPACE_KEYCODE) || isActive && (event.which === ESCAPE_KEYCODE || event.which === SPACE_KEYCODE)) {\n        if (event.which === ESCAPE_KEYCODE) {\n          var toggle = $(parent).find(Selector.DATA_TOGGLE)[0];\n          $(toggle).trigger('focus');\n        }\n\n        $(this).trigger('click');\n        return;\n      }\n\n      var items = $(parent).find(Selector.VISIBLE_ITEMS).get();\n\n      if (items.length === 0) {\n        return;\n      }\n\n      var index = items.indexOf(event.target);\n\n      if (event.which === ARROW_UP_KEYCODE && index > 0) {\n        // Up\n        index--;\n      }\n\n      if (event.which === ARROW_DOWN_KEYCODE && index < items.length - 1) {\n        // Down\n        index++;\n      }\n\n      if (index < 0) {\n        index = 0;\n      }\n\n      items[index].focus();\n    };\n\n    _createClass(Dropdown, null, [{\n      key: \"VERSION\",\n      get: function get() {\n        return VERSION;\n      }\n    }, {\n      key: \"Default\",\n      get: function get() {\n        return Default;\n      }\n    }, {\n      key: \"DefaultType\",\n      get: function get() {\n        return DefaultType;\n      }\n    }]);\n\n    return Dropdown;\n  }();\n  /**\n   * ------------------------------------------------------------------------\n   * Data Api implementation\n   * ------------------------------------------------------------------------\n   */\n\n\n  $(document).on(Event.KEYDOWN_DATA_API, Selector.DATA_TOGGLE, Dropdown._dataApiKeydownHandler).on(Event.KEYDOWN_DATA_API, Selector.MENU, Dropdown._dataApiKeydownHandler).on(Event.CLICK_DATA_API + \" \" + Event.KEYUP_DATA_API, Dropdown._clearMenus).on(Event.CLICK_DATA_API, Selector.DATA_TOGGLE, function (event) {\n    event.preventDefault();\n    event.stopPropagation();\n\n    Dropdown._jQueryInterface.call($(this), 'toggle');\n  }).on(Event.CLICK_DATA_API, Selector.FORM_CHILD, function (e) {\n    e.stopPropagation();\n  });\n  /**\n   * ------------------------------------------------------------------------\n   * jQuery\n   * ------------------------------------------------------------------------\n   */\n\n  $.fn[NAME] = Dropdown._jQueryInterface;\n  $.fn[NAME].Constructor = Dropdown;\n\n  $.fn[NAME].noConflict = function () {\n    $.fn[NAME] = JQUERY_NO_CONFLICT;\n    return Dropdown._jQueryInterface;\n  };\n\n  return Dropdown;\n}($, Popper);\n//# sourceMappingURL=dropdown.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/bootstrap/js/dist/dropdown.js\n// module id = 13\n// module chunks = 0","function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\n * --------------------------------------------------------------------------\n * Bootstrap (v4.1.1): modal.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n * --------------------------------------------------------------------------\n */\nvar Modal = function ($) {\n  /**\n   * ------------------------------------------------------------------------\n   * Constants\n   * ------------------------------------------------------------------------\n   */\n  var NAME = 'modal';\n  var VERSION = '4.1.1';\n  var DATA_KEY = 'bs.modal';\n  var EVENT_KEY = \".\" + DATA_KEY;\n  var DATA_API_KEY = '.data-api';\n  var JQUERY_NO_CONFLICT = $.fn[NAME];\n  var ESCAPE_KEYCODE = 27; // KeyboardEvent.which value for Escape (Esc) key\n\n  var Default = {\n    backdrop: true,\n    keyboard: true,\n    focus: true,\n    show: true\n  };\n  var DefaultType = {\n    backdrop: '(boolean|string)',\n    keyboard: 'boolean',\n    focus: 'boolean',\n    show: 'boolean'\n  };\n  var Event = {\n    HIDE: \"hide\" + EVENT_KEY,\n    HIDDEN: \"hidden\" + EVENT_KEY,\n    SHOW: \"show\" + EVENT_KEY,\n    SHOWN: \"shown\" + EVENT_KEY,\n    FOCUSIN: \"focusin\" + EVENT_KEY,\n    RESIZE: \"resize\" + EVENT_KEY,\n    CLICK_DISMISS: \"click.dismiss\" + EVENT_KEY,\n    KEYDOWN_DISMISS: \"keydown.dismiss\" + EVENT_KEY,\n    MOUSEUP_DISMISS: \"mouseup.dismiss\" + EVENT_KEY,\n    MOUSEDOWN_DISMISS: \"mousedown.dismiss\" + EVENT_KEY,\n    CLICK_DATA_API: \"click\" + EVENT_KEY + DATA_API_KEY\n  };\n  var ClassName = {\n    SCROLLBAR_MEASURER: 'modal-scrollbar-measure',\n    BACKDROP: 'modal-backdrop',\n    OPEN: 'modal-open',\n    FADE: 'fade',\n    SHOW: 'show'\n  };\n  var Selector = {\n    DIALOG: '.modal-dialog',\n    DATA_TOGGLE: '[data-toggle=\"modal\"]',\n    DATA_DISMISS: '[data-dismiss=\"modal\"]',\n    FIXED_CONTENT: '.fixed-top, .fixed-bottom, .is-fixed, .sticky-top',\n    STICKY_CONTENT: '.sticky-top',\n    NAVBAR_TOGGLER: '.navbar-toggler'\n    /**\n     * ------------------------------------------------------------------------\n     * Class Definition\n     * ------------------------------------------------------------------------\n     */\n\n  };\n\n  var Modal =\n  /*#__PURE__*/\n  function () {\n    function Modal(element, config) {\n      this._config = this._getConfig(config);\n      this._element = element;\n      this._dialog = $(element).find(Selector.DIALOG)[0];\n      this._backdrop = null;\n      this._isShown = false;\n      this._isBodyOverflowing = false;\n      this._ignoreBackdropClick = false;\n      this._scrollbarWidth = 0;\n    } // Getters\n\n\n    var _proto = Modal.prototype;\n\n    // Public\n    _proto.toggle = function toggle(relatedTarget) {\n      return this._isShown ? this.hide() : this.show(relatedTarget);\n    };\n\n    _proto.show = function show(relatedTarget) {\n      var _this = this;\n\n      if (this._isTransitioning || this._isShown) {\n        return;\n      }\n\n      if ($(this._element).hasClass(ClassName.FADE)) {\n        this._isTransitioning = true;\n      }\n\n      var showEvent = $.Event(Event.SHOW, {\n        relatedTarget: relatedTarget\n      });\n      $(this._element).trigger(showEvent);\n\n      if (this._isShown || showEvent.isDefaultPrevented()) {\n        return;\n      }\n\n      this._isShown = true;\n\n      this._checkScrollbar();\n\n      this._setScrollbar();\n\n      this._adjustDialog();\n\n      $(document.body).addClass(ClassName.OPEN);\n\n      this._setEscapeEvent();\n\n      this._setResizeEvent();\n\n      $(this._element).on(Event.CLICK_DISMISS, Selector.DATA_DISMISS, function (event) {\n        return _this.hide(event);\n      });\n      $(this._dialog).on(Event.MOUSEDOWN_DISMISS, function () {\n        $(_this._element).one(Event.MOUSEUP_DISMISS, function (event) {\n          if ($(event.target).is(_this._element)) {\n            _this._ignoreBackdropClick = true;\n          }\n        });\n      });\n\n      this._showBackdrop(function () {\n        return _this._showElement(relatedTarget);\n      });\n    };\n\n    _proto.hide = function hide(event) {\n      var _this2 = this;\n\n      if (event) {\n        event.preventDefault();\n      }\n\n      if (this._isTransitioning || !this._isShown) {\n        return;\n      }\n\n      var hideEvent = $.Event(Event.HIDE);\n      $(this._element).trigger(hideEvent);\n\n      if (!this._isShown || hideEvent.isDefaultPrevented()) {\n        return;\n      }\n\n      this._isShown = false;\n      var transition = $(this._element).hasClass(ClassName.FADE);\n\n      if (transition) {\n        this._isTransitioning = true;\n      }\n\n      this._setEscapeEvent();\n\n      this._setResizeEvent();\n\n      $(document).off(Event.FOCUSIN);\n      $(this._element).removeClass(ClassName.SHOW);\n      $(this._element).off(Event.CLICK_DISMISS);\n      $(this._dialog).off(Event.MOUSEDOWN_DISMISS);\n\n      if (transition) {\n        var transitionDuration = Util.getTransitionDurationFromElement(this._element);\n        $(this._element).one(Util.TRANSITION_END, function (event) {\n          return _this2._hideModal(event);\n        }).emulateTransitionEnd(transitionDuration);\n      } else {\n        this._hideModal();\n      }\n    };\n\n    _proto.dispose = function dispose() {\n      $.removeData(this._element, DATA_KEY);\n      $(window, document, this._element, this._backdrop).off(EVENT_KEY);\n      this._config = null;\n      this._element = null;\n      this._dialog = null;\n      this._backdrop = null;\n      this._isShown = null;\n      this._isBodyOverflowing = null;\n      this._ignoreBackdropClick = null;\n      this._scrollbarWidth = null;\n    };\n\n    _proto.handleUpdate = function handleUpdate() {\n      this._adjustDialog();\n    }; // Private\n\n\n    _proto._getConfig = function _getConfig(config) {\n      config = _objectSpread({}, Default, config);\n      Util.typeCheckConfig(NAME, config, DefaultType);\n      return config;\n    };\n\n    _proto._showElement = function _showElement(relatedTarget) {\n      var _this3 = this;\n\n      var transition = $(this._element).hasClass(ClassName.FADE);\n\n      if (!this._element.parentNode || this._element.parentNode.nodeType !== Node.ELEMENT_NODE) {\n        // Don't move modal's DOM position\n        document.body.appendChild(this._element);\n      }\n\n      this._element.style.display = 'block';\n\n      this._element.removeAttribute('aria-hidden');\n\n      this._element.scrollTop = 0;\n\n      if (transition) {\n        Util.reflow(this._element);\n      }\n\n      $(this._element).addClass(ClassName.SHOW);\n\n      if (this._config.focus) {\n        this._enforceFocus();\n      }\n\n      var shownEvent = $.Event(Event.SHOWN, {\n        relatedTarget: relatedTarget\n      });\n\n      var transitionComplete = function transitionComplete() {\n        if (_this3._config.focus) {\n          _this3._element.focus();\n        }\n\n        _this3._isTransitioning = false;\n        $(_this3._element).trigger(shownEvent);\n      };\n\n      if (transition) {\n        var transitionDuration = Util.getTransitionDurationFromElement(this._element);\n        $(this._dialog).one(Util.TRANSITION_END, transitionComplete).emulateTransitionEnd(transitionDuration);\n      } else {\n        transitionComplete();\n      }\n    };\n\n    _proto._enforceFocus = function _enforceFocus() {\n      var _this4 = this;\n\n      $(document).off(Event.FOCUSIN) // Guard against infinite focus loop\n      .on(Event.FOCUSIN, function (event) {\n        if (document !== event.target && _this4._element !== event.target && $(_this4._element).has(event.target).length === 0) {\n          _this4._element.focus();\n        }\n      });\n    };\n\n    _proto._setEscapeEvent = function _setEscapeEvent() {\n      var _this5 = this;\n\n      if (this._isShown && this._config.keyboard) {\n        $(this._element).on(Event.KEYDOWN_DISMISS, function (event) {\n          if (event.which === ESCAPE_KEYCODE) {\n            event.preventDefault();\n\n            _this5.hide();\n          }\n        });\n      } else if (!this._isShown) {\n        $(this._element).off(Event.KEYDOWN_DISMISS);\n      }\n    };\n\n    _proto._setResizeEvent = function _setResizeEvent() {\n      var _this6 = this;\n\n      if (this._isShown) {\n        $(window).on(Event.RESIZE, function (event) {\n          return _this6.handleUpdate(event);\n        });\n      } else {\n        $(window).off(Event.RESIZE);\n      }\n    };\n\n    _proto._hideModal = function _hideModal() {\n      var _this7 = this;\n\n      this._element.style.display = 'none';\n\n      this._element.setAttribute('aria-hidden', true);\n\n      this._isTransitioning = false;\n\n      this._showBackdrop(function () {\n        $(document.body).removeClass(ClassName.OPEN);\n\n        _this7._resetAdjustments();\n\n        _this7._resetScrollbar();\n\n        $(_this7._element).trigger(Event.HIDDEN);\n      });\n    };\n\n    _proto._removeBackdrop = function _removeBackdrop() {\n      if (this._backdrop) {\n        $(this._backdrop).remove();\n        this._backdrop = null;\n      }\n    };\n\n    _proto._showBackdrop = function _showBackdrop(callback) {\n      var _this8 = this;\n\n      var animate = $(this._element).hasClass(ClassName.FADE) ? ClassName.FADE : '';\n\n      if (this._isShown && this._config.backdrop) {\n        this._backdrop = document.createElement('div');\n        this._backdrop.className = ClassName.BACKDROP;\n\n        if (animate) {\n          $(this._backdrop).addClass(animate);\n        }\n\n        $(this._backdrop).appendTo(document.body);\n        $(this._element).on(Event.CLICK_DISMISS, function (event) {\n          if (_this8._ignoreBackdropClick) {\n            _this8._ignoreBackdropClick = false;\n            return;\n          }\n\n          if (event.target !== event.currentTarget) {\n            return;\n          }\n\n          if (_this8._config.backdrop === 'static') {\n            _this8._element.focus();\n          } else {\n            _this8.hide();\n          }\n        });\n\n        if (animate) {\n          Util.reflow(this._backdrop);\n        }\n\n        $(this._backdrop).addClass(ClassName.SHOW);\n\n        if (!callback) {\n          return;\n        }\n\n        if (!animate) {\n          callback();\n          return;\n        }\n\n        var backdropTransitionDuration = Util.getTransitionDurationFromElement(this._backdrop);\n        $(this._backdrop).one(Util.TRANSITION_END, callback).emulateTransitionEnd(backdropTransitionDuration);\n      } else if (!this._isShown && this._backdrop) {\n        $(this._backdrop).removeClass(ClassName.SHOW);\n\n        var callbackRemove = function callbackRemove() {\n          _this8._removeBackdrop();\n\n          if (callback) {\n            callback();\n          }\n        };\n\n        if ($(this._element).hasClass(ClassName.FADE)) {\n          var _backdropTransitionDuration = Util.getTransitionDurationFromElement(this._backdrop);\n\n          $(this._backdrop).one(Util.TRANSITION_END, callbackRemove).emulateTransitionEnd(_backdropTransitionDuration);\n        } else {\n          callbackRemove();\n        }\n      } else if (callback) {\n        callback();\n      }\n    }; // ----------------------------------------------------------------------\n    // the following methods are used to handle overflowing modals\n    // todo (fat): these should probably be refactored out of modal.js\n    // ----------------------------------------------------------------------\n\n\n    _proto._adjustDialog = function _adjustDialog() {\n      var isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;\n\n      if (!this._isBodyOverflowing && isModalOverflowing) {\n        this._element.style.paddingLeft = this._scrollbarWidth + \"px\";\n      }\n\n      if (this._isBodyOverflowing && !isModalOverflowing) {\n        this._element.style.paddingRight = this._scrollbarWidth + \"px\";\n      }\n    };\n\n    _proto._resetAdjustments = function _resetAdjustments() {\n      this._element.style.paddingLeft = '';\n      this._element.style.paddingRight = '';\n    };\n\n    _proto._checkScrollbar = function _checkScrollbar() {\n      var rect = document.body.getBoundingClientRect();\n      this._isBodyOverflowing = rect.left + rect.right < window.innerWidth;\n      this._scrollbarWidth = this._getScrollbarWidth();\n    };\n\n    _proto._setScrollbar = function _setScrollbar() {\n      var _this9 = this;\n\n      if (this._isBodyOverflowing) {\n        // Note: DOMNode.style.paddingRight returns the actual value or '' if not set\n        //   while $(DOMNode).css('padding-right') returns the calculated value or 0 if not set\n        // Adjust fixed content padding\n        $(Selector.FIXED_CONTENT).each(function (index, element) {\n          var actualPadding = $(element)[0].style.paddingRight;\n          var calculatedPadding = $(element).css('padding-right');\n          $(element).data('padding-right', actualPadding).css('padding-right', parseFloat(calculatedPadding) + _this9._scrollbarWidth + \"px\");\n        }); // Adjust sticky content margin\n\n        $(Selector.STICKY_CONTENT).each(function (index, element) {\n          var actualMargin = $(element)[0].style.marginRight;\n          var calculatedMargin = $(element).css('margin-right');\n          $(element).data('margin-right', actualMargin).css('margin-right', parseFloat(calculatedMargin) - _this9._scrollbarWidth + \"px\");\n        }); // Adjust navbar-toggler margin\n\n        $(Selector.NAVBAR_TOGGLER).each(function (index, element) {\n          var actualMargin = $(element)[0].style.marginRight;\n          var calculatedMargin = $(element).css('margin-right');\n          $(element).data('margin-right', actualMargin).css('margin-right', parseFloat(calculatedMargin) + _this9._scrollbarWidth + \"px\");\n        }); // Adjust body padding\n\n        var actualPadding = document.body.style.paddingRight;\n        var calculatedPadding = $(document.body).css('padding-right');\n        $(document.body).data('padding-right', actualPadding).css('padding-right', parseFloat(calculatedPadding) + this._scrollbarWidth + \"px\");\n      }\n    };\n\n    _proto._resetScrollbar = function _resetScrollbar() {\n      // Restore fixed content padding\n      $(Selector.FIXED_CONTENT).each(function (index, element) {\n        var padding = $(element).data('padding-right');\n\n        if (typeof padding !== 'undefined') {\n          $(element).css('padding-right', padding).removeData('padding-right');\n        }\n      }); // Restore sticky content and navbar-toggler margin\n\n      $(Selector.STICKY_CONTENT + \", \" + Selector.NAVBAR_TOGGLER).each(function (index, element) {\n        var margin = $(element).data('margin-right');\n\n        if (typeof margin !== 'undefined') {\n          $(element).css('margin-right', margin).removeData('margin-right');\n        }\n      }); // Restore body padding\n\n      var padding = $(document.body).data('padding-right');\n\n      if (typeof padding !== 'undefined') {\n        $(document.body).css('padding-right', padding).removeData('padding-right');\n      }\n    };\n\n    _proto._getScrollbarWidth = function _getScrollbarWidth() {\n      // thx d.walsh\n      var scrollDiv = document.createElement('div');\n      scrollDiv.className = ClassName.SCROLLBAR_MEASURER;\n      document.body.appendChild(scrollDiv);\n      var scrollbarWidth = scrollDiv.getBoundingClientRect().width - scrollDiv.clientWidth;\n      document.body.removeChild(scrollDiv);\n      return scrollbarWidth;\n    }; // Static\n\n\n    Modal._jQueryInterface = function _jQueryInterface(config, relatedTarget) {\n      return this.each(function () {\n        var data = $(this).data(DATA_KEY);\n\n        var _config = _objectSpread({}, Default, $(this).data(), typeof config === 'object' && config ? config : {});\n\n        if (!data) {\n          data = new Modal(this, _config);\n          $(this).data(DATA_KEY, data);\n        }\n\n        if (typeof config === 'string') {\n          if (typeof data[config] === 'undefined') {\n            throw new TypeError(\"No method named \\\"\" + config + \"\\\"\");\n          }\n\n          data[config](relatedTarget);\n        } else if (_config.show) {\n          data.show(relatedTarget);\n        }\n      });\n    };\n\n    _createClass(Modal, null, [{\n      key: \"VERSION\",\n      get: function get() {\n        return VERSION;\n      }\n    }, {\n      key: \"Default\",\n      get: function get() {\n        return Default;\n      }\n    }]);\n\n    return Modal;\n  }();\n  /**\n   * ------------------------------------------------------------------------\n   * Data Api implementation\n   * ------------------------------------------------------------------------\n   */\n\n\n  $(document).on(Event.CLICK_DATA_API, Selector.DATA_TOGGLE, function (event) {\n    var _this10 = this;\n\n    var target;\n    var selector = Util.getSelectorFromElement(this);\n\n    if (selector) {\n      target = $(selector)[0];\n    }\n\n    var config = $(target).data(DATA_KEY) ? 'toggle' : _objectSpread({}, $(target).data(), $(this).data());\n\n    if (this.tagName === 'A' || this.tagName === 'AREA') {\n      event.preventDefault();\n    }\n\n    var $target = $(target).one(Event.SHOW, function (showEvent) {\n      if (showEvent.isDefaultPrevented()) {\n        // Only register focus restorer if modal will actually get shown\n        return;\n      }\n\n      $target.one(Event.HIDDEN, function () {\n        if ($(_this10).is(':visible')) {\n          _this10.focus();\n        }\n      });\n    });\n\n    Modal._jQueryInterface.call($(target), config, this);\n  });\n  /**\n   * ------------------------------------------------------------------------\n   * jQuery\n   * ------------------------------------------------------------------------\n   */\n\n  $.fn[NAME] = Modal._jQueryInterface;\n  $.fn[NAME].Constructor = Modal;\n\n  $.fn[NAME].noConflict = function () {\n    $.fn[NAME] = JQUERY_NO_CONFLICT;\n    return Modal._jQueryInterface;\n  };\n\n  return Modal;\n}($);\n//# sourceMappingURL=modal.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/bootstrap/js/dist/modal.js\n// module id = 14\n// module chunks = 0","function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\n * --------------------------------------------------------------------------\n * Bootstrap (v4.1.1): tooltip.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n * --------------------------------------------------------------------------\n */\nvar Tooltip = function ($) {\n  /**\n   * ------------------------------------------------------------------------\n   * Constants\n   * ------------------------------------------------------------------------\n   */\n  var NAME = 'tooltip';\n  var VERSION = '4.1.1';\n  var DATA_KEY = 'bs.tooltip';\n  var EVENT_KEY = \".\" + DATA_KEY;\n  var JQUERY_NO_CONFLICT = $.fn[NAME];\n  var CLASS_PREFIX = 'bs-tooltip';\n  var BSCLS_PREFIX_REGEX = new RegExp(\"(^|\\\\s)\" + CLASS_PREFIX + \"\\\\S+\", 'g');\n  var DefaultType = {\n    animation: 'boolean',\n    template: 'string',\n    title: '(string|element|function)',\n    trigger: 'string',\n    delay: '(number|object)',\n    html: 'boolean',\n    selector: '(string|boolean)',\n    placement: '(string|function)',\n    offset: '(number|string)',\n    container: '(string|element|boolean)',\n    fallbackPlacement: '(string|array)',\n    boundary: '(string|element)'\n  };\n  var AttachmentMap = {\n    AUTO: 'auto',\n    TOP: 'top',\n    RIGHT: 'right',\n    BOTTOM: 'bottom',\n    LEFT: 'left'\n  };\n  var Default = {\n    animation: true,\n    template: '<div class=\"tooltip\" role=\"tooltip\">' + '<div class=\"arrow\"></div>' + '<div class=\"tooltip-inner\"></div></div>',\n    trigger: 'hover focus',\n    title: '',\n    delay: 0,\n    html: false,\n    selector: false,\n    placement: 'top',\n    offset: 0,\n    container: false,\n    fallbackPlacement: 'flip',\n    boundary: 'scrollParent'\n  };\n  var HoverState = {\n    SHOW: 'show',\n    OUT: 'out'\n  };\n  var Event = {\n    HIDE: \"hide\" + EVENT_KEY,\n    HIDDEN: \"hidden\" + EVENT_KEY,\n    SHOW: \"show\" + EVENT_KEY,\n    SHOWN: \"shown\" + EVENT_KEY,\n    INSERTED: \"inserted\" + EVENT_KEY,\n    CLICK: \"click\" + EVENT_KEY,\n    FOCUSIN: \"focusin\" + EVENT_KEY,\n    FOCUSOUT: \"focusout\" + EVENT_KEY,\n    MOUSEENTER: \"mouseenter\" + EVENT_KEY,\n    MOUSELEAVE: \"mouseleave\" + EVENT_KEY\n  };\n  var ClassName = {\n    FADE: 'fade',\n    SHOW: 'show'\n  };\n  var Selector = {\n    TOOLTIP: '.tooltip',\n    TOOLTIP_INNER: '.tooltip-inner',\n    ARROW: '.arrow'\n  };\n  var Trigger = {\n    HOVER: 'hover',\n    FOCUS: 'focus',\n    CLICK: 'click',\n    MANUAL: 'manual'\n    /**\n     * ------------------------------------------------------------------------\n     * Class Definition\n     * ------------------------------------------------------------------------\n     */\n\n  };\n\n  var Tooltip =\n  /*#__PURE__*/\n  function () {\n    function Tooltip(element, config) {\n      /**\n       * Check for Popper dependency\n       * Popper - https://popper.js.org\n       */\n      if (typeof Popper === 'undefined') {\n        throw new TypeError('Bootstrap tooltips require Popper.js (https://popper.js.org)');\n      } // private\n\n\n      this._isEnabled = true;\n      this._timeout = 0;\n      this._hoverState = '';\n      this._activeTrigger = {};\n      this._popper = null; // Protected\n\n      this.element = element;\n      this.config = this._getConfig(config);\n      this.tip = null;\n\n      this._setListeners();\n    } // Getters\n\n\n    var _proto = Tooltip.prototype;\n\n    // Public\n    _proto.enable = function enable() {\n      this._isEnabled = true;\n    };\n\n    _proto.disable = function disable() {\n      this._isEnabled = false;\n    };\n\n    _proto.toggleEnabled = function toggleEnabled() {\n      this._isEnabled = !this._isEnabled;\n    };\n\n    _proto.toggle = function toggle(event) {\n      if (!this._isEnabled) {\n        return;\n      }\n\n      if (event) {\n        var dataKey = this.constructor.DATA_KEY;\n        var context = $(event.currentTarget).data(dataKey);\n\n        if (!context) {\n          context = new this.constructor(event.currentTarget, this._getDelegateConfig());\n          $(event.currentTarget).data(dataKey, context);\n        }\n\n        context._activeTrigger.click = !context._activeTrigger.click;\n\n        if (context._isWithActiveTrigger()) {\n          context._enter(null, context);\n        } else {\n          context._leave(null, context);\n        }\n      } else {\n        if ($(this.getTipElement()).hasClass(ClassName.SHOW)) {\n          this._leave(null, this);\n\n          return;\n        }\n\n        this._enter(null, this);\n      }\n    };\n\n    _proto.dispose = function dispose() {\n      clearTimeout(this._timeout);\n      $.removeData(this.element, this.constructor.DATA_KEY);\n      $(this.element).off(this.constructor.EVENT_KEY);\n      $(this.element).closest('.modal').off('hide.bs.modal');\n\n      if (this.tip) {\n        $(this.tip).remove();\n      }\n\n      this._isEnabled = null;\n      this._timeout = null;\n      this._hoverState = null;\n      this._activeTrigger = null;\n\n      if (this._popper !== null) {\n        this._popper.destroy();\n      }\n\n      this._popper = null;\n      this.element = null;\n      this.config = null;\n      this.tip = null;\n    };\n\n    _proto.show = function show() {\n      var _this = this;\n\n      if ($(this.element).css('display') === 'none') {\n        throw new Error('Please use show on visible elements');\n      }\n\n      var showEvent = $.Event(this.constructor.Event.SHOW);\n\n      if (this.isWithContent() && this._isEnabled) {\n        $(this.element).trigger(showEvent);\n        var isInTheDom = $.contains(this.element.ownerDocument.documentElement, this.element);\n\n        if (showEvent.isDefaultPrevented() || !isInTheDom) {\n          return;\n        }\n\n        var tip = this.getTipElement();\n        var tipId = Util.getUID(this.constructor.NAME);\n        tip.setAttribute('id', tipId);\n        this.element.setAttribute('aria-describedby', tipId);\n        this.setContent();\n\n        if (this.config.animation) {\n          $(tip).addClass(ClassName.FADE);\n        }\n\n        var placement = typeof this.config.placement === 'function' ? this.config.placement.call(this, tip, this.element) : this.config.placement;\n\n        var attachment = this._getAttachment(placement);\n\n        this.addAttachmentClass(attachment);\n        var container = this.config.container === false ? document.body : $(this.config.container);\n        $(tip).data(this.constructor.DATA_KEY, this);\n\n        if (!$.contains(this.element.ownerDocument.documentElement, this.tip)) {\n          $(tip).appendTo(container);\n        }\n\n        $(this.element).trigger(this.constructor.Event.INSERTED);\n        this._popper = new Popper(this.element, tip, {\n          placement: attachment,\n          modifiers: {\n            offset: {\n              offset: this.config.offset\n            },\n            flip: {\n              behavior: this.config.fallbackPlacement\n            },\n            arrow: {\n              element: Selector.ARROW\n            },\n            preventOverflow: {\n              boundariesElement: this.config.boundary\n            }\n          },\n          onCreate: function onCreate(data) {\n            if (data.originalPlacement !== data.placement) {\n              _this._handlePopperPlacementChange(data);\n            }\n          },\n          onUpdate: function onUpdate(data) {\n            _this._handlePopperPlacementChange(data);\n          }\n        });\n        $(tip).addClass(ClassName.SHOW); // If this is a touch-enabled device we add extra\n        // empty mouseover listeners to the body's immediate children;\n        // only needed because of broken event delegation on iOS\n        // https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html\n\n        if ('ontouchstart' in document.documentElement) {\n          $(document.body).children().on('mouseover', null, $.noop);\n        }\n\n        var complete = function complete() {\n          if (_this.config.animation) {\n            _this._fixTransition();\n          }\n\n          var prevHoverState = _this._hoverState;\n          _this._hoverState = null;\n          $(_this.element).trigger(_this.constructor.Event.SHOWN);\n\n          if (prevHoverState === HoverState.OUT) {\n            _this._leave(null, _this);\n          }\n        };\n\n        if ($(this.tip).hasClass(ClassName.FADE)) {\n          var transitionDuration = Util.getTransitionDurationFromElement(this.tip);\n          $(this.tip).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);\n        } else {\n          complete();\n        }\n      }\n    };\n\n    _proto.hide = function hide(callback) {\n      var _this2 = this;\n\n      var tip = this.getTipElement();\n      var hideEvent = $.Event(this.constructor.Event.HIDE);\n\n      var complete = function complete() {\n        if (_this2._hoverState !== HoverState.SHOW && tip.parentNode) {\n          tip.parentNode.removeChild(tip);\n        }\n\n        _this2._cleanTipClass();\n\n        _this2.element.removeAttribute('aria-describedby');\n\n        $(_this2.element).trigger(_this2.constructor.Event.HIDDEN);\n\n        if (_this2._popper !== null) {\n          _this2._popper.destroy();\n        }\n\n        if (callback) {\n          callback();\n        }\n      };\n\n      $(this.element).trigger(hideEvent);\n\n      if (hideEvent.isDefaultPrevented()) {\n        return;\n      }\n\n      $(tip).removeClass(ClassName.SHOW); // If this is a touch-enabled device we remove the extra\n      // empty mouseover listeners we added for iOS support\n\n      if ('ontouchstart' in document.documentElement) {\n        $(document.body).children().off('mouseover', null, $.noop);\n      }\n\n      this._activeTrigger[Trigger.CLICK] = false;\n      this._activeTrigger[Trigger.FOCUS] = false;\n      this._activeTrigger[Trigger.HOVER] = false;\n\n      if ($(this.tip).hasClass(ClassName.FADE)) {\n        var transitionDuration = Util.getTransitionDurationFromElement(tip);\n        $(tip).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);\n      } else {\n        complete();\n      }\n\n      this._hoverState = '';\n    };\n\n    _proto.update = function update() {\n      if (this._popper !== null) {\n        this._popper.scheduleUpdate();\n      }\n    }; // Protected\n\n\n    _proto.isWithContent = function isWithContent() {\n      return Boolean(this.getTitle());\n    };\n\n    _proto.addAttachmentClass = function addAttachmentClass(attachment) {\n      $(this.getTipElement()).addClass(CLASS_PREFIX + \"-\" + attachment);\n    };\n\n    _proto.getTipElement = function getTipElement() {\n      this.tip = this.tip || $(this.config.template)[0];\n      return this.tip;\n    };\n\n    _proto.setContent = function setContent() {\n      var $tip = $(this.getTipElement());\n      this.setElementContent($tip.find(Selector.TOOLTIP_INNER), this.getTitle());\n      $tip.removeClass(ClassName.FADE + \" \" + ClassName.SHOW);\n    };\n\n    _proto.setElementContent = function setElementContent($element, content) {\n      var html = this.config.html;\n\n      if (typeof content === 'object' && (content.nodeType || content.jquery)) {\n        // Content is a DOM node or a jQuery\n        if (html) {\n          if (!$(content).parent().is($element)) {\n            $element.empty().append(content);\n          }\n        } else {\n          $element.text($(content).text());\n        }\n      } else {\n        $element[html ? 'html' : 'text'](content);\n      }\n    };\n\n    _proto.getTitle = function getTitle() {\n      var title = this.element.getAttribute('data-original-title');\n\n      if (!title) {\n        title = typeof this.config.title === 'function' ? this.config.title.call(this.element) : this.config.title;\n      }\n\n      return title;\n    }; // Private\n\n\n    _proto._getAttachment = function _getAttachment(placement) {\n      return AttachmentMap[placement.toUpperCase()];\n    };\n\n    _proto._setListeners = function _setListeners() {\n      var _this3 = this;\n\n      var triggers = this.config.trigger.split(' ');\n      triggers.forEach(function (trigger) {\n        if (trigger === 'click') {\n          $(_this3.element).on(_this3.constructor.Event.CLICK, _this3.config.selector, function (event) {\n            return _this3.toggle(event);\n          });\n        } else if (trigger !== Trigger.MANUAL) {\n          var eventIn = trigger === Trigger.HOVER ? _this3.constructor.Event.MOUSEENTER : _this3.constructor.Event.FOCUSIN;\n          var eventOut = trigger === Trigger.HOVER ? _this3.constructor.Event.MOUSELEAVE : _this3.constructor.Event.FOCUSOUT;\n          $(_this3.element).on(eventIn, _this3.config.selector, function (event) {\n            return _this3._enter(event);\n          }).on(eventOut, _this3.config.selector, function (event) {\n            return _this3._leave(event);\n          });\n        }\n\n        $(_this3.element).closest('.modal').on('hide.bs.modal', function () {\n          return _this3.hide();\n        });\n      });\n\n      if (this.config.selector) {\n        this.config = _objectSpread({}, this.config, {\n          trigger: 'manual',\n          selector: ''\n        });\n      } else {\n        this._fixTitle();\n      }\n    };\n\n    _proto._fixTitle = function _fixTitle() {\n      var titleType = typeof this.element.getAttribute('data-original-title');\n\n      if (this.element.getAttribute('title') || titleType !== 'string') {\n        this.element.setAttribute('data-original-title', this.element.getAttribute('title') || '');\n        this.element.setAttribute('title', '');\n      }\n    };\n\n    _proto._enter = function _enter(event, context) {\n      var dataKey = this.constructor.DATA_KEY;\n      context = context || $(event.currentTarget).data(dataKey);\n\n      if (!context) {\n        context = new this.constructor(event.currentTarget, this._getDelegateConfig());\n        $(event.currentTarget).data(dataKey, context);\n      }\n\n      if (event) {\n        context._activeTrigger[event.type === 'focusin' ? Trigger.FOCUS : Trigger.HOVER] = true;\n      }\n\n      if ($(context.getTipElement()).hasClass(ClassName.SHOW) || context._hoverState === HoverState.SHOW) {\n        context._hoverState = HoverState.SHOW;\n        return;\n      }\n\n      clearTimeout(context._timeout);\n      context._hoverState = HoverState.SHOW;\n\n      if (!context.config.delay || !context.config.delay.show) {\n        context.show();\n        return;\n      }\n\n      context._timeout = setTimeout(function () {\n        if (context._hoverState === HoverState.SHOW) {\n          context.show();\n        }\n      }, context.config.delay.show);\n    };\n\n    _proto._leave = function _leave(event, context) {\n      var dataKey = this.constructor.DATA_KEY;\n      context = context || $(event.currentTarget).data(dataKey);\n\n      if (!context) {\n        context = new this.constructor(event.currentTarget, this._getDelegateConfig());\n        $(event.currentTarget).data(dataKey, context);\n      }\n\n      if (event) {\n        context._activeTrigger[event.type === 'focusout' ? Trigger.FOCUS : Trigger.HOVER] = false;\n      }\n\n      if (context._isWithActiveTrigger()) {\n        return;\n      }\n\n      clearTimeout(context._timeout);\n      context._hoverState = HoverState.OUT;\n\n      if (!context.config.delay || !context.config.delay.hide) {\n        context.hide();\n        return;\n      }\n\n      context._timeout = setTimeout(function () {\n        if (context._hoverState === HoverState.OUT) {\n          context.hide();\n        }\n      }, context.config.delay.hide);\n    };\n\n    _proto._isWithActiveTrigger = function _isWithActiveTrigger() {\n      for (var trigger in this._activeTrigger) {\n        if (this._activeTrigger[trigger]) {\n          return true;\n        }\n      }\n\n      return false;\n    };\n\n    _proto._getConfig = function _getConfig(config) {\n      config = _objectSpread({}, this.constructor.Default, $(this.element).data(), typeof config === 'object' && config ? config : {});\n\n      if (typeof config.delay === 'number') {\n        config.delay = {\n          show: config.delay,\n          hide: config.delay\n        };\n      }\n\n      if (typeof config.title === 'number') {\n        config.title = config.title.toString();\n      }\n\n      if (typeof config.content === 'number') {\n        config.content = config.content.toString();\n      }\n\n      Util.typeCheckConfig(NAME, config, this.constructor.DefaultType);\n      return config;\n    };\n\n    _proto._getDelegateConfig = function _getDelegateConfig() {\n      var config = {};\n\n      if (this.config) {\n        for (var key in this.config) {\n          if (this.constructor.Default[key] !== this.config[key]) {\n            config[key] = this.config[key];\n          }\n        }\n      }\n\n      return config;\n    };\n\n    _proto._cleanTipClass = function _cleanTipClass() {\n      var $tip = $(this.getTipElement());\n      var tabClass = $tip.attr('class').match(BSCLS_PREFIX_REGEX);\n\n      if (tabClass !== null && tabClass.length > 0) {\n        $tip.removeClass(tabClass.join(''));\n      }\n    };\n\n    _proto._handlePopperPlacementChange = function _handlePopperPlacementChange(data) {\n      this._cleanTipClass();\n\n      this.addAttachmentClass(this._getAttachment(data.placement));\n    };\n\n    _proto._fixTransition = function _fixTransition() {\n      var tip = this.getTipElement();\n      var initConfigAnimation = this.config.animation;\n\n      if (tip.getAttribute('x-placement') !== null) {\n        return;\n      }\n\n      $(tip).removeClass(ClassName.FADE);\n      this.config.animation = false;\n      this.hide();\n      this.show();\n      this.config.animation = initConfigAnimation;\n    }; // Static\n\n\n    Tooltip._jQueryInterface = function _jQueryInterface(config) {\n      return this.each(function () {\n        var data = $(this).data(DATA_KEY);\n\n        var _config = typeof config === 'object' && config;\n\n        if (!data && /dispose|hide/.test(config)) {\n          return;\n        }\n\n        if (!data) {\n          data = new Tooltip(this, _config);\n          $(this).data(DATA_KEY, data);\n        }\n\n        if (typeof config === 'string') {\n          if (typeof data[config] === 'undefined') {\n            throw new TypeError(\"No method named \\\"\" + config + \"\\\"\");\n          }\n\n          data[config]();\n        }\n      });\n    };\n\n    _createClass(Tooltip, null, [{\n      key: \"VERSION\",\n      get: function get() {\n        return VERSION;\n      }\n    }, {\n      key: \"Default\",\n      get: function get() {\n        return Default;\n      }\n    }, {\n      key: \"NAME\",\n      get: function get() {\n        return NAME;\n      }\n    }, {\n      key: \"DATA_KEY\",\n      get: function get() {\n        return DATA_KEY;\n      }\n    }, {\n      key: \"Event\",\n      get: function get() {\n        return Event;\n      }\n    }, {\n      key: \"EVENT_KEY\",\n      get: function get() {\n        return EVENT_KEY;\n      }\n    }, {\n      key: \"DefaultType\",\n      get: function get() {\n        return DefaultType;\n      }\n    }]);\n\n    return Tooltip;\n  }();\n  /**\n   * ------------------------------------------------------------------------\n   * jQuery\n   * ------------------------------------------------------------------------\n   */\n\n\n  $.fn[NAME] = Tooltip._jQueryInterface;\n  $.fn[NAME].Constructor = Tooltip;\n\n  $.fn[NAME].noConflict = function () {\n    $.fn[NAME] = JQUERY_NO_CONFLICT;\n    return Tooltip._jQueryInterface;\n  };\n\n  return Tooltip;\n}($, Popper);\n//# sourceMappingURL=tooltip.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/bootstrap/js/dist/tooltip.js\n// module id = 15\n// module chunks = 0","function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/**\n * --------------------------------------------------------------------------\n * Bootstrap (v4.1.1): popover.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n * --------------------------------------------------------------------------\n */\nvar Popover = function ($) {\n  /**\n   * ------------------------------------------------------------------------\n   * Constants\n   * ------------------------------------------------------------------------\n   */\n  var NAME = 'popover';\n  var VERSION = '4.1.1';\n  var DATA_KEY = 'bs.popover';\n  var EVENT_KEY = \".\" + DATA_KEY;\n  var JQUERY_NO_CONFLICT = $.fn[NAME];\n  var CLASS_PREFIX = 'bs-popover';\n  var BSCLS_PREFIX_REGEX = new RegExp(\"(^|\\\\s)\" + CLASS_PREFIX + \"\\\\S+\", 'g');\n\n  var Default = _objectSpread({}, Tooltip.Default, {\n    placement: 'right',\n    trigger: 'click',\n    content: '',\n    template: '<div class=\"popover\" role=\"tooltip\">' + '<div class=\"arrow\"></div>' + '<h3 class=\"popover-header\"></h3>' + '<div class=\"popover-body\"></div></div>'\n  });\n\n  var DefaultType = _objectSpread({}, Tooltip.DefaultType, {\n    content: '(string|element|function)'\n  });\n\n  var ClassName = {\n    FADE: 'fade',\n    SHOW: 'show'\n  };\n  var Selector = {\n    TITLE: '.popover-header',\n    CONTENT: '.popover-body'\n  };\n  var Event = {\n    HIDE: \"hide\" + EVENT_KEY,\n    HIDDEN: \"hidden\" + EVENT_KEY,\n    SHOW: \"show\" + EVENT_KEY,\n    SHOWN: \"shown\" + EVENT_KEY,\n    INSERTED: \"inserted\" + EVENT_KEY,\n    CLICK: \"click\" + EVENT_KEY,\n    FOCUSIN: \"focusin\" + EVENT_KEY,\n    FOCUSOUT: \"focusout\" + EVENT_KEY,\n    MOUSEENTER: \"mouseenter\" + EVENT_KEY,\n    MOUSELEAVE: \"mouseleave\" + EVENT_KEY\n    /**\n     * ------------------------------------------------------------------------\n     * Class Definition\n     * ------------------------------------------------------------------------\n     */\n\n  };\n\n  var Popover =\n  /*#__PURE__*/\n  function (_Tooltip) {\n    _inheritsLoose(Popover, _Tooltip);\n\n    function Popover() {\n      return _Tooltip.apply(this, arguments) || this;\n    }\n\n    var _proto = Popover.prototype;\n\n    // Overrides\n    _proto.isWithContent = function isWithContent() {\n      return this.getTitle() || this._getContent();\n    };\n\n    _proto.addAttachmentClass = function addAttachmentClass(attachment) {\n      $(this.getTipElement()).addClass(CLASS_PREFIX + \"-\" + attachment);\n    };\n\n    _proto.getTipElement = function getTipElement() {\n      this.tip = this.tip || $(this.config.template)[0];\n      return this.tip;\n    };\n\n    _proto.setContent = function setContent() {\n      var $tip = $(this.getTipElement()); // We use append for html objects to maintain js events\n\n      this.setElementContent($tip.find(Selector.TITLE), this.getTitle());\n\n      var content = this._getContent();\n\n      if (typeof content === 'function') {\n        content = content.call(this.element);\n      }\n\n      this.setElementContent($tip.find(Selector.CONTENT), content);\n      $tip.removeClass(ClassName.FADE + \" \" + ClassName.SHOW);\n    }; // Private\n\n\n    _proto._getContent = function _getContent() {\n      return this.element.getAttribute('data-content') || this.config.content;\n    };\n\n    _proto._cleanTipClass = function _cleanTipClass() {\n      var $tip = $(this.getTipElement());\n      var tabClass = $tip.attr('class').match(BSCLS_PREFIX_REGEX);\n\n      if (tabClass !== null && tabClass.length > 0) {\n        $tip.removeClass(tabClass.join(''));\n      }\n    }; // Static\n\n\n    Popover._jQueryInterface = function _jQueryInterface(config) {\n      return this.each(function () {\n        var data = $(this).data(DATA_KEY);\n\n        var _config = typeof config === 'object' ? config : null;\n\n        if (!data && /destroy|hide/.test(config)) {\n          return;\n        }\n\n        if (!data) {\n          data = new Popover(this, _config);\n          $(this).data(DATA_KEY, data);\n        }\n\n        if (typeof config === 'string') {\n          if (typeof data[config] === 'undefined') {\n            throw new TypeError(\"No method named \\\"\" + config + \"\\\"\");\n          }\n\n          data[config]();\n        }\n      });\n    };\n\n    _createClass(Popover, null, [{\n      key: \"VERSION\",\n      // Getters\n      get: function get() {\n        return VERSION;\n      }\n    }, {\n      key: \"Default\",\n      get: function get() {\n        return Default;\n      }\n    }, {\n      key: \"NAME\",\n      get: function get() {\n        return NAME;\n      }\n    }, {\n      key: \"DATA_KEY\",\n      get: function get() {\n        return DATA_KEY;\n      }\n    }, {\n      key: \"Event\",\n      get: function get() {\n        return Event;\n      }\n    }, {\n      key: \"EVENT_KEY\",\n      get: function get() {\n        return EVENT_KEY;\n      }\n    }, {\n      key: \"DefaultType\",\n      get: function get() {\n        return DefaultType;\n      }\n    }]);\n\n    return Popover;\n  }(Tooltip);\n  /**\n   * ------------------------------------------------------------------------\n   * jQuery\n   * ------------------------------------------------------------------------\n   */\n\n\n  $.fn[NAME] = Popover._jQueryInterface;\n  $.fn[NAME].Constructor = Popover;\n\n  $.fn[NAME].noConflict = function () {\n    $.fn[NAME] = JQUERY_NO_CONFLICT;\n    return Popover._jQueryInterface;\n  };\n\n  return Popover;\n}($);\n//# sourceMappingURL=popover.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/bootstrap/js/dist/popover.js\n// module id = 16\n// module chunks = 0","function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\n * --------------------------------------------------------------------------\n * Bootstrap (v4.1.1): tooltip.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n * --------------------------------------------------------------------------\n */\nvar Tooltip = function ($) {\n  /**\n   * ------------------------------------------------------------------------\n   * Constants\n   * ------------------------------------------------------------------------\n   */\n  var NAME = 'tooltip';\n  var VERSION = '4.1.1';\n  var DATA_KEY = 'bs.tooltip';\n  var EVENT_KEY = \".\" + DATA_KEY;\n  var JQUERY_NO_CONFLICT = $.fn[NAME];\n  var CLASS_PREFIX = 'bs-tooltip';\n  var BSCLS_PREFIX_REGEX = new RegExp(\"(^|\\\\s)\" + CLASS_PREFIX + \"\\\\S+\", 'g');\n  var DefaultType = {\n    animation: 'boolean',\n    template: 'string',\n    title: '(string|element|function)',\n    trigger: 'string',\n    delay: '(number|object)',\n    html: 'boolean',\n    selector: '(string|boolean)',\n    placement: '(string|function)',\n    offset: '(number|string)',\n    container: '(string|element|boolean)',\n    fallbackPlacement: '(string|array)',\n    boundary: '(string|element)'\n  };\n  var AttachmentMap = {\n    AUTO: 'auto',\n    TOP: 'top',\n    RIGHT: 'right',\n    BOTTOM: 'bottom',\n    LEFT: 'left'\n  };\n  var Default = {\n    animation: true,\n    template: '<div class=\"tooltip\" role=\"tooltip\">' + '<div class=\"arrow\"></div>' + '<div class=\"tooltip-inner\"></div></div>',\n    trigger: 'hover focus',\n    title: '',\n    delay: 0,\n    html: false,\n    selector: false,\n    placement: 'top',\n    offset: 0,\n    container: false,\n    fallbackPlacement: 'flip',\n    boundary: 'scrollParent'\n  };\n  var HoverState = {\n    SHOW: 'show',\n    OUT: 'out'\n  };\n  var Event = {\n    HIDE: \"hide\" + EVENT_KEY,\n    HIDDEN: \"hidden\" + EVENT_KEY,\n    SHOW: \"show\" + EVENT_KEY,\n    SHOWN: \"shown\" + EVENT_KEY,\n    INSERTED: \"inserted\" + EVENT_KEY,\n    CLICK: \"click\" + EVENT_KEY,\n    FOCUSIN: \"focusin\" + EVENT_KEY,\n    FOCUSOUT: \"focusout\" + EVENT_KEY,\n    MOUSEENTER: \"mouseenter\" + EVENT_KEY,\n    MOUSELEAVE: \"mouseleave\" + EVENT_KEY\n  };\n  var ClassName = {\n    FADE: 'fade',\n    SHOW: 'show'\n  };\n  var Selector = {\n    TOOLTIP: '.tooltip',\n    TOOLTIP_INNER: '.tooltip-inner',\n    ARROW: '.arrow'\n  };\n  var Trigger = {\n    HOVER: 'hover',\n    FOCUS: 'focus',\n    CLICK: 'click',\n    MANUAL: 'manual'\n    /**\n     * ------------------------------------------------------------------------\n     * Class Definition\n     * ------------------------------------------------------------------------\n     */\n\n  };\n\n  var Tooltip =\n  /*#__PURE__*/\n  function () {\n    function Tooltip(element, config) {\n      /**\n       * Check for Popper dependency\n       * Popper - https://popper.js.org\n       */\n      if (typeof Popper === 'undefined') {\n        throw new TypeError('Bootstrap tooltips require Popper.js (https://popper.js.org)');\n      } // private\n\n\n      this._isEnabled = true;\n      this._timeout = 0;\n      this._hoverState = '';\n      this._activeTrigger = {};\n      this._popper = null; // Protected\n\n      this.element = element;\n      this.config = this._getConfig(config);\n      this.tip = null;\n\n      this._setListeners();\n    } // Getters\n\n\n    var _proto = Tooltip.prototype;\n\n    // Public\n    _proto.enable = function enable() {\n      this._isEnabled = true;\n    };\n\n    _proto.disable = function disable() {\n      this._isEnabled = false;\n    };\n\n    _proto.toggleEnabled = function toggleEnabled() {\n      this._isEnabled = !this._isEnabled;\n    };\n\n    _proto.toggle = function toggle(event) {\n      if (!this._isEnabled) {\n        return;\n      }\n\n      if (event) {\n        var dataKey = this.constructor.DATA_KEY;\n        var context = $(event.currentTarget).data(dataKey);\n\n        if (!context) {\n          context = new this.constructor(event.currentTarget, this._getDelegateConfig());\n          $(event.currentTarget).data(dataKey, context);\n        }\n\n        context._activeTrigger.click = !context._activeTrigger.click;\n\n        if (context._isWithActiveTrigger()) {\n          context._enter(null, context);\n        } else {\n          context._leave(null, context);\n        }\n      } else {\n        if ($(this.getTipElement()).hasClass(ClassName.SHOW)) {\n          this._leave(null, this);\n\n          return;\n        }\n\n        this._enter(null, this);\n      }\n    };\n\n    _proto.dispose = function dispose() {\n      clearTimeout(this._timeout);\n      $.removeData(this.element, this.constructor.DATA_KEY);\n      $(this.element).off(this.constructor.EVENT_KEY);\n      $(this.element).closest('.modal').off('hide.bs.modal');\n\n      if (this.tip) {\n        $(this.tip).remove();\n      }\n\n      this._isEnabled = null;\n      this._timeout = null;\n      this._hoverState = null;\n      this._activeTrigger = null;\n\n      if (this._popper !== null) {\n        this._popper.destroy();\n      }\n\n      this._popper = null;\n      this.element = null;\n      this.config = null;\n      this.tip = null;\n    };\n\n    _proto.show = function show() {\n      var _this = this;\n\n      if ($(this.element).css('display') === 'none') {\n        throw new Error('Please use show on visible elements');\n      }\n\n      var showEvent = $.Event(this.constructor.Event.SHOW);\n\n      if (this.isWithContent() && this._isEnabled) {\n        $(this.element).trigger(showEvent);\n        var isInTheDom = $.contains(this.element.ownerDocument.documentElement, this.element);\n\n        if (showEvent.isDefaultPrevented() || !isInTheDom) {\n          return;\n        }\n\n        var tip = this.getTipElement();\n        var tipId = Util.getUID(this.constructor.NAME);\n        tip.setAttribute('id', tipId);\n        this.element.setAttribute('aria-describedby', tipId);\n        this.setContent();\n\n        if (this.config.animation) {\n          $(tip).addClass(ClassName.FADE);\n        }\n\n        var placement = typeof this.config.placement === 'function' ? this.config.placement.call(this, tip, this.element) : this.config.placement;\n\n        var attachment = this._getAttachment(placement);\n\n        this.addAttachmentClass(attachment);\n        var container = this.config.container === false ? document.body : $(this.config.container);\n        $(tip).data(this.constructor.DATA_KEY, this);\n\n        if (!$.contains(this.element.ownerDocument.documentElement, this.tip)) {\n          $(tip).appendTo(container);\n        }\n\n        $(this.element).trigger(this.constructor.Event.INSERTED);\n        this._popper = new Popper(this.element, tip, {\n          placement: attachment,\n          modifiers: {\n            offset: {\n              offset: this.config.offset\n            },\n            flip: {\n              behavior: this.config.fallbackPlacement\n            },\n            arrow: {\n              element: Selector.ARROW\n            },\n            preventOverflow: {\n              boundariesElement: this.config.boundary\n            }\n          },\n          onCreate: function onCreate(data) {\n            if (data.originalPlacement !== data.placement) {\n              _this._handlePopperPlacementChange(data);\n            }\n          },\n          onUpdate: function onUpdate(data) {\n            _this._handlePopperPlacementChange(data);\n          }\n        });\n        $(tip).addClass(ClassName.SHOW); // If this is a touch-enabled device we add extra\n        // empty mouseover listeners to the body's immediate children;\n        // only needed because of broken event delegation on iOS\n        // https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html\n\n        if ('ontouchstart' in document.documentElement) {\n          $(document.body).children().on('mouseover', null, $.noop);\n        }\n\n        var complete = function complete() {\n          if (_this.config.animation) {\n            _this._fixTransition();\n          }\n\n          var prevHoverState = _this._hoverState;\n          _this._hoverState = null;\n          $(_this.element).trigger(_this.constructor.Event.SHOWN);\n\n          if (prevHoverState === HoverState.OUT) {\n            _this._leave(null, _this);\n          }\n        };\n\n        if ($(this.tip).hasClass(ClassName.FADE)) {\n          var transitionDuration = Util.getTransitionDurationFromElement(this.tip);\n          $(this.tip).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);\n        } else {\n          complete();\n        }\n      }\n    };\n\n    _proto.hide = function hide(callback) {\n      var _this2 = this;\n\n      var tip = this.getTipElement();\n      var hideEvent = $.Event(this.constructor.Event.HIDE);\n\n      var complete = function complete() {\n        if (_this2._hoverState !== HoverState.SHOW && tip.parentNode) {\n          tip.parentNode.removeChild(tip);\n        }\n\n        _this2._cleanTipClass();\n\n        _this2.element.removeAttribute('aria-describedby');\n\n        $(_this2.element).trigger(_this2.constructor.Event.HIDDEN);\n\n        if (_this2._popper !== null) {\n          _this2._popper.destroy();\n        }\n\n        if (callback) {\n          callback();\n        }\n      };\n\n      $(this.element).trigger(hideEvent);\n\n      if (hideEvent.isDefaultPrevented()) {\n        return;\n      }\n\n      $(tip).removeClass(ClassName.SHOW); // If this is a touch-enabled device we remove the extra\n      // empty mouseover listeners we added for iOS support\n\n      if ('ontouchstart' in document.documentElement) {\n        $(document.body).children().off('mouseover', null, $.noop);\n      }\n\n      this._activeTrigger[Trigger.CLICK] = false;\n      this._activeTrigger[Trigger.FOCUS] = false;\n      this._activeTrigger[Trigger.HOVER] = false;\n\n      if ($(this.tip).hasClass(ClassName.FADE)) {\n        var transitionDuration = Util.getTransitionDurationFromElement(tip);\n        $(tip).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);\n      } else {\n        complete();\n      }\n\n      this._hoverState = '';\n    };\n\n    _proto.update = function update() {\n      if (this._popper !== null) {\n        this._popper.scheduleUpdate();\n      }\n    }; // Protected\n\n\n    _proto.isWithContent = function isWithContent() {\n      return Boolean(this.getTitle());\n    };\n\n    _proto.addAttachmentClass = function addAttachmentClass(attachment) {\n      $(this.getTipElement()).addClass(CLASS_PREFIX + \"-\" + attachment);\n    };\n\n    _proto.getTipElement = function getTipElement() {\n      this.tip = this.tip || $(this.config.template)[0];\n      return this.tip;\n    };\n\n    _proto.setContent = function setContent() {\n      var $tip = $(this.getTipElement());\n      this.setElementContent($tip.find(Selector.TOOLTIP_INNER), this.getTitle());\n      $tip.removeClass(ClassName.FADE + \" \" + ClassName.SHOW);\n    };\n\n    _proto.setElementContent = function setElementContent($element, content) {\n      var html = this.config.html;\n\n      if (typeof content === 'object' && (content.nodeType || content.jquery)) {\n        // Content is a DOM node or a jQuery\n        if (html) {\n          if (!$(content).parent().is($element)) {\n            $element.empty().append(content);\n          }\n        } else {\n          $element.text($(content).text());\n        }\n      } else {\n        $element[html ? 'html' : 'text'](content);\n      }\n    };\n\n    _proto.getTitle = function getTitle() {\n      var title = this.element.getAttribute('data-original-title');\n\n      if (!title) {\n        title = typeof this.config.title === 'function' ? this.config.title.call(this.element) : this.config.title;\n      }\n\n      return title;\n    }; // Private\n\n\n    _proto._getAttachment = function _getAttachment(placement) {\n      return AttachmentMap[placement.toUpperCase()];\n    };\n\n    _proto._setListeners = function _setListeners() {\n      var _this3 = this;\n\n      var triggers = this.config.trigger.split(' ');\n      triggers.forEach(function (trigger) {\n        if (trigger === 'click') {\n          $(_this3.element).on(_this3.constructor.Event.CLICK, _this3.config.selector, function (event) {\n            return _this3.toggle(event);\n          });\n        } else if (trigger !== Trigger.MANUAL) {\n          var eventIn = trigger === Trigger.HOVER ? _this3.constructor.Event.MOUSEENTER : _this3.constructor.Event.FOCUSIN;\n          var eventOut = trigger === Trigger.HOVER ? _this3.constructor.Event.MOUSELEAVE : _this3.constructor.Event.FOCUSOUT;\n          $(_this3.element).on(eventIn, _this3.config.selector, function (event) {\n            return _this3._enter(event);\n          }).on(eventOut, _this3.config.selector, function (event) {\n            return _this3._leave(event);\n          });\n        }\n\n        $(_this3.element).closest('.modal').on('hide.bs.modal', function () {\n          return _this3.hide();\n        });\n      });\n\n      if (this.config.selector) {\n        this.config = _objectSpread({}, this.config, {\n          trigger: 'manual',\n          selector: ''\n        });\n      } else {\n        this._fixTitle();\n      }\n    };\n\n    _proto._fixTitle = function _fixTitle() {\n      var titleType = typeof this.element.getAttribute('data-original-title');\n\n      if (this.element.getAttribute('title') || titleType !== 'string') {\n        this.element.setAttribute('data-original-title', this.element.getAttribute('title') || '');\n        this.element.setAttribute('title', '');\n      }\n    };\n\n    _proto._enter = function _enter(event, context) {\n      var dataKey = this.constructor.DATA_KEY;\n      context = context || $(event.currentTarget).data(dataKey);\n\n      if (!context) {\n        context = new this.constructor(event.currentTarget, this._getDelegateConfig());\n        $(event.currentTarget).data(dataKey, context);\n      }\n\n      if (event) {\n        context._activeTrigger[event.type === 'focusin' ? Trigger.FOCUS : Trigger.HOVER] = true;\n      }\n\n      if ($(context.getTipElement()).hasClass(ClassName.SHOW) || context._hoverState === HoverState.SHOW) {\n        context._hoverState = HoverState.SHOW;\n        return;\n      }\n\n      clearTimeout(context._timeout);\n      context._hoverState = HoverState.SHOW;\n\n      if (!context.config.delay || !context.config.delay.show) {\n        context.show();\n        return;\n      }\n\n      context._timeout = setTimeout(function () {\n        if (context._hoverState === HoverState.SHOW) {\n          context.show();\n        }\n      }, context.config.delay.show);\n    };\n\n    _proto._leave = function _leave(event, context) {\n      var dataKey = this.constructor.DATA_KEY;\n      context = context || $(event.currentTarget).data(dataKey);\n\n      if (!context) {\n        context = new this.constructor(event.currentTarget, this._getDelegateConfig());\n        $(event.currentTarget).data(dataKey, context);\n      }\n\n      if (event) {\n        context._activeTrigger[event.type === 'focusout' ? Trigger.FOCUS : Trigger.HOVER] = false;\n      }\n\n      if (context._isWithActiveTrigger()) {\n        return;\n      }\n\n      clearTimeout(context._timeout);\n      context._hoverState = HoverState.OUT;\n\n      if (!context.config.delay || !context.config.delay.hide) {\n        context.hide();\n        return;\n      }\n\n      context._timeout = setTimeout(function () {\n        if (context._hoverState === HoverState.OUT) {\n          context.hide();\n        }\n      }, context.config.delay.hide);\n    };\n\n    _proto._isWithActiveTrigger = function _isWithActiveTrigger() {\n      for (var trigger in this._activeTrigger) {\n        if (this._activeTrigger[trigger]) {\n          return true;\n        }\n      }\n\n      return false;\n    };\n\n    _proto._getConfig = function _getConfig(config) {\n      config = _objectSpread({}, this.constructor.Default, $(this.element).data(), typeof config === 'object' && config ? config : {});\n\n      if (typeof config.delay === 'number') {\n        config.delay = {\n          show: config.delay,\n          hide: config.delay\n        };\n      }\n\n      if (typeof config.title === 'number') {\n        config.title = config.title.toString();\n      }\n\n      if (typeof config.content === 'number') {\n        config.content = config.content.toString();\n      }\n\n      Util.typeCheckConfig(NAME, config, this.constructor.DefaultType);\n      return config;\n    };\n\n    _proto._getDelegateConfig = function _getDelegateConfig() {\n      var config = {};\n\n      if (this.config) {\n        for (var key in this.config) {\n          if (this.constructor.Default[key] !== this.config[key]) {\n            config[key] = this.config[key];\n          }\n        }\n      }\n\n      return config;\n    };\n\n    _proto._cleanTipClass = function _cleanTipClass() {\n      var $tip = $(this.getTipElement());\n      var tabClass = $tip.attr('class').match(BSCLS_PREFIX_REGEX);\n\n      if (tabClass !== null && tabClass.length > 0) {\n        $tip.removeClass(tabClass.join(''));\n      }\n    };\n\n    _proto._handlePopperPlacementChange = function _handlePopperPlacementChange(data) {\n      this._cleanTipClass();\n\n      this.addAttachmentClass(this._getAttachment(data.placement));\n    };\n\n    _proto._fixTransition = function _fixTransition() {\n      var tip = this.getTipElement();\n      var initConfigAnimation = this.config.animation;\n\n      if (tip.getAttribute('x-placement') !== null) {\n        return;\n      }\n\n      $(tip).removeClass(ClassName.FADE);\n      this.config.animation = false;\n      this.hide();\n      this.show();\n      this.config.animation = initConfigAnimation;\n    }; // Static\n\n\n    Tooltip._jQueryInterface = function _jQueryInterface(config) {\n      return this.each(function () {\n        var data = $(this).data(DATA_KEY);\n\n        var _config = typeof config === 'object' && config;\n\n        if (!data && /dispose|hide/.test(config)) {\n          return;\n        }\n\n        if (!data) {\n          data = new Tooltip(this, _config);\n          $(this).data(DATA_KEY, data);\n        }\n\n        if (typeof config === 'string') {\n          if (typeof data[config] === 'undefined') {\n            throw new TypeError(\"No method named \\\"\" + config + \"\\\"\");\n          }\n\n          data[config]();\n        }\n      });\n    };\n\n    _createClass(Tooltip, null, [{\n      key: \"VERSION\",\n      get: function get() {\n        return VERSION;\n      }\n    }, {\n      key: \"Default\",\n      get: function get() {\n        return Default;\n      }\n    }, {\n      key: \"NAME\",\n      get: function get() {\n        return NAME;\n      }\n    }, {\n      key: \"DATA_KEY\",\n      get: function get() {\n        return DATA_KEY;\n      }\n    }, {\n      key: \"Event\",\n      get: function get() {\n        return Event;\n      }\n    }, {\n      key: \"EVENT_KEY\",\n      get: function get() {\n        return EVENT_KEY;\n      }\n    }, {\n      key: \"DefaultType\",\n      get: function get() {\n        return DefaultType;\n      }\n    }]);\n\n    return Tooltip;\n  }();\n  /**\n   * ------------------------------------------------------------------------\n   * jQuery\n   * ------------------------------------------------------------------------\n   */\n\n\n  $.fn[NAME] = Tooltip._jQueryInterface;\n  $.fn[NAME].Constructor = Tooltip;\n\n  $.fn[NAME].noConflict = function () {\n    $.fn[NAME] = JQUERY_NO_CONFLICT;\n    return Tooltip._jQueryInterface;\n  };\n\n  return Tooltip;\n}($, Popper);\n//# sourceMappingURL=tooltip.js.map\n\n/*** EXPORTS FROM exports-loader ***/\nmodule.exports = Tooltip;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/exports-loader?Tooltip!./node_modules/bootstrap/js/dist/tooltip.js\n// module id = 17\n// module chunks = 0","function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\n * --------------------------------------------------------------------------\n * Bootstrap (v4.1.1): scrollspy.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n * --------------------------------------------------------------------------\n */\nvar ScrollSpy = function ($) {\n  /**\n   * ------------------------------------------------------------------------\n   * Constants\n   * ------------------------------------------------------------------------\n   */\n  var NAME = 'scrollspy';\n  var VERSION = '4.1.1';\n  var DATA_KEY = 'bs.scrollspy';\n  var EVENT_KEY = \".\" + DATA_KEY;\n  var DATA_API_KEY = '.data-api';\n  var JQUERY_NO_CONFLICT = $.fn[NAME];\n  var Default = {\n    offset: 10,\n    method: 'auto',\n    target: ''\n  };\n  var DefaultType = {\n    offset: 'number',\n    method: 'string',\n    target: '(string|element)'\n  };\n  var Event = {\n    ACTIVATE: \"activate\" + EVENT_KEY,\n    SCROLL: \"scroll\" + EVENT_KEY,\n    LOAD_DATA_API: \"load\" + EVENT_KEY + DATA_API_KEY\n  };\n  var ClassName = {\n    DROPDOWN_ITEM: 'dropdown-item',\n    DROPDOWN_MENU: 'dropdown-menu',\n    ACTIVE: 'active'\n  };\n  var Selector = {\n    DATA_SPY: '[data-spy=\"scroll\"]',\n    ACTIVE: '.active',\n    NAV_LIST_GROUP: '.nav, .list-group',\n    NAV_LINKS: '.nav-link',\n    NAV_ITEMS: '.nav-item',\n    LIST_ITEMS: '.list-group-item',\n    DROPDOWN: '.dropdown',\n    DROPDOWN_ITEMS: '.dropdown-item',\n    DROPDOWN_TOGGLE: '.dropdown-toggle'\n  };\n  var OffsetMethod = {\n    OFFSET: 'offset',\n    POSITION: 'position'\n    /**\n     * ------------------------------------------------------------------------\n     * Class Definition\n     * ------------------------------------------------------------------------\n     */\n\n  };\n\n  var ScrollSpy =\n  /*#__PURE__*/\n  function () {\n    function ScrollSpy(element, config) {\n      var _this = this;\n\n      this._element = element;\n      this._scrollElement = element.tagName === 'BODY' ? window : element;\n      this._config = this._getConfig(config);\n      this._selector = this._config.target + \" \" + Selector.NAV_LINKS + \",\" + (this._config.target + \" \" + Selector.LIST_ITEMS + \",\") + (this._config.target + \" \" + Selector.DROPDOWN_ITEMS);\n      this._offsets = [];\n      this._targets = [];\n      this._activeTarget = null;\n      this._scrollHeight = 0;\n      $(this._scrollElement).on(Event.SCROLL, function (event) {\n        return _this._process(event);\n      });\n      this.refresh();\n\n      this._process();\n    } // Getters\n\n\n    var _proto = ScrollSpy.prototype;\n\n    // Public\n    _proto.refresh = function refresh() {\n      var _this2 = this;\n\n      var autoMethod = this._scrollElement === this._scrollElement.window ? OffsetMethod.OFFSET : OffsetMethod.POSITION;\n      var offsetMethod = this._config.method === 'auto' ? autoMethod : this._config.method;\n      var offsetBase = offsetMethod === OffsetMethod.POSITION ? this._getScrollTop() : 0;\n      this._offsets = [];\n      this._targets = [];\n      this._scrollHeight = this._getScrollHeight();\n      var targets = $.makeArray($(this._selector));\n      targets.map(function (element) {\n        var target;\n        var targetSelector = Util.getSelectorFromElement(element);\n\n        if (targetSelector) {\n          target = $(targetSelector)[0];\n        }\n\n        if (target) {\n          var targetBCR = target.getBoundingClientRect();\n\n          if (targetBCR.width || targetBCR.height) {\n            // TODO (fat): remove sketch reliance on jQuery position/offset\n            return [$(target)[offsetMethod]().top + offsetBase, targetSelector];\n          }\n        }\n\n        return null;\n      }).filter(function (item) {\n        return item;\n      }).sort(function (a, b) {\n        return a[0] - b[0];\n      }).forEach(function (item) {\n        _this2._offsets.push(item[0]);\n\n        _this2._targets.push(item[1]);\n      });\n    };\n\n    _proto.dispose = function dispose() {\n      $.removeData(this._element, DATA_KEY);\n      $(this._scrollElement).off(EVENT_KEY);\n      this._element = null;\n      this._scrollElement = null;\n      this._config = null;\n      this._selector = null;\n      this._offsets = null;\n      this._targets = null;\n      this._activeTarget = null;\n      this._scrollHeight = null;\n    }; // Private\n\n\n    _proto._getConfig = function _getConfig(config) {\n      config = _objectSpread({}, Default, typeof config === 'object' && config ? config : {});\n\n      if (typeof config.target !== 'string') {\n        var id = $(config.target).attr('id');\n\n        if (!id) {\n          id = Util.getUID(NAME);\n          $(config.target).attr('id', id);\n        }\n\n        config.target = \"#\" + id;\n      }\n\n      Util.typeCheckConfig(NAME, config, DefaultType);\n      return config;\n    };\n\n    _proto._getScrollTop = function _getScrollTop() {\n      return this._scrollElement === window ? this._scrollElement.pageYOffset : this._scrollElement.scrollTop;\n    };\n\n    _proto._getScrollHeight = function _getScrollHeight() {\n      return this._scrollElement.scrollHeight || Math.max(document.body.scrollHeight, document.documentElement.scrollHeight);\n    };\n\n    _proto._getOffsetHeight = function _getOffsetHeight() {\n      return this._scrollElement === window ? window.innerHeight : this._scrollElement.getBoundingClientRect().height;\n    };\n\n    _proto._process = function _process() {\n      var scrollTop = this._getScrollTop() + this._config.offset;\n\n      var scrollHeight = this._getScrollHeight();\n\n      var maxScroll = this._config.offset + scrollHeight - this._getOffsetHeight();\n\n      if (this._scrollHeight !== scrollHeight) {\n        this.refresh();\n      }\n\n      if (scrollTop >= maxScroll) {\n        var target = this._targets[this._targets.length - 1];\n\n        if (this._activeTarget !== target) {\n          this._activate(target);\n        }\n\n        return;\n      }\n\n      if (this._activeTarget && scrollTop < this._offsets[0] && this._offsets[0] > 0) {\n        this._activeTarget = null;\n\n        this._clear();\n\n        return;\n      }\n\n      for (var i = this._offsets.length; i--;) {\n        var isActiveTarget = this._activeTarget !== this._targets[i] && scrollTop >= this._offsets[i] && (typeof this._offsets[i + 1] === 'undefined' || scrollTop < this._offsets[i + 1]);\n\n        if (isActiveTarget) {\n          this._activate(this._targets[i]);\n        }\n      }\n    };\n\n    _proto._activate = function _activate(target) {\n      this._activeTarget = target;\n\n      this._clear();\n\n      var queries = this._selector.split(','); // eslint-disable-next-line arrow-body-style\n\n\n      queries = queries.map(function (selector) {\n        return selector + \"[data-target=\\\"\" + target + \"\\\"],\" + (selector + \"[href=\\\"\" + target + \"\\\"]\");\n      });\n      var $link = $(queries.join(','));\n\n      if ($link.hasClass(ClassName.DROPDOWN_ITEM)) {\n        $link.closest(Selector.DROPDOWN).find(Selector.DROPDOWN_TOGGLE).addClass(ClassName.ACTIVE);\n        $link.addClass(ClassName.ACTIVE);\n      } else {\n        // Set triggered link as active\n        $link.addClass(ClassName.ACTIVE); // Set triggered links parents as active\n        // With both <ul> and <nav> markup a parent is the previous sibling of any nav ancestor\n\n        $link.parents(Selector.NAV_LIST_GROUP).prev(Selector.NAV_LINKS + \", \" + Selector.LIST_ITEMS).addClass(ClassName.ACTIVE); // Handle special case when .nav-link is inside .nav-item\n\n        $link.parents(Selector.NAV_LIST_GROUP).prev(Selector.NAV_ITEMS).children(Selector.NAV_LINKS).addClass(ClassName.ACTIVE);\n      }\n\n      $(this._scrollElement).trigger(Event.ACTIVATE, {\n        relatedTarget: target\n      });\n    };\n\n    _proto._clear = function _clear() {\n      $(this._selector).filter(Selector.ACTIVE).removeClass(ClassName.ACTIVE);\n    }; // Static\n\n\n    ScrollSpy._jQueryInterface = function _jQueryInterface(config) {\n      return this.each(function () {\n        var data = $(this).data(DATA_KEY);\n\n        var _config = typeof config === 'object' && config;\n\n        if (!data) {\n          data = new ScrollSpy(this, _config);\n          $(this).data(DATA_KEY, data);\n        }\n\n        if (typeof config === 'string') {\n          if (typeof data[config] === 'undefined') {\n            throw new TypeError(\"No method named \\\"\" + config + \"\\\"\");\n          }\n\n          data[config]();\n        }\n      });\n    };\n\n    _createClass(ScrollSpy, null, [{\n      key: \"VERSION\",\n      get: function get() {\n        return VERSION;\n      }\n    }, {\n      key: \"Default\",\n      get: function get() {\n        return Default;\n      }\n    }]);\n\n    return ScrollSpy;\n  }();\n  /**\n   * ------------------------------------------------------------------------\n   * Data Api implementation\n   * ------------------------------------------------------------------------\n   */\n\n\n  $(window).on(Event.LOAD_DATA_API, function () {\n    var scrollSpys = $.makeArray($(Selector.DATA_SPY));\n\n    for (var i = scrollSpys.length; i--;) {\n      var $spy = $(scrollSpys[i]);\n\n      ScrollSpy._jQueryInterface.call($spy, $spy.data());\n    }\n  });\n  /**\n   * ------------------------------------------------------------------------\n   * jQuery\n   * ------------------------------------------------------------------------\n   */\n\n  $.fn[NAME] = ScrollSpy._jQueryInterface;\n  $.fn[NAME].Constructor = ScrollSpy;\n\n  $.fn[NAME].noConflict = function () {\n    $.fn[NAME] = JQUERY_NO_CONFLICT;\n    return ScrollSpy._jQueryInterface;\n  };\n\n  return ScrollSpy;\n}($);\n//# sourceMappingURL=scrollspy.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/bootstrap/js/dist/scrollspy.js\n// module id = 18\n// module chunks = 0","function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\n * --------------------------------------------------------------------------\n * Bootstrap (v4.1.1): tab.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n * --------------------------------------------------------------------------\n */\nvar Tab = function ($) {\n  /**\n   * ------------------------------------------------------------------------\n   * Constants\n   * ------------------------------------------------------------------------\n   */\n  var NAME = 'tab';\n  var VERSION = '4.1.1';\n  var DATA_KEY = 'bs.tab';\n  var EVENT_KEY = \".\" + DATA_KEY;\n  var DATA_API_KEY = '.data-api';\n  var JQUERY_NO_CONFLICT = $.fn[NAME];\n  var Event = {\n    HIDE: \"hide\" + EVENT_KEY,\n    HIDDEN: \"hidden\" + EVENT_KEY,\n    SHOW: \"show\" + EVENT_KEY,\n    SHOWN: \"shown\" + EVENT_KEY,\n    CLICK_DATA_API: \"click\" + EVENT_KEY + DATA_API_KEY\n  };\n  var ClassName = {\n    DROPDOWN_MENU: 'dropdown-menu',\n    ACTIVE: 'active',\n    DISABLED: 'disabled',\n    FADE: 'fade',\n    SHOW: 'show'\n  };\n  var Selector = {\n    DROPDOWN: '.dropdown',\n    NAV_LIST_GROUP: '.nav, .list-group',\n    ACTIVE: '.active',\n    ACTIVE_UL: '> li > .active',\n    DATA_TOGGLE: '[data-toggle=\"tab\"], [data-toggle=\"pill\"], [data-toggle=\"list\"]',\n    DROPDOWN_TOGGLE: '.dropdown-toggle',\n    DROPDOWN_ACTIVE_CHILD: '> .dropdown-menu .active'\n    /**\n     * ------------------------------------------------------------------------\n     * Class Definition\n     * ------------------------------------------------------------------------\n     */\n\n  };\n\n  var Tab =\n  /*#__PURE__*/\n  function () {\n    function Tab(element) {\n      this._element = element;\n    } // Getters\n\n\n    var _proto = Tab.prototype;\n\n    // Public\n    _proto.show = function show() {\n      var _this = this;\n\n      if (this._element.parentNode && this._element.parentNode.nodeType === Node.ELEMENT_NODE && $(this._element).hasClass(ClassName.ACTIVE) || $(this._element).hasClass(ClassName.DISABLED)) {\n        return;\n      }\n\n      var target;\n      var previous;\n      var listElement = $(this._element).closest(Selector.NAV_LIST_GROUP)[0];\n      var selector = Util.getSelectorFromElement(this._element);\n\n      if (listElement) {\n        var itemSelector = listElement.nodeName === 'UL' ? Selector.ACTIVE_UL : Selector.ACTIVE;\n        previous = $.makeArray($(listElement).find(itemSelector));\n        previous = previous[previous.length - 1];\n      }\n\n      var hideEvent = $.Event(Event.HIDE, {\n        relatedTarget: this._element\n      });\n      var showEvent = $.Event(Event.SHOW, {\n        relatedTarget: previous\n      });\n\n      if (previous) {\n        $(previous).trigger(hideEvent);\n      }\n\n      $(this._element).trigger(showEvent);\n\n      if (showEvent.isDefaultPrevented() || hideEvent.isDefaultPrevented()) {\n        return;\n      }\n\n      if (selector) {\n        target = $(selector)[0];\n      }\n\n      this._activate(this._element, listElement);\n\n      var complete = function complete() {\n        var hiddenEvent = $.Event(Event.HIDDEN, {\n          relatedTarget: _this._element\n        });\n        var shownEvent = $.Event(Event.SHOWN, {\n          relatedTarget: previous\n        });\n        $(previous).trigger(hiddenEvent);\n        $(_this._element).trigger(shownEvent);\n      };\n\n      if (target) {\n        this._activate(target, target.parentNode, complete);\n      } else {\n        complete();\n      }\n    };\n\n    _proto.dispose = function dispose() {\n      $.removeData(this._element, DATA_KEY);\n      this._element = null;\n    }; // Private\n\n\n    _proto._activate = function _activate(element, container, callback) {\n      var _this2 = this;\n\n      var activeElements;\n\n      if (container.nodeName === 'UL') {\n        activeElements = $(container).find(Selector.ACTIVE_UL);\n      } else {\n        activeElements = $(container).children(Selector.ACTIVE);\n      }\n\n      var active = activeElements[0];\n      var isTransitioning = callback && active && $(active).hasClass(ClassName.FADE);\n\n      var complete = function complete() {\n        return _this2._transitionComplete(element, active, callback);\n      };\n\n      if (active && isTransitioning) {\n        var transitionDuration = Util.getTransitionDurationFromElement(active);\n        $(active).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);\n      } else {\n        complete();\n      }\n    };\n\n    _proto._transitionComplete = function _transitionComplete(element, active, callback) {\n      if (active) {\n        $(active).removeClass(ClassName.SHOW + \" \" + ClassName.ACTIVE);\n        var dropdownChild = $(active.parentNode).find(Selector.DROPDOWN_ACTIVE_CHILD)[0];\n\n        if (dropdownChild) {\n          $(dropdownChild).removeClass(ClassName.ACTIVE);\n        }\n\n        if (active.getAttribute('role') === 'tab') {\n          active.setAttribute('aria-selected', false);\n        }\n      }\n\n      $(element).addClass(ClassName.ACTIVE);\n\n      if (element.getAttribute('role') === 'tab') {\n        element.setAttribute('aria-selected', true);\n      }\n\n      Util.reflow(element);\n      $(element).addClass(ClassName.SHOW);\n\n      if (element.parentNode && $(element.parentNode).hasClass(ClassName.DROPDOWN_MENU)) {\n        var dropdownElement = $(element).closest(Selector.DROPDOWN)[0];\n\n        if (dropdownElement) {\n          $(dropdownElement).find(Selector.DROPDOWN_TOGGLE).addClass(ClassName.ACTIVE);\n        }\n\n        element.setAttribute('aria-expanded', true);\n      }\n\n      if (callback) {\n        callback();\n      }\n    }; // Static\n\n\n    Tab._jQueryInterface = function _jQueryInterface(config) {\n      return this.each(function () {\n        var $this = $(this);\n        var data = $this.data(DATA_KEY);\n\n        if (!data) {\n          data = new Tab(this);\n          $this.data(DATA_KEY, data);\n        }\n\n        if (typeof config === 'string') {\n          if (typeof data[config] === 'undefined') {\n            throw new TypeError(\"No method named \\\"\" + config + \"\\\"\");\n          }\n\n          data[config]();\n        }\n      });\n    };\n\n    _createClass(Tab, null, [{\n      key: \"VERSION\",\n      get: function get() {\n        return VERSION;\n      }\n    }]);\n\n    return Tab;\n  }();\n  /**\n   * ------------------------------------------------------------------------\n   * Data Api implementation\n   * ------------------------------------------------------------------------\n   */\n\n\n  $(document).on(Event.CLICK_DATA_API, Selector.DATA_TOGGLE, function (event) {\n    event.preventDefault();\n\n    Tab._jQueryInterface.call($(this), 'show');\n  });\n  /**\n   * ------------------------------------------------------------------------\n   * jQuery\n   * ------------------------------------------------------------------------\n   */\n\n  $.fn[NAME] = Tab._jQueryInterface;\n  $.fn[NAME].Constructor = Tab;\n\n  $.fn[NAME].noConflict = function () {\n    $.fn[NAME] = JQUERY_NO_CONFLICT;\n    return Tab._jQueryInterface;\n  };\n\n  return Tab;\n}($);\n//# sourceMappingURL=tab.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/bootstrap/js/dist/tab.js\n// module id = 19\n// module chunks = 0","(function() {\n  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };\n\n  (function($, window) {\n    var Offcanvas, OffcanvasDropdown, OffcanvasTouch;\n    OffcanvasDropdown = (function() {\n      function OffcanvasDropdown(element) {\n        this.element = element;\n        this._clickEvent = __bind(this._clickEvent, this);\n        this.element = $(this.element);\n        this.nav = this.element.closest(\".nav\");\n        this.dropdown = this.element.parent().find(\".dropdown-menu\");\n        this.element.on('click', this._clickEvent);\n        this.nav.closest('.navbar-offcanvas').on('click', (function(_this) {\n          return function() {\n            if (_this.dropdown.is('.shown')) {\n              return _this.dropdown.removeClass('shown').closest('.open').removeClass('open');\n            }\n          };\n        })(this));\n      }\n\n      OffcanvasDropdown.prototype._clickEvent = function(e) {\n        if (!this.dropdown.hasClass('shown')) {\n          e.preventDefault();\n        }\n        e.stopPropagation();\n        $('.dropdown-toggle').not(this.element).closest('.open').removeClass('open').find('.dropdown-menu').removeClass('shown');\n        this.dropdown.toggleClass(\"shown\");\n        return this.element.parent().toggleClass('open');\n      };\n\n      return OffcanvasDropdown;\n\n    })();\n    OffcanvasTouch = (function() {\n      function OffcanvasTouch(button, element, location, offcanvas) {\n        this.button = button;\n        this.element = element;\n        this.location = location;\n        this.offcanvas = offcanvas;\n        this._getFade = __bind(this._getFade, this);\n        this._getCss = __bind(this._getCss, this);\n        this._touchEnd = __bind(this._touchEnd, this);\n        this._touchMove = __bind(this._touchMove, this);\n        this._touchStart = __bind(this._touchStart, this);\n        this.endThreshold = 130;\n        this.startThreshold = this.element.hasClass('navbar-offcanvas-right') ? $(\"body\").outerWidth() - 60 : 20;\n        this.maxStartThreshold = this.element.hasClass('navbar-offcanvas-right') ? $(\"body\").outerWidth() - 20 : 60;\n        this.currentX = 0;\n        this.fade = this.element.hasClass('navbar-offcanvas-fade') ? true : false;\n        $(document).on(\"touchstart\", this._touchStart);\n        $(document).on(\"touchmove\", this._touchMove);\n        $(document).on(\"touchend\", this._touchEnd);\n      }\n\n      OffcanvasTouch.prototype._touchStart = function(e) {\n        this.startX = e.originalEvent.touches[0].pageX;\n        if (this.element.is('.in')) {\n          return this.element.height($(window).outerHeight());\n        }\n      };\n\n      OffcanvasTouch.prototype._touchMove = function(e) {\n        var x;\n        if ($(e.target).parents('.navbar-offcanvas').length > 0) {\n          return true;\n        }\n        if (this.startX > this.startThreshold && this.startX < this.maxStartThreshold) {\n          e.preventDefault();\n          x = e.originalEvent.touches[0].pageX - this.startX;\n          x = this.element.hasClass('navbar-offcanvas-right') ? -x : x;\n          if (Math.abs(x) < this.element.outerWidth()) {\n            this.element.css(this._getCss(x));\n            return this.element.css(this._getFade(x));\n          }\n        } else if (this.element.hasClass('in')) {\n          e.preventDefault();\n          x = e.originalEvent.touches[0].pageX + (this.currentX - this.startX);\n          x = this.element.hasClass('navbar-offcanvas-right') ? -x : x;\n          if (Math.abs(x) < this.element.outerWidth()) {\n            this.element.css(this._getCss(x));\n            return this.element.css(this._getFade(x));\n          }\n        }\n      };\n\n      OffcanvasTouch.prototype._touchEnd = function(e) {\n        var end, sendEvents, x;\n        if ($(e.target).parents('.navbar-offcanvas').length > 0) {\n          return true;\n        }\n        sendEvents = false;\n        x = e.originalEvent.changedTouches[0].pageX;\n        if (Math.abs(x) === this.startX) {\n          return;\n        }\n        end = this.element.hasClass('navbar-offcanvas-right') ? Math.abs(x) > (this.endThreshold + 50) : x < (this.endThreshold + 50);\n        if (this.element.hasClass('in') && end) {\n          this.currentX = 0;\n          this.element.removeClass('in').css(this._clearCss());\n          this.button.removeClass('is-open');\n          sendEvents = true;\n        } else if (Math.abs(x - this.startX) > this.endThreshold && this.startX > this.startThreshold && this.startX < this.maxStartThreshold) {\n          this.currentX = this.element.hasClass('navbar-offcanvas-right') ? -this.element.outerWidth() : this.element.outerWidth();\n          this.element.toggleClass('in').css(this._clearCss());\n          this.button.toggleClass('is-open');\n          sendEvents = true;\n        } else {\n          this.element.css(this._clearCss());\n        }\n        return this.offcanvas.bodyOverflow(sendEvents);\n      };\n\n      OffcanvasTouch.prototype._getCss = function(x) {\n        x = this.element.hasClass('navbar-offcanvas-right') ? -x : x;\n        return {\n          \"-webkit-transform\": \"translate3d(\" + x + \"px, 0px, 0px)\",\n          \"-webkit-transition-duration\": \"0s\",\n          \"-moz-transform\": \"translate3d(\" + x + \"px, 0px, 0px)\",\n          \"-moz-transition\": \"0s\",\n          \"-o-transform\": \"translate3d(\" + x + \"px, 0px, 0px)\",\n          \"-o-transition\": \"0s\",\n          \"transform\": \"translate3d(\" + x + \"px, 0px, 0px)\",\n          \"transition\": \"0s\"\n        };\n      };\n\n      OffcanvasTouch.prototype._getFade = function(x) {\n        if (this.fade) {\n          return {\n            \"opacity\": x / this.element.outerWidth()\n          };\n        } else {\n          return {};\n        }\n      };\n\n      OffcanvasTouch.prototype._clearCss = function() {\n        return {\n          \"-webkit-transform\": \"\",\n          \"-webkit-transition-duration\": \"\",\n          \"-moz-transform\": \"\",\n          \"-moz-transition\": \"\",\n          \"-o-transform\": \"\",\n          \"-o-transition\": \"\",\n          \"transform\": \"\",\n          \"transition\": \"\",\n          \"opacity\": \"\"\n        };\n      };\n\n      return OffcanvasTouch;\n\n    })();\n    window.Offcanvas = Offcanvas = (function() {\n      function Offcanvas(element) {\n        var t, target;\n        this.element = element;\n        this.bodyOverflow = __bind(this.bodyOverflow, this);\n        this._sendEventsAfter = __bind(this._sendEventsAfter, this);\n        this._sendEventsBefore = __bind(this._sendEventsBefore, this);\n        this._documentClicked = __bind(this._documentClicked, this);\n        this._close = __bind(this._close, this);\n        this._open = __bind(this._open, this);\n        this._clicked = __bind(this._clicked, this);\n        this._navbarHeight = __bind(this._navbarHeight, this);\n        target = this.element.attr('data-target') ? this.element.attr('data-target') : false;\n        if (target) {\n          this.target = $(target);\n          if (this.target.length && !this.target.hasClass('js-offcanvas-done')) {\n            this.element.addClass('js-offcanvas-has-events');\n            this.location = this.target.hasClass(\"navbar-offcanvas-right\") ? \"right\" : \"left\";\n            this.target.addClass(this._transformSupported() ? \"offcanvas-transform js-offcanvas-done\" : \"offcanvas-position js-offcanvas-done\");\n            this.target.data('offcanvas', this);\n            this.element.on(\"click\", this._clicked);\n            this.target.on('transitionend', (function(_this) {\n              return function() {\n                if (_this.target.is(':not(.in)')) {\n                  return _this.target.height('');\n                }\n              };\n            })(this));\n            $(document).on(\"click\", this._documentClicked);\n            if (this.target.hasClass('navbar-offcanvas-touch')) {\n              t = new OffcanvasTouch(this.element, this.target, this.location, this);\n            }\n            this.target.find(\".dropdown-toggle\").each(function() {\n              var d;\n              return d = new OffcanvasDropdown(this);\n            });\n            this.target.on('offcanvas.toggle', (function(_this) {\n              return function(e) {\n                return _this._clicked(e);\n              };\n            })(this));\n            this.target.on('offcanvas.close', (function(_this) {\n              return function(e) {\n                return _this._close(e);\n              };\n            })(this));\n            this.target.on('offcanvas.open', (function(_this) {\n              return function(e) {\n                return _this._open(e);\n              };\n            })(this));\n          }\n        } else {\n          console.warn('Offcanvas: `data-target` attribute must be present.');\n        }\n      }\n\n      Offcanvas.prototype._navbarHeight = function() {\n        if (this.target.is('.in')) {\n          return this.target.height($(window).outerHeight());\n        }\n      };\n\n      Offcanvas.prototype._clicked = function(e) {\n        e.preventDefault();\n        this._sendEventsBefore();\n        $(\".navbar-offcanvas\").not(this.target).trigger('offcanvas.close');\n        this.target.toggleClass('in');\n        this.element.toggleClass('is-open');\n        this._navbarHeight();\n        return this.bodyOverflow();\n      };\n\n      Offcanvas.prototype._open = function(e) {\n        e.preventDefault();\n        if (this.target.is('.in')) {\n          return;\n        }\n        this._sendEventsBefore();\n        this.target.addClass('in');\n        this.element.addClass('is-open');\n        this._navbarHeight();\n        return this.bodyOverflow();\n      };\n\n      Offcanvas.prototype._close = function(e) {\n        e.preventDefault();\n        if (this.target.is(':not(.in)')) {\n          return;\n        }\n        this._sendEventsBefore();\n        this.target.removeClass('in');\n        this.element.removeClass('is-open');\n        this._navbarHeight();\n        return this.bodyOverflow();\n      };\n\n      Offcanvas.prototype._documentClicked = function(e) {\n        var clickedEl;\n        clickedEl = $(e.target);\n        if (!clickedEl.hasClass('offcanvas-toggle') && clickedEl.parents('.offcanvas-toggle').length === 0 && clickedEl.parents('.navbar-offcanvas').length === 0 && !clickedEl.hasClass('navbar-offcanvas')) {\n          if (this.target.hasClass('in')) {\n            e.preventDefault();\n            this._sendEventsBefore();\n            this.target.removeClass('in');\n            this.element.removeClass('is-open');\n            this._navbarHeight();\n            return this.bodyOverflow();\n          }\n        }\n      };\n\n      Offcanvas.prototype._sendEventsBefore = function() {\n        if (this.target.hasClass('in')) {\n          return this.target.trigger('hide.bs.offcanvas');\n        } else {\n          return this.target.trigger('show.bs.offcanvas');\n        }\n      };\n\n      Offcanvas.prototype._sendEventsAfter = function() {\n        if (this.target.hasClass('in')) {\n          return this.target.trigger('shown.bs.offcanvas');\n        } else {\n          return this.target.trigger('hidden.bs.offcanvas');\n        }\n      };\n\n      Offcanvas.prototype.bodyOverflow = function(events) {\n        if (events == null) {\n          events = true;\n        }\n        if (this.target.is('.in')) {\n          $('body').addClass('offcanvas-stop-scrolling');\n        } else {\n          $('body').removeClass('offcanvas-stop-scrolling');\n        }\n        if (events) {\n          return this._sendEventsAfter();\n        }\n      };\n\n      Offcanvas.prototype._transformSupported = function() {\n        var asSupport, el, regex, translate3D;\n        el = document.createElement('div');\n        translate3D = \"translate3d(0px, 0px, 0px)\";\n        regex = /translate3d\\(0px, 0px, 0px\\)/g;\n        el.style.cssText = \"-webkit-transform: \" + translate3D + \"; -moz-transform: \" + translate3D + \"; -o-transform: \" + translate3D + \"; transform: \" + translate3D;\n        asSupport = el.style.cssText.match(regex);\n        return asSupport.length != null;\n      };\n\n      return Offcanvas;\n\n    })();\n    $.fn.bsOffcanvas = function() {\n      return this.each(function() {\n        return new Offcanvas($(this));\n      });\n    };\n    return $(function() {\n      $('[data-toggle=\"offcanvas\"]').each(function() {\n        return $(this).bsOffcanvas();\n      });\n      $(window).on('resize', function() {\n        $('.navbar-offcanvas.in').each(function() {\n          return $(this).height('').removeClass('in');\n        });\n        $('.offcanvas-toggle').removeClass('is-open');\n        return $('body').removeClass('offcanvas-stop-scrolling');\n      });\n      return $('.offcanvas-toggle').each(function() {\n        return $(this).on('click', function(e) {\n          var el, selector;\n          if (!$(this).hasClass('js-offcanvas-has-events')) {\n            selector = $(this).attr('data-target');\n            el = $(selector);\n            if (el) {\n              el.height('');\n              el.removeClass('in');\n              return $('body').css({\n                overflow: '',\n                position: ''\n              });\n            }\n          }\n        });\n      });\n    });\n  })(window.jQuery, window);\n\n}).call(this);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/offcanvas-bootstrap/dist/js/bootstrap.offcanvas.js\n// module id = 20\n// module chunks = 0","(function(factory) {\r\n    if (typeof define === 'function' && define.amd) {\r\n        define(['jquery', 'hammerjs'], factory);\r\n    } else if (typeof exports === 'object') {\r\n        factory(require('jquery'), require('hammerjs'));\r\n    } else {\r\n        factory(jQuery, Hammer);\r\n    }\r\n}(function($, Hammer) {\r\n    function hammerify(el, options) {\r\n        var $el = $(el);\r\n        if(!$el.data(\"hammer\")) {\r\n            $el.data(\"hammer\", new Hammer($el[0], options));\r\n        }\r\n    }\r\n\r\n    $.fn.hammer = function(options) {\r\n        return this.each(function() {\r\n            hammerify(this, options);\r\n        });\r\n    };\r\n\r\n    // extend the emit method to also trigger jQuery events\r\n    Hammer.Manager.prototype.emit = (function(originalEmit) {\r\n        return function(type, data) {\r\n            originalEmit.call(this, type, data);\r\n            $(this.element).trigger({\r\n                type: type,\r\n                gesture: data\r\n            });\r\n        };\r\n    })(Hammer.Manager.prototype.emit);\r\n}));\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jquery-hammerjs/jquery.hammer.js\n// module id = 21\n// module chunks = 0","// PouchDB 6.4.3\n// \n// (c) 2012-2018 Dale Harvey and the PouchDB team\n// PouchDB may be freely distributed under the Apache license, version 2.0.\n// For all details and documentation:\n// http://pouchdb.com\n(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.PouchDB = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){\n'use strict';\n\nmodule.exports = argsArray;\n\nfunction argsArray(fun) {\n  return function () {\n    var len = arguments.length;\n    if (len) {\n      var args = [];\n      var i = -1;\n      while (++i < len) {\n        args[i] = arguments[i];\n      }\n      return fun.call(this, args);\n    } else {\n      return fun.call(this, []);\n    }\n  };\n}\n},{}],2:[function(_dereq_,module,exports){\n(function (process){\n/**\n * This is the web browser implementation of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = _dereq_(3);\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = 'undefined' != typeof chrome\n               && 'undefined' != typeof chrome.storage\n                  ? chrome.storage.local\n                  : localstorage();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n  '#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC',\n  '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF',\n  '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC',\n  '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF',\n  '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC',\n  '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033',\n  '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366',\n  '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933',\n  '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC',\n  '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF',\n  '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\nfunction useColors() {\n  // NB: In an Electron preload script, document will be defined but not fully\n  // initialized. Since we know we're in Chrome, we'll just detect this case\n  // explicitly\n  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {\n    return true;\n  }\n\n  // Internet Explorer and Edge do not support colors.\n  if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n    return false;\n  }\n\n  // is webkit? http://stackoverflow.com/a/16459606/376773\n  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n  return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n    // is firebug? http://stackoverflow.com/a/398120/376773\n    (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n    // is firefox >= v31?\n    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||\n    // double check webkit in userAgent just in case we are in a worker\n    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nexports.formatters.j = function(v) {\n  try {\n    return JSON.stringify(v);\n  } catch (err) {\n    return '[UnexpectedJSONParseError]: ' + err.message;\n  }\n};\n\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n  var useColors = this.useColors;\n\n  args[0] = (useColors ? '%c' : '')\n    + this.namespace\n    + (useColors ? ' %c' : ' ')\n    + args[0]\n    + (useColors ? '%c ' : ' ')\n    + '+' + exports.humanize(this.diff);\n\n  if (!useColors) return;\n\n  var c = 'color: ' + this.color;\n  args.splice(1, 0, c, 'color: inherit')\n\n  // the final \"%c\" is somewhat tricky, because there could be other\n  // arguments passed either before or after the %c, so we need to\n  // figure out the correct index to insert the CSS into\n  var index = 0;\n  var lastC = 0;\n  args[0].replace(/%[a-zA-Z%]/g, function(match) {\n    if ('%%' === match) return;\n    index++;\n    if ('%c' === match) {\n      // we only are interested in the *last* %c\n      // (the user may have provided their own)\n      lastC = index;\n    }\n  });\n\n  args.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.log()` when available.\n * No-op when `console.log` is not a \"function\".\n *\n * @api public\n */\n\nfunction log() {\n  // this hackery is required for IE8/9, where\n  // the `console.log` function doesn't have 'apply'\n  return 'object' === typeof console\n    && console.log\n    && Function.prototype.apply.call(console.log, console, arguments);\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\nfunction save(namespaces) {\n  try {\n    if (null == namespaces) {\n      exports.storage.removeItem('debug');\n    } else {\n      exports.storage.debug = namespaces;\n    }\n  } catch(e) {}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n  var r;\n  try {\n    r = exports.storage.debug;\n  } catch(e) {}\n\n  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n  if (!r && typeof process !== 'undefined' && 'env' in process) {\n    r = process.env.DEBUG;\n  }\n\n  return r;\n}\n\n/**\n * Enable namespaces listed in `localStorage.debug` initially.\n */\n\nexports.enable(load());\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n  try {\n    return window.localStorage;\n  } catch (e) {}\n}\n\n}).call(this,_dereq_(9))\n},{\"3\":3,\"9\":9}],3:[function(_dereq_,module,exports){\n\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = createDebug.debug = createDebug['default'] = createDebug;\nexports.coerce = coerce;\nexports.disable = disable;\nexports.enable = enable;\nexports.enabled = enabled;\nexports.humanize = _dereq_(8);\n\n/**\n * Active `debug` instances.\n */\nexports.instances = [];\n\n/**\n * The currently active debug mode names, and names to skip.\n */\n\nexports.names = [];\nexports.skips = [];\n\n/**\n * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n *\n * Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n */\n\nexports.formatters = {};\n\n/**\n * Select a color.\n * @param {String} namespace\n * @return {Number}\n * @api private\n */\n\nfunction selectColor(namespace) {\n  var hash = 0, i;\n\n  for (i in namespace) {\n    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);\n    hash |= 0; // Convert to 32bit integer\n  }\n\n  return exports.colors[Math.abs(hash) % exports.colors.length];\n}\n\n/**\n * Create a debugger with the given `namespace`.\n *\n * @param {String} namespace\n * @return {Function}\n * @api public\n */\n\nfunction createDebug(namespace) {\n\n  var prevTime;\n\n  function debug() {\n    // disabled?\n    if (!debug.enabled) return;\n\n    var self = debug;\n\n    // set `diff` timestamp\n    var curr = +new Date();\n    var ms = curr - (prevTime || curr);\n    self.diff = ms;\n    self.prev = prevTime;\n    self.curr = curr;\n    prevTime = curr;\n\n    // turn the `arguments` into a proper Array\n    var args = new Array(arguments.length);\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i];\n    }\n\n    args[0] = exports.coerce(args[0]);\n\n    if ('string' !== typeof args[0]) {\n      // anything else let's inspect with %O\n      args.unshift('%O');\n    }\n\n    // apply any `formatters` transformations\n    var index = 0;\n    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {\n      // if we encounter an escaped % then don't increase the array index\n      if (match === '%%') return match;\n      index++;\n      var formatter = exports.formatters[format];\n      if ('function' === typeof formatter) {\n        var val = args[index];\n        match = formatter.call(self, val);\n\n        // now we need to remove `args[index]` since it's inlined in the `format`\n        args.splice(index, 1);\n        index--;\n      }\n      return match;\n    });\n\n    // apply env-specific formatting (colors, etc.)\n    exports.formatArgs.call(self, args);\n\n    var logFn = debug.log || exports.log || console.log.bind(console);\n    logFn.apply(self, args);\n  }\n\n  debug.namespace = namespace;\n  debug.enabled = exports.enabled(namespace);\n  debug.useColors = exports.useColors();\n  debug.color = selectColor(namespace);\n  debug.destroy = destroy;\n\n  // env-specific initialization logic for debug instances\n  if ('function' === typeof exports.init) {\n    exports.init(debug);\n  }\n\n  exports.instances.push(debug);\n\n  return debug;\n}\n\nfunction destroy () {\n  var index = exports.instances.indexOf(this);\n  if (index !== -1) {\n    exports.instances.splice(index, 1);\n    return true;\n  } else {\n    return false;\n  }\n}\n\n/**\n * Enables a debug mode by namespaces. This can include modes\n * separated by a colon and wildcards.\n *\n * @param {String} namespaces\n * @api public\n */\n\nfunction enable(namespaces) {\n  exports.save(namespaces);\n\n  exports.names = [];\n  exports.skips = [];\n\n  var i;\n  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n  var len = split.length;\n\n  for (i = 0; i < len; i++) {\n    if (!split[i]) continue; // ignore empty strings\n    namespaces = split[i].replace(/\\*/g, '.*?');\n    if (namespaces[0] === '-') {\n      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n    } else {\n      exports.names.push(new RegExp('^' + namespaces + '$'));\n    }\n  }\n\n  for (i = 0; i < exports.instances.length; i++) {\n    var instance = exports.instances[i];\n    instance.enabled = exports.enabled(instance.namespace);\n  }\n}\n\n/**\n * Disable debug output.\n *\n * @api public\n */\n\nfunction disable() {\n  exports.enable('');\n}\n\n/**\n * Returns true if the given mode name is enabled, false otherwise.\n *\n * @param {String} name\n * @return {Boolean}\n * @api public\n */\n\nfunction enabled(name) {\n  if (name[name.length - 1] === '*') {\n    return true;\n  }\n  var i, len;\n  for (i = 0, len = exports.skips.length; i < len; i++) {\n    if (exports.skips[i].test(name)) {\n      return false;\n    }\n  }\n  for (i = 0, len = exports.names.length; i < len; i++) {\n    if (exports.names[i].test(name)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Coerce `val`.\n *\n * @param {Mixed} val\n * @return {Mixed}\n * @api private\n */\n\nfunction coerce(val) {\n  if (val instanceof Error) return val.stack || val.message;\n  return val;\n}\n\n},{\"8\":8}],4:[function(_dereq_,module,exports){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nfunction EventEmitter() {\n  this._events = this._events || {};\n  this._maxListeners = this._maxListeners || undefined;\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nEventEmitter.defaultMaxListeners = 10;\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!isNumber(n) || n < 0 || isNaN(n))\n    throw TypeError('n must be a positive number');\n  this._maxListeners = n;\n  return this;\n};\n\nEventEmitter.prototype.emit = function(type) {\n  var er, handler, len, args, i, listeners;\n\n  if (!this._events)\n    this._events = {};\n\n  // If there is no 'error' event listener then throw.\n  if (type === 'error') {\n    if (!this._events.error ||\n        (isObject(this._events.error) && !this._events.error.length)) {\n      er = arguments[1];\n      if (er instanceof Error) {\n        throw er; // Unhandled 'error' event\n      } else {\n        // At least give some kind of context to the user\n        var err = new Error('Uncaught, unspecified \"error\" event. (' + er + ')');\n        err.context = er;\n        throw err;\n      }\n    }\n  }\n\n  handler = this._events[type];\n\n  if (isUndefined(handler))\n    return false;\n\n  if (isFunction(handler)) {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        args = Array.prototype.slice.call(arguments, 1);\n        handler.apply(this, args);\n    }\n  } else if (isObject(handler)) {\n    args = Array.prototype.slice.call(arguments, 1);\n    listeners = handler.slice();\n    len = listeners.length;\n    for (i = 0; i < len; i++)\n      listeners[i].apply(this, args);\n  }\n\n  return true;\n};\n\nEventEmitter.prototype.addListener = function(type, listener) {\n  var m;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events)\n    this._events = {};\n\n  // To avoid recursion in the case that type === \"newListener\"! Before\n  // adding it to the listeners, first emit \"newListener\".\n  if (this._events.newListener)\n    this.emit('newListener', type,\n              isFunction(listener.listener) ?\n              listener.listener : listener);\n\n  if (!this._events[type])\n    // Optimize the case of one listener. Don't need the extra array object.\n    this._events[type] = listener;\n  else if (isObject(this._events[type]))\n    // If we've already got an array, just append.\n    this._events[type].push(listener);\n  else\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n\n  // Check for listener leak\n  if (isObject(this._events[type]) && !this._events[type].warned) {\n    if (!isUndefined(this._maxListeners)) {\n      m = this._maxListeners;\n    } else {\n      m = EventEmitter.defaultMaxListeners;\n    }\n\n    if (m && m > 0 && this._events[type].length > m) {\n      this._events[type].warned = true;\n      console.error('(node) warning: possible EventEmitter memory ' +\n                    'leak detected. %d listeners added. ' +\n                    'Use emitter.setMaxListeners() to increase limit.',\n                    this._events[type].length);\n      if (typeof console.trace === 'function') {\n        // not supported in IE 10\n        console.trace();\n      }\n    }\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  var fired = false;\n\n  function g() {\n    this.removeListener(type, g);\n\n    if (!fired) {\n      fired = true;\n      listener.apply(this, arguments);\n    }\n  }\n\n  g.listener = listener;\n  this.on(type, g);\n\n  return this;\n};\n\n// emits a 'removeListener' event iff the listener was removed\nEventEmitter.prototype.removeListener = function(type, listener) {\n  var list, position, length, i;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events || !this._events[type])\n    return this;\n\n  list = this._events[type];\n  length = list.length;\n  position = -1;\n\n  if (list === listener ||\n      (isFunction(list.listener) && list.listener === listener)) {\n    delete this._events[type];\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n\n  } else if (isObject(list)) {\n    for (i = length; i-- > 0;) {\n      if (list[i] === listener ||\n          (list[i].listener && list[i].listener === listener)) {\n        position = i;\n        break;\n      }\n    }\n\n    if (position < 0)\n      return this;\n\n    if (list.length === 1) {\n      list.length = 0;\n      delete this._events[type];\n    } else {\n      list.splice(position, 1);\n    }\n\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  var key, listeners;\n\n  if (!this._events)\n    return this;\n\n  // not listening for removeListener, no need to emit\n  if (!this._events.removeListener) {\n    if (arguments.length === 0)\n      this._events = {};\n    else if (this._events[type])\n      delete this._events[type];\n    return this;\n  }\n\n  // emit removeListener for all listeners on all events\n  if (arguments.length === 0) {\n    for (key in this._events) {\n      if (key === 'removeListener') continue;\n      this.removeAllListeners(key);\n    }\n    this.removeAllListeners('removeListener');\n    this._events = {};\n    return this;\n  }\n\n  listeners = this._events[type];\n\n  if (isFunction(listeners)) {\n    this.removeListener(type, listeners);\n  } else if (listeners) {\n    // LIFO order\n    while (listeners.length)\n      this.removeListener(type, listeners[listeners.length - 1]);\n  }\n  delete this._events[type];\n\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  var ret;\n  if (!this._events || !this._events[type])\n    ret = [];\n  else if (isFunction(this._events[type]))\n    ret = [this._events[type]];\n  else\n    ret = this._events[type].slice();\n  return ret;\n};\n\nEventEmitter.prototype.listenerCount = function(type) {\n  if (this._events) {\n    var evlistener = this._events[type];\n\n    if (isFunction(evlistener))\n      return 1;\n    else if (evlistener)\n      return evlistener.length;\n  }\n  return 0;\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  return emitter.listenerCount(type);\n};\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\n\n},{}],5:[function(_dereq_,module,exports){\n(function (global){\n'use strict';\nvar Mutation = global.MutationObserver || global.WebKitMutationObserver;\n\nvar scheduleDrain;\n\n{\n  if (Mutation) {\n    var called = 0;\n    var observer = new Mutation(nextTick);\n    var element = global.document.createTextNode('');\n    observer.observe(element, {\n      characterData: true\n    });\n    scheduleDrain = function () {\n      element.data = (called = ++called % 2);\n    };\n  } else if (!global.setImmediate && typeof global.MessageChannel !== 'undefined') {\n    var channel = new global.MessageChannel();\n    channel.port1.onmessage = nextTick;\n    scheduleDrain = function () {\n      channel.port2.postMessage(0);\n    };\n  } else if ('document' in global && 'onreadystatechange' in global.document.createElement('script')) {\n    scheduleDrain = function () {\n\n      // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n      // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n      var scriptEl = global.document.createElement('script');\n      scriptEl.onreadystatechange = function () {\n        nextTick();\n\n        scriptEl.onreadystatechange = null;\n        scriptEl.parentNode.removeChild(scriptEl);\n        scriptEl = null;\n      };\n      global.document.documentElement.appendChild(scriptEl);\n    };\n  } else {\n    scheduleDrain = function () {\n      setTimeout(nextTick, 0);\n    };\n  }\n}\n\nvar draining;\nvar queue = [];\n//named nextTick for less confusing stack traces\nfunction nextTick() {\n  draining = true;\n  var i, oldQueue;\n  var len = queue.length;\n  while (len) {\n    oldQueue = queue;\n    queue = [];\n    i = -1;\n    while (++i < len) {\n      oldQueue[i]();\n    }\n    len = queue.length;\n  }\n  draining = false;\n}\n\nmodule.exports = immediate;\nfunction immediate(task) {\n  if (queue.push(task) === 1 && !draining) {\n    scheduleDrain();\n  }\n}\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{}],6:[function(_dereq_,module,exports){\nif (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    var TempCtor = function () {}\n    TempCtor.prototype = superCtor.prototype\n    ctor.prototype = new TempCtor()\n    ctor.prototype.constructor = ctor\n  }\n}\n\n},{}],7:[function(_dereq_,module,exports){\n'use strict';\nvar immediate = _dereq_(5);\n\n/* istanbul ignore next */\nfunction INTERNAL() {}\n\nvar handlers = {};\n\nvar REJECTED = ['REJECTED'];\nvar FULFILLED = ['FULFILLED'];\nvar PENDING = ['PENDING'];\n\nmodule.exports = Promise;\n\nfunction Promise(resolver) {\n  if (typeof resolver !== 'function') {\n    throw new TypeError('resolver must be a function');\n  }\n  this.state = PENDING;\n  this.queue = [];\n  this.outcome = void 0;\n  if (resolver !== INTERNAL) {\n    safelyResolveThenable(this, resolver);\n  }\n}\n\nPromise.prototype[\"catch\"] = function (onRejected) {\n  return this.then(null, onRejected);\n};\nPromise.prototype.then = function (onFulfilled, onRejected) {\n  if (typeof onFulfilled !== 'function' && this.state === FULFILLED ||\n    typeof onRejected !== 'function' && this.state === REJECTED) {\n    return this;\n  }\n  var promise = new this.constructor(INTERNAL);\n  if (this.state !== PENDING) {\n    var resolver = this.state === FULFILLED ? onFulfilled : onRejected;\n    unwrap(promise, resolver, this.outcome);\n  } else {\n    this.queue.push(new QueueItem(promise, onFulfilled, onRejected));\n  }\n\n  return promise;\n};\nfunction QueueItem(promise, onFulfilled, onRejected) {\n  this.promise = promise;\n  if (typeof onFulfilled === 'function') {\n    this.onFulfilled = onFulfilled;\n    this.callFulfilled = this.otherCallFulfilled;\n  }\n  if (typeof onRejected === 'function') {\n    this.onRejected = onRejected;\n    this.callRejected = this.otherCallRejected;\n  }\n}\nQueueItem.prototype.callFulfilled = function (value) {\n  handlers.resolve(this.promise, value);\n};\nQueueItem.prototype.otherCallFulfilled = function (value) {\n  unwrap(this.promise, this.onFulfilled, value);\n};\nQueueItem.prototype.callRejected = function (value) {\n  handlers.reject(this.promise, value);\n};\nQueueItem.prototype.otherCallRejected = function (value) {\n  unwrap(this.promise, this.onRejected, value);\n};\n\nfunction unwrap(promise, func, value) {\n  immediate(function () {\n    var returnValue;\n    try {\n      returnValue = func(value);\n    } catch (e) {\n      return handlers.reject(promise, e);\n    }\n    if (returnValue === promise) {\n      handlers.reject(promise, new TypeError('Cannot resolve promise with itself'));\n    } else {\n      handlers.resolve(promise, returnValue);\n    }\n  });\n}\n\nhandlers.resolve = function (self, value) {\n  var result = tryCatch(getThen, value);\n  if (result.status === 'error') {\n    return handlers.reject(self, result.value);\n  }\n  var thenable = result.value;\n\n  if (thenable) {\n    safelyResolveThenable(self, thenable);\n  } else {\n    self.state = FULFILLED;\n    self.outcome = value;\n    var i = -1;\n    var len = self.queue.length;\n    while (++i < len) {\n      self.queue[i].callFulfilled(value);\n    }\n  }\n  return self;\n};\nhandlers.reject = function (self, error) {\n  self.state = REJECTED;\n  self.outcome = error;\n  var i = -1;\n  var len = self.queue.length;\n  while (++i < len) {\n    self.queue[i].callRejected(error);\n  }\n  return self;\n};\n\nfunction getThen(obj) {\n  // Make sure we only access the accessor once as required by the spec\n  var then = obj && obj.then;\n  if (obj && (typeof obj === 'object' || typeof obj === 'function') && typeof then === 'function') {\n    return function appyThen() {\n      then.apply(obj, arguments);\n    };\n  }\n}\n\nfunction safelyResolveThenable(self, thenable) {\n  // Either fulfill, reject or reject with error\n  var called = false;\n  function onError(value) {\n    if (called) {\n      return;\n    }\n    called = true;\n    handlers.reject(self, value);\n  }\n\n  function onSuccess(value) {\n    if (called) {\n      return;\n    }\n    called = true;\n    handlers.resolve(self, value);\n  }\n\n  function tryToUnwrap() {\n    thenable(onSuccess, onError);\n  }\n\n  var result = tryCatch(tryToUnwrap);\n  if (result.status === 'error') {\n    onError(result.value);\n  }\n}\n\nfunction tryCatch(func, value) {\n  var out = {};\n  try {\n    out.value = func(value);\n    out.status = 'success';\n  } catch (e) {\n    out.status = 'error';\n    out.value = e;\n  }\n  return out;\n}\n\nPromise.resolve = resolve;\nfunction resolve(value) {\n  if (value instanceof this) {\n    return value;\n  }\n  return handlers.resolve(new this(INTERNAL), value);\n}\n\nPromise.reject = reject;\nfunction reject(reason) {\n  var promise = new this(INTERNAL);\n  return handlers.reject(promise, reason);\n}\n\nPromise.all = all;\nfunction all(iterable) {\n  var self = this;\n  if (Object.prototype.toString.call(iterable) !== '[object Array]') {\n    return this.reject(new TypeError('must be an array'));\n  }\n\n  var len = iterable.length;\n  var called = false;\n  if (!len) {\n    return this.resolve([]);\n  }\n\n  var values = new Array(len);\n  var resolved = 0;\n  var i = -1;\n  var promise = new this(INTERNAL);\n\n  while (++i < len) {\n    allResolver(iterable[i], i);\n  }\n  return promise;\n  function allResolver(value, i) {\n    self.resolve(value).then(resolveFromAll, function (error) {\n      if (!called) {\n        called = true;\n        handlers.reject(promise, error);\n      }\n    });\n    function resolveFromAll(outValue) {\n      values[i] = outValue;\n      if (++resolved === len && !called) {\n        called = true;\n        handlers.resolve(promise, values);\n      }\n    }\n  }\n}\n\nPromise.race = race;\nfunction race(iterable) {\n  var self = this;\n  if (Object.prototype.toString.call(iterable) !== '[object Array]') {\n    return this.reject(new TypeError('must be an array'));\n  }\n\n  var len = iterable.length;\n  var called = false;\n  if (!len) {\n    return this.resolve([]);\n  }\n\n  var i = -1;\n  var promise = new this(INTERNAL);\n\n  while (++i < len) {\n    resolver(iterable[i]);\n  }\n  return promise;\n  function resolver(value) {\n    self.resolve(value).then(function (response) {\n      if (!called) {\n        called = true;\n        handlers.resolve(promise, response);\n      }\n    }, function (error) {\n      if (!called) {\n        called = true;\n        handlers.reject(promise, error);\n      }\n    });\n  }\n}\n\n},{\"5\":5}],8:[function(_dereq_,module,exports){\n/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isNaN(val) === false) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^((?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  if (ms >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (ms >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (ms >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (ms >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  return plural(ms, d, 'day') ||\n    plural(ms, h, 'hour') ||\n    plural(ms, m, 'minute') ||\n    plural(ms, s, 'second') ||\n    ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, n, name) {\n  if (ms < n) {\n    return;\n  }\n  if (ms < n * 1.5) {\n    return Math.floor(ms / n) + ' ' + name;\n  }\n  return Math.ceil(ms / n) + ' ' + name + 's';\n}\n\n},{}],9:[function(_dereq_,module,exports){\n// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n},{}],10:[function(_dereq_,module,exports){\n(function (factory) {\n    if (typeof exports === 'object') {\n        // Node/CommonJS\n        module.exports = factory();\n    } else if (typeof define === 'function' && define.amd) {\n        // AMD\n        define(factory);\n    } else {\n        // Browser globals (with support for web workers)\n        var glob;\n\n        try {\n            glob = window;\n        } catch (e) {\n            glob = self;\n        }\n\n        glob.SparkMD5 = factory();\n    }\n}(function (undefined) {\n\n    'use strict';\n\n    /*\n     * Fastest md5 implementation around (JKM md5).\n     * Credits: Joseph Myers\n     *\n     * @see http://www.myersdaily.org/joseph/javascript/md5-text.html\n     * @see http://jsperf.com/md5-shootout/7\n     */\n\n    /* this function is much faster,\n      so if possible we use it. Some IEs\n      are the only ones I know of that\n      need the idiotic second function,\n      generated by an if clause.  */\n    var add32 = function (a, b) {\n        return (a + b) & 0xFFFFFFFF;\n    },\n        hex_chr = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'];\n\n\n    function cmn(q, a, b, x, s, t) {\n        a = add32(add32(a, q), add32(x, t));\n        return add32((a << s) | (a >>> (32 - s)), b);\n    }\n\n    function md5cycle(x, k) {\n        var a = x[0],\n            b = x[1],\n            c = x[2],\n            d = x[3];\n\n        a += (b & c | ~b & d) + k[0] - 680876936 | 0;\n        a  = (a << 7 | a >>> 25) + b | 0;\n        d += (a & b | ~a & c) + k[1] - 389564586 | 0;\n        d  = (d << 12 | d >>> 20) + a | 0;\n        c += (d & a | ~d & b) + k[2] + 606105819 | 0;\n        c  = (c << 17 | c >>> 15) + d | 0;\n        b += (c & d | ~c & a) + k[3] - 1044525330 | 0;\n        b  = (b << 22 | b >>> 10) + c | 0;\n        a += (b & c | ~b & d) + k[4] - 176418897 | 0;\n        a  = (a << 7 | a >>> 25) + b | 0;\n        d += (a & b | ~a & c) + k[5] + 1200080426 | 0;\n        d  = (d << 12 | d >>> 20) + a | 0;\n        c += (d & a | ~d & b) + k[6] - 1473231341 | 0;\n        c  = (c << 17 | c >>> 15) + d | 0;\n        b += (c & d | ~c & a) + k[7] - 45705983 | 0;\n        b  = (b << 22 | b >>> 10) + c | 0;\n        a += (b & c | ~b & d) + k[8] + 1770035416 | 0;\n        a  = (a << 7 | a >>> 25) + b | 0;\n        d += (a & b | ~a & c) + k[9] - 1958414417 | 0;\n        d  = (d << 12 | d >>> 20) + a | 0;\n        c += (d & a | ~d & b) + k[10] - 42063 | 0;\n        c  = (c << 17 | c >>> 15) + d | 0;\n        b += (c & d | ~c & a) + k[11] - 1990404162 | 0;\n        b  = (b << 22 | b >>> 10) + c | 0;\n        a += (b & c | ~b & d) + k[12] + 1804603682 | 0;\n        a  = (a << 7 | a >>> 25) + b | 0;\n        d += (a & b | ~a & c) + k[13] - 40341101 | 0;\n        d  = (d << 12 | d >>> 20) + a | 0;\n        c += (d & a | ~d & b) + k[14] - 1502002290 | 0;\n        c  = (c << 17 | c >>> 15) + d | 0;\n        b += (c & d | ~c & a) + k[15] + 1236535329 | 0;\n        b  = (b << 22 | b >>> 10) + c | 0;\n\n        a += (b & d | c & ~d) + k[1] - 165796510 | 0;\n        a  = (a << 5 | a >>> 27) + b | 0;\n        d += (a & c | b & ~c) + k[6] - 1069501632 | 0;\n        d  = (d << 9 | d >>> 23) + a | 0;\n        c += (d & b | a & ~b) + k[11] + 643717713 | 0;\n        c  = (c << 14 | c >>> 18) + d | 0;\n        b += (c & a | d & ~a) + k[0] - 373897302 | 0;\n        b  = (b << 20 | b >>> 12) + c | 0;\n        a += (b & d | c & ~d) + k[5] - 701558691 | 0;\n        a  = (a << 5 | a >>> 27) + b | 0;\n        d += (a & c | b & ~c) + k[10] + 38016083 | 0;\n        d  = (d << 9 | d >>> 23) + a | 0;\n        c += (d & b | a & ~b) + k[15] - 660478335 | 0;\n        c  = (c << 14 | c >>> 18) + d | 0;\n        b += (c & a | d & ~a) + k[4] - 405537848 | 0;\n        b  = (b << 20 | b >>> 12) + c | 0;\n        a += (b & d | c & ~d) + k[9] + 568446438 | 0;\n        a  = (a << 5 | a >>> 27) + b | 0;\n        d += (a & c | b & ~c) + k[14] - 1019803690 | 0;\n        d  = (d << 9 | d >>> 23) + a | 0;\n        c += (d & b | a & ~b) + k[3] - 187363961 | 0;\n        c  = (c << 14 | c >>> 18) + d | 0;\n        b += (c & a | d & ~a) + k[8] + 1163531501 | 0;\n        b  = (b << 20 | b >>> 12) + c | 0;\n        a += (b & d | c & ~d) + k[13] - 1444681467 | 0;\n        a  = (a << 5 | a >>> 27) + b | 0;\n        d += (a & c | b & ~c) + k[2] - 51403784 | 0;\n        d  = (d << 9 | d >>> 23) + a | 0;\n        c += (d & b | a & ~b) + k[7] + 1735328473 | 0;\n        c  = (c << 14 | c >>> 18) + d | 0;\n        b += (c & a | d & ~a) + k[12] - 1926607734 | 0;\n        b  = (b << 20 | b >>> 12) + c | 0;\n\n        a += (b ^ c ^ d) + k[5] - 378558 | 0;\n        a  = (a << 4 | a >>> 28) + b | 0;\n        d += (a ^ b ^ c) + k[8] - 2022574463 | 0;\n        d  = (d << 11 | d >>> 21) + a | 0;\n        c += (d ^ a ^ b) + k[11] + 1839030562 | 0;\n        c  = (c << 16 | c >>> 16) + d | 0;\n        b += (c ^ d ^ a) + k[14] - 35309556 | 0;\n        b  = (b << 23 | b >>> 9) + c | 0;\n        a += (b ^ c ^ d) + k[1] - 1530992060 | 0;\n        a  = (a << 4 | a >>> 28) + b | 0;\n        d += (a ^ b ^ c) + k[4] + 1272893353 | 0;\n        d  = (d << 11 | d >>> 21) + a | 0;\n        c += (d ^ a ^ b) + k[7] - 155497632 | 0;\n        c  = (c << 16 | c >>> 16) + d | 0;\n        b += (c ^ d ^ a) + k[10] - 1094730640 | 0;\n        b  = (b << 23 | b >>> 9) + c | 0;\n        a += (b ^ c ^ d) + k[13] + 681279174 | 0;\n        a  = (a << 4 | a >>> 28) + b | 0;\n        d += (a ^ b ^ c) + k[0] - 358537222 | 0;\n        d  = (d << 11 | d >>> 21) + a | 0;\n        c += (d ^ a ^ b) + k[3] - 722521979 | 0;\n        c  = (c << 16 | c >>> 16) + d | 0;\n        b += (c ^ d ^ a) + k[6] + 76029189 | 0;\n        b  = (b << 23 | b >>> 9) + c | 0;\n        a += (b ^ c ^ d) + k[9] - 640364487 | 0;\n        a  = (a << 4 | a >>> 28) + b | 0;\n        d += (a ^ b ^ c) + k[12] - 421815835 | 0;\n        d  = (d << 11 | d >>> 21) + a | 0;\n        c += (d ^ a ^ b) + k[15] + 530742520 | 0;\n        c  = (c << 16 | c >>> 16) + d | 0;\n        b += (c ^ d ^ a) + k[2] - 995338651 | 0;\n        b  = (b << 23 | b >>> 9) + c | 0;\n\n        a += (c ^ (b | ~d)) + k[0] - 198630844 | 0;\n        a  = (a << 6 | a >>> 26) + b | 0;\n        d += (b ^ (a | ~c)) + k[7] + 1126891415 | 0;\n        d  = (d << 10 | d >>> 22) + a | 0;\n        c += (a ^ (d | ~b)) + k[14] - 1416354905 | 0;\n        c  = (c << 15 | c >>> 17) + d | 0;\n        b += (d ^ (c | ~a)) + k[5] - 57434055 | 0;\n        b  = (b << 21 |b >>> 11) + c | 0;\n        a += (c ^ (b | ~d)) + k[12] + 1700485571 | 0;\n        a  = (a << 6 | a >>> 26) + b | 0;\n        d += (b ^ (a | ~c)) + k[3] - 1894986606 | 0;\n        d  = (d << 10 | d >>> 22) + a | 0;\n        c += (a ^ (d | ~b)) + k[10] - 1051523 | 0;\n        c  = (c << 15 | c >>> 17) + d | 0;\n        b += (d ^ (c | ~a)) + k[1] - 2054922799 | 0;\n        b  = (b << 21 |b >>> 11) + c | 0;\n        a += (c ^ (b | ~d)) + k[8] + 1873313359 | 0;\n        a  = (a << 6 | a >>> 26) + b | 0;\n        d += (b ^ (a | ~c)) + k[15] - 30611744 | 0;\n        d  = (d << 10 | d >>> 22) + a | 0;\n        c += (a ^ (d | ~b)) + k[6] - 1560198380 | 0;\n        c  = (c << 15 | c >>> 17) + d | 0;\n        b += (d ^ (c | ~a)) + k[13] + 1309151649 | 0;\n        b  = (b << 21 |b >>> 11) + c | 0;\n        a += (c ^ (b | ~d)) + k[4] - 145523070 | 0;\n        a  = (a << 6 | a >>> 26) + b | 0;\n        d += (b ^ (a | ~c)) + k[11] - 1120210379 | 0;\n        d  = (d << 10 | d >>> 22) + a | 0;\n        c += (a ^ (d | ~b)) + k[2] + 718787259 | 0;\n        c  = (c << 15 | c >>> 17) + d | 0;\n        b += (d ^ (c | ~a)) + k[9] - 343485551 | 0;\n        b  = (b << 21 | b >>> 11) + c | 0;\n\n        x[0] = a + x[0] | 0;\n        x[1] = b + x[1] | 0;\n        x[2] = c + x[2] | 0;\n        x[3] = d + x[3] | 0;\n    }\n\n    function md5blk(s) {\n        var md5blks = [],\n            i; /* Andy King said do it this way. */\n\n        for (i = 0; i < 64; i += 4) {\n            md5blks[i >> 2] = s.charCodeAt(i) + (s.charCodeAt(i + 1) << 8) + (s.charCodeAt(i + 2) << 16) + (s.charCodeAt(i + 3) << 24);\n        }\n        return md5blks;\n    }\n\n    function md5blk_array(a) {\n        var md5blks = [],\n            i; /* Andy King said do it this way. */\n\n        for (i = 0; i < 64; i += 4) {\n            md5blks[i >> 2] = a[i] + (a[i + 1] << 8) + (a[i + 2] << 16) + (a[i + 3] << 24);\n        }\n        return md5blks;\n    }\n\n    function md51(s) {\n        var n = s.length,\n            state = [1732584193, -271733879, -1732584194, 271733878],\n            i,\n            length,\n            tail,\n            tmp,\n            lo,\n            hi;\n\n        for (i = 64; i <= n; i += 64) {\n            md5cycle(state, md5blk(s.substring(i - 64, i)));\n        }\n        s = s.substring(i - 64);\n        length = s.length;\n        tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n        for (i = 0; i < length; i += 1) {\n            tail[i >> 2] |= s.charCodeAt(i) << ((i % 4) << 3);\n        }\n        tail[i >> 2] |= 0x80 << ((i % 4) << 3);\n        if (i > 55) {\n            md5cycle(state, tail);\n            for (i = 0; i < 16; i += 1) {\n                tail[i] = 0;\n            }\n        }\n\n        // Beware that the final length might not fit in 32 bits so we take care of that\n        tmp = n * 8;\n        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);\n        lo = parseInt(tmp[2], 16);\n        hi = parseInt(tmp[1], 16) || 0;\n\n        tail[14] = lo;\n        tail[15] = hi;\n\n        md5cycle(state, tail);\n        return state;\n    }\n\n    function md51_array(a) {\n        var n = a.length,\n            state = [1732584193, -271733879, -1732584194, 271733878],\n            i,\n            length,\n            tail,\n            tmp,\n            lo,\n            hi;\n\n        for (i = 64; i <= n; i += 64) {\n            md5cycle(state, md5blk_array(a.subarray(i - 64, i)));\n        }\n\n        // Not sure if it is a bug, however IE10 will always produce a sub array of length 1\n        // containing the last element of the parent array if the sub array specified starts\n        // beyond the length of the parent array - weird.\n        // https://connect.microsoft.com/IE/feedback/details/771452/typed-array-subarray-issue\n        a = (i - 64) < n ? a.subarray(i - 64) : new Uint8Array(0);\n\n        length = a.length;\n        tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n        for (i = 0; i < length; i += 1) {\n            tail[i >> 2] |= a[i] << ((i % 4) << 3);\n        }\n\n        tail[i >> 2] |= 0x80 << ((i % 4) << 3);\n        if (i > 55) {\n            md5cycle(state, tail);\n            for (i = 0; i < 16; i += 1) {\n                tail[i] = 0;\n            }\n        }\n\n        // Beware that the final length might not fit in 32 bits so we take care of that\n        tmp = n * 8;\n        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);\n        lo = parseInt(tmp[2], 16);\n        hi = parseInt(tmp[1], 16) || 0;\n\n        tail[14] = lo;\n        tail[15] = hi;\n\n        md5cycle(state, tail);\n\n        return state;\n    }\n\n    function rhex(n) {\n        var s = '',\n            j;\n        for (j = 0; j < 4; j += 1) {\n            s += hex_chr[(n >> (j * 8 + 4)) & 0x0F] + hex_chr[(n >> (j * 8)) & 0x0F];\n        }\n        return s;\n    }\n\n    function hex(x) {\n        var i;\n        for (i = 0; i < x.length; i += 1) {\n            x[i] = rhex(x[i]);\n        }\n        return x.join('');\n    }\n\n    // In some cases the fast add32 function cannot be used..\n    if (hex(md51('hello')) !== '5d41402abc4b2a76b9719d911017c592') {\n        add32 = function (x, y) {\n            var lsw = (x & 0xFFFF) + (y & 0xFFFF),\n                msw = (x >> 16) + (y >> 16) + (lsw >> 16);\n            return (msw << 16) | (lsw & 0xFFFF);\n        };\n    }\n\n    // ---------------------------------------------------\n\n    /**\n     * ArrayBuffer slice polyfill.\n     *\n     * @see https://github.com/ttaubert/node-arraybuffer-slice\n     */\n\n    if (typeof ArrayBuffer !== 'undefined' && !ArrayBuffer.prototype.slice) {\n        (function () {\n            function clamp(val, length) {\n                val = (val | 0) || 0;\n\n                if (val < 0) {\n                    return Math.max(val + length, 0);\n                }\n\n                return Math.min(val, length);\n            }\n\n            ArrayBuffer.prototype.slice = function (from, to) {\n                var length = this.byteLength,\n                    begin = clamp(from, length),\n                    end = length,\n                    num,\n                    target,\n                    targetArray,\n                    sourceArray;\n\n                if (to !== undefined) {\n                    end = clamp(to, length);\n                }\n\n                if (begin > end) {\n                    return new ArrayBuffer(0);\n                }\n\n                num = end - begin;\n                target = new ArrayBuffer(num);\n                targetArray = new Uint8Array(target);\n\n                sourceArray = new Uint8Array(this, begin, num);\n                targetArray.set(sourceArray);\n\n                return target;\n            };\n        })();\n    }\n\n    // ---------------------------------------------------\n\n    /**\n     * Helpers.\n     */\n\n    function toUtf8(str) {\n        if (/[\\u0080-\\uFFFF]/.test(str)) {\n            str = unescape(encodeURIComponent(str));\n        }\n\n        return str;\n    }\n\n    function utf8Str2ArrayBuffer(str, returnUInt8Array) {\n        var length = str.length,\n           buff = new ArrayBuffer(length),\n           arr = new Uint8Array(buff),\n           i;\n\n        for (i = 0; i < length; i += 1) {\n            arr[i] = str.charCodeAt(i);\n        }\n\n        return returnUInt8Array ? arr : buff;\n    }\n\n    function arrayBuffer2Utf8Str(buff) {\n        return String.fromCharCode.apply(null, new Uint8Array(buff));\n    }\n\n    function concatenateArrayBuffers(first, second, returnUInt8Array) {\n        var result = new Uint8Array(first.byteLength + second.byteLength);\n\n        result.set(new Uint8Array(first));\n        result.set(new Uint8Array(second), first.byteLength);\n\n        return returnUInt8Array ? result : result.buffer;\n    }\n\n    function hexToBinaryString(hex) {\n        var bytes = [],\n            length = hex.length,\n            x;\n\n        for (x = 0; x < length - 1; x += 2) {\n            bytes.push(parseInt(hex.substr(x, 2), 16));\n        }\n\n        return String.fromCharCode.apply(String, bytes);\n    }\n\n    // ---------------------------------------------------\n\n    /**\n     * SparkMD5 OOP implementation.\n     *\n     * Use this class to perform an incremental md5, otherwise use the\n     * static methods instead.\n     */\n\n    function SparkMD5() {\n        // call reset to init the instance\n        this.reset();\n    }\n\n    /**\n     * Appends a string.\n     * A conversion will be applied if an utf8 string is detected.\n     *\n     * @param {String} str The string to be appended\n     *\n     * @return {SparkMD5} The instance itself\n     */\n    SparkMD5.prototype.append = function (str) {\n        // Converts the string to utf8 bytes if necessary\n        // Then append as binary\n        this.appendBinary(toUtf8(str));\n\n        return this;\n    };\n\n    /**\n     * Appends a binary string.\n     *\n     * @param {String} contents The binary string to be appended\n     *\n     * @return {SparkMD5} The instance itself\n     */\n    SparkMD5.prototype.appendBinary = function (contents) {\n        this._buff += contents;\n        this._length += contents.length;\n\n        var length = this._buff.length,\n            i;\n\n        for (i = 64; i <= length; i += 64) {\n            md5cycle(this._hash, md5blk(this._buff.substring(i - 64, i)));\n        }\n\n        this._buff = this._buff.substring(i - 64);\n\n        return this;\n    };\n\n    /**\n     * Finishes the incremental computation, reseting the internal state and\n     * returning the result.\n     *\n     * @param {Boolean} raw True to get the raw string, false to get the hex string\n     *\n     * @return {String} The result\n     */\n    SparkMD5.prototype.end = function (raw) {\n        var buff = this._buff,\n            length = buff.length,\n            i,\n            tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n            ret;\n\n        for (i = 0; i < length; i += 1) {\n            tail[i >> 2] |= buff.charCodeAt(i) << ((i % 4) << 3);\n        }\n\n        this._finish(tail, length);\n        ret = hex(this._hash);\n\n        if (raw) {\n            ret = hexToBinaryString(ret);\n        }\n\n        this.reset();\n\n        return ret;\n    };\n\n    /**\n     * Resets the internal state of the computation.\n     *\n     * @return {SparkMD5} The instance itself\n     */\n    SparkMD5.prototype.reset = function () {\n        this._buff = '';\n        this._length = 0;\n        this._hash = [1732584193, -271733879, -1732584194, 271733878];\n\n        return this;\n    };\n\n    /**\n     * Gets the internal state of the computation.\n     *\n     * @return {Object} The state\n     */\n    SparkMD5.prototype.getState = function () {\n        return {\n            buff: this._buff,\n            length: this._length,\n            hash: this._hash\n        };\n    };\n\n    /**\n     * Gets the internal state of the computation.\n     *\n     * @param {Object} state The state\n     *\n     * @return {SparkMD5} The instance itself\n     */\n    SparkMD5.prototype.setState = function (state) {\n        this._buff = state.buff;\n        this._length = state.length;\n        this._hash = state.hash;\n\n        return this;\n    };\n\n    /**\n     * Releases memory used by the incremental buffer and other additional\n     * resources. If you plan to use the instance again, use reset instead.\n     */\n    SparkMD5.prototype.destroy = function () {\n        delete this._hash;\n        delete this._buff;\n        delete this._length;\n    };\n\n    /**\n     * Finish the final calculation based on the tail.\n     *\n     * @param {Array}  tail   The tail (will be modified)\n     * @param {Number} length The length of the remaining buffer\n     */\n    SparkMD5.prototype._finish = function (tail, length) {\n        var i = length,\n            tmp,\n            lo,\n            hi;\n\n        tail[i >> 2] |= 0x80 << ((i % 4) << 3);\n        if (i > 55) {\n            md5cycle(this._hash, tail);\n            for (i = 0; i < 16; i += 1) {\n                tail[i] = 0;\n            }\n        }\n\n        // Do the final computation based on the tail and length\n        // Beware that the final length may not fit in 32 bits so we take care of that\n        tmp = this._length * 8;\n        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);\n        lo = parseInt(tmp[2], 16);\n        hi = parseInt(tmp[1], 16) || 0;\n\n        tail[14] = lo;\n        tail[15] = hi;\n        md5cycle(this._hash, tail);\n    };\n\n    /**\n     * Performs the md5 hash on a string.\n     * A conversion will be applied if utf8 string is detected.\n     *\n     * @param {String}  str The string\n     * @param {Boolean} raw True to get the raw string, false to get the hex string\n     *\n     * @return {String} The result\n     */\n    SparkMD5.hash = function (str, raw) {\n        // Converts the string to utf8 bytes if necessary\n        // Then compute it using the binary function\n        return SparkMD5.hashBinary(toUtf8(str), raw);\n    };\n\n    /**\n     * Performs the md5 hash on a binary string.\n     *\n     * @param {String}  content The binary string\n     * @param {Boolean} raw     True to get the raw string, false to get the hex string\n     *\n     * @return {String} The result\n     */\n    SparkMD5.hashBinary = function (content, raw) {\n        var hash = md51(content),\n            ret = hex(hash);\n\n        return raw ? hexToBinaryString(ret) : ret;\n    };\n\n    // ---------------------------------------------------\n\n    /**\n     * SparkMD5 OOP implementation for array buffers.\n     *\n     * Use this class to perform an incremental md5 ONLY for array buffers.\n     */\n    SparkMD5.ArrayBuffer = function () {\n        // call reset to init the instance\n        this.reset();\n    };\n\n    /**\n     * Appends an array buffer.\n     *\n     * @param {ArrayBuffer} arr The array to be appended\n     *\n     * @return {SparkMD5.ArrayBuffer} The instance itself\n     */\n    SparkMD5.ArrayBuffer.prototype.append = function (arr) {\n        var buff = concatenateArrayBuffers(this._buff.buffer, arr, true),\n            length = buff.length,\n            i;\n\n        this._length += arr.byteLength;\n\n        for (i = 64; i <= length; i += 64) {\n            md5cycle(this._hash, md5blk_array(buff.subarray(i - 64, i)));\n        }\n\n        this._buff = (i - 64) < length ? new Uint8Array(buff.buffer.slice(i - 64)) : new Uint8Array(0);\n\n        return this;\n    };\n\n    /**\n     * Finishes the incremental computation, reseting the internal state and\n     * returning the result.\n     *\n     * @param {Boolean} raw True to get the raw string, false to get the hex string\n     *\n     * @return {String} The result\n     */\n    SparkMD5.ArrayBuffer.prototype.end = function (raw) {\n        var buff = this._buff,\n            length = buff.length,\n            tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n            i,\n            ret;\n\n        for (i = 0; i < length; i += 1) {\n            tail[i >> 2] |= buff[i] << ((i % 4) << 3);\n        }\n\n        this._finish(tail, length);\n        ret = hex(this._hash);\n\n        if (raw) {\n            ret = hexToBinaryString(ret);\n        }\n\n        this.reset();\n\n        return ret;\n    };\n\n    /**\n     * Resets the internal state of the computation.\n     *\n     * @return {SparkMD5.ArrayBuffer} The instance itself\n     */\n    SparkMD5.ArrayBuffer.prototype.reset = function () {\n        this._buff = new Uint8Array(0);\n        this._length = 0;\n        this._hash = [1732584193, -271733879, -1732584194, 271733878];\n\n        return this;\n    };\n\n    /**\n     * Gets the internal state of the computation.\n     *\n     * @return {Object} The state\n     */\n    SparkMD5.ArrayBuffer.prototype.getState = function () {\n        var state = SparkMD5.prototype.getState.call(this);\n\n        // Convert buffer to a string\n        state.buff = arrayBuffer2Utf8Str(state.buff);\n\n        return state;\n    };\n\n    /**\n     * Gets the internal state of the computation.\n     *\n     * @param {Object} state The state\n     *\n     * @return {SparkMD5.ArrayBuffer} The instance itself\n     */\n    SparkMD5.ArrayBuffer.prototype.setState = function (state) {\n        // Convert string to buffer\n        state.buff = utf8Str2ArrayBuffer(state.buff, true);\n\n        return SparkMD5.prototype.setState.call(this, state);\n    };\n\n    SparkMD5.ArrayBuffer.prototype.destroy = SparkMD5.prototype.destroy;\n\n    SparkMD5.ArrayBuffer.prototype._finish = SparkMD5.prototype._finish;\n\n    /**\n     * Performs the md5 hash on an array buffer.\n     *\n     * @param {ArrayBuffer} arr The array buffer\n     * @param {Boolean}     raw True to get the raw string, false to get the hex one\n     *\n     * @return {String} The result\n     */\n    SparkMD5.ArrayBuffer.hash = function (arr, raw) {\n        var hash = md51_array(new Uint8Array(arr)),\n            ret = hex(hash);\n\n        return raw ? hexToBinaryString(ret) : ret;\n    };\n\n    return SparkMD5;\n}));\n\n},{}],11:[function(_dereq_,module,exports){\nvar v1 = _dereq_(14);\nvar v4 = _dereq_(15);\n\nvar uuid = v4;\nuuid.v1 = v1;\nuuid.v4 = v4;\n\nmodule.exports = uuid;\n\n},{\"14\":14,\"15\":15}],12:[function(_dereq_,module,exports){\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\nvar byteToHex = [];\nfor (var i = 0; i < 256; ++i) {\n  byteToHex[i] = (i + 0x100).toString(16).substr(1);\n}\n\nfunction bytesToUuid(buf, offset) {\n  var i = offset || 0;\n  var bth = byteToHex;\n  return bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]];\n}\n\nmodule.exports = bytesToUuid;\n\n},{}],13:[function(_dereq_,module,exports){\n// Unique ID creation requires a high quality random # generator.  In the\n// browser this is a little complicated due to unknown quality of Math.random()\n// and inconsistent support for the `crypto` API.  We do the best we can via\n// feature-detection\n\n// getRandomValues needs to be invoked in a context where \"this\" is a Crypto implementation.\nvar getRandomValues = (typeof(crypto) != 'undefined' && crypto.getRandomValues.bind(crypto)) ||\n                      (typeof(msCrypto) != 'undefined' && msCrypto.getRandomValues.bind(msCrypto));\nif (getRandomValues) {\n  // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto\n  var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef\n\n  module.exports = function whatwgRNG() {\n    getRandomValues(rnds8);\n    return rnds8;\n  };\n} else {\n  // Math.random()-based (RNG)\n  //\n  // If all else fails, use Math.random().  It's fast, but is of unspecified\n  // quality.\n  var rnds = new Array(16);\n\n  module.exports = function mathRNG() {\n    for (var i = 0, r; i < 16; i++) {\n      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;\n      rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;\n    }\n\n    return rnds;\n  };\n}\n\n},{}],14:[function(_dereq_,module,exports){\nvar rng = _dereq_(13);\nvar bytesToUuid = _dereq_(12);\n\n// **`v1()` - Generate time-based UUID**\n//\n// Inspired by https://github.com/LiosK/UUID.js\n// and http://docs.python.org/library/uuid.html\n\nvar _nodeId;\nvar _clockseq;\n\n// Previous uuid creation time\nvar _lastMSecs = 0;\nvar _lastNSecs = 0;\n\n// See https://github.com/broofa/node-uuid for API details\nfunction v1(options, buf, offset) {\n  var i = buf && offset || 0;\n  var b = buf || [];\n\n  options = options || {};\n  var node = options.node || _nodeId;\n  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;\n\n  // node and clockseq need to be initialized to random values if they're not\n  // specified.  We do this lazily to minimize issues related to insufficient\n  // system entropy.  See #189\n  if (node == null || clockseq == null) {\n    var seedBytes = rng();\n    if (node == null) {\n      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)\n      node = _nodeId = [\n        seedBytes[0] | 0x01,\n        seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]\n      ];\n    }\n    if (clockseq == null) {\n      // Per 4.2.2, randomize (14 bit) clockseq\n      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;\n    }\n  }\n\n  // UUID timestamps are 100 nano-second units since the Gregorian epoch,\n  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so\n  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'\n  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.\n  var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime();\n\n  // Per 4.2.1.2, use count of uuid's generated during the current clock\n  // cycle to simulate higher resolution clock\n  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;\n\n  // Time since last uuid creation (in msecs)\n  var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;\n\n  // Per 4.2.1.2, Bump clockseq on clock regression\n  if (dt < 0 && options.clockseq === undefined) {\n    clockseq = clockseq + 1 & 0x3fff;\n  }\n\n  // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new\n  // time interval\n  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {\n    nsecs = 0;\n  }\n\n  // Per 4.2.1.2 Throw error if too many uuids are requested\n  if (nsecs >= 10000) {\n    throw new Error('uuid.v1(): Can\\'t create more than 10M uuids/sec');\n  }\n\n  _lastMSecs = msecs;\n  _lastNSecs = nsecs;\n  _clockseq = clockseq;\n\n  // Per 4.1.4 - Convert from unix epoch to Gregorian epoch\n  msecs += 12219292800000;\n\n  // `time_low`\n  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;\n  b[i++] = tl >>> 24 & 0xff;\n  b[i++] = tl >>> 16 & 0xff;\n  b[i++] = tl >>> 8 & 0xff;\n  b[i++] = tl & 0xff;\n\n  // `time_mid`\n  var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;\n  b[i++] = tmh >>> 8 & 0xff;\n  b[i++] = tmh & 0xff;\n\n  // `time_high_and_version`\n  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version\n  b[i++] = tmh >>> 16 & 0xff;\n\n  // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)\n  b[i++] = clockseq >>> 8 | 0x80;\n\n  // `clock_seq_low`\n  b[i++] = clockseq & 0xff;\n\n  // `node`\n  for (var n = 0; n < 6; ++n) {\n    b[i + n] = node[n];\n  }\n\n  return buf ? buf : bytesToUuid(b);\n}\n\nmodule.exports = v1;\n\n},{\"12\":12,\"13\":13}],15:[function(_dereq_,module,exports){\nvar rng = _dereq_(13);\nvar bytesToUuid = _dereq_(12);\n\nfunction v4(options, buf, offset) {\n  var i = buf && offset || 0;\n\n  if (typeof(options) == 'string') {\n    buf = options === 'binary' ? new Array(16) : null;\n    options = null;\n  }\n  options = options || {};\n\n  var rnds = options.random || (options.rng || rng)();\n\n  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n  rnds[6] = (rnds[6] & 0x0f) | 0x40;\n  rnds[8] = (rnds[8] & 0x3f) | 0x80;\n\n  // Copy bytes to buffer, if provided\n  if (buf) {\n    for (var ii = 0; ii < 16; ++ii) {\n      buf[i + ii] = rnds[ii];\n    }\n  }\n\n  return buf || bytesToUuid(rnds);\n}\n\nmodule.exports = v4;\n\n},{\"12\":12,\"13\":13}],16:[function(_dereq_,module,exports){\n'use strict';\n\n/**\n * Stringify/parse functions that don't operate\n * recursively, so they avoid call stack exceeded\n * errors.\n */\nexports.stringify = function stringify(input) {\n  var queue = [];\n  queue.push({obj: input});\n\n  var res = '';\n  var next, obj, prefix, val, i, arrayPrefix, keys, k, key, value, objPrefix;\n  while ((next = queue.pop())) {\n    obj = next.obj;\n    prefix = next.prefix || '';\n    val = next.val || '';\n    res += prefix;\n    if (val) {\n      res += val;\n    } else if (typeof obj !== 'object') {\n      res += typeof obj === 'undefined' ? null : JSON.stringify(obj);\n    } else if (obj === null) {\n      res += 'null';\n    } else if (Array.isArray(obj)) {\n      queue.push({val: ']'});\n      for (i = obj.length - 1; i >= 0; i--) {\n        arrayPrefix = i === 0 ? '' : ',';\n        queue.push({obj: obj[i], prefix: arrayPrefix});\n      }\n      queue.push({val: '['});\n    } else { // object\n      keys = [];\n      for (k in obj) {\n        if (obj.hasOwnProperty(k)) {\n          keys.push(k);\n        }\n      }\n      queue.push({val: '}'});\n      for (i = keys.length - 1; i >= 0; i--) {\n        key = keys[i];\n        value = obj[key];\n        objPrefix = (i > 0 ? ',' : '');\n        objPrefix += JSON.stringify(key) + ':';\n        queue.push({obj: value, prefix: objPrefix});\n      }\n      queue.push({val: '{'});\n    }\n  }\n  return res;\n};\n\n// Convenience function for the parse function.\n// This pop function is basically copied from\n// pouchCollate.parseIndexableString\nfunction pop(obj, stack, metaStack) {\n  var lastMetaElement = metaStack[metaStack.length - 1];\n  if (obj === lastMetaElement.element) {\n    // popping a meta-element, e.g. an object whose value is another object\n    metaStack.pop();\n    lastMetaElement = metaStack[metaStack.length - 1];\n  }\n  var element = lastMetaElement.element;\n  var lastElementIndex = lastMetaElement.index;\n  if (Array.isArray(element)) {\n    element.push(obj);\n  } else if (lastElementIndex === stack.length - 2) { // obj with key+value\n    var key = stack.pop();\n    element[key] = obj;\n  } else {\n    stack.push(obj); // obj with key only\n  }\n}\n\nexports.parse = function (str) {\n  var stack = [];\n  var metaStack = []; // stack for arrays and objects\n  var i = 0;\n  var collationIndex,parsedNum,numChar;\n  var parsedString,lastCh,numConsecutiveSlashes,ch;\n  var arrayElement, objElement;\n  while (true) {\n    collationIndex = str[i++];\n    if (collationIndex === '}' ||\n        collationIndex === ']' ||\n        typeof collationIndex === 'undefined') {\n      if (stack.length === 1) {\n        return stack.pop();\n      } else {\n        pop(stack.pop(), stack, metaStack);\n        continue;\n      }\n    }\n    switch (collationIndex) {\n      case ' ':\n      case '\\t':\n      case '\\n':\n      case ':':\n      case ',':\n        break;\n      case 'n':\n        i += 3; // 'ull'\n        pop(null, stack, metaStack);\n        break;\n      case 't':\n        i += 3; // 'rue'\n        pop(true, stack, metaStack);\n        break;\n      case 'f':\n        i += 4; // 'alse'\n        pop(false, stack, metaStack);\n        break;\n      case '0':\n      case '1':\n      case '2':\n      case '3':\n      case '4':\n      case '5':\n      case '6':\n      case '7':\n      case '8':\n      case '9':\n      case '-':\n        parsedNum = '';\n        i--;\n        while (true) {\n          numChar = str[i++];\n          if (/[\\d\\.\\-e\\+]/.test(numChar)) {\n            parsedNum += numChar;\n          } else {\n            i--;\n            break;\n          }\n        }\n        pop(parseFloat(parsedNum), stack, metaStack);\n        break;\n      case '\"':\n        parsedString = '';\n        lastCh = void 0;\n        numConsecutiveSlashes = 0;\n        while (true) {\n          ch = str[i++];\n          if (ch !== '\"' || (lastCh === '\\\\' &&\n              numConsecutiveSlashes % 2 === 1)) {\n            parsedString += ch;\n            lastCh = ch;\n            if (lastCh === '\\\\') {\n              numConsecutiveSlashes++;\n            } else {\n              numConsecutiveSlashes = 0;\n            }\n          } else {\n            break;\n          }\n        }\n        pop(JSON.parse('\"' + parsedString + '\"'), stack, metaStack);\n        break;\n      case '[':\n        arrayElement = { element: [], index: stack.length };\n        stack.push(arrayElement.element);\n        metaStack.push(arrayElement);\n        break;\n      case '{':\n        objElement = { element: {}, index: stack.length };\n        stack.push(objElement.element);\n        metaStack.push(objElement);\n        break;\n      default:\n        throw new Error(\n          'unexpectedly reached end of input: ' + collationIndex);\n    }\n  }\n};\n\n},{}],17:[function(_dereq_,module,exports){\n(function (global){\n'use strict';\n\nfunction _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }\n\nvar lie = _interopDefault(_dereq_(7));\nvar getArguments = _interopDefault(_dereq_(1));\nvar nextTick = _interopDefault(_dereq_(5));\nvar events = _dereq_(4);\nvar inherits = _interopDefault(_dereq_(6));\nvar uuidV4 = _interopDefault(_dereq_(11));\nvar debug = _interopDefault(_dereq_(2));\nvar Md5 = _interopDefault(_dereq_(10));\nvar vuvuzela = _interopDefault(_dereq_(16));\n\n/* istanbul ignore next */\nvar PouchPromise = typeof Promise === 'function' ? Promise : lie;\n\nfunction isBinaryObject(object) {\n  return (typeof ArrayBuffer !== 'undefined' && object instanceof ArrayBuffer) ||\n    (typeof Blob !== 'undefined' && object instanceof Blob);\n}\n\nfunction cloneArrayBuffer(buff) {\n  if (typeof buff.slice === 'function') {\n    return buff.slice(0);\n  }\n  // IE10-11 slice() polyfill\n  var target = new ArrayBuffer(buff.byteLength);\n  var targetArray = new Uint8Array(target);\n  var sourceArray = new Uint8Array(buff);\n  targetArray.set(sourceArray);\n  return target;\n}\n\nfunction cloneBinaryObject(object) {\n  if (object instanceof ArrayBuffer) {\n    return cloneArrayBuffer(object);\n  }\n  var size = object.size;\n  var type = object.type;\n  // Blob\n  if (typeof object.slice === 'function') {\n    return object.slice(0, size, type);\n  }\n  // PhantomJS slice() replacement\n  return object.webkitSlice(0, size, type);\n}\n\n// most of this is borrowed from lodash.isPlainObject:\n// https://github.com/fis-components/lodash.isplainobject/\n// blob/29c358140a74f252aeb08c9eb28bef86f2217d4a/index.js\n\nvar funcToString = Function.prototype.toString;\nvar objectCtorString = funcToString.call(Object);\n\nfunction isPlainObject(value) {\n  var proto = Object.getPrototypeOf(value);\n  /* istanbul ignore if */\n  if (proto === null) { // not sure when this happens, but I guess it can\n    return true;\n  }\n  var Ctor = proto.constructor;\n  return (typeof Ctor == 'function' &&\n    Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString);\n}\n\nfunction clone(object) {\n  var newObject;\n  var i;\n  var len;\n\n  if (!object || typeof object !== 'object') {\n    return object;\n  }\n\n  if (Array.isArray(object)) {\n    newObject = [];\n    for (i = 0, len = object.length; i < len; i++) {\n      newObject[i] = clone(object[i]);\n    }\n    return newObject;\n  }\n\n  // special case: to avoid inconsistencies between IndexedDB\n  // and other backends, we automatically stringify Dates\n  if (object instanceof Date) {\n    return object.toISOString();\n  }\n\n  if (isBinaryObject(object)) {\n    return cloneBinaryObject(object);\n  }\n\n  if (!isPlainObject(object)) {\n    return object; // don't clone objects like Workers\n  }\n\n  newObject = {};\n  for (i in object) {\n    /* istanbul ignore else */\n    if (Object.prototype.hasOwnProperty.call(object, i)) {\n      var value = clone(object[i]);\n      if (typeof value !== 'undefined') {\n        newObject[i] = value;\n      }\n    }\n  }\n  return newObject;\n}\n\nfunction once(fun) {\n  var called = false;\n  return getArguments(function (args) {\n    /* istanbul ignore if */\n    if (called) {\n      // this is a smoke test and should never actually happen\n      throw new Error('once called more than once');\n    } else {\n      called = true;\n      fun.apply(this, args);\n    }\n  });\n}\n\nfunction toPromise(func) {\n  //create the function we will be returning\n  return getArguments(function (args) {\n    // Clone arguments\n    args = clone(args);\n    var self = this;\n    // if the last argument is a function, assume its a callback\n    var usedCB = (typeof args[args.length - 1] === 'function') ? args.pop() : false;\n    var promise = new PouchPromise(function (fulfill, reject) {\n      var resp;\n      try {\n        var callback = once(function (err, mesg) {\n          if (err) {\n            reject(err);\n          } else {\n            fulfill(mesg);\n          }\n        });\n        // create a callback for this invocation\n        // apply the function in the orig context\n        args.push(callback);\n        resp = func.apply(self, args);\n        if (resp && typeof resp.then === 'function') {\n          fulfill(resp);\n        }\n      } catch (e) {\n        reject(e);\n      }\n    });\n    // if there is a callback, call it back\n    if (usedCB) {\n      promise.then(function (result) {\n        usedCB(null, result);\n      }, usedCB);\n    }\n    return promise;\n  });\n}\n\nfunction logApiCall(self, name, args) {\n  /* istanbul ignore if */\n  if (self.constructor.listeners('debug').length) {\n    var logArgs = ['api', self.name, name];\n    for (var i = 0; i < args.length - 1; i++) {\n      logArgs.push(args[i]);\n    }\n    self.constructor.emit('debug', logArgs);\n\n    // override the callback itself to log the response\n    var origCallback = args[args.length - 1];\n    args[args.length - 1] = function (err, res) {\n      var responseArgs = ['api', self.name, name];\n      responseArgs = responseArgs.concat(\n        err ? ['error', err] : ['success', res]\n      );\n      self.constructor.emit('debug', responseArgs);\n      origCallback(err, res);\n    };\n  }\n}\n\nfunction adapterFun(name, callback) {\n  return toPromise(getArguments(function (args) {\n    if (this._closed) {\n      return PouchPromise.reject(new Error('database is closed'));\n    }\n    if (this._destroyed) {\n      return PouchPromise.reject(new Error('database is destroyed'));\n    }\n    var self = this;\n    logApiCall(self, name, args);\n    if (!this.taskqueue.isReady) {\n      return new PouchPromise(function (fulfill, reject) {\n        self.taskqueue.addTask(function (failed) {\n          if (failed) {\n            reject(failed);\n          } else {\n            fulfill(self[name].apply(self, args));\n          }\n        });\n      });\n    }\n    return callback.apply(this, args);\n  }));\n}\n\nfunction mangle(key) {\n  return '$' + key;\n}\nfunction unmangle(key) {\n  return key.substring(1);\n}\nfunction Map$1() {\n  this._store = {};\n}\nMap$1.prototype.get = function (key) {\n  var mangled = mangle(key);\n  return this._store[mangled];\n};\nMap$1.prototype.set = function (key, value) {\n  var mangled = mangle(key);\n  this._store[mangled] = value;\n  return true;\n};\nMap$1.prototype.has = function (key) {\n  var mangled = mangle(key);\n  return mangled in this._store;\n};\nMap$1.prototype[\"delete\"] = function (key) {\n  var mangled = mangle(key);\n  var res = mangled in this._store;\n  delete this._store[mangled];\n  return res;\n};\nMap$1.prototype.forEach = function (cb) {\n  var keys = Object.keys(this._store);\n  for (var i = 0, len = keys.length; i < len; i++) {\n    var key = keys[i];\n    var value = this._store[key];\n    key = unmangle(key);\n    cb(value, key);\n  }\n};\nObject.defineProperty(Map$1.prototype, 'size', {\n  get: function () {\n    return Object.keys(this._store).length;\n  }\n});\n\nfunction Set$1(array) {\n  this._store = new Map$1();\n\n  // init with an array\n  if (array && Array.isArray(array)) {\n    for (var i = 0, len = array.length; i < len; i++) {\n      this.add(array[i]);\n    }\n  }\n}\nSet$1.prototype.add = function (key) {\n  return this._store.set(key, true);\n};\nSet$1.prototype.has = function (key) {\n  return this._store.has(key);\n};\nSet$1.prototype.forEach = function (cb) {\n  this._store.forEach(function (value, key) {\n    cb(key);\n  });\n};\nObject.defineProperty(Set$1.prototype, 'size', {\n  get: function () {\n    return this._store.size;\n  }\n});\n\n/* global Map,Set,Symbol */\n// Based on https://kangax.github.io/compat-table/es6/ we can sniff out\n// incomplete Map/Set implementations which would otherwise cause our tests to fail.\n// Notably they fail in IE11 and iOS 8.4, which this prevents.\nfunction supportsMapAndSet() {\n  if (typeof Symbol === 'undefined' || typeof Map === 'undefined' || typeof Set === 'undefined') {\n    return false;\n  }\n  var prop = Object.getOwnPropertyDescriptor(Map, Symbol.species);\n  return prop && 'get' in prop && Map[Symbol.species] === Map;\n}\n\n// based on https://github.com/montagejs/collections\n/* global Map,Set */\n\nvar ExportedSet;\nvar ExportedMap;\n\n{\n  if (supportsMapAndSet()) { // prefer built-in Map/Set\n    ExportedSet = Set;\n    ExportedMap = Map;\n  } else { // fall back to our polyfill\n    ExportedSet = Set$1;\n    ExportedMap = Map$1;\n  }\n}\n\n// like underscore/lodash _.pick()\nfunction pick(obj, arr) {\n  var res = {};\n  for (var i = 0, len = arr.length; i < len; i++) {\n    var prop = arr[i];\n    if (prop in obj) {\n      res[prop] = obj[prop];\n    }\n  }\n  return res;\n}\n\n// Most browsers throttle concurrent requests at 6, so it's silly\n// to shim _bulk_get by trying to launch potentially hundreds of requests\n// and then letting the majority time out. We can handle this ourselves.\nvar MAX_NUM_CONCURRENT_REQUESTS = 6;\n\nfunction identityFunction(x) {\n  return x;\n}\n\nfunction formatResultForOpenRevsGet(result) {\n  return [{\n    ok: result\n  }];\n}\n\n// shim for P/CouchDB adapters that don't directly implement _bulk_get\nfunction bulkGet(db, opts, callback) {\n  var requests = opts.docs;\n\n  // consolidate into one request per doc if possible\n  var requestsById = new ExportedMap();\n  requests.forEach(function (request) {\n    if (requestsById.has(request.id)) {\n      requestsById.get(request.id).push(request);\n    } else {\n      requestsById.set(request.id, [request]);\n    }\n  });\n\n  var numDocs = requestsById.size;\n  var numDone = 0;\n  var perDocResults = new Array(numDocs);\n\n  function collapseResultsAndFinish() {\n    var results = [];\n    perDocResults.forEach(function (res) {\n      res.docs.forEach(function (info) {\n        results.push({\n          id: res.id,\n          docs: [info]\n        });\n      });\n    });\n    callback(null, {results: results});\n  }\n\n  function checkDone() {\n    if (++numDone === numDocs) {\n      collapseResultsAndFinish();\n    }\n  }\n\n  function gotResult(docIndex, id, docs) {\n    perDocResults[docIndex] = {id: id, docs: docs};\n    checkDone();\n  }\n\n  var allRequests = [];\n  requestsById.forEach(function (value, key) {\n    allRequests.push(key);\n  });\n\n  var i = 0;\n\n  function nextBatch() {\n\n    if (i >= allRequests.length) {\n      return;\n    }\n\n    var upTo = Math.min(i + MAX_NUM_CONCURRENT_REQUESTS, allRequests.length);\n    var batch = allRequests.slice(i, upTo);\n    processBatch(batch, i);\n    i += batch.length;\n  }\n\n  function processBatch(batch, offset) {\n    batch.forEach(function (docId, j) {\n      var docIdx = offset + j;\n      var docRequests = requestsById.get(docId);\n\n      // just use the first request as the \"template\"\n      // TODO: The _bulk_get API allows for more subtle use cases than this,\n      // but for now it is unlikely that there will be a mix of different\n      // \"atts_since\" or \"attachments\" in the same request, since it's just\n      // replicate.js that is using this for the moment.\n      // Also, atts_since is aspirational, since we don't support it yet.\n      var docOpts = pick(docRequests[0], ['atts_since', 'attachments']);\n      docOpts.open_revs = docRequests.map(function (request) {\n        // rev is optional, open_revs disallowed\n        return request.rev;\n      });\n\n      // remove falsey / undefined revisions\n      docOpts.open_revs = docOpts.open_revs.filter(identityFunction);\n\n      var formatResult = identityFunction;\n\n      if (docOpts.open_revs.length === 0) {\n        delete docOpts.open_revs;\n\n        // when fetching only the \"winning\" leaf,\n        // transform the result so it looks like an open_revs\n        // request\n        formatResult = formatResultForOpenRevsGet;\n      }\n\n      // globally-supplied options\n      ['revs', 'attachments', 'binary', 'ajax', 'latest'].forEach(function (param) {\n        if (param in opts) {\n          docOpts[param] = opts[param];\n        }\n      });\n      db.get(docId, docOpts, function (err, res) {\n        var result;\n        /* istanbul ignore if */\n        if (err) {\n          result = [{error: err}];\n        } else {\n          result = formatResult(res);\n        }\n        gotResult(docIdx, docId, result);\n        nextBatch();\n      });\n    });\n  }\n\n  nextBatch();\n\n}\n\nfunction isChromeApp() {\n  return (typeof chrome !== \"undefined\" &&\n    typeof chrome.storage !== \"undefined\" &&\n    typeof chrome.storage.local !== \"undefined\");\n}\n\nvar hasLocal;\n\nif (isChromeApp()) {\n  hasLocal = false;\n} else {\n  try {\n    localStorage.setItem('_pouch_check_localstorage', 1);\n    hasLocal = !!localStorage.getItem('_pouch_check_localstorage');\n  } catch (e) {\n    hasLocal = false;\n  }\n}\n\nfunction hasLocalStorage() {\n  return hasLocal;\n}\n\n// Custom nextTick() shim for browsers. In node, this will just be process.nextTick(). We\n// avoid using process.nextTick() directly because the polyfill is very large and we don't\n// need all of it (see: https://github.com/defunctzombie/node-process).\n// \"immediate\" 3.0.8 is used by lie, and it's a smaller version of the latest \"immediate\"\n// package, so it's the one we use.\n// When we use nextTick() in our codebase, we only care about not releasing Zalgo\n// (see: http://blog.izs.me/post/59142742143/designing-apis-for-asynchrony).\n// Microtask vs macrotask doesn't matter to us. So we're free to use the fastest\n// (least latency) option, which is \"immediate\" due to use of microtasks.\n// All of our nextTicks are isolated to this one function so we can easily swap out one\n// implementation for another.\n\ninherits(Changes, events.EventEmitter);\n\n/* istanbul ignore next */\nfunction attachBrowserEvents(self) {\n  if (isChromeApp()) {\n    chrome.storage.onChanged.addListener(function (e) {\n      // make sure it's event addressed to us\n      if (e.db_name != null) {\n        //object only has oldValue, newValue members\n        self.emit(e.dbName.newValue);\n      }\n    });\n  } else if (hasLocalStorage()) {\n    if (typeof addEventListener !== 'undefined') {\n      addEventListener(\"storage\", function (e) {\n        self.emit(e.key);\n      });\n    } else { // old IE\n      window.attachEvent(\"storage\", function (e) {\n        self.emit(e.key);\n      });\n    }\n  }\n}\n\nfunction Changes() {\n  events.EventEmitter.call(this);\n  this._listeners = {};\n\n  attachBrowserEvents(this);\n}\nChanges.prototype.addListener = function (dbName, id, db, opts) {\n  /* istanbul ignore if */\n  if (this._listeners[id]) {\n    return;\n  }\n  var self = this;\n  var inprogress = false;\n  function eventFunction() {\n    /* istanbul ignore if */\n    if (!self._listeners[id]) {\n      return;\n    }\n    if (inprogress) {\n      inprogress = 'waiting';\n      return;\n    }\n    inprogress = true;\n    var changesOpts = pick(opts, [\n      'style', 'include_docs', 'attachments', 'conflicts', 'filter',\n      'doc_ids', 'view', 'since', 'query_params', 'binary'\n    ]);\n\n    /* istanbul ignore next */\n    function onError() {\n      inprogress = false;\n    }\n\n    db.changes(changesOpts).on('change', function (c) {\n      if (c.seq > opts.since && !opts.cancelled) {\n        opts.since = c.seq;\n        opts.onChange(c);\n      }\n    }).on('complete', function () {\n      if (inprogress === 'waiting') {\n        nextTick(eventFunction);\n      }\n      inprogress = false;\n    }).on('error', onError);\n  }\n  this._listeners[id] = eventFunction;\n  this.on(dbName, eventFunction);\n};\n\nChanges.prototype.removeListener = function (dbName, id) {\n  /* istanbul ignore if */\n  if (!(id in this._listeners)) {\n    return;\n  }\n  events.EventEmitter.prototype.removeListener.call(this, dbName,\n    this._listeners[id]);\n  delete this._listeners[id];\n};\n\n\n/* istanbul ignore next */\nChanges.prototype.notifyLocalWindows = function (dbName) {\n  //do a useless change on a storage thing\n  //in order to get other windows's listeners to activate\n  if (isChromeApp()) {\n    chrome.storage.local.set({dbName: dbName});\n  } else if (hasLocalStorage()) {\n    localStorage[dbName] = (localStorage[dbName] === \"a\") ? \"b\" : \"a\";\n  }\n};\n\nChanges.prototype.notify = function (dbName) {\n  this.emit(dbName);\n  this.notifyLocalWindows(dbName);\n};\n\nfunction guardedConsole(method) {\n  /* istanbul ignore else */\n  if (typeof console !== 'undefined' && typeof console[method] === 'function') {\n    var args = Array.prototype.slice.call(arguments, 1);\n    console[method].apply(console, args);\n  }\n}\n\nfunction randomNumber(min, max) {\n  var maxTimeout = 600000; // Hard-coded default of 10 minutes\n  min = parseInt(min, 10) || 0;\n  max = parseInt(max, 10);\n  if (max !== max || max <= min) {\n    max = (min || 1) << 1; //doubling\n  } else {\n    max = max + 1;\n  }\n  // In order to not exceed maxTimeout, pick a random value between half of maxTimeout and maxTimeout\n  if (max > maxTimeout) {\n    min = maxTimeout >> 1; // divide by two\n    max = maxTimeout;\n  }\n  var ratio = Math.random();\n  var range = max - min;\n\n  return ~~(range * ratio + min); // ~~ coerces to an int, but fast.\n}\n\nfunction defaultBackOff(min) {\n  var max = 0;\n  if (!min) {\n    max = 2000;\n  }\n  return randomNumber(min, max);\n}\n\n// designed to give info to browser users, who are disturbed\n// when they see http errors in the console\nfunction explainError(status, str) {\n  guardedConsole('info', 'The above ' + status + ' is totally normal. ' + str);\n}\n\nvar assign;\n{\n  if (typeof Object.assign === 'function') {\n    assign = Object.assign;\n  } else {\n    // lite Object.assign polyfill based on\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\n    assign = function (target) {\n      var to = Object(target);\n\n      for (var index = 1; index < arguments.length; index++) {\n        var nextSource = arguments[index];\n\n        if (nextSource != null) { // Skip over if undefined or null\n          for (var nextKey in nextSource) {\n            // Avoid bugs when hasOwnProperty is shadowed\n            if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {\n              to[nextKey] = nextSource[nextKey];\n            }\n          }\n        }\n      }\n      return to;\n    };\n  }\n}\n\nvar $inject_Object_assign = assign;\n\ninherits(PouchError, Error);\n\nfunction PouchError(status, error, reason) {\n  Error.call(this, reason);\n  this.status = status;\n  this.name = error;\n  this.message = reason;\n  this.error = true;\n}\n\nPouchError.prototype.toString = function () {\n  return JSON.stringify({\n    status: this.status,\n    name: this.name,\n    message: this.message,\n    reason: this.reason\n  });\n};\n\nvar UNAUTHORIZED = new PouchError(401, 'unauthorized', \"Name or password is incorrect.\");\nvar MISSING_BULK_DOCS = new PouchError(400, 'bad_request', \"Missing JSON list of 'docs'\");\nvar MISSING_DOC = new PouchError(404, 'not_found', 'missing');\nvar REV_CONFLICT = new PouchError(409, 'conflict', 'Document update conflict');\nvar INVALID_ID = new PouchError(400, 'bad_request', '_id field must contain a string');\nvar MISSING_ID = new PouchError(412, 'missing_id', '_id is required for puts');\nvar RESERVED_ID = new PouchError(400, 'bad_request', 'Only reserved document ids may start with underscore.');\nvar NOT_OPEN = new PouchError(412, 'precondition_failed', 'Database not open');\nvar UNKNOWN_ERROR = new PouchError(500, 'unknown_error', 'Database encountered an unknown error');\nvar BAD_ARG = new PouchError(500, 'badarg', 'Some query argument is invalid');\nvar INVALID_REQUEST = new PouchError(400, 'invalid_request', 'Request was invalid');\nvar QUERY_PARSE_ERROR = new PouchError(400, 'query_parse_error', 'Some query parameter is invalid');\nvar DOC_VALIDATION = new PouchError(500, 'doc_validation', 'Bad special document member');\nvar BAD_REQUEST = new PouchError(400, 'bad_request', 'Something wrong with the request');\nvar NOT_AN_OBJECT = new PouchError(400, 'bad_request', 'Document must be a JSON object');\nvar DB_MISSING = new PouchError(404, 'not_found', 'Database not found');\nvar IDB_ERROR = new PouchError(500, 'indexed_db_went_bad', 'unknown');\nvar WSQ_ERROR = new PouchError(500, 'web_sql_went_bad', 'unknown');\nvar LDB_ERROR = new PouchError(500, 'levelDB_went_went_bad', 'unknown');\nvar FORBIDDEN = new PouchError(403, 'forbidden', 'Forbidden by design doc validate_doc_update function');\nvar INVALID_REV = new PouchError(400, 'bad_request', 'Invalid rev format');\nvar FILE_EXISTS = new PouchError(412, 'file_exists', 'The database could not be created, the file already exists.');\nvar MISSING_STUB = new PouchError(412, 'missing_stub', 'A pre-existing attachment stub wasn\\'t found');\nvar INVALID_URL = new PouchError(413, 'invalid_url', 'Provided URL is invalid');\n\nfunction createError(error, reason) {\n  function CustomPouchError(reason) {\n    // inherit error properties from our parent error manually\n    // so as to allow proper JSON parsing.\n    /* jshint ignore:start */\n    for (var p in error) {\n      if (typeof error[p] !== 'function') {\n        this[p] = error[p];\n      }\n    }\n    /* jshint ignore:end */\n    if (reason !== undefined) {\n      this.reason = reason;\n    }\n  }\n  CustomPouchError.prototype = PouchError.prototype;\n  return new CustomPouchError(reason);\n}\n\nfunction generateErrorFromResponse(err) {\n\n  if (typeof err !== 'object') {\n    var data = err;\n    err = UNKNOWN_ERROR;\n    err.data = data;\n  }\n\n  if ('error' in err && err.error === 'conflict') {\n    err.name = 'conflict';\n    err.status = 409;\n  }\n\n  if (!('name' in err)) {\n    err.name = err.error || 'unknown';\n  }\n\n  if (!('status' in err)) {\n    err.status = 500;\n  }\n\n  if (!('message' in err)) {\n    err.message = err.message || err.reason;\n  }\n\n  return err;\n}\n\nfunction tryFilter(filter, doc, req) {\n  try {\n    return !filter(doc, req);\n  } catch (err) {\n    var msg = 'Filter function threw: ' + err.toString();\n    return createError(BAD_REQUEST, msg);\n  }\n}\n\nfunction filterChange(opts) {\n  var req = {};\n  var hasFilter = opts.filter && typeof opts.filter === 'function';\n  req.query = opts.query_params;\n\n  return function filter(change) {\n    if (!change.doc) {\n      // CSG sends events on the changes feed that don't have documents,\n      // this hack makes a whole lot of existing code robust.\n      change.doc = {};\n    }\n\n    var filterReturn = hasFilter && tryFilter(opts.filter, change.doc, req);\n\n    if (typeof filterReturn === 'object') {\n      return filterReturn;\n    }\n\n    if (filterReturn) {\n      return false;\n    }\n\n    if (!opts.include_docs) {\n      delete change.doc;\n    } else if (!opts.attachments) {\n      for (var att in change.doc._attachments) {\n        /* istanbul ignore else */\n        if (change.doc._attachments.hasOwnProperty(att)) {\n          change.doc._attachments[att].stub = true;\n        }\n      }\n    }\n    return true;\n  };\n}\n\nfunction flatten(arrs) {\n  var res = [];\n  for (var i = 0, len = arrs.length; i < len; i++) {\n    res = res.concat(arrs[i]);\n  }\n  return res;\n}\n\n// shim for Function.prototype.name,\n// for browsers that don't support it like IE\n\n/* istanbul ignore next */\n\n// Determine id an ID is valid\n//   - invalid IDs begin with an underescore that does not begin '_design' or\n//     '_local'\n//   - any other string value is a valid id\n// Returns the specific error object for each case\nfunction invalidIdError(id) {\n  var err;\n  if (!id) {\n    err = createError(MISSING_ID);\n  } else if (typeof id !== 'string') {\n    err = createError(INVALID_ID);\n  } else if (/^_/.test(id) && !(/^_(design|local)/).test(id)) {\n    err = createError(RESERVED_ID);\n  }\n  if (err) {\n    throw err;\n  }\n}\n\n// Checks if a PouchDB object is \"remote\" or not. This is\n// designed to opt-in to certain optimizations, such as\n// avoiding checks for \"dependentDbs\" and other things that\n// we know only apply to local databases. In general, \"remote\"\n// should be true for the http adapter, and for third-party\n// adapters with similar expensive boundaries to cross for\n// every API call, such as socket-pouch and worker-pouch.\n// Previously, this was handled via db.type() === 'http'\n// which is now deprecated.\n\nfunction isRemote(db) {\n  if (typeof db._remote === 'boolean') {\n    return db._remote;\n  }\n  /* istanbul ignore next */\n  if (typeof db.type === 'function') {\n    guardedConsole('warn',\n      'db.type() is deprecated and will be removed in ' +\n      'a future version of PouchDB');\n    return db.type() === 'http';\n  }\n  /* istanbul ignore next */\n  return false;\n}\n\nfunction listenerCount(ee, type) {\n  return 'listenerCount' in ee ? ee.listenerCount(type) :\n                                 events.EventEmitter.listenerCount(ee, type);\n}\n\nfunction parseDesignDocFunctionName(s) {\n  if (!s) {\n    return null;\n  }\n  var parts = s.split('/');\n  if (parts.length === 2) {\n    return parts;\n  }\n  if (parts.length === 1) {\n    return [s, s];\n  }\n  return null;\n}\n\nfunction normalizeDesignDocFunctionName(s) {\n  var normalized = parseDesignDocFunctionName(s);\n  return normalized ? normalized.join('/') : null;\n}\n\n// originally parseUri 1.2.2, now patched by us\n// (c) Steven Levithan <stevenlevithan.com>\n// MIT License\nvar keys = [\"source\", \"protocol\", \"authority\", \"userInfo\", \"user\", \"password\",\n    \"host\", \"port\", \"relative\", \"path\", \"directory\", \"file\", \"query\", \"anchor\"];\nvar qName =\"queryKey\";\nvar qParser = /(?:^|&)([^&=]*)=?([^&]*)/g;\n\n// use the \"loose\" parser\n/* eslint maxlen: 0, no-useless-escape: 0 */\nvar parser = /^(?:(?![^:@]+:[^:@\\/]*@)([^:\\/?#.]+):)?(?:\\/\\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/;\n\nfunction parseUri(str) {\n  var m = parser.exec(str);\n  var uri = {};\n  var i = 14;\n\n  while (i--) {\n    var key = keys[i];\n    var value = m[i] || \"\";\n    var encoded = ['user', 'password'].indexOf(key) !== -1;\n    uri[key] = encoded ? decodeURIComponent(value) : value;\n  }\n\n  uri[qName] = {};\n  uri[keys[12]].replace(qParser, function ($0, $1, $2) {\n    if ($1) {\n      uri[qName][$1] = $2;\n    }\n  });\n\n  return uri;\n}\n\n// Based on https://github.com/alexdavid/scope-eval v0.0.3\n// (source: https://unpkg.com/scope-eval@0.0.3/scope_eval.js)\n// This is basically just a wrapper around new Function()\n\nfunction scopeEval(source, scope) {\n  var keys = [];\n  var values = [];\n  for (var key in scope) {\n    if (scope.hasOwnProperty(key)) {\n      keys.push(key);\n      values.push(scope[key]);\n    }\n  }\n  keys.push(source);\n  return Function.apply(null, keys).apply(null, values);\n}\n\n// this is essentially the \"update sugar\" function from daleharvey/pouchdb#1388\n// the diffFun tells us what delta to apply to the doc.  it either returns\n// the doc, or false if it doesn't need to do an update after all\nfunction upsert(db, docId, diffFun) {\n  return new PouchPromise(function (fulfill, reject) {\n    db.get(docId, function (err, doc) {\n      if (err) {\n        /* istanbul ignore next */\n        if (err.status !== 404) {\n          return reject(err);\n        }\n        doc = {};\n      }\n\n      // the user might change the _rev, so save it for posterity\n      var docRev = doc._rev;\n      var newDoc = diffFun(doc);\n\n      if (!newDoc) {\n        // if the diffFun returns falsy, we short-circuit as\n        // an optimization\n        return fulfill({updated: false, rev: docRev});\n      }\n\n      // users aren't allowed to modify these values,\n      // so reset them here\n      newDoc._id = docId;\n      newDoc._rev = docRev;\n      fulfill(tryAndPut(db, newDoc, diffFun));\n    });\n  });\n}\n\nfunction tryAndPut(db, doc, diffFun) {\n  return db.put(doc).then(function (res) {\n    return {\n      updated: true,\n      rev: res.rev\n    };\n  }, function (err) {\n    /* istanbul ignore next */\n    if (err.status !== 409) {\n      throw err;\n    }\n    return upsert(db, doc._id, diffFun);\n  });\n}\n\nfunction rev() {\n  return uuidV4.v4().replace(/-/g, '').toLowerCase();\n}\n\nvar uuid = uuidV4.v4;\n\n// We fetch all leafs of the revision tree, and sort them based on tree length\n// and whether they were deleted, undeleted documents with the longest revision\n// tree (most edits) win\n// The final sort algorithm is slightly documented in a sidebar here:\n// http://guide.couchdb.org/draft/conflicts.html\nfunction winningRev(metadata) {\n  var winningId;\n  var winningPos;\n  var winningDeleted;\n  var toVisit = metadata.rev_tree.slice();\n  var node;\n  while ((node = toVisit.pop())) {\n    var tree = node.ids;\n    var branches = tree[2];\n    var pos = node.pos;\n    if (branches.length) { // non-leaf\n      for (var i = 0, len = branches.length; i < len; i++) {\n        toVisit.push({pos: pos + 1, ids: branches[i]});\n      }\n      continue;\n    }\n    var deleted = !!tree[1].deleted;\n    var id = tree[0];\n    // sort by deleted, then pos, then id\n    if (!winningId || (winningDeleted !== deleted ? winningDeleted :\n        winningPos !== pos ? winningPos < pos : winningId < id)) {\n      winningId = id;\n      winningPos = pos;\n      winningDeleted = deleted;\n    }\n  }\n\n  return winningPos + '-' + winningId;\n}\n\n// Pretty much all below can be combined into a higher order function to\n// traverse revisions\n// The return value from the callback will be passed as context to all\n// children of that node\nfunction traverseRevTree(revs, callback) {\n  var toVisit = revs.slice();\n\n  var node;\n  while ((node = toVisit.pop())) {\n    var pos = node.pos;\n    var tree = node.ids;\n    var branches = tree[2];\n    var newCtx =\n      callback(branches.length === 0, pos, tree[0], node.ctx, tree[1]);\n    for (var i = 0, len = branches.length; i < len; i++) {\n      toVisit.push({pos: pos + 1, ids: branches[i], ctx: newCtx});\n    }\n  }\n}\n\nfunction sortByPos(a, b) {\n  return a.pos - b.pos;\n}\n\nfunction collectLeaves(revs) {\n  var leaves = [];\n  traverseRevTree(revs, function (isLeaf, pos, id, acc, opts) {\n    if (isLeaf) {\n      leaves.push({rev: pos + \"-\" + id, pos: pos, opts: opts});\n    }\n  });\n  leaves.sort(sortByPos).reverse();\n  for (var i = 0, len = leaves.length; i < len; i++) {\n    delete leaves[i].pos;\n  }\n  return leaves;\n}\n\n// returns revs of all conflicts that is leaves such that\n// 1. are not deleted and\n// 2. are different than winning revision\nfunction collectConflicts(metadata) {\n  var win = winningRev(metadata);\n  var leaves = collectLeaves(metadata.rev_tree);\n  var conflicts = [];\n  for (var i = 0, len = leaves.length; i < len; i++) {\n    var leaf = leaves[i];\n    if (leaf.rev !== win && !leaf.opts.deleted) {\n      conflicts.push(leaf.rev);\n    }\n  }\n  return conflicts;\n}\n\n// compact a tree by marking its non-leafs as missing,\n// and return a list of revs to delete\nfunction compactTree(metadata) {\n  var revs = [];\n  traverseRevTree(metadata.rev_tree, function (isLeaf, pos,\n                                               revHash, ctx, opts) {\n    if (opts.status === 'available' && !isLeaf) {\n      revs.push(pos + '-' + revHash);\n      opts.status = 'missing';\n    }\n  });\n  return revs;\n}\n\n// build up a list of all the paths to the leafs in this revision tree\nfunction rootToLeaf(revs) {\n  var paths = [];\n  var toVisit = revs.slice();\n  var node;\n  while ((node = toVisit.pop())) {\n    var pos = node.pos;\n    var tree = node.ids;\n    var id = tree[0];\n    var opts = tree[1];\n    var branches = tree[2];\n    var isLeaf = branches.length === 0;\n\n    var history = node.history ? node.history.slice() : [];\n    history.push({id: id, opts: opts});\n    if (isLeaf) {\n      paths.push({pos: (pos + 1 - history.length), ids: history});\n    }\n    for (var i = 0, len = branches.length; i < len; i++) {\n      toVisit.push({pos: pos + 1, ids: branches[i], history: history});\n    }\n  }\n  return paths.reverse();\n}\n\n// for a better overview of what this is doing, read:\n// https://github.com/apache/couchdb-couch/blob/master/src/couch_key_tree.erl\n//\n// But for a quick intro, CouchDB uses a revision tree to store a documents\n// history, A -> B -> C, when a document has conflicts, that is a branch in the\n// tree, A -> (B1 | B2 -> C), We store these as a nested array in the format\n//\n// KeyTree = [Path ... ]\n// Path = {pos: position_from_root, ids: Tree}\n// Tree = [Key, Opts, [Tree, ...]], in particular single node: [Key, []]\n\nfunction sortByPos$1(a, b) {\n  return a.pos - b.pos;\n}\n\n// classic binary search\nfunction binarySearch(arr, item, comparator) {\n  var low = 0;\n  var high = arr.length;\n  var mid;\n  while (low < high) {\n    mid = (low + high) >>> 1;\n    if (comparator(arr[mid], item) < 0) {\n      low = mid + 1;\n    } else {\n      high = mid;\n    }\n  }\n  return low;\n}\n\n// assuming the arr is sorted, insert the item in the proper place\nfunction insertSorted(arr, item, comparator) {\n  var idx = binarySearch(arr, item, comparator);\n  arr.splice(idx, 0, item);\n}\n\n// Turn a path as a flat array into a tree with a single branch.\n// If any should be stemmed from the beginning of the array, that's passed\n// in as the second argument\nfunction pathToTree(path, numStemmed) {\n  var root;\n  var leaf;\n  for (var i = numStemmed, len = path.length; i < len; i++) {\n    var node = path[i];\n    var currentLeaf = [node.id, node.opts, []];\n    if (leaf) {\n      leaf[2].push(currentLeaf);\n      leaf = currentLeaf;\n    } else {\n      root = leaf = currentLeaf;\n    }\n  }\n  return root;\n}\n\n// compare the IDs of two trees\nfunction compareTree(a, b) {\n  return a[0] < b[0] ? -1 : 1;\n}\n\n// Merge two trees together\n// The roots of tree1 and tree2 must be the same revision\nfunction mergeTree(in_tree1, in_tree2) {\n  var queue = [{tree1: in_tree1, tree2: in_tree2}];\n  var conflicts = false;\n  while (queue.length > 0) {\n    var item = queue.pop();\n    var tree1 = item.tree1;\n    var tree2 = item.tree2;\n\n    if (tree1[1].status || tree2[1].status) {\n      tree1[1].status =\n        (tree1[1].status ===  'available' ||\n        tree2[1].status === 'available') ? 'available' : 'missing';\n    }\n\n    for (var i = 0; i < tree2[2].length; i++) {\n      if (!tree1[2][0]) {\n        conflicts = 'new_leaf';\n        tree1[2][0] = tree2[2][i];\n        continue;\n      }\n\n      var merged = false;\n      for (var j = 0; j < tree1[2].length; j++) {\n        if (tree1[2][j][0] === tree2[2][i][0]) {\n          queue.push({tree1: tree1[2][j], tree2: tree2[2][i]});\n          merged = true;\n        }\n      }\n      if (!merged) {\n        conflicts = 'new_branch';\n        insertSorted(tree1[2], tree2[2][i], compareTree);\n      }\n    }\n  }\n  return {conflicts: conflicts, tree: in_tree1};\n}\n\nfunction doMerge(tree, path, dontExpand) {\n  var restree = [];\n  var conflicts = false;\n  var merged = false;\n  var res;\n\n  if (!tree.length) {\n    return {tree: [path], conflicts: 'new_leaf'};\n  }\n\n  for (var i = 0, len = tree.length; i < len; i++) {\n    var branch = tree[i];\n    if (branch.pos === path.pos && branch.ids[0] === path.ids[0]) {\n      // Paths start at the same position and have the same root, so they need\n      // merged\n      res = mergeTree(branch.ids, path.ids);\n      restree.push({pos: branch.pos, ids: res.tree});\n      conflicts = conflicts || res.conflicts;\n      merged = true;\n    } else if (dontExpand !== true) {\n      // The paths start at a different position, take the earliest path and\n      // traverse up until it as at the same point from root as the path we\n      // want to merge.  If the keys match we return the longer path with the\n      // other merged After stemming we dont want to expand the trees\n\n      var t1 = branch.pos < path.pos ? branch : path;\n      var t2 = branch.pos < path.pos ? path : branch;\n      var diff = t2.pos - t1.pos;\n\n      var candidateParents = [];\n\n      var trees = [];\n      trees.push({ids: t1.ids, diff: diff, parent: null, parentIdx: null});\n      while (trees.length > 0) {\n        var item = trees.pop();\n        if (item.diff === 0) {\n          if (item.ids[0] === t2.ids[0]) {\n            candidateParents.push(item);\n          }\n          continue;\n        }\n        var elements = item.ids[2];\n        for (var j = 0, elementsLen = elements.length; j < elementsLen; j++) {\n          trees.push({\n            ids: elements[j],\n            diff: item.diff - 1,\n            parent: item.ids,\n            parentIdx: j\n          });\n        }\n      }\n\n      var el = candidateParents[0];\n\n      if (!el) {\n        restree.push(branch);\n      } else {\n        res = mergeTree(el.ids, t2.ids);\n        el.parent[2][el.parentIdx] = res.tree;\n        restree.push({pos: t1.pos, ids: t1.ids});\n        conflicts = conflicts || res.conflicts;\n        merged = true;\n      }\n    } else {\n      restree.push(branch);\n    }\n  }\n\n  // We didnt find\n  if (!merged) {\n    restree.push(path);\n  }\n\n  restree.sort(sortByPos$1);\n\n  return {\n    tree: restree,\n    conflicts: conflicts || 'internal_node'\n  };\n}\n\n// To ensure we dont grow the revision tree infinitely, we stem old revisions\nfunction stem(tree, depth) {\n  // First we break out the tree into a complete list of root to leaf paths\n  var paths = rootToLeaf(tree);\n  var stemmedRevs;\n\n  var result;\n  for (var i = 0, len = paths.length; i < len; i++) {\n    // Then for each path, we cut off the start of the path based on the\n    // `depth` to stem to, and generate a new set of flat trees\n    var path = paths[i];\n    var stemmed = path.ids;\n    var node;\n    if (stemmed.length > depth) {\n      // only do the stemming work if we actually need to stem\n      if (!stemmedRevs) {\n        stemmedRevs = {}; // avoid allocating this object unnecessarily\n      }\n      var numStemmed = stemmed.length - depth;\n      node = {\n        pos: path.pos + numStemmed,\n        ids: pathToTree(stemmed, numStemmed)\n      };\n\n      for (var s = 0; s < numStemmed; s++) {\n        var rev = (path.pos + s) + '-' + stemmed[s].id;\n        stemmedRevs[rev] = true;\n      }\n    } else { // no need to actually stem\n      node = {\n        pos: path.pos,\n        ids: pathToTree(stemmed, 0)\n      };\n    }\n\n    // Then we remerge all those flat trees together, ensuring that we dont\n    // connect trees that would go beyond the depth limit\n    if (result) {\n      result = doMerge(result, node, true).tree;\n    } else {\n      result = [node];\n    }\n  }\n\n  // this is memory-heavy per Chrome profiler, avoid unless we actually stemmed\n  if (stemmedRevs) {\n    traverseRevTree(result, function (isLeaf, pos, revHash) {\n      // some revisions may have been removed in a branch but not in another\n      delete stemmedRevs[pos + '-' + revHash];\n    });\n  }\n\n  return {\n    tree: result,\n    revs: stemmedRevs ? Object.keys(stemmedRevs) : []\n  };\n}\n\nfunction merge(tree, path, depth) {\n  var newTree = doMerge(tree, path);\n  var stemmed = stem(newTree.tree, depth);\n  return {\n    tree: stemmed.tree,\n    stemmedRevs: stemmed.revs,\n    conflicts: newTree.conflicts\n  };\n}\n\n// return true if a rev exists in the rev tree, false otherwise\nfunction revExists(revs, rev) {\n  var toVisit = revs.slice();\n  var splitRev = rev.split('-');\n  var targetPos = parseInt(splitRev[0], 10);\n  var targetId = splitRev[1];\n\n  var node;\n  while ((node = toVisit.pop())) {\n    if (node.pos === targetPos && node.ids[0] === targetId) {\n      return true;\n    }\n    var branches = node.ids[2];\n    for (var i = 0, len = branches.length; i < len; i++) {\n      toVisit.push({pos: node.pos + 1, ids: branches[i]});\n    }\n  }\n  return false;\n}\n\nfunction getTrees(node) {\n  return node.ids;\n}\n\n// check if a specific revision of a doc has been deleted\n//  - metadata: the metadata object from the doc store\n//  - rev: (optional) the revision to check. defaults to winning revision\nfunction isDeleted(metadata, rev) {\n  if (!rev) {\n    rev = winningRev(metadata);\n  }\n  var id = rev.substring(rev.indexOf('-') + 1);\n  var toVisit = metadata.rev_tree.map(getTrees);\n\n  var tree;\n  while ((tree = toVisit.pop())) {\n    if (tree[0] === id) {\n      return !!tree[1].deleted;\n    }\n    toVisit = toVisit.concat(tree[2]);\n  }\n}\n\nfunction isLocalId(id) {\n  return (/^_local/).test(id);\n}\n\n// returns the current leaf node for a given revision\nfunction latest(rev, metadata) {\n  var toVisit = metadata.rev_tree.slice();\n  var node;\n  while ((node = toVisit.pop())) {\n    var pos = node.pos;\n    var tree = node.ids;\n    var id = tree[0];\n    var opts = tree[1];\n    var branches = tree[2];\n    var isLeaf = branches.length === 0;\n\n    var history = node.history ? node.history.slice() : [];\n    history.push({id: id, pos: pos, opts: opts});\n\n    if (isLeaf) {\n      for (var i = 0, len = history.length; i < len; i++) {\n        var historyNode = history[i];\n        var historyRev = historyNode.pos + '-' + historyNode.id;\n\n        if (historyRev === rev) {\n          // return the rev of this leaf\n          return pos + '-' + id;\n        }\n      }\n    }\n\n    for (var j = 0, l = branches.length; j < l; j++) {\n      toVisit.push({pos: pos + 1, ids: branches[j], history: history});\n    }\n  }\n\n  /* istanbul ignore next */\n  throw new Error('Unable to resolve latest revision for id ' + metadata.id + ', rev ' + rev);\n}\n\ninherits(Changes$2, events.EventEmitter);\n\nfunction tryCatchInChangeListener(self, change, pending, lastSeq) {\n  // isolate try/catches to avoid V8 deoptimizations\n  try {\n    self.emit('change', change, pending, lastSeq);\n  } catch (e) {\n    guardedConsole('error', 'Error in .on(\"change\", function):', e);\n  }\n}\n\nfunction Changes$2(db, opts, callback) {\n  events.EventEmitter.call(this);\n  var self = this;\n  this.db = db;\n  opts = opts ? clone(opts) : {};\n  var complete = opts.complete = once(function (err, resp) {\n    if (err) {\n      if (listenerCount(self, 'error') > 0) {\n        self.emit('error', err);\n      }\n    } else {\n      self.emit('complete', resp);\n    }\n    self.removeAllListeners();\n    db.removeListener('destroyed', onDestroy);\n  });\n  if (callback) {\n    self.on('complete', function (resp) {\n      callback(null, resp);\n    });\n    self.on('error', callback);\n  }\n  function onDestroy() {\n    self.cancel();\n  }\n  db.once('destroyed', onDestroy);\n\n  opts.onChange = function (change, pending, lastSeq) {\n    /* istanbul ignore if */\n    if (self.isCancelled) {\n      return;\n    }\n    tryCatchInChangeListener(self, change, pending, lastSeq);\n  };\n\n  var promise = new PouchPromise(function (fulfill, reject) {\n    opts.complete = function (err, res) {\n      if (err) {\n        reject(err);\n      } else {\n        fulfill(res);\n      }\n    };\n  });\n  self.once('cancel', function () {\n    db.removeListener('destroyed', onDestroy);\n    opts.complete(null, {status: 'cancelled'});\n  });\n  this.then = promise.then.bind(promise);\n  this['catch'] = promise['catch'].bind(promise);\n  this.then(function (result) {\n    complete(null, result);\n  }, complete);\n\n\n\n  if (!db.taskqueue.isReady) {\n    db.taskqueue.addTask(function (failed) {\n      if (failed) {\n        opts.complete(failed);\n      } else if (self.isCancelled) {\n        self.emit('cancel');\n      } else {\n        self.validateChanges(opts);\n      }\n    });\n  } else {\n    self.validateChanges(opts);\n  }\n}\nChanges$2.prototype.cancel = function () {\n  this.isCancelled = true;\n  if (this.db.taskqueue.isReady) {\n    this.emit('cancel');\n  }\n};\nfunction processChange(doc, metadata, opts) {\n  var changeList = [{rev: doc._rev}];\n  if (opts.style === 'all_docs') {\n    changeList = collectLeaves(metadata.rev_tree)\n    .map(function (x) { return {rev: x.rev}; });\n  }\n  var change = {\n    id: metadata.id,\n    changes: changeList,\n    doc: doc\n  };\n\n  if (isDeleted(metadata, doc._rev)) {\n    change.deleted = true;\n  }\n  if (opts.conflicts) {\n    change.doc._conflicts = collectConflicts(metadata);\n    if (!change.doc._conflicts.length) {\n      delete change.doc._conflicts;\n    }\n  }\n  return change;\n}\n\nChanges$2.prototype.validateChanges = function (opts) {\n  var callback = opts.complete;\n  var self = this;\n\n  /* istanbul ignore else */\n  if (PouchDB._changesFilterPlugin) {\n    PouchDB._changesFilterPlugin.validate(opts, function (err) {\n      if (err) {\n        return callback(err);\n      }\n      self.doChanges(opts);\n    });\n  } else {\n    self.doChanges(opts);\n  }\n};\n\nChanges$2.prototype.doChanges = function (opts) {\n  var self = this;\n  var callback = opts.complete;\n\n  opts = clone(opts);\n  if ('live' in opts && !('continuous' in opts)) {\n    opts.continuous = opts.live;\n  }\n  opts.processChange = processChange;\n\n  if (opts.since === 'latest') {\n    opts.since = 'now';\n  }\n  if (!opts.since) {\n    opts.since = 0;\n  }\n  if (opts.since === 'now') {\n    this.db.info().then(function (info) {\n      /* istanbul ignore if */\n      if (self.isCancelled) {\n        callback(null, {status: 'cancelled'});\n        return;\n      }\n      opts.since = info.update_seq;\n      self.doChanges(opts);\n    }, callback);\n    return;\n  }\n\n  /* istanbul ignore else */\n  if (PouchDB._changesFilterPlugin) {\n    PouchDB._changesFilterPlugin.normalize(opts);\n    if (PouchDB._changesFilterPlugin.shouldFilter(this, opts)) {\n      return PouchDB._changesFilterPlugin.filter(this, opts);\n    }\n  } else {\n    ['doc_ids', 'filter', 'selector', 'view'].forEach(function (key) {\n      if (key in opts) {\n        guardedConsole('warn',\n          'The \"' + key + '\" option was passed in to changes/replicate, ' +\n          'but pouchdb-changes-filter plugin is not installed, so it ' +\n          'was ignored. Please install the plugin to enable filtering.'\n        );\n      }\n    });\n  }\n\n  if (!('descending' in opts)) {\n    opts.descending = false;\n  }\n\n  // 0 and 1 should return 1 document\n  opts.limit = opts.limit === 0 ? 1 : opts.limit;\n  opts.complete = callback;\n  var newPromise = this.db._changes(opts);\n  /* istanbul ignore else */\n  if (newPromise && typeof newPromise.cancel === 'function') {\n    var cancel = self.cancel;\n    self.cancel = getArguments(function (args) {\n      newPromise.cancel();\n      cancel.apply(this, args);\n    });\n  }\n};\n\n/*\n * A generic pouch adapter\n */\n\nfunction compare(left, right) {\n  return left < right ? -1 : left > right ? 1 : 0;\n}\n\n// Wrapper for functions that call the bulkdocs api with a single doc,\n// if the first result is an error, return an error\nfunction yankError(callback, docId) {\n  return function (err, results) {\n    if (err || (results[0] && results[0].error)) {\n      err = err || results[0];\n      err.docId = docId;\n      callback(err);\n    } else {\n      callback(null, results.length ? results[0]  : results);\n    }\n  };\n}\n\n// clean docs given to us by the user\nfunction cleanDocs(docs) {\n  for (var i = 0; i < docs.length; i++) {\n    var doc = docs[i];\n    if (doc._deleted) {\n      delete doc._attachments; // ignore atts for deleted docs\n    } else if (doc._attachments) {\n      // filter out extraneous keys from _attachments\n      var atts = Object.keys(doc._attachments);\n      for (var j = 0; j < atts.length; j++) {\n        var att = atts[j];\n        doc._attachments[att] = pick(doc._attachments[att],\n          ['data', 'digest', 'content_type', 'length', 'revpos', 'stub']);\n      }\n    }\n  }\n}\n\n// compare two docs, first by _id then by _rev\nfunction compareByIdThenRev(a, b) {\n  var idCompare = compare(a._id, b._id);\n  if (idCompare !== 0) {\n    return idCompare;\n  }\n  var aStart = a._revisions ? a._revisions.start : 0;\n  var bStart = b._revisions ? b._revisions.start : 0;\n  return compare(aStart, bStart);\n}\n\n// for every node in a revision tree computes its distance from the closest\n// leaf\nfunction computeHeight(revs) {\n  var height = {};\n  var edges = [];\n  traverseRevTree(revs, function (isLeaf, pos, id, prnt) {\n    var rev$$1 = pos + \"-\" + id;\n    if (isLeaf) {\n      height[rev$$1] = 0;\n    }\n    if (prnt !== undefined) {\n      edges.push({from: prnt, to: rev$$1});\n    }\n    return rev$$1;\n  });\n\n  edges.reverse();\n  edges.forEach(function (edge) {\n    if (height[edge.from] === undefined) {\n      height[edge.from] = 1 + height[edge.to];\n    } else {\n      height[edge.from] = Math.min(height[edge.from], 1 + height[edge.to]);\n    }\n  });\n  return height;\n}\n\nfunction allDocsKeysParse(opts) {\n  var keys =  ('limit' in opts) ?\n    opts.keys.slice(opts.skip, opts.limit + opts.skip) :\n    (opts.skip > 0) ? opts.keys.slice(opts.skip) : opts.keys;\n  opts.keys = keys;\n  opts.skip = 0;\n  delete opts.limit;\n  if (opts.descending) {\n    keys.reverse();\n    opts.descending = false;\n  }\n}\n\n// all compaction is done in a queue, to avoid attaching\n// too many listeners at once\nfunction doNextCompaction(self) {\n  var task = self._compactionQueue[0];\n  var opts = task.opts;\n  var callback = task.callback;\n  self.get('_local/compaction')[\"catch\"](function () {\n    return false;\n  }).then(function (doc) {\n    if (doc && doc.last_seq) {\n      opts.last_seq = doc.last_seq;\n    }\n    self._compact(opts, function (err, res) {\n      /* istanbul ignore if */\n      if (err) {\n        callback(err);\n      } else {\n        callback(null, res);\n      }\n      nextTick(function () {\n        self._compactionQueue.shift();\n        if (self._compactionQueue.length) {\n          doNextCompaction(self);\n        }\n      });\n    });\n  });\n}\n\nfunction attachmentNameError(name) {\n  if (name.charAt(0) === '_') {\n    return name + ' is not a valid attachment name, attachment ' +\n      'names cannot start with \\'_\\'';\n  }\n  return false;\n}\n\ninherits(AbstractPouchDB, events.EventEmitter);\n\nfunction AbstractPouchDB() {\n  events.EventEmitter.call(this);\n}\n\nAbstractPouchDB.prototype.post =\n  adapterFun('post', function (doc, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  if (typeof doc !== 'object' || Array.isArray(doc)) {\n    return callback(createError(NOT_AN_OBJECT));\n  }\n  this.bulkDocs({docs: [doc]}, opts, yankError(callback, doc._id));\n});\n\nAbstractPouchDB.prototype.put = adapterFun('put', function (doc, opts, cb) {\n  if (typeof opts === 'function') {\n    cb = opts;\n    opts = {};\n  }\n  if (typeof doc !== 'object' || Array.isArray(doc)) {\n    return cb(createError(NOT_AN_OBJECT));\n  }\n  invalidIdError(doc._id);\n  if (isLocalId(doc._id) && typeof this._putLocal === 'function') {\n    if (doc._deleted) {\n      return this._removeLocal(doc, cb);\n    } else {\n      return this._putLocal(doc, cb);\n    }\n  }\n  var self = this;\n  if (opts.force && doc._rev) {\n    transformForceOptionToNewEditsOption();\n    putDoc(function (err) {\n      var result = err ? null : {ok: true, id: doc._id, rev: doc._rev};\n      cb(err, result);\n    });\n  } else {\n    putDoc(cb);\n  }\n\n  function transformForceOptionToNewEditsOption() {\n    var parts = doc._rev.split('-');\n    var oldRevId = parts[1];\n    var oldRevNum = parseInt(parts[0], 10);\n\n    var newRevNum = oldRevNum + 1;\n    var newRevId = rev();\n\n    doc._revisions = {\n      start: newRevNum,\n      ids: [newRevId, oldRevId]\n    };\n    doc._rev = newRevNum + '-' + newRevId;\n    opts.new_edits = false;\n  }\n  function putDoc(next) {\n    if (typeof self._put === 'function' && opts.new_edits !== false) {\n      self._put(doc, opts, next);\n    } else {\n      self.bulkDocs({docs: [doc]}, opts, yankError(next, doc._id));\n    }\n  }\n});\n\nAbstractPouchDB.prototype.putAttachment =\n  adapterFun('putAttachment', function (docId, attachmentId, rev$$1,\n                                              blob, type) {\n  var api = this;\n  if (typeof type === 'function') {\n    type = blob;\n    blob = rev$$1;\n    rev$$1 = null;\n  }\n  // Lets fix in https://github.com/pouchdb/pouchdb/issues/3267\n  /* istanbul ignore if */\n  if (typeof type === 'undefined') {\n    type = blob;\n    blob = rev$$1;\n    rev$$1 = null;\n  }\n  if (!type) {\n    guardedConsole('warn', 'Attachment', attachmentId, 'on document', docId, 'is missing content_type');\n  }\n\n  function createAttachment(doc) {\n    var prevrevpos = '_rev' in doc ? parseInt(doc._rev, 10) : 0;\n    doc._attachments = doc._attachments || {};\n    doc._attachments[attachmentId] = {\n      content_type: type,\n      data: blob,\n      revpos: ++prevrevpos\n    };\n    return api.put(doc);\n  }\n\n  return api.get(docId).then(function (doc) {\n    if (doc._rev !== rev$$1) {\n      throw createError(REV_CONFLICT);\n    }\n\n    return createAttachment(doc);\n  }, function (err) {\n     // create new doc\n    /* istanbul ignore else */\n    if (err.reason === MISSING_DOC.message) {\n      return createAttachment({_id: docId});\n    } else {\n      throw err;\n    }\n  });\n});\n\nAbstractPouchDB.prototype.removeAttachment =\n  adapterFun('removeAttachment', function (docId, attachmentId, rev$$1,\n                                                 callback) {\n  var self = this;\n  self.get(docId, function (err, obj) {\n    /* istanbul ignore if */\n    if (err) {\n      callback(err);\n      return;\n    }\n    if (obj._rev !== rev$$1) {\n      callback(createError(REV_CONFLICT));\n      return;\n    }\n    /* istanbul ignore if */\n    if (!obj._attachments) {\n      return callback();\n    }\n    delete obj._attachments[attachmentId];\n    if (Object.keys(obj._attachments).length === 0) {\n      delete obj._attachments;\n    }\n    self.put(obj, callback);\n  });\n});\n\nAbstractPouchDB.prototype.remove =\n  adapterFun('remove', function (docOrId, optsOrRev, opts, callback) {\n  var doc;\n  if (typeof optsOrRev === 'string') {\n    // id, rev, opts, callback style\n    doc = {\n      _id: docOrId,\n      _rev: optsOrRev\n    };\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n  } else {\n    // doc, opts, callback style\n    doc = docOrId;\n    if (typeof optsOrRev === 'function') {\n      callback = optsOrRev;\n      opts = {};\n    } else {\n      callback = opts;\n      opts = optsOrRev;\n    }\n  }\n  opts = opts || {};\n  opts.was_delete = true;\n  var newDoc = {_id: doc._id, _rev: (doc._rev || opts.rev)};\n  newDoc._deleted = true;\n  if (isLocalId(newDoc._id) && typeof this._removeLocal === 'function') {\n    return this._removeLocal(doc, callback);\n  }\n  this.bulkDocs({docs: [newDoc]}, opts, yankError(callback, newDoc._id));\n});\n\nAbstractPouchDB.prototype.revsDiff =\n  adapterFun('revsDiff', function (req, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  var ids = Object.keys(req);\n\n  if (!ids.length) {\n    return callback(null, {});\n  }\n\n  var count = 0;\n  var missing = new ExportedMap();\n\n  function addToMissing(id, revId) {\n    if (!missing.has(id)) {\n      missing.set(id, {missing: []});\n    }\n    missing.get(id).missing.push(revId);\n  }\n\n  function processDoc(id, rev_tree) {\n    // Is this fast enough? Maybe we should switch to a set simulated by a map\n    var missingForId = req[id].slice(0);\n    traverseRevTree(rev_tree, function (isLeaf, pos, revHash, ctx,\n      opts) {\n        var rev$$1 = pos + '-' + revHash;\n        var idx = missingForId.indexOf(rev$$1);\n        if (idx === -1) {\n          return;\n        }\n\n        missingForId.splice(idx, 1);\n        /* istanbul ignore if */\n        if (opts.status !== 'available') {\n          addToMissing(id, rev$$1);\n        }\n      });\n\n    // Traversing the tree is synchronous, so now `missingForId` contains\n    // revisions that were not found in the tree\n    missingForId.forEach(function (rev$$1) {\n      addToMissing(id, rev$$1);\n    });\n  }\n\n  ids.map(function (id) {\n    this._getRevisionTree(id, function (err, rev_tree) {\n      if (err && err.status === 404 && err.message === 'missing') {\n        missing.set(id, {missing: req[id]});\n      } else if (err) {\n        /* istanbul ignore next */\n        return callback(err);\n      } else {\n        processDoc(id, rev_tree);\n      }\n\n      if (++count === ids.length) {\n        // convert LazyMap to object\n        var missingObj = {};\n        missing.forEach(function (value, key) {\n          missingObj[key] = value;\n        });\n        return callback(null, missingObj);\n      }\n    });\n  }, this);\n});\n\n// _bulk_get API for faster replication, as described in\n// https://github.com/apache/couchdb-chttpd/pull/33\n// At the \"abstract\" level, it will just run multiple get()s in\n// parallel, because this isn't much of a performance cost\n// for local databases (except the cost of multiple transactions, which is\n// small). The http adapter overrides this in order\n// to do a more efficient single HTTP request.\nAbstractPouchDB.prototype.bulkGet =\n  adapterFun('bulkGet', function (opts, callback) {\n  bulkGet(this, opts, callback);\n});\n\n// compact one document and fire callback\n// by compacting we mean removing all revisions which\n// are further from the leaf in revision tree than max_height\nAbstractPouchDB.prototype.compactDocument =\n  adapterFun('compactDocument', function (docId, maxHeight, callback) {\n  var self = this;\n  this._getRevisionTree(docId, function (err, revTree) {\n    /* istanbul ignore if */\n    if (err) {\n      return callback(err);\n    }\n    var height = computeHeight(revTree);\n    var candidates = [];\n    var revs = [];\n    Object.keys(height).forEach(function (rev$$1) {\n      if (height[rev$$1] > maxHeight) {\n        candidates.push(rev$$1);\n      }\n    });\n\n    traverseRevTree(revTree, function (isLeaf, pos, revHash, ctx, opts) {\n      var rev$$1 = pos + '-' + revHash;\n      if (opts.status === 'available' && candidates.indexOf(rev$$1) !== -1) {\n        revs.push(rev$$1);\n      }\n    });\n    self._doCompaction(docId, revs, callback);\n  });\n});\n\n// compact the whole database using single document\n// compaction\nAbstractPouchDB.prototype.compact =\n  adapterFun('compact', function (opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n\n  var self = this;\n  opts = opts || {};\n\n  self._compactionQueue = self._compactionQueue || [];\n  self._compactionQueue.push({opts: opts, callback: callback});\n  if (self._compactionQueue.length === 1) {\n    doNextCompaction(self);\n  }\n});\nAbstractPouchDB.prototype._compact = function (opts, callback) {\n  var self = this;\n  var changesOpts = {\n    return_docs: false,\n    last_seq: opts.last_seq || 0\n  };\n  var promises = [];\n\n  function onChange(row) {\n    promises.push(self.compactDocument(row.id, 0));\n  }\n  function onComplete(resp) {\n    var lastSeq = resp.last_seq;\n    PouchPromise.all(promises).then(function () {\n      return upsert(self, '_local/compaction', function deltaFunc(doc) {\n        if (!doc.last_seq || doc.last_seq < lastSeq) {\n          doc.last_seq = lastSeq;\n          return doc;\n        }\n        return false; // somebody else got here first, don't update\n      });\n    }).then(function () {\n      callback(null, {ok: true});\n    })[\"catch\"](callback);\n  }\n  self.changes(changesOpts)\n    .on('change', onChange)\n    .on('complete', onComplete)\n    .on('error', callback);\n};\n\n/* Begin api wrappers. Specific functionality to storage belongs in the\n   _[method] */\nAbstractPouchDB.prototype.get = adapterFun('get', function (id, opts, cb) {\n  if (typeof opts === 'function') {\n    cb = opts;\n    opts = {};\n  }\n  if (typeof id !== 'string') {\n    return cb(createError(INVALID_ID));\n  }\n  if (isLocalId(id) && typeof this._getLocal === 'function') {\n    return this._getLocal(id, cb);\n  }\n  var leaves = [], self = this;\n\n  function finishOpenRevs() {\n    var result = [];\n    var count = leaves.length;\n    /* istanbul ignore if */\n    if (!count) {\n      return cb(null, result);\n    }\n\n    // order with open_revs is unspecified\n    leaves.forEach(function (leaf) {\n      self.get(id, {\n        rev: leaf,\n        revs: opts.revs,\n        latest: opts.latest,\n        attachments: opts.attachments,\n        binary: opts.binary\n      }, function (err, doc) {\n        if (!err) {\n          // using latest=true can produce duplicates\n          var existing;\n          for (var i = 0, l = result.length; i < l; i++) {\n            if (result[i].ok && result[i].ok._rev === doc._rev) {\n              existing = true;\n              break;\n            }\n          }\n          if (!existing) {\n            result.push({ok: doc});\n          }\n        } else {\n          result.push({missing: leaf});\n        }\n        count--;\n        if (!count) {\n          cb(null, result);\n        }\n      });\n    });\n  }\n\n  if (opts.open_revs) {\n    if (opts.open_revs === \"all\") {\n      this._getRevisionTree(id, function (err, rev_tree) {\n        if (err) {\n          return cb(err);\n        }\n        leaves = collectLeaves(rev_tree).map(function (leaf) {\n          return leaf.rev;\n        });\n        finishOpenRevs();\n      });\n    } else {\n      if (Array.isArray(opts.open_revs)) {\n        leaves = opts.open_revs;\n        for (var i = 0; i < leaves.length; i++) {\n          var l = leaves[i];\n          // looks like it's the only thing couchdb checks\n          if (!(typeof (l) === \"string\" && /^\\d+-/.test(l))) {\n            return cb(createError(INVALID_REV));\n          }\n        }\n        finishOpenRevs();\n      } else {\n        return cb(createError(UNKNOWN_ERROR, 'function_clause'));\n      }\n    }\n    return; // open_revs does not like other options\n  }\n\n  return this._get(id, opts, function (err, result) {\n    if (err) {\n      err.docId = id;\n      return cb(err);\n    }\n\n    var doc = result.doc;\n    var metadata = result.metadata;\n    var ctx = result.ctx;\n\n    if (opts.conflicts) {\n      var conflicts = collectConflicts(metadata);\n      if (conflicts.length) {\n        doc._conflicts = conflicts;\n      }\n    }\n\n    if (isDeleted(metadata, doc._rev)) {\n      doc._deleted = true;\n    }\n\n    if (opts.revs || opts.revs_info) {\n      var splittedRev = doc._rev.split('-');\n      var revNo       = parseInt(splittedRev[0], 10);\n      var revHash     = splittedRev[1];\n\n      var paths = rootToLeaf(metadata.rev_tree);\n      var path = null;\n\n      for (var i = 0; i < paths.length; i++) {\n        var currentPath = paths[i];\n        var hashIndex = currentPath.ids.map(function (x) { return x.id; })\n          .indexOf(revHash);\n        var hashFoundAtRevPos = hashIndex === (revNo - 1);\n\n        if (hashFoundAtRevPos || (!path && hashIndex !== -1)) {\n          path = currentPath;\n        }\n      }\n\n      var indexOfRev = path.ids.map(function (x) { return x.id; })\n        .indexOf(doc._rev.split('-')[1]) + 1;\n      var howMany = path.ids.length - indexOfRev;\n      path.ids.splice(indexOfRev, howMany);\n      path.ids.reverse();\n\n      if (opts.revs) {\n        doc._revisions = {\n          start: (path.pos + path.ids.length) - 1,\n          ids: path.ids.map(function (rev$$1) {\n            return rev$$1.id;\n          })\n        };\n      }\n      if (opts.revs_info) {\n        var pos =  path.pos + path.ids.length;\n        doc._revs_info = path.ids.map(function (rev$$1) {\n          pos--;\n          return {\n            rev: pos + '-' + rev$$1.id,\n            status: rev$$1.opts.status\n          };\n        });\n      }\n    }\n\n    if (opts.attachments && doc._attachments) {\n      var attachments = doc._attachments;\n      var count = Object.keys(attachments).length;\n      if (count === 0) {\n        return cb(null, doc);\n      }\n      Object.keys(attachments).forEach(function (key) {\n        this._getAttachment(doc._id, key, attachments[key], {\n          // Previously the revision handling was done in adapter.js\n          // getAttachment, however since idb-next doesnt we need to\n          // pass the rev through\n          rev: doc._rev,\n          binary: opts.binary,\n          ctx: ctx\n        }, function (err, data) {\n          var att = doc._attachments[key];\n          att.data = data;\n          delete att.stub;\n          delete att.length;\n          if (!--count) {\n            cb(null, doc);\n          }\n        });\n      }, self);\n    } else {\n      if (doc._attachments) {\n        for (var key in doc._attachments) {\n          /* istanbul ignore else */\n          if (doc._attachments.hasOwnProperty(key)) {\n            doc._attachments[key].stub = true;\n          }\n        }\n      }\n      cb(null, doc);\n    }\n  });\n});\n\n// TODO: I dont like this, it forces an extra read for every\n// attachment read and enforces a confusing api between\n// adapter.js and the adapter implementation\nAbstractPouchDB.prototype.getAttachment =\n  adapterFun('getAttachment', function (docId, attachmentId, opts, callback) {\n  var self = this;\n  if (opts instanceof Function) {\n    callback = opts;\n    opts = {};\n  }\n  this._get(docId, opts, function (err, res) {\n    if (err) {\n      return callback(err);\n    }\n    if (res.doc._attachments && res.doc._attachments[attachmentId]) {\n      opts.ctx = res.ctx;\n      opts.binary = true;\n      self._getAttachment(docId, attachmentId,\n                          res.doc._attachments[attachmentId], opts, callback);\n    } else {\n      return callback(createError(MISSING_DOC));\n    }\n  });\n});\n\nAbstractPouchDB.prototype.allDocs =\n  adapterFun('allDocs', function (opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  opts.skip = typeof opts.skip !== 'undefined' ? opts.skip : 0;\n  if (opts.start_key) {\n    opts.startkey = opts.start_key;\n  }\n  if (opts.end_key) {\n    opts.endkey = opts.end_key;\n  }\n  if ('keys' in opts) {\n    if (!Array.isArray(opts.keys)) {\n      return callback(new TypeError('options.keys must be an array'));\n    }\n    var incompatibleOpt =\n      ['startkey', 'endkey', 'key'].filter(function (incompatibleOpt) {\n      return incompatibleOpt in opts;\n    })[0];\n    if (incompatibleOpt) {\n      callback(createError(QUERY_PARSE_ERROR,\n        'Query parameter `' + incompatibleOpt +\n        '` is not compatible with multi-get'\n      ));\n      return;\n    }\n    if (!isRemote(this)) {\n      allDocsKeysParse(opts);\n      if (opts.keys.length === 0) {\n        return this._allDocs({limit: 0}, callback);\n      }\n    }\n  }\n\n  return this._allDocs(opts, callback);\n});\n\nAbstractPouchDB.prototype.changes = function (opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  return new Changes$2(this, opts, callback);\n};\n\nAbstractPouchDB.prototype.close = adapterFun('close', function (callback) {\n  this._closed = true;\n  this.emit('closed');\n  return this._close(callback);\n});\n\nAbstractPouchDB.prototype.info = adapterFun('info', function (callback) {\n  var self = this;\n  this._info(function (err, info) {\n    if (err) {\n      return callback(err);\n    }\n    // assume we know better than the adapter, unless it informs us\n    info.db_name = info.db_name || self.name;\n    info.auto_compaction = !!(self.auto_compaction && !isRemote(self));\n    info.adapter = self.adapter;\n    callback(null, info);\n  });\n});\n\nAbstractPouchDB.prototype.id = adapterFun('id', function (callback) {\n  return this._id(callback);\n});\n\n/* istanbul ignore next */\nAbstractPouchDB.prototype.type = function () {\n  return (typeof this._type === 'function') ? this._type() : this.adapter;\n};\n\nAbstractPouchDB.prototype.bulkDocs =\n  adapterFun('bulkDocs', function (req, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n\n  opts = opts || {};\n\n  if (Array.isArray(req)) {\n    req = {\n      docs: req\n    };\n  }\n\n  if (!req || !req.docs || !Array.isArray(req.docs)) {\n    return callback(createError(MISSING_BULK_DOCS));\n  }\n\n  for (var i = 0; i < req.docs.length; ++i) {\n    if (typeof req.docs[i] !== 'object' || Array.isArray(req.docs[i])) {\n      return callback(createError(NOT_AN_OBJECT));\n    }\n  }\n\n  var attachmentError;\n  req.docs.forEach(function (doc) {\n    if (doc._attachments) {\n      Object.keys(doc._attachments).forEach(function (name) {\n        attachmentError = attachmentError || attachmentNameError(name);\n        if (!doc._attachments[name].content_type) {\n          guardedConsole('warn', 'Attachment', name, 'on document', doc._id, 'is missing content_type');\n        }\n      });\n    }\n  });\n\n  if (attachmentError) {\n    return callback(createError(BAD_REQUEST, attachmentError));\n  }\n\n  if (!('new_edits' in opts)) {\n    if ('new_edits' in req) {\n      opts.new_edits = req.new_edits;\n    } else {\n      opts.new_edits = true;\n    }\n  }\n\n  var adapter = this;\n  if (!opts.new_edits && !isRemote(adapter)) {\n    // ensure revisions of the same doc are sorted, so that\n    // the local adapter processes them correctly (#2935)\n    req.docs.sort(compareByIdThenRev);\n  }\n\n  cleanDocs(req.docs);\n\n  // in the case of conflicts, we want to return the _ids to the user\n  // however, the underlying adapter may destroy the docs array, so\n  // create a copy here\n  var ids = req.docs.map(function (doc) {\n    return doc._id;\n  });\n\n  return this._bulkDocs(req, opts, function (err, res) {\n    if (err) {\n      return callback(err);\n    }\n    if (!opts.new_edits) {\n      // this is what couch does when new_edits is false\n      res = res.filter(function (x) {\n        return x.error;\n      });\n    }\n    // add ids for error/conflict responses (not required for CouchDB)\n    if (!isRemote(adapter)) {\n      for (var i = 0, l = res.length; i < l; i++) {\n        res[i].id = res[i].id || ids[i];\n      }\n    }\n\n    callback(null, res);\n  });\n});\n\nAbstractPouchDB.prototype.registerDependentDatabase =\n  adapterFun('registerDependentDatabase', function (dependentDb,\n                                                          callback) {\n  var depDB = new this.constructor(dependentDb, this.__opts);\n\n  function diffFun(doc) {\n    doc.dependentDbs = doc.dependentDbs || {};\n    if (doc.dependentDbs[dependentDb]) {\n      return false; // no update required\n    }\n    doc.dependentDbs[dependentDb] = true;\n    return doc;\n  }\n  upsert(this, '_local/_pouch_dependentDbs', diffFun)\n    .then(function () {\n      callback(null, {db: depDB});\n    })[\"catch\"](callback);\n});\n\nAbstractPouchDB.prototype.destroy =\n  adapterFun('destroy', function (opts, callback) {\n\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n\n  var self = this;\n  var usePrefix = 'use_prefix' in self ? self.use_prefix : true;\n\n  function destroyDb() {\n    // call destroy method of the particular adaptor\n    self._destroy(opts, function (err, resp) {\n      if (err) {\n        return callback(err);\n      }\n      self._destroyed = true;\n      self.emit('destroyed');\n      callback(null, resp || { 'ok': true });\n    });\n  }\n\n  if (isRemote(self)) {\n    // no need to check for dependent DBs if it's a remote DB\n    return destroyDb();\n  }\n\n  self.get('_local/_pouch_dependentDbs', function (err, localDoc) {\n    if (err) {\n      /* istanbul ignore if */\n      if (err.status !== 404) {\n        return callback(err);\n      } else { // no dependencies\n        return destroyDb();\n      }\n    }\n    var dependentDbs = localDoc.dependentDbs;\n    var PouchDB = self.constructor;\n    var deletedMap = Object.keys(dependentDbs).map(function (name) {\n      // use_prefix is only false in the browser\n      /* istanbul ignore next */\n      var trueName = usePrefix ?\n        name.replace(new RegExp('^' + PouchDB.prefix), '') : name;\n      return new PouchDB(trueName, self.__opts).destroy();\n    });\n    PouchPromise.all(deletedMap).then(destroyDb, callback);\n  });\n});\n\nfunction TaskQueue$1() {\n  this.isReady = false;\n  this.failed = false;\n  this.queue = [];\n}\n\nTaskQueue$1.prototype.execute = function () {\n  var fun;\n  if (this.failed) {\n    while ((fun = this.queue.shift())) {\n      fun(this.failed);\n    }\n  } else {\n    while ((fun = this.queue.shift())) {\n      fun();\n    }\n  }\n};\n\nTaskQueue$1.prototype.fail = function (err) {\n  this.failed = err;\n  this.execute();\n};\n\nTaskQueue$1.prototype.ready = function (db) {\n  this.isReady = true;\n  this.db = db;\n  this.execute();\n};\n\nTaskQueue$1.prototype.addTask = function (fun) {\n  this.queue.push(fun);\n  if (this.failed) {\n    this.execute();\n  }\n};\n\nfunction parseAdapter(name, opts) {\n  var match = name.match(/([a-z-]*):\\/\\/(.*)/);\n  if (match) {\n    // the http adapter expects the fully qualified name\n    return {\n      name: /https?/.test(match[1]) ? match[1] + '://' + match[2] : match[2],\n      adapter: match[1]\n    };\n  }\n\n  var adapters = PouchDB.adapters;\n  var preferredAdapters = PouchDB.preferredAdapters;\n  var prefix = PouchDB.prefix;\n  var adapterName = opts.adapter;\n\n  if (!adapterName) { // automatically determine adapter\n    for (var i = 0; i < preferredAdapters.length; ++i) {\n      adapterName = preferredAdapters[i];\n      // check for browsers that have been upgraded from websql-only to websql+idb\n      /* istanbul ignore if */\n      if (adapterName === 'idb' && 'websql' in adapters &&\n          hasLocalStorage() && localStorage['_pouch__websqldb_' + prefix + name]) {\n        // log it, because this can be confusing during development\n        guardedConsole('log', 'PouchDB is downgrading \"' + name + '\" to WebSQL to' +\n          ' avoid data loss, because it was already opened with WebSQL.');\n        continue; // keep using websql to avoid user data loss\n      }\n      break;\n    }\n  }\n\n  var adapter = adapters[adapterName];\n\n  // if adapter is invalid, then an error will be thrown later\n  var usePrefix = (adapter && 'use_prefix' in adapter) ?\n    adapter.use_prefix : true;\n\n  return {\n    name: usePrefix ? (prefix + name) : name,\n    adapter: adapterName\n  };\n}\n\n// OK, so here's the deal. Consider this code:\n//     var db1 = new PouchDB('foo');\n//     var db2 = new PouchDB('foo');\n//     db1.destroy();\n// ^ these two both need to emit 'destroyed' events,\n// as well as the PouchDB constructor itself.\n// So we have one db object (whichever one got destroy() called on it)\n// responsible for emitting the initial event, which then gets emitted\n// by the constructor, which then broadcasts it to any other dbs\n// that may have been created with the same name.\nfunction prepareForDestruction(self) {\n\n  function onDestroyed(from_constructor) {\n    self.removeListener('closed', onClosed);\n    if (!from_constructor) {\n      self.constructor.emit('destroyed', self.name);\n    }\n  }\n\n  function onClosed() {\n    self.removeListener('destroyed', onDestroyed);\n    self.constructor.emit('unref', self);\n  }\n\n  self.once('destroyed', onDestroyed);\n  self.once('closed', onClosed);\n  self.constructor.emit('ref', self);\n}\n\ninherits(PouchDB, AbstractPouchDB);\nfunction PouchDB(name, opts) {\n  // In Node our test suite only tests this for PouchAlt unfortunately\n  /* istanbul ignore if */\n  if (!(this instanceof PouchDB)) {\n    return new PouchDB(name, opts);\n  }\n\n  var self = this;\n  opts = opts || {};\n\n  if (name && typeof name === 'object') {\n    opts = name;\n    name = opts.name;\n    delete opts.name;\n  }\n\n  this.__opts = opts = clone(opts);\n\n  self.auto_compaction = opts.auto_compaction;\n  self.prefix = PouchDB.prefix;\n\n  if (typeof name !== 'string') {\n    throw new Error('Missing/invalid DB name');\n  }\n\n  var prefixedName = (opts.prefix || '') + name;\n  var backend = parseAdapter(prefixedName, opts);\n\n  opts.name = backend.name;\n  opts.adapter = opts.adapter || backend.adapter;\n\n  self.name = name;\n  self._adapter = opts.adapter;\n  PouchDB.emit('debug', ['adapter', 'Picked adapter: ', opts.adapter]);\n\n  if (!PouchDB.adapters[opts.adapter] ||\n      !PouchDB.adapters[opts.adapter].valid()) {\n    throw new Error('Invalid Adapter: ' + opts.adapter);\n  }\n\n  AbstractPouchDB.call(self);\n  self.taskqueue = new TaskQueue$1();\n\n  self.adapter = opts.adapter;\n\n  PouchDB.adapters[opts.adapter].call(self, opts, function (err) {\n    if (err) {\n      return self.taskqueue.fail(err);\n    }\n    prepareForDestruction(self);\n\n    self.emit('created', self);\n    PouchDB.emit('created', self.name);\n    self.taskqueue.ready(self);\n  });\n\n}\n\nPouchDB.adapters = {};\nPouchDB.preferredAdapters = [];\n\nPouchDB.prefix = '_pouch_';\n\nvar eventEmitter = new events.EventEmitter();\n\nfunction setUpEventEmitter(Pouch) {\n  Object.keys(events.EventEmitter.prototype).forEach(function (key) {\n    if (typeof events.EventEmitter.prototype[key] === 'function') {\n      Pouch[key] = eventEmitter[key].bind(eventEmitter);\n    }\n  });\n\n  // these are created in constructor.js, and allow us to notify each DB with\n  // the same name that it was destroyed, via the constructor object\n  var destructListeners = Pouch._destructionListeners = new ExportedMap();\n\n  Pouch.on('ref', function onConstructorRef(db) {\n    if (!destructListeners.has(db.name)) {\n      destructListeners.set(db.name, []);\n    }\n    destructListeners.get(db.name).push(db);\n  });\n\n  Pouch.on('unref', function onConstructorUnref(db) {\n    if (!destructListeners.has(db.name)) {\n      return;\n    }\n    var dbList = destructListeners.get(db.name);\n    var pos = dbList.indexOf(db);\n    if (pos < 0) {\n      /* istanbul ignore next */\n      return;\n    }\n    dbList.splice(pos, 1);\n    if (dbList.length > 1) {\n      /* istanbul ignore next */\n      destructListeners.set(db.name, dbList);\n    } else {\n      destructListeners[\"delete\"](db.name);\n    }\n  });\n\n  Pouch.on('destroyed', function onConstructorDestroyed(name) {\n    if (!destructListeners.has(name)) {\n      return;\n    }\n    var dbList = destructListeners.get(name);\n    destructListeners[\"delete\"](name);\n    dbList.forEach(function (db) {\n      db.emit('destroyed',true);\n    });\n  });\n}\n\nsetUpEventEmitter(PouchDB);\n\nPouchDB.adapter = function (id, obj, addToPreferredAdapters) {\n  /* istanbul ignore else */\n  if (obj.valid()) {\n    PouchDB.adapters[id] = obj;\n    if (addToPreferredAdapters) {\n      PouchDB.preferredAdapters.push(id);\n    }\n  }\n};\n\nPouchDB.plugin = function (obj) {\n  if (typeof obj === 'function') { // function style for plugins\n    obj(PouchDB);\n  } else if (typeof obj !== 'object' || Object.keys(obj).length === 0) {\n    throw new Error('Invalid plugin: got \"' + obj + '\", expected an object or a function');\n  } else {\n    Object.keys(obj).forEach(function (id) { // object style for plugins\n      PouchDB.prototype[id] = obj[id];\n    });\n  }\n  if (this.__defaults) {\n    PouchDB.__defaults = $inject_Object_assign({}, this.__defaults);\n  }\n  return PouchDB;\n};\n\nPouchDB.defaults = function (defaultOpts) {\n  function PouchAlt(name, opts) {\n    if (!(this instanceof PouchAlt)) {\n      return new PouchAlt(name, opts);\n    }\n\n    opts = opts || {};\n\n    if (name && typeof name === 'object') {\n      opts = name;\n      name = opts.name;\n      delete opts.name;\n    }\n\n    opts = $inject_Object_assign({}, PouchAlt.__defaults, opts);\n    PouchDB.call(this, name, opts);\n  }\n\n  inherits(PouchAlt, PouchDB);\n\n  PouchAlt.preferredAdapters = PouchDB.preferredAdapters.slice();\n  Object.keys(PouchDB).forEach(function (key) {\n    if (!(key in PouchAlt)) {\n      PouchAlt[key] = PouchDB[key];\n    }\n  });\n\n  // make default options transitive\n  // https://github.com/pouchdb/pouchdb/issues/5922\n  PouchAlt.__defaults = $inject_Object_assign({}, this.__defaults, defaultOpts);\n\n  return PouchAlt;\n};\n\n// managed automatically by set-version.js\nvar version = \"6.4.3\";\n\nfunction debugPouch(PouchDB) {\n  PouchDB.debug = debug;\n  var logs = {};\n  /* istanbul ignore next */\n  PouchDB.on('debug', function (args) {\n    // first argument is log identifier\n    var logId = args[0];\n    // rest should be passed verbatim to debug module\n    var logArgs = args.slice(1);\n    if (!logs[logId]) {\n      logs[logId] = debug('pouchdb:' + logId);\n    }\n    logs[logId].apply(null, logArgs);\n  });\n}\n\n// this would just be \"return doc[field]\", but fields\n// can be \"deep\" due to dot notation\nfunction getFieldFromDoc(doc, parsedField) {\n  var value = doc;\n  for (var i = 0, len = parsedField.length; i < len; i++) {\n    var key = parsedField[i];\n    value = value[key];\n    if (!value) {\n      break;\n    }\n  }\n  return value;\n}\n\nfunction compare$1(left, right) {\n  return left < right ? -1 : left > right ? 1 : 0;\n}\n\n// Converts a string in dot notation to an array of its components, with backslash escaping\nfunction parseField(fieldName) {\n  // fields may be deep (e.g. \"foo.bar.baz\"), so parse\n  var fields = [];\n  var current = '';\n  for (var i = 0, len = fieldName.length; i < len; i++) {\n    var ch = fieldName[i];\n    if (ch === '.') {\n      if (i > 0 && fieldName[i - 1] === '\\\\') { // escaped delimiter\n        current = current.substring(0, current.length - 1) + '.';\n      } else { // not escaped, so delimiter\n        fields.push(current);\n        current = '';\n      }\n    } else { // normal character\n      current += ch;\n    }\n  }\n  fields.push(current);\n  return fields;\n}\n\nvar combinationFields = ['$or', '$nor', '$not'];\nfunction isCombinationalField(field) {\n  return combinationFields.indexOf(field) > -1;\n}\n\nfunction getKey(obj) {\n  return Object.keys(obj)[0];\n}\n\nfunction getValue(obj) {\n  return obj[getKey(obj)];\n}\n\n\n// flatten an array of selectors joined by an $and operator\nfunction mergeAndedSelectors(selectors) {\n\n  // sort to ensure that e.g. if the user specified\n  // $and: [{$gt: 'a'}, {$gt: 'b'}], then it's collapsed into\n  // just {$gt: 'b'}\n  var res = {};\n\n  selectors.forEach(function (selector) {\n    Object.keys(selector).forEach(function (field) {\n      var matcher = selector[field];\n      if (typeof matcher !== 'object') {\n        matcher = {$eq: matcher};\n      }\n\n      if (isCombinationalField(field)) {\n        if (matcher instanceof Array) {\n          res[field] = matcher.map(function (m) {\n            return mergeAndedSelectors([m]);\n          });\n        } else {\n          res[field] = mergeAndedSelectors([matcher]);\n        }\n      } else {\n        var fieldMatchers = res[field] = res[field] || {};\n        Object.keys(matcher).forEach(function (operator) {\n          var value = matcher[operator];\n\n          if (operator === '$gt' || operator === '$gte') {\n            return mergeGtGte(operator, value, fieldMatchers);\n          } else if (operator === '$lt' || operator === '$lte') {\n            return mergeLtLte(operator, value, fieldMatchers);\n          } else if (operator === '$ne') {\n            return mergeNe(value, fieldMatchers);\n          } else if (operator === '$eq') {\n            return mergeEq(value, fieldMatchers);\n          }\n          fieldMatchers[operator] = value;\n        });\n      }\n    });\n  });\n\n  return res;\n}\n\n\n\n// collapse logically equivalent gt/gte values\nfunction mergeGtGte(operator, value, fieldMatchers) {\n  if (typeof fieldMatchers.$eq !== 'undefined') {\n    return; // do nothing\n  }\n  if (typeof fieldMatchers.$gte !== 'undefined') {\n    if (operator === '$gte') {\n      if (value > fieldMatchers.$gte) { // more specificity\n        fieldMatchers.$gte = value;\n      }\n    } else { // operator === '$gt'\n      if (value >= fieldMatchers.$gte) { // more specificity\n        delete fieldMatchers.$gte;\n        fieldMatchers.$gt = value;\n      }\n    }\n  } else if (typeof fieldMatchers.$gt !== 'undefined') {\n    if (operator === '$gte') {\n      if (value > fieldMatchers.$gt) { // more specificity\n        delete fieldMatchers.$gt;\n        fieldMatchers.$gte = value;\n      }\n    } else { // operator === '$gt'\n      if (value > fieldMatchers.$gt) { // more specificity\n        fieldMatchers.$gt = value;\n      }\n    }\n  } else {\n    fieldMatchers[operator] = value;\n  }\n}\n\n// collapse logically equivalent lt/lte values\nfunction mergeLtLte(operator, value, fieldMatchers) {\n  if (typeof fieldMatchers.$eq !== 'undefined') {\n    return; // do nothing\n  }\n  if (typeof fieldMatchers.$lte !== 'undefined') {\n    if (operator === '$lte') {\n      if (value < fieldMatchers.$lte) { // more specificity\n        fieldMatchers.$lte = value;\n      }\n    } else { // operator === '$gt'\n      if (value <= fieldMatchers.$lte) { // more specificity\n        delete fieldMatchers.$lte;\n        fieldMatchers.$lt = value;\n      }\n    }\n  } else if (typeof fieldMatchers.$lt !== 'undefined') {\n    if (operator === '$lte') {\n      if (value < fieldMatchers.$lt) { // more specificity\n        delete fieldMatchers.$lt;\n        fieldMatchers.$lte = value;\n      }\n    } else { // operator === '$gt'\n      if (value < fieldMatchers.$lt) { // more specificity\n        fieldMatchers.$lt = value;\n      }\n    }\n  } else {\n    fieldMatchers[operator] = value;\n  }\n}\n\n// combine $ne values into one array\nfunction mergeNe(value, fieldMatchers) {\n  if ('$ne' in fieldMatchers) {\n    // there are many things this could \"not\" be\n    fieldMatchers.$ne.push(value);\n  } else { // doesn't exist yet\n    fieldMatchers.$ne = [value];\n  }\n}\n\n// add $eq into the mix\nfunction mergeEq(value, fieldMatchers) {\n  // these all have less specificity than the $eq\n  // TODO: check for user errors here\n  delete fieldMatchers.$gt;\n  delete fieldMatchers.$gte;\n  delete fieldMatchers.$lt;\n  delete fieldMatchers.$lte;\n  delete fieldMatchers.$ne;\n  fieldMatchers.$eq = value;\n}\n\n\n//\n// normalize the selector\n//\nfunction massageSelector(input) {\n  var result = clone(input);\n  var wasAnded = false;\n  if ('$and' in result) {\n    result = mergeAndedSelectors(result['$and']);\n    wasAnded = true;\n  }\n\n  ['$or', '$nor'].forEach(function (orOrNor) {\n    if (orOrNor in result) {\n      // message each individual selector\n      // e.g. {foo: 'bar'} becomes {foo: {$eq: 'bar'}}\n      result[orOrNor].forEach(function (subSelector) {\n        var fields = Object.keys(subSelector);\n        for (var i = 0; i < fields.length; i++) {\n          var field = fields[i];\n          var matcher = subSelector[field];\n          if (typeof matcher !== 'object' || matcher === null) {\n            subSelector[field] = {$eq: matcher};\n          }\n        }\n      });\n    }\n  });\n\n  if ('$not' in result) {\n    //This feels a little like forcing, but it will work for now,\n    //I would like to come back to this and make the merging of selectors a little more generic\n    result['$not'] = mergeAndedSelectors([result['$not']]);\n  }\n\n  var fields = Object.keys(result);\n\n  for (var i = 0; i < fields.length; i++) {\n    var field = fields[i];\n    var matcher = result[field];\n\n    if (typeof matcher !== 'object' || matcher === null) {\n      matcher = {$eq: matcher};\n    } else if ('$ne' in matcher && !wasAnded) {\n      // I put these in an array, since there may be more than one\n      // but in the \"mergeAnded\" operation, I already take care of that\n      matcher.$ne = [matcher.$ne];\n    }\n    result[field] = matcher;\n  }\n\n  return result;\n}\n\nfunction pad(str, padWith, upToLength) {\n  var padding = '';\n  var targetLength = upToLength - str.length;\n  /* istanbul ignore next */\n  while (padding.length < targetLength) {\n    padding += padWith;\n  }\n  return padding;\n}\n\nfunction padLeft(str, padWith, upToLength) {\n  var padding = pad(str, padWith, upToLength);\n  return padding + str;\n}\n\nvar MIN_MAGNITUDE = -324; // verified by -Number.MIN_VALUE\nvar MAGNITUDE_DIGITS = 3; // ditto\nvar SEP = ''; // set to '_' for easier debugging \n\nfunction collate(a, b) {\n\n  if (a === b) {\n    return 0;\n  }\n\n  a = normalizeKey(a);\n  b = normalizeKey(b);\n\n  var ai = collationIndex(a);\n  var bi = collationIndex(b);\n  if ((ai - bi) !== 0) {\n    return ai - bi;\n  }\n  switch (typeof a) {\n    case 'number':\n      return a - b;\n    case 'boolean':\n      return a < b ? -1 : 1;\n    case 'string':\n      return stringCollate(a, b);\n  }\n  return Array.isArray(a) ? arrayCollate(a, b) : objectCollate(a, b);\n}\n\n// couch considers null/NaN/Infinity/-Infinity === undefined,\n// for the purposes of mapreduce indexes. also, dates get stringified.\nfunction normalizeKey(key) {\n  switch (typeof key) {\n    case 'undefined':\n      return null;\n    case 'number':\n      if (key === Infinity || key === -Infinity || isNaN(key)) {\n        return null;\n      }\n      return key;\n    case 'object':\n      var origKey = key;\n      if (Array.isArray(key)) {\n        var len = key.length;\n        key = new Array(len);\n        for (var i = 0; i < len; i++) {\n          key[i] = normalizeKey(origKey[i]);\n        }\n      /* istanbul ignore next */\n      } else if (key instanceof Date) {\n        return key.toJSON();\n      } else if (key !== null) { // generic object\n        key = {};\n        for (var k in origKey) {\n          if (origKey.hasOwnProperty(k)) {\n            var val = origKey[k];\n            if (typeof val !== 'undefined') {\n              key[k] = normalizeKey(val);\n            }\n          }\n        }\n      }\n  }\n  return key;\n}\n\nfunction indexify(key) {\n  if (key !== null) {\n    switch (typeof key) {\n      case 'boolean':\n        return key ? 1 : 0;\n      case 'number':\n        return numToIndexableString(key);\n      case 'string':\n        // We've to be sure that key does not contain \\u0000\n        // Do order-preserving replacements:\n        // 0 -> 1, 1\n        // 1 -> 1, 2\n        // 2 -> 2, 2\n        return key\n          .replace(/\\u0002/g, '\\u0002\\u0002')\n          .replace(/\\u0001/g, '\\u0001\\u0002')\n          .replace(/\\u0000/g, '\\u0001\\u0001');\n      case 'object':\n        var isArray = Array.isArray(key);\n        var arr = isArray ? key : Object.keys(key);\n        var i = -1;\n        var len = arr.length;\n        var result = '';\n        if (isArray) {\n          while (++i < len) {\n            result += toIndexableString(arr[i]);\n          }\n        } else {\n          while (++i < len) {\n            var objKey = arr[i];\n            result += toIndexableString(objKey) +\n                toIndexableString(key[objKey]);\n          }\n        }\n        return result;\n    }\n  }\n  return '';\n}\n\n// convert the given key to a string that would be appropriate\n// for lexical sorting, e.g. within a database, where the\n// sorting is the same given by the collate() function.\nfunction toIndexableString(key) {\n  var zero = '\\u0000';\n  key = normalizeKey(key);\n  return collationIndex(key) + SEP + indexify(key) + zero;\n}\n\nfunction parseNumber(str, i) {\n  var originalIdx = i;\n  var num;\n  var zero = str[i] === '1';\n  if (zero) {\n    num = 0;\n    i++;\n  } else {\n    var neg = str[i] === '0';\n    i++;\n    var numAsString = '';\n    var magAsString = str.substring(i, i + MAGNITUDE_DIGITS);\n    var magnitude = parseInt(magAsString, 10) + MIN_MAGNITUDE;\n    /* istanbul ignore next */\n    if (neg) {\n      magnitude = -magnitude;\n    }\n    i += MAGNITUDE_DIGITS;\n    while (true) {\n      var ch = str[i];\n      if (ch === '\\u0000') {\n        break;\n      } else {\n        numAsString += ch;\n      }\n      i++;\n    }\n    numAsString = numAsString.split('.');\n    if (numAsString.length === 1) {\n      num = parseInt(numAsString, 10);\n    } else {\n      /* istanbul ignore next */\n      num = parseFloat(numAsString[0] + '.' + numAsString[1]);\n    }\n    /* istanbul ignore next */\n    if (neg) {\n      num = num - 10;\n    }\n    /* istanbul ignore next */\n    if (magnitude !== 0) {\n      // parseFloat is more reliable than pow due to rounding errors\n      // e.g. Number.MAX_VALUE would return Infinity if we did\n      // num * Math.pow(10, magnitude);\n      num = parseFloat(num + 'e' + magnitude);\n    }\n  }\n  return {num: num, length : i - originalIdx};\n}\n\n// move up the stack while parsing\n// this function moved outside of parseIndexableString for performance\nfunction pop(stack, metaStack) {\n  var obj = stack.pop();\n\n  if (metaStack.length) {\n    var lastMetaElement = metaStack[metaStack.length - 1];\n    if (obj === lastMetaElement.element) {\n      // popping a meta-element, e.g. an object whose value is another object\n      metaStack.pop();\n      lastMetaElement = metaStack[metaStack.length - 1];\n    }\n    var element = lastMetaElement.element;\n    var lastElementIndex = lastMetaElement.index;\n    if (Array.isArray(element)) {\n      element.push(obj);\n    } else if (lastElementIndex === stack.length - 2) { // obj with key+value\n      var key = stack.pop();\n      element[key] = obj;\n    } else {\n      stack.push(obj); // obj with key only\n    }\n  }\n}\n\nfunction parseIndexableString(str) {\n  var stack = [];\n  var metaStack = []; // stack for arrays and objects\n  var i = 0;\n\n  /*eslint no-constant-condition: [\"error\", { \"checkLoops\": false }]*/\n  while (true) {\n    var collationIndex = str[i++];\n    if (collationIndex === '\\u0000') {\n      if (stack.length === 1) {\n        return stack.pop();\n      } else {\n        pop(stack, metaStack);\n        continue;\n      }\n    }\n    switch (collationIndex) {\n      case '1':\n        stack.push(null);\n        break;\n      case '2':\n        stack.push(str[i] === '1');\n        i++;\n        break;\n      case '3':\n        var parsedNum = parseNumber(str, i);\n        stack.push(parsedNum.num);\n        i += parsedNum.length;\n        break;\n      case '4':\n        var parsedStr = '';\n        /*eslint no-constant-condition: [\"error\", { \"checkLoops\": false }]*/\n        while (true) {\n          var ch = str[i];\n          if (ch === '\\u0000') {\n            break;\n          }\n          parsedStr += ch;\n          i++;\n        }\n        // perform the reverse of the order-preserving replacement\n        // algorithm (see above)\n        parsedStr = parsedStr.replace(/\\u0001\\u0001/g, '\\u0000')\n          .replace(/\\u0001\\u0002/g, '\\u0001')\n          .replace(/\\u0002\\u0002/g, '\\u0002');\n        stack.push(parsedStr);\n        break;\n      case '5':\n        var arrayElement = { element: [], index: stack.length };\n        stack.push(arrayElement.element);\n        metaStack.push(arrayElement);\n        break;\n      case '6':\n        var objElement = { element: {}, index: stack.length };\n        stack.push(objElement.element);\n        metaStack.push(objElement);\n        break;\n      /* istanbul ignore next */\n      default:\n        throw new Error(\n          'bad collationIndex or unexpectedly reached end of input: ' +\n            collationIndex);\n    }\n  }\n}\n\nfunction arrayCollate(a, b) {\n  var len = Math.min(a.length, b.length);\n  for (var i = 0; i < len; i++) {\n    var sort = collate(a[i], b[i]);\n    if (sort !== 0) {\n      return sort;\n    }\n  }\n  return (a.length === b.length) ? 0 :\n    (a.length > b.length) ? 1 : -1;\n}\nfunction stringCollate(a, b) {\n  // See: https://github.com/daleharvey/pouchdb/issues/40\n  // This is incompatible with the CouchDB implementation, but its the\n  // best we can do for now\n  return (a === b) ? 0 : ((a > b) ? 1 : -1);\n}\nfunction objectCollate(a, b) {\n  var ak = Object.keys(a), bk = Object.keys(b);\n  var len = Math.min(ak.length, bk.length);\n  for (var i = 0; i < len; i++) {\n    // First sort the keys\n    var sort = collate(ak[i], bk[i]);\n    if (sort !== 0) {\n      return sort;\n    }\n    // if the keys are equal sort the values\n    sort = collate(a[ak[i]], b[bk[i]]);\n    if (sort !== 0) {\n      return sort;\n    }\n\n  }\n  return (ak.length === bk.length) ? 0 :\n    (ak.length > bk.length) ? 1 : -1;\n}\n// The collation is defined by erlangs ordered terms\n// the atoms null, true, false come first, then numbers, strings,\n// arrays, then objects\n// null/undefined/NaN/Infinity/-Infinity are all considered null\nfunction collationIndex(x) {\n  var id = ['boolean', 'number', 'string', 'object'];\n  var idx = id.indexOf(typeof x);\n  //false if -1 otherwise true, but fast!!!!1\n  if (~idx) {\n    if (x === null) {\n      return 1;\n    }\n    if (Array.isArray(x)) {\n      return 5;\n    }\n    return idx < 3 ? (idx + 2) : (idx + 3);\n  }\n  /* istanbul ignore next */\n  if (Array.isArray(x)) {\n    return 5;\n  }\n}\n\n// conversion:\n// x yyy zz...zz\n// x = 0 for negative, 1 for 0, 2 for positive\n// y = exponent (for negative numbers negated) moved so that it's >= 0\n// z = mantisse\nfunction numToIndexableString(num) {\n\n  if (num === 0) {\n    return '1';\n  }\n\n  // convert number to exponential format for easier and\n  // more succinct string sorting\n  var expFormat = num.toExponential().split(/e\\+?/);\n  var magnitude = parseInt(expFormat[1], 10);\n\n  var neg = num < 0;\n\n  var result = neg ? '0' : '2';\n\n  // first sort by magnitude\n  // it's easier if all magnitudes are positive\n  var magForComparison = ((neg ? -magnitude : magnitude) - MIN_MAGNITUDE);\n  var magString = padLeft((magForComparison).toString(), '0', MAGNITUDE_DIGITS);\n\n  result += SEP + magString;\n\n  // then sort by the factor\n  var factor = Math.abs(parseFloat(expFormat[0])); // [1..10)\n  /* istanbul ignore next */\n  if (neg) { // for negative reverse ordering\n    factor = 10 - factor;\n  }\n\n  var factorStr = factor.toFixed(20);\n\n  // strip zeros from the end\n  factorStr = factorStr.replace(/\\.?0+$/, '');\n\n  result += SEP + factorStr;\n\n  return result;\n}\n\n// create a comparator based on the sort object\nfunction createFieldSorter(sort) {\n\n  function getFieldValuesAsArray(doc) {\n    return sort.map(function (sorting) {\n      var fieldName = getKey(sorting);\n      var parsedField = parseField(fieldName);\n      var docFieldValue = getFieldFromDoc(doc, parsedField);\n      return docFieldValue;\n    });\n  }\n\n  return function (aRow, bRow) {\n    var aFieldValues = getFieldValuesAsArray(aRow.doc);\n    var bFieldValues = getFieldValuesAsArray(bRow.doc);\n    var collation = collate(aFieldValues, bFieldValues);\n    if (collation !== 0) {\n      return collation;\n    }\n    // this is what mango seems to do\n    return compare$1(aRow.doc._id, bRow.doc._id);\n  };\n}\n\nfunction filterInMemoryFields(rows, requestDef, inMemoryFields) {\n  rows = rows.filter(function (row) {\n    return rowFilter(row.doc, requestDef.selector, inMemoryFields);\n  });\n\n  if (requestDef.sort) {\n    // in-memory sort\n    var fieldSorter = createFieldSorter(requestDef.sort);\n    rows = rows.sort(fieldSorter);\n    if (typeof requestDef.sort[0] !== 'string' &&\n        getValue(requestDef.sort[0]) === 'desc') {\n      rows = rows.reverse();\n    }\n  }\n\n  if ('limit' in requestDef || 'skip' in requestDef) {\n    // have to do the limit in-memory\n    var skip = requestDef.skip || 0;\n    var limit = ('limit' in requestDef ? requestDef.limit : rows.length) + skip;\n    rows = rows.slice(skip, limit);\n  }\n  return rows;\n}\n\nfunction rowFilter(doc, selector, inMemoryFields) {\n  return inMemoryFields.every(function (field) {\n    var matcher = selector[field];\n    var parsedField = parseField(field);\n    var docFieldValue = getFieldFromDoc(doc, parsedField);\n    if (isCombinationalField(field)) {\n      return matchCominationalSelector(field, matcher, doc);\n    }\n\n    return matchSelector(matcher, doc, parsedField, docFieldValue);\n  });\n}\n\nfunction matchSelector(matcher, doc, parsedField, docFieldValue) {\n  if (!matcher) {\n    // no filtering necessary; this field is just needed for sorting\n    return true;\n  }\n\n  return Object.keys(matcher).every(function (userOperator) {\n    var userValue = matcher[userOperator];\n    return match(userOperator, doc, userValue, parsedField, docFieldValue);\n  });\n}\n\nfunction matchCominationalSelector(field, matcher, doc) {\n\n  if (field === '$or') {\n    return matcher.some(function (orMatchers) {\n      return rowFilter(doc, orMatchers, Object.keys(orMatchers));\n    });\n  }\n\n  if (field === '$not') {\n    return !rowFilter(doc, matcher, Object.keys(matcher));\n  }\n\n  //`$nor`\n  return !matcher.find(function (orMatchers) {\n    return rowFilter(doc, orMatchers, Object.keys(orMatchers));\n  });\n\n}\n\nfunction match(userOperator, doc, userValue, parsedField, docFieldValue) {\n  if (!matchers[userOperator]) {\n    throw new Error('unknown operator \"' + userOperator +\n      '\" - should be one of $eq, $lte, $lt, $gt, $gte, $exists, $ne, $in, ' +\n      '$nin, $size, $mod, $regex, $elemMatch, $type, $allMatch or $all');\n  }\n  return matchers[userOperator](doc, userValue, parsedField, docFieldValue);\n}\n\nfunction fieldExists(docFieldValue) {\n  return typeof docFieldValue !== 'undefined' && docFieldValue !== null;\n}\n\nfunction fieldIsNotUndefined(docFieldValue) {\n  return typeof docFieldValue !== 'undefined';\n}\n\nfunction modField(docFieldValue, userValue) {\n  var divisor = userValue[0];\n  var mod = userValue[1];\n  if (divisor === 0) {\n    throw new Error('Bad divisor, cannot divide by zero');\n  }\n\n  if (parseInt(divisor, 10) !== divisor ) {\n    throw new Error('Divisor is not an integer');\n  }\n\n  if (parseInt(mod, 10) !== mod ) {\n    throw new Error('Modulus is not an integer');\n  }\n\n  if (parseInt(docFieldValue, 10) !== docFieldValue) {\n    return false;\n  }\n\n  return docFieldValue % divisor === mod;\n}\n\nfunction arrayContainsValue(docFieldValue, userValue) {\n  return userValue.some(function (val) {\n    if (docFieldValue instanceof Array) {\n      return docFieldValue.indexOf(val) > -1;\n    }\n\n    return docFieldValue === val;\n  });\n}\n\nfunction arrayContainsAllValues(docFieldValue, userValue) {\n  return userValue.every(function (val) {\n    return docFieldValue.indexOf(val) > -1;\n  });\n}\n\nfunction arraySize(docFieldValue, userValue) {\n  return docFieldValue.length === userValue;\n}\n\nfunction regexMatch(docFieldValue, userValue) {\n  var re = new RegExp(userValue);\n\n  return re.test(docFieldValue);\n}\n\nfunction typeMatch(docFieldValue, userValue) {\n\n  switch (userValue) {\n    case 'null':\n      return docFieldValue === null;\n    case 'boolean':\n      return typeof (docFieldValue) === 'boolean';\n    case 'number':\n      return typeof (docFieldValue) === 'number';\n    case 'string':\n      return typeof (docFieldValue) === 'string';\n    case 'array':\n      return docFieldValue instanceof Array;\n    case 'object':\n      return ({}).toString.call(docFieldValue) === '[object Object]';\n  }\n\n  throw new Error(userValue + ' not supported as a type.' +\n                  'Please use one of object, string, array, number, boolean or null.');\n\n}\n\nvar matchers = {\n\n  '$elemMatch': function (doc, userValue, parsedField, docFieldValue) {\n    if (!Array.isArray(docFieldValue)) {\n      return false;\n    }\n\n    if (docFieldValue.length === 0) {\n      return false;\n    }\n\n    if (typeof docFieldValue[0] === 'object') {\n      return docFieldValue.some(function (val) {\n        return rowFilter(val, userValue, Object.keys(userValue));\n      });\n    }\n\n    return docFieldValue.some(function (val) {\n      return matchSelector(userValue, doc, parsedField, val);\n    });\n  },\n\n  '$allMatch': function (doc, userValue, parsedField, docFieldValue) {\n    if (!Array.isArray(docFieldValue)) {\n      return false;\n    }\n\n    /* istanbul ignore next */\n    if (docFieldValue.length === 0) {\n      return false;\n    }\n\n    if (typeof docFieldValue[0] === 'object') {\n      return docFieldValue.every(function (val) {\n        return rowFilter(val, userValue, Object.keys(userValue));\n      });\n    }\n\n    return docFieldValue.every(function (val) {\n      return matchSelector(userValue, doc, parsedField, val);\n    });\n  },\n\n  '$eq': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) === 0;\n  },\n\n  '$gte': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) >= 0;\n  },\n\n  '$gt': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) > 0;\n  },\n\n  '$lte': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) <= 0;\n  },\n\n  '$lt': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) < 0;\n  },\n\n  '$exists': function (doc, userValue, parsedField, docFieldValue) {\n    //a field that is null is still considered to exist\n    if (userValue) {\n      return fieldIsNotUndefined(docFieldValue);\n    }\n\n    return !fieldIsNotUndefined(docFieldValue);\n  },\n\n  '$mod': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldExists(docFieldValue) && modField(docFieldValue, userValue);\n  },\n\n  '$ne': function (doc, userValue, parsedField, docFieldValue) {\n    return userValue.every(function (neValue) {\n      return collate(docFieldValue, neValue) !== 0;\n    });\n  },\n  '$in': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldExists(docFieldValue) && arrayContainsValue(docFieldValue, userValue);\n  },\n\n  '$nin': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldExists(docFieldValue) && !arrayContainsValue(docFieldValue, userValue);\n  },\n\n  '$size': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldExists(docFieldValue) && arraySize(docFieldValue, userValue);\n  },\n\n  '$all': function (doc, userValue, parsedField, docFieldValue) {\n    return Array.isArray(docFieldValue) && arrayContainsAllValues(docFieldValue, userValue);\n  },\n\n  '$regex': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldExists(docFieldValue) && regexMatch(docFieldValue, userValue);\n  },\n\n  '$type': function (doc, userValue, parsedField, docFieldValue) {\n    return typeMatch(docFieldValue, userValue);\n  }\n};\n\n// return true if the given doc matches the supplied selector\nfunction matchesSelector(doc, selector) {\n  /* istanbul ignore if */\n  if (typeof selector !== 'object') {\n    // match the CouchDB error message\n    throw new Error('Selector error: expected a JSON object');\n  }\n\n  selector = massageSelector(selector);\n  var row = {\n    'doc': doc\n  };\n\n  var rowsMatched = filterInMemoryFields([row], { 'selector': selector }, Object.keys(selector));\n  return rowsMatched && rowsMatched.length === 1;\n}\n\nfunction evalFilter(input) {\n  return scopeEval('\"use strict\";\\nreturn ' + input + ';', {});\n}\n\nfunction evalView(input) {\n  var code = [\n    'return function(doc) {',\n    '  \"use strict\";',\n    '  var emitted = false;',\n    '  var emit = function (a, b) {',\n    '    emitted = true;',\n    '  };',\n    '  var view = ' + input + ';',\n    '  view(doc);',\n    '  if (emitted) {',\n    '    return true;',\n    '  }',\n    '};'\n  ].join('\\n');\n\n  return scopeEval(code, {});\n}\n\nfunction validate(opts, callback) {\n  if (opts.selector) {\n    if (opts.filter && opts.filter !== '_selector') {\n      var filterName = typeof opts.filter === 'string' ?\n        opts.filter : 'function';\n      return callback(new Error('selector invalid for filter \"' + filterName + '\"'));\n    }\n  }\n  callback();\n}\n\nfunction normalize(opts) {\n  if (opts.view && !opts.filter) {\n    opts.filter = '_view';\n  }\n\n  if (opts.selector && !opts.filter) {\n    opts.filter = '_selector';\n  }\n\n  if (opts.filter && typeof opts.filter === 'string') {\n    if (opts.filter === '_view') {\n      opts.view = normalizeDesignDocFunctionName(opts.view);\n    } else {\n      opts.filter = normalizeDesignDocFunctionName(opts.filter);\n    }\n  }\n}\n\nfunction shouldFilter(changesHandler, opts) {\n  return opts.filter && typeof opts.filter === 'string' &&\n    !opts.doc_ids && !isRemote(changesHandler.db);\n}\n\nfunction filter(changesHandler, opts) {\n  var callback = opts.complete;\n  if (opts.filter === '_view') {\n    if (!opts.view || typeof opts.view !== 'string') {\n      var err = createError(BAD_REQUEST,\n        '`view` filter parameter not found or invalid.');\n      return callback(err);\n    }\n    // fetch a view from a design doc, make it behave like a filter\n    var viewName = parseDesignDocFunctionName(opts.view);\n    changesHandler.db.get('_design/' + viewName[0], function (err, ddoc) {\n      /* istanbul ignore if */\n      if (changesHandler.isCancelled) {\n        return callback(null, {status: 'cancelled'});\n      }\n      /* istanbul ignore next */\n      if (err) {\n        return callback(generateErrorFromResponse(err));\n      }\n      var mapFun = ddoc && ddoc.views && ddoc.views[viewName[1]] &&\n        ddoc.views[viewName[1]].map;\n      if (!mapFun) {\n        return callback(createError(MISSING_DOC,\n          (ddoc.views ? 'missing json key: ' + viewName[1] :\n            'missing json key: views')));\n      }\n      opts.filter = evalView(mapFun);\n      changesHandler.doChanges(opts);\n    });\n  } else if (opts.selector) {\n    opts.filter = function (doc) {\n      return matchesSelector(doc, opts.selector);\n    };\n    changesHandler.doChanges(opts);\n  } else {\n    // fetch a filter from a design doc\n    var filterName = parseDesignDocFunctionName(opts.filter);\n    changesHandler.db.get('_design/' + filterName[0], function (err, ddoc) {\n      /* istanbul ignore if */\n      if (changesHandler.isCancelled) {\n        return callback(null, {status: 'cancelled'});\n      }\n      /* istanbul ignore next */\n      if (err) {\n        return callback(generateErrorFromResponse(err));\n      }\n      var filterFun = ddoc && ddoc.filters && ddoc.filters[filterName[1]];\n      if (!filterFun) {\n        return callback(createError(MISSING_DOC,\n          ((ddoc && ddoc.filters) ? 'missing json key: ' + filterName[1]\n            : 'missing json key: filters')));\n      }\n      opts.filter = evalFilter(filterFun);\n      changesHandler.doChanges(opts);\n    });\n  }\n}\n\nfunction applyChangesFilterPlugin(PouchDB) {\n  PouchDB._changesFilterPlugin = {\n    validate: validate,\n    normalize: normalize,\n    shouldFilter: shouldFilter,\n    filter: filter\n  };\n}\n\n// TODO: remove from pouchdb-core (breaking)\nPouchDB.plugin(debugPouch);\n\n// TODO: remove from pouchdb-core (breaking)\nPouchDB.plugin(applyChangesFilterPlugin);\n\nPouchDB.version = version;\n\nfunction toObject(array) {\n  return array.reduce(function (obj, item) {\n    obj[item] = true;\n    return obj;\n  }, {});\n}\n// List of top level reserved words for doc\nvar reservedWords = toObject([\n  '_id',\n  '_rev',\n  '_attachments',\n  '_deleted',\n  '_revisions',\n  '_revs_info',\n  '_conflicts',\n  '_deleted_conflicts',\n  '_local_seq',\n  '_rev_tree',\n  //replication documents\n  '_replication_id',\n  '_replication_state',\n  '_replication_state_time',\n  '_replication_state_reason',\n  '_replication_stats',\n  // Specific to Couchbase Sync Gateway\n  '_removed'\n]);\n\n// List of reserved words that should end up the document\nvar dataWords = toObject([\n  '_attachments',\n  //replication documents\n  '_replication_id',\n  '_replication_state',\n  '_replication_state_time',\n  '_replication_state_reason',\n  '_replication_stats'\n]);\n\nfunction parseRevisionInfo(rev$$1) {\n  if (!/^\\d+-./.test(rev$$1)) {\n    return createError(INVALID_REV);\n  }\n  var idx = rev$$1.indexOf('-');\n  var left = rev$$1.substring(0, idx);\n  var right = rev$$1.substring(idx + 1);\n  return {\n    prefix: parseInt(left, 10),\n    id: right\n  };\n}\n\nfunction makeRevTreeFromRevisions(revisions, opts) {\n  var pos = revisions.start - revisions.ids.length + 1;\n\n  var revisionIds = revisions.ids;\n  var ids = [revisionIds[0], opts, []];\n\n  for (var i = 1, len = revisionIds.length; i < len; i++) {\n    ids = [revisionIds[i], {status: 'missing'}, [ids]];\n  }\n\n  return [{\n    pos: pos,\n    ids: ids\n  }];\n}\n\n// Preprocess documents, parse their revisions, assign an id and a\n// revision for new writes that are missing them, etc\nfunction parseDoc(doc, newEdits) {\n\n  var nRevNum;\n  var newRevId;\n  var revInfo;\n  var opts = {status: 'available'};\n  if (doc._deleted) {\n    opts.deleted = true;\n  }\n\n  if (newEdits) {\n    if (!doc._id) {\n      doc._id = uuid();\n    }\n    newRevId = rev();\n    if (doc._rev) {\n      revInfo = parseRevisionInfo(doc._rev);\n      if (revInfo.error) {\n        return revInfo;\n      }\n      doc._rev_tree = [{\n        pos: revInfo.prefix,\n        ids: [revInfo.id, {status: 'missing'}, [[newRevId, opts, []]]]\n      }];\n      nRevNum = revInfo.prefix + 1;\n    } else {\n      doc._rev_tree = [{\n        pos: 1,\n        ids : [newRevId, opts, []]\n      }];\n      nRevNum = 1;\n    }\n  } else {\n    if (doc._revisions) {\n      doc._rev_tree = makeRevTreeFromRevisions(doc._revisions, opts);\n      nRevNum = doc._revisions.start;\n      newRevId = doc._revisions.ids[0];\n    }\n    if (!doc._rev_tree) {\n      revInfo = parseRevisionInfo(doc._rev);\n      if (revInfo.error) {\n        return revInfo;\n      }\n      nRevNum = revInfo.prefix;\n      newRevId = revInfo.id;\n      doc._rev_tree = [{\n        pos: nRevNum,\n        ids: [newRevId, opts, []]\n      }];\n    }\n  }\n\n  invalidIdError(doc._id);\n\n  doc._rev = nRevNum + '-' + newRevId;\n\n  var result = {metadata : {}, data : {}};\n  for (var key in doc) {\n    /* istanbul ignore else */\n    if (Object.prototype.hasOwnProperty.call(doc, key)) {\n      var specialKey = key[0] === '_';\n      if (specialKey && !reservedWords[key]) {\n        var error = createError(DOC_VALIDATION, key);\n        error.message = DOC_VALIDATION.message + ': ' + key;\n        throw error;\n      } else if (specialKey && !dataWords[key]) {\n        result.metadata[key.slice(1)] = doc[key];\n      } else {\n        result.data[key] = doc[key];\n      }\n    }\n  }\n  return result;\n}\n\nvar thisAtob = function (str) {\n  return atob(str);\n};\n\nvar thisBtoa = function (str) {\n  return btoa(str);\n};\n\n// Abstracts constructing a Blob object, so it also works in older\n// browsers that don't support the native Blob constructor (e.g.\n// old QtWebKit versions, Android < 4.4).\nfunction createBlob(parts, properties) {\n  /* global BlobBuilder,MSBlobBuilder,MozBlobBuilder,WebKitBlobBuilder */\n  parts = parts || [];\n  properties = properties || {};\n  try {\n    return new Blob(parts, properties);\n  } catch (e) {\n    if (e.name !== \"TypeError\") {\n      throw e;\n    }\n    var Builder = typeof BlobBuilder !== 'undefined' ? BlobBuilder :\n                  typeof MSBlobBuilder !== 'undefined' ? MSBlobBuilder :\n                  typeof MozBlobBuilder !== 'undefined' ? MozBlobBuilder :\n                  WebKitBlobBuilder;\n    var builder = new Builder();\n    for (var i = 0; i < parts.length; i += 1) {\n      builder.append(parts[i]);\n    }\n    return builder.getBlob(properties.type);\n  }\n}\n\n// From http://stackoverflow.com/questions/14967647/ (continues on next line)\n// encode-decode-image-with-base64-breaks-image (2013-04-21)\nfunction binaryStringToArrayBuffer(bin) {\n  var length = bin.length;\n  var buf = new ArrayBuffer(length);\n  var arr = new Uint8Array(buf);\n  for (var i = 0; i < length; i++) {\n    arr[i] = bin.charCodeAt(i);\n  }\n  return buf;\n}\n\nfunction binStringToBluffer(binString, type) {\n  return createBlob([binaryStringToArrayBuffer(binString)], {type: type});\n}\n\nfunction b64ToBluffer(b64, type) {\n  return binStringToBluffer(thisAtob(b64), type);\n}\n\n//Can't find original post, but this is close\n//http://stackoverflow.com/questions/6965107/ (continues on next line)\n//converting-between-strings-and-arraybuffers\nfunction arrayBufferToBinaryString(buffer) {\n  var binary = '';\n  var bytes = new Uint8Array(buffer);\n  var length = bytes.byteLength;\n  for (var i = 0; i < length; i++) {\n    binary += String.fromCharCode(bytes[i]);\n  }\n  return binary;\n}\n\n// shim for browsers that don't support it\nfunction readAsBinaryString(blob, callback) {\n  if (typeof FileReader === 'undefined') {\n    // fix for Firefox in a web worker\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=901097\n    return callback(arrayBufferToBinaryString(\n      new FileReaderSync().readAsArrayBuffer(blob)));\n  }\n\n  var reader = new FileReader();\n  var hasBinaryString = typeof reader.readAsBinaryString === 'function';\n  reader.onloadend = function (e) {\n    var result = e.target.result || '';\n    if (hasBinaryString) {\n      return callback(result);\n    }\n    callback(arrayBufferToBinaryString(result));\n  };\n  if (hasBinaryString) {\n    reader.readAsBinaryString(blob);\n  } else {\n    reader.readAsArrayBuffer(blob);\n  }\n}\n\nfunction blobToBinaryString(blobOrBuffer, callback) {\n  readAsBinaryString(blobOrBuffer, function (bin) {\n    callback(bin);\n  });\n}\n\nfunction blobToBase64(blobOrBuffer, callback) {\n  blobToBinaryString(blobOrBuffer, function (base64) {\n    callback(thisBtoa(base64));\n  });\n}\n\n// simplified API. universal browser support is assumed\nfunction readAsArrayBuffer(blob, callback) {\n  if (typeof FileReader === 'undefined') {\n    // fix for Firefox in a web worker:\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=901097\n    return callback(new FileReaderSync().readAsArrayBuffer(blob));\n  }\n\n  var reader = new FileReader();\n  reader.onloadend = function (e) {\n    var result = e.target.result || new ArrayBuffer(0);\n    callback(result);\n  };\n  reader.readAsArrayBuffer(blob);\n}\n\n// this is not used in the browser\n\nvar setImmediateShim = global.setImmediate || global.setTimeout;\nvar MD5_CHUNK_SIZE = 32768;\n\nfunction rawToBase64(raw) {\n  return thisBtoa(raw);\n}\n\nfunction sliceBlob(blob, start, end) {\n  if (blob.webkitSlice) {\n    return blob.webkitSlice(start, end);\n  }\n  return blob.slice(start, end);\n}\n\nfunction appendBlob(buffer, blob, start, end, callback) {\n  if (start > 0 || end < blob.size) {\n    // only slice blob if we really need to\n    blob = sliceBlob(blob, start, end);\n  }\n  readAsArrayBuffer(blob, function (arrayBuffer) {\n    buffer.append(arrayBuffer);\n    callback();\n  });\n}\n\nfunction appendString(buffer, string, start, end, callback) {\n  if (start > 0 || end < string.length) {\n    // only create a substring if we really need to\n    string = string.substring(start, end);\n  }\n  buffer.appendBinary(string);\n  callback();\n}\n\nfunction binaryMd5(data, callback) {\n  var inputIsString = typeof data === 'string';\n  var len = inputIsString ? data.length : data.size;\n  var chunkSize = Math.min(MD5_CHUNK_SIZE, len);\n  var chunks = Math.ceil(len / chunkSize);\n  var currentChunk = 0;\n  var buffer = inputIsString ? new Md5() : new Md5.ArrayBuffer();\n\n  var append = inputIsString ? appendString : appendBlob;\n\n  function next() {\n    setImmediateShim(loadNextChunk);\n  }\n\n  function done() {\n    var raw = buffer.end(true);\n    var base64 = rawToBase64(raw);\n    callback(base64);\n    buffer.destroy();\n  }\n\n  function loadNextChunk() {\n    var start = currentChunk * chunkSize;\n    var end = start + chunkSize;\n    currentChunk++;\n    if (currentChunk < chunks) {\n      append(buffer, data, start, end, next);\n    } else {\n      append(buffer, data, start, end, done);\n    }\n  }\n  loadNextChunk();\n}\n\nfunction stringMd5(string) {\n  return Md5.hash(string);\n}\n\nfunction parseBase64(data) {\n  try {\n    return thisAtob(data);\n  } catch (e) {\n    var err = createError(BAD_ARG,\n      'Attachment is not a valid base64 string');\n    return {error: err};\n  }\n}\n\nfunction preprocessString(att, blobType, callback) {\n  var asBinary = parseBase64(att.data);\n  if (asBinary.error) {\n    return callback(asBinary.error);\n  }\n\n  att.length = asBinary.length;\n  if (blobType === 'blob') {\n    att.data = binStringToBluffer(asBinary, att.content_type);\n  } else if (blobType === 'base64') {\n    att.data = thisBtoa(asBinary);\n  } else { // binary\n    att.data = asBinary;\n  }\n  binaryMd5(asBinary, function (result) {\n    att.digest = 'md5-' + result;\n    callback();\n  });\n}\n\nfunction preprocessBlob(att, blobType, callback) {\n  binaryMd5(att.data, function (md5) {\n    att.digest = 'md5-' + md5;\n    // size is for blobs (browser), length is for buffers (node)\n    att.length = att.data.size || att.data.length || 0;\n    if (blobType === 'binary') {\n      blobToBinaryString(att.data, function (binString) {\n        att.data = binString;\n        callback();\n      });\n    } else if (blobType === 'base64') {\n      blobToBase64(att.data, function (b64) {\n        att.data = b64;\n        callback();\n      });\n    } else {\n      callback();\n    }\n  });\n}\n\nfunction preprocessAttachment(att, blobType, callback) {\n  if (att.stub) {\n    return callback();\n  }\n  if (typeof att.data === 'string') { // input is a base64 string\n    preprocessString(att, blobType, callback);\n  } else { // input is a blob\n    preprocessBlob(att, blobType, callback);\n  }\n}\n\nfunction preprocessAttachments(docInfos, blobType, callback) {\n\n  if (!docInfos.length) {\n    return callback();\n  }\n\n  var docv = 0;\n  var overallErr;\n\n  docInfos.forEach(function (docInfo) {\n    var attachments = docInfo.data && docInfo.data._attachments ?\n      Object.keys(docInfo.data._attachments) : [];\n    var recv = 0;\n\n    if (!attachments.length) {\n      return done();\n    }\n\n    function processedAttachment(err) {\n      overallErr = err;\n      recv++;\n      if (recv === attachments.length) {\n        done();\n      }\n    }\n\n    for (var key in docInfo.data._attachments) {\n      if (docInfo.data._attachments.hasOwnProperty(key)) {\n        preprocessAttachment(docInfo.data._attachments[key],\n          blobType, processedAttachment);\n      }\n    }\n  });\n\n  function done() {\n    docv++;\n    if (docInfos.length === docv) {\n      if (overallErr) {\n        callback(overallErr);\n      } else {\n        callback();\n      }\n    }\n  }\n}\n\nfunction updateDoc(revLimit, prev, docInfo, results,\n                   i, cb, writeDoc, newEdits) {\n\n  if (revExists(prev.rev_tree, docInfo.metadata.rev)) {\n    results[i] = docInfo;\n    return cb();\n  }\n\n  // sometimes this is pre-calculated. historically not always\n  var previousWinningRev = prev.winningRev || winningRev(prev);\n  var previouslyDeleted = 'deleted' in prev ? prev.deleted :\n    isDeleted(prev, previousWinningRev);\n  var deleted = 'deleted' in docInfo.metadata ? docInfo.metadata.deleted :\n    isDeleted(docInfo.metadata);\n  var isRoot = /^1-/.test(docInfo.metadata.rev);\n\n  if (previouslyDeleted && !deleted && newEdits && isRoot) {\n    var newDoc = docInfo.data;\n    newDoc._rev = previousWinningRev;\n    newDoc._id = docInfo.metadata.id;\n    docInfo = parseDoc(newDoc, newEdits);\n  }\n\n  var merged = merge(prev.rev_tree, docInfo.metadata.rev_tree[0], revLimit);\n\n  var inConflict = newEdits && ((\n    (previouslyDeleted && deleted && merged.conflicts !== 'new_leaf') ||\n    (!previouslyDeleted && merged.conflicts !== 'new_leaf') ||\n    (previouslyDeleted && !deleted && merged.conflicts === 'new_branch')));\n\n  if (inConflict) {\n    var err = createError(REV_CONFLICT);\n    results[i] = err;\n    return cb();\n  }\n\n  var newRev = docInfo.metadata.rev;\n  docInfo.metadata.rev_tree = merged.tree;\n  docInfo.stemmedRevs = merged.stemmedRevs || [];\n  /* istanbul ignore else */\n  if (prev.rev_map) {\n    docInfo.metadata.rev_map = prev.rev_map; // used only by leveldb\n  }\n\n  // recalculate\n  var winningRev$$1 = winningRev(docInfo.metadata);\n  var winningRevIsDeleted = isDeleted(docInfo.metadata, winningRev$$1);\n\n  // calculate the total number of documents that were added/removed,\n  // from the perspective of total_rows/doc_count\n  var delta = (previouslyDeleted === winningRevIsDeleted) ? 0 :\n    previouslyDeleted < winningRevIsDeleted ? -1 : 1;\n\n  var newRevIsDeleted;\n  if (newRev === winningRev$$1) {\n    // if the new rev is the same as the winning rev, we can reuse that value\n    newRevIsDeleted = winningRevIsDeleted;\n  } else {\n    // if they're not the same, then we need to recalculate\n    newRevIsDeleted = isDeleted(docInfo.metadata, newRev);\n  }\n\n  writeDoc(docInfo, winningRev$$1, winningRevIsDeleted, newRevIsDeleted,\n    true, delta, i, cb);\n}\n\nfunction rootIsMissing(docInfo) {\n  return docInfo.metadata.rev_tree[0].ids[1].status === 'missing';\n}\n\nfunction processDocs(revLimit, docInfos, api, fetchedDocs, tx, results,\n                     writeDoc, opts, overallCallback) {\n\n  // Default to 1000 locally\n  revLimit = revLimit || 1000;\n\n  function insertDoc(docInfo, resultsIdx, callback) {\n    // Cant insert new deleted documents\n    var winningRev$$1 = winningRev(docInfo.metadata);\n    var deleted = isDeleted(docInfo.metadata, winningRev$$1);\n    if ('was_delete' in opts && deleted) {\n      results[resultsIdx] = createError(MISSING_DOC, 'deleted');\n      return callback();\n    }\n\n    // 4712 - detect whether a new document was inserted with a _rev\n    var inConflict = newEdits && rootIsMissing(docInfo);\n\n    if (inConflict) {\n      var err = createError(REV_CONFLICT);\n      results[resultsIdx] = err;\n      return callback();\n    }\n\n    var delta = deleted ? 0 : 1;\n\n    writeDoc(docInfo, winningRev$$1, deleted, deleted, false,\n      delta, resultsIdx, callback);\n  }\n\n  var newEdits = opts.new_edits;\n  var idsToDocs = new ExportedMap();\n\n  var docsDone = 0;\n  var docsToDo = docInfos.length;\n\n  function checkAllDocsDone() {\n    if (++docsDone === docsToDo && overallCallback) {\n      overallCallback();\n    }\n  }\n\n  docInfos.forEach(function (currentDoc, resultsIdx) {\n\n    if (currentDoc._id && isLocalId(currentDoc._id)) {\n      var fun = currentDoc._deleted ? '_removeLocal' : '_putLocal';\n      api[fun](currentDoc, {ctx: tx}, function (err, res) {\n        results[resultsIdx] = err || res;\n        checkAllDocsDone();\n      });\n      return;\n    }\n\n    var id = currentDoc.metadata.id;\n    if (idsToDocs.has(id)) {\n      docsToDo--; // duplicate\n      idsToDocs.get(id).push([currentDoc, resultsIdx]);\n    } else {\n      idsToDocs.set(id, [[currentDoc, resultsIdx]]);\n    }\n  });\n\n  // in the case of new_edits, the user can provide multiple docs\n  // with the same id. these need to be processed sequentially\n  idsToDocs.forEach(function (docs, id) {\n    var numDone = 0;\n\n    function docWritten() {\n      if (++numDone < docs.length) {\n        nextDoc();\n      } else {\n        checkAllDocsDone();\n      }\n    }\n    function nextDoc() {\n      var value = docs[numDone];\n      var currentDoc = value[0];\n      var resultsIdx = value[1];\n\n      if (fetchedDocs.has(id)) {\n        updateDoc(revLimit, fetchedDocs.get(id), currentDoc, results,\n          resultsIdx, docWritten, writeDoc, newEdits);\n      } else {\n        // Ensure stemming applies to new writes as well\n        var merged = merge([], currentDoc.metadata.rev_tree[0], revLimit);\n        currentDoc.metadata.rev_tree = merged.tree;\n        currentDoc.stemmedRevs = merged.stemmedRevs || [];\n        insertDoc(currentDoc, resultsIdx, docWritten);\n      }\n    }\n    nextDoc();\n  });\n}\n\n// IndexedDB requires a versioned database structure, so we use the\n// version here to manage migrations.\nvar ADAPTER_VERSION = 5;\n\n// The object stores created for each database\n// DOC_STORE stores the document meta data, its revision history and state\n// Keyed by document id\nvar DOC_STORE = 'document-store';\n// BY_SEQ_STORE stores a particular version of a document, keyed by its\n// sequence id\nvar BY_SEQ_STORE = 'by-sequence';\n// Where we store attachments\nvar ATTACH_STORE = 'attach-store';\n// Where we store many-to-many relations\n// between attachment digests and seqs\nvar ATTACH_AND_SEQ_STORE = 'attach-seq-store';\n\n// Where we store database-wide meta data in a single record\n// keyed by id: META_STORE\nvar META_STORE = 'meta-store';\n// Where we store local documents\nvar LOCAL_STORE = 'local-store';\n// Where we detect blob support\nvar DETECT_BLOB_SUPPORT_STORE = 'detect-blob-support';\n\nfunction safeJsonParse(str) {\n  // This try/catch guards against stack overflow errors.\n  // JSON.parse() is faster than vuvuzela.parse() but vuvuzela\n  // cannot overflow.\n  try {\n    return JSON.parse(str);\n  } catch (e) {\n    /* istanbul ignore next */\n    return vuvuzela.parse(str);\n  }\n}\n\nfunction safeJsonStringify(json) {\n  try {\n    return JSON.stringify(json);\n  } catch (e) {\n    /* istanbul ignore next */\n    return vuvuzela.stringify(json);\n  }\n}\n\nfunction idbError(callback) {\n  return function (evt) {\n    var message = 'unknown_error';\n    if (evt.target && evt.target.error) {\n      message = evt.target.error.name || evt.target.error.message;\n    }\n    callback(createError(IDB_ERROR, message, evt.type));\n  };\n}\n\n// Unfortunately, the metadata has to be stringified\n// when it is put into the database, because otherwise\n// IndexedDB can throw errors for deeply-nested objects.\n// Originally we just used JSON.parse/JSON.stringify; now\n// we use this custom vuvuzela library that avoids recursion.\n// If we could do it all over again, we'd probably use a\n// format for the revision trees other than JSON.\nfunction encodeMetadata(metadata, winningRev, deleted) {\n  return {\n    data: safeJsonStringify(metadata),\n    winningRev: winningRev,\n    deletedOrLocal: deleted ? '1' : '0',\n    seq: metadata.seq, // highest seq for this doc\n    id: metadata.id\n  };\n}\n\nfunction decodeMetadata(storedObject) {\n  if (!storedObject) {\n    return null;\n  }\n  var metadata = safeJsonParse(storedObject.data);\n  metadata.winningRev = storedObject.winningRev;\n  metadata.deleted = storedObject.deletedOrLocal === '1';\n  metadata.seq = storedObject.seq;\n  return metadata;\n}\n\n// read the doc back out from the database. we don't store the\n// _id or _rev because we already have _doc_id_rev.\nfunction decodeDoc(doc) {\n  if (!doc) {\n    return doc;\n  }\n  var idx = doc._doc_id_rev.lastIndexOf(':');\n  doc._id = doc._doc_id_rev.substring(0, idx - 1);\n  doc._rev = doc._doc_id_rev.substring(idx + 1);\n  delete doc._doc_id_rev;\n  return doc;\n}\n\n// Read a blob from the database, encoding as necessary\n// and translating from base64 if the IDB doesn't support\n// native Blobs\nfunction readBlobData(body, type, asBlob, callback) {\n  if (asBlob) {\n    if (!body) {\n      callback(createBlob([''], {type: type}));\n    } else if (typeof body !== 'string') { // we have blob support\n      callback(body);\n    } else { // no blob support\n      callback(b64ToBluffer(body, type));\n    }\n  } else { // as base64 string\n    if (!body) {\n      callback('');\n    } else if (typeof body !== 'string') { // we have blob support\n      readAsBinaryString(body, function (binary) {\n        callback(thisBtoa(binary));\n      });\n    } else { // no blob support\n      callback(body);\n    }\n  }\n}\n\nfunction fetchAttachmentsIfNecessary(doc, opts, txn, cb) {\n  var attachments = Object.keys(doc._attachments || {});\n  if (!attachments.length) {\n    return cb && cb();\n  }\n  var numDone = 0;\n\n  function checkDone() {\n    if (++numDone === attachments.length && cb) {\n      cb();\n    }\n  }\n\n  function fetchAttachment(doc, att) {\n    var attObj = doc._attachments[att];\n    var digest = attObj.digest;\n    var req = txn.objectStore(ATTACH_STORE).get(digest);\n    req.onsuccess = function (e) {\n      attObj.body = e.target.result.body;\n      checkDone();\n    };\n  }\n\n  attachments.forEach(function (att) {\n    if (opts.attachments && opts.include_docs) {\n      fetchAttachment(doc, att);\n    } else {\n      doc._attachments[att].stub = true;\n      checkDone();\n    }\n  });\n}\n\n// IDB-specific postprocessing necessary because\n// we don't know whether we stored a true Blob or\n// a base64-encoded string, and if it's a Blob it\n// needs to be read outside of the transaction context\nfunction postProcessAttachments(results, asBlob) {\n  return PouchPromise.all(results.map(function (row) {\n    if (row.doc && row.doc._attachments) {\n      var attNames = Object.keys(row.doc._attachments);\n      return PouchPromise.all(attNames.map(function (att) {\n        var attObj = row.doc._attachments[att];\n        if (!('body' in attObj)) { // already processed\n          return;\n        }\n        var body = attObj.body;\n        var type = attObj.content_type;\n        return new PouchPromise(function (resolve) {\n          readBlobData(body, type, asBlob, function (data) {\n            row.doc._attachments[att] = $inject_Object_assign(\n              pick(attObj, ['digest', 'content_type']),\n              {data: data}\n            );\n            resolve();\n          });\n        });\n      }));\n    }\n  }));\n}\n\nfunction compactRevs(revs, docId, txn) {\n\n  var possiblyOrphanedDigests = [];\n  var seqStore = txn.objectStore(BY_SEQ_STORE);\n  var attStore = txn.objectStore(ATTACH_STORE);\n  var attAndSeqStore = txn.objectStore(ATTACH_AND_SEQ_STORE);\n  var count = revs.length;\n\n  function checkDone() {\n    count--;\n    if (!count) { // done processing all revs\n      deleteOrphanedAttachments();\n    }\n  }\n\n  function deleteOrphanedAttachments() {\n    if (!possiblyOrphanedDigests.length) {\n      return;\n    }\n    possiblyOrphanedDigests.forEach(function (digest) {\n      var countReq = attAndSeqStore.index('digestSeq').count(\n        IDBKeyRange.bound(\n          digest + '::', digest + '::\\uffff', false, false));\n      countReq.onsuccess = function (e) {\n        var count = e.target.result;\n        if (!count) {\n          // orphaned\n          attStore[\"delete\"](digest);\n        }\n      };\n    });\n  }\n\n  revs.forEach(function (rev$$1) {\n    var index = seqStore.index('_doc_id_rev');\n    var key = docId + \"::\" + rev$$1;\n    index.getKey(key).onsuccess = function (e) {\n      var seq = e.target.result;\n      if (typeof seq !== 'number') {\n        return checkDone();\n      }\n      seqStore[\"delete\"](seq);\n\n      var cursor = attAndSeqStore.index('seq')\n        .openCursor(IDBKeyRange.only(seq));\n\n      cursor.onsuccess = function (event) {\n        var cursor = event.target.result;\n        if (cursor) {\n          var digest = cursor.value.digestSeq.split('::')[0];\n          possiblyOrphanedDigests.push(digest);\n          attAndSeqStore[\"delete\"](cursor.primaryKey);\n          cursor[\"continue\"]();\n        } else { // done\n          checkDone();\n        }\n      };\n    };\n  });\n}\n\nfunction openTransactionSafely(idb, stores, mode) {\n  try {\n    return {\n      txn: idb.transaction(stores, mode)\n    };\n  } catch (err) {\n    return {\n      error: err\n    };\n  }\n}\n\nvar changesHandler$$1 = new Changes();\n\nfunction idbBulkDocs(dbOpts, req, opts, api, idb, callback) {\n  var docInfos = req.docs;\n  var txn;\n  var docStore;\n  var bySeqStore;\n  var attachStore;\n  var attachAndSeqStore;\n  var metaStore;\n  var docInfoError;\n  var metaDoc;\n\n  for (var i = 0, len = docInfos.length; i < len; i++) {\n    var doc = docInfos[i];\n    if (doc._id && isLocalId(doc._id)) {\n      continue;\n    }\n    doc = docInfos[i] = parseDoc(doc, opts.new_edits);\n    if (doc.error && !docInfoError) {\n      docInfoError = doc;\n    }\n  }\n\n  if (docInfoError) {\n    return callback(docInfoError);\n  }\n\n  var allDocsProcessed = false;\n  var docCountDelta = 0;\n  var results = new Array(docInfos.length);\n  var fetchedDocs = new ExportedMap();\n  var preconditionErrored = false;\n  var blobType = api._meta.blobSupport ? 'blob' : 'base64';\n\n  preprocessAttachments(docInfos, blobType, function (err) {\n    if (err) {\n      return callback(err);\n    }\n    startTransaction();\n  });\n\n  function startTransaction() {\n\n    var stores = [\n      DOC_STORE, BY_SEQ_STORE,\n      ATTACH_STORE,\n      LOCAL_STORE, ATTACH_AND_SEQ_STORE,\n      META_STORE\n    ];\n    var txnResult = openTransactionSafely(idb, stores, 'readwrite');\n    if (txnResult.error) {\n      return callback(txnResult.error);\n    }\n    txn = txnResult.txn;\n    txn.onabort = idbError(callback);\n    txn.ontimeout = idbError(callback);\n    txn.oncomplete = complete;\n    docStore = txn.objectStore(DOC_STORE);\n    bySeqStore = txn.objectStore(BY_SEQ_STORE);\n    attachStore = txn.objectStore(ATTACH_STORE);\n    attachAndSeqStore = txn.objectStore(ATTACH_AND_SEQ_STORE);\n    metaStore = txn.objectStore(META_STORE);\n\n    metaStore.get(META_STORE).onsuccess = function (e) {\n      metaDoc = e.target.result;\n      updateDocCountIfReady();\n    };\n\n    verifyAttachments(function (err) {\n      if (err) {\n        preconditionErrored = true;\n        return callback(err);\n      }\n      fetchExistingDocs();\n    });\n  }\n\n  function onAllDocsProcessed() {\n    allDocsProcessed = true;\n    updateDocCountIfReady();\n  }\n\n  function idbProcessDocs() {\n    processDocs(dbOpts.revs_limit, docInfos, api, fetchedDocs,\n                txn, results, writeDoc, opts, onAllDocsProcessed);\n  }\n\n  function updateDocCountIfReady() {\n    if (!metaDoc || !allDocsProcessed) {\n      return;\n    }\n    // caching the docCount saves a lot of time in allDocs() and\n    // info(), which is why we go to all the trouble of doing this\n    metaDoc.docCount += docCountDelta;\n    metaStore.put(metaDoc);\n  }\n\n  function fetchExistingDocs() {\n\n    if (!docInfos.length) {\n      return;\n    }\n\n    var numFetched = 0;\n\n    function checkDone() {\n      if (++numFetched === docInfos.length) {\n        idbProcessDocs();\n      }\n    }\n\n    function readMetadata(event) {\n      var metadata = decodeMetadata(event.target.result);\n\n      if (metadata) {\n        fetchedDocs.set(metadata.id, metadata);\n      }\n      checkDone();\n    }\n\n    for (var i = 0, len = docInfos.length; i < len; i++) {\n      var docInfo = docInfos[i];\n      if (docInfo._id && isLocalId(docInfo._id)) {\n        checkDone(); // skip local docs\n        continue;\n      }\n      var req = docStore.get(docInfo.metadata.id);\n      req.onsuccess = readMetadata;\n    }\n  }\n\n  function complete() {\n    if (preconditionErrored) {\n      return;\n    }\n\n    changesHandler$$1.notify(api._meta.name);\n    callback(null, results);\n  }\n\n  function verifyAttachment(digest, callback) {\n\n    var req = attachStore.get(digest);\n    req.onsuccess = function (e) {\n      if (!e.target.result) {\n        var err = createError(MISSING_STUB,\n          'unknown stub attachment with digest ' +\n          digest);\n        err.status = 412;\n        callback(err);\n      } else {\n        callback();\n      }\n    };\n  }\n\n  function verifyAttachments(finish) {\n\n\n    var digests = [];\n    docInfos.forEach(function (docInfo) {\n      if (docInfo.data && docInfo.data._attachments) {\n        Object.keys(docInfo.data._attachments).forEach(function (filename) {\n          var att = docInfo.data._attachments[filename];\n          if (att.stub) {\n            digests.push(att.digest);\n          }\n        });\n      }\n    });\n    if (!digests.length) {\n      return finish();\n    }\n    var numDone = 0;\n    var err;\n\n    function checkDone() {\n      if (++numDone === digests.length) {\n        finish(err);\n      }\n    }\n    digests.forEach(function (digest) {\n      verifyAttachment(digest, function (attErr) {\n        if (attErr && !err) {\n          err = attErr;\n        }\n        checkDone();\n      });\n    });\n  }\n\n  function writeDoc(docInfo, winningRev$$1, winningRevIsDeleted, newRevIsDeleted,\n                    isUpdate, delta, resultsIdx, callback) {\n\n    docInfo.metadata.winningRev = winningRev$$1;\n    docInfo.metadata.deleted = winningRevIsDeleted;\n\n    var doc = docInfo.data;\n    doc._id = docInfo.metadata.id;\n    doc._rev = docInfo.metadata.rev;\n\n    if (newRevIsDeleted) {\n      doc._deleted = true;\n    }\n\n    var hasAttachments = doc._attachments &&\n      Object.keys(doc._attachments).length;\n    if (hasAttachments) {\n      return writeAttachments(docInfo, winningRev$$1, winningRevIsDeleted,\n        isUpdate, resultsIdx, callback);\n    }\n\n    docCountDelta += delta;\n    updateDocCountIfReady();\n\n    finishDoc(docInfo, winningRev$$1, winningRevIsDeleted,\n      isUpdate, resultsIdx, callback);\n  }\n\n  function finishDoc(docInfo, winningRev$$1, winningRevIsDeleted,\n                     isUpdate, resultsIdx, callback) {\n\n    var doc = docInfo.data;\n    var metadata = docInfo.metadata;\n\n    doc._doc_id_rev = metadata.id + '::' + metadata.rev;\n    delete doc._id;\n    delete doc._rev;\n\n    function afterPutDoc(e) {\n      var revsToDelete = docInfo.stemmedRevs || [];\n\n      if (isUpdate && api.auto_compaction) {\n        revsToDelete = revsToDelete.concat(compactTree(docInfo.metadata));\n      }\n\n      if (revsToDelete && revsToDelete.length) {\n        compactRevs(revsToDelete, docInfo.metadata.id, txn);\n      }\n\n      metadata.seq = e.target.result;\n      // Current _rev is calculated from _rev_tree on read\n      // delete metadata.rev;\n      var metadataToStore = encodeMetadata(metadata, winningRev$$1,\n        winningRevIsDeleted);\n      var metaDataReq = docStore.put(metadataToStore);\n      metaDataReq.onsuccess = afterPutMetadata;\n    }\n\n    function afterPutDocError(e) {\n      // ConstraintError, need to update, not put (see #1638 for details)\n      e.preventDefault(); // avoid transaction abort\n      e.stopPropagation(); // avoid transaction onerror\n      var index = bySeqStore.index('_doc_id_rev');\n      var getKeyReq = index.getKey(doc._doc_id_rev);\n      getKeyReq.onsuccess = function (e) {\n        var putReq = bySeqStore.put(doc, e.target.result);\n        putReq.onsuccess = afterPutDoc;\n      };\n    }\n\n    function afterPutMetadata() {\n      results[resultsIdx] = {\n        ok: true,\n        id: metadata.id,\n        rev: metadata.rev\n      };\n      fetchedDocs.set(docInfo.metadata.id, docInfo.metadata);\n      insertAttachmentMappings(docInfo, metadata.seq, callback);\n    }\n\n    var putReq = bySeqStore.put(doc);\n\n    putReq.onsuccess = afterPutDoc;\n    putReq.onerror = afterPutDocError;\n  }\n\n  function writeAttachments(docInfo, winningRev$$1, winningRevIsDeleted,\n                            isUpdate, resultsIdx, callback) {\n\n\n    var doc = docInfo.data;\n\n    var numDone = 0;\n    var attachments = Object.keys(doc._attachments);\n\n    function collectResults() {\n      if (numDone === attachments.length) {\n        finishDoc(docInfo, winningRev$$1, winningRevIsDeleted,\n          isUpdate, resultsIdx, callback);\n      }\n    }\n\n    function attachmentSaved() {\n      numDone++;\n      collectResults();\n    }\n\n    attachments.forEach(function (key) {\n      var att = docInfo.data._attachments[key];\n      if (!att.stub) {\n        var data = att.data;\n        delete att.data;\n        att.revpos = parseInt(winningRev$$1, 10);\n        var digest = att.digest;\n        saveAttachment(digest, data, attachmentSaved);\n      } else {\n        numDone++;\n        collectResults();\n      }\n    });\n  }\n\n  // map seqs to attachment digests, which\n  // we will need later during compaction\n  function insertAttachmentMappings(docInfo, seq, callback) {\n\n    var attsAdded = 0;\n    var attsToAdd = Object.keys(docInfo.data._attachments || {});\n\n    if (!attsToAdd.length) {\n      return callback();\n    }\n\n    function checkDone() {\n      if (++attsAdded === attsToAdd.length) {\n        callback();\n      }\n    }\n\n    function add(att) {\n      var digest = docInfo.data._attachments[att].digest;\n      var req = attachAndSeqStore.put({\n        seq: seq,\n        digestSeq: digest + '::' + seq\n      });\n\n      req.onsuccess = checkDone;\n      req.onerror = function (e) {\n        // this callback is for a constaint error, which we ignore\n        // because this docid/rev has already been associated with\n        // the digest (e.g. when new_edits == false)\n        e.preventDefault(); // avoid transaction abort\n        e.stopPropagation(); // avoid transaction onerror\n        checkDone();\n      };\n    }\n    for (var i = 0; i < attsToAdd.length; i++) {\n      add(attsToAdd[i]); // do in parallel\n    }\n  }\n\n  function saveAttachment(digest, data, callback) {\n\n\n    var getKeyReq = attachStore.count(digest);\n    getKeyReq.onsuccess = function (e) {\n      var count = e.target.result;\n      if (count) {\n        return callback(); // already exists\n      }\n      var newAtt = {\n        digest: digest,\n        body: data\n      };\n      var putReq = attachStore.put(newAtt);\n      putReq.onsuccess = callback;\n    };\n  }\n}\n\n// Abstraction over IDBCursor and getAll()/getAllKeys() that allows us to batch our operations\n// while falling back to a normal IDBCursor operation on browsers that don't support getAll() or\n// getAllKeys(). This allows for a much faster implementation than just straight-up cursors, because\n// we're not processing each document one-at-a-time.\nfunction runBatchedCursor(objectStore, keyRange, descending, batchSize, onBatch) {\n\n  // Bail out of getAll()/getAllKeys() in the following cases:\n  // 1) either method is unsupported - we need both\n  // 2) batchSize is 1 (might as well use IDBCursor), or batchSize is -1 (i.e. batchSize unlimited,\n  //    not really clear the user wants a batched approach where the entire DB is read into memory,\n  //    perhaps they are filtering on a per-doc basis)\n  // 3) descending – no real way to do this via getAll()/getAllKeys()\n\n  var useGetAll = typeof objectStore.getAll === 'function' &&\n    typeof objectStore.getAllKeys === 'function' &&\n    batchSize > 1 && !descending;\n\n  var keysBatch;\n  var valuesBatch;\n  var pseudoCursor;\n\n  function onGetAll(e) {\n    valuesBatch = e.target.result;\n    if (keysBatch) {\n      onBatch(keysBatch, valuesBatch, pseudoCursor);\n    }\n  }\n\n  function onGetAllKeys(e) {\n    keysBatch = e.target.result;\n    if (valuesBatch) {\n      onBatch(keysBatch, valuesBatch, pseudoCursor);\n    }\n  }\n\n  function continuePseudoCursor() {\n    if (!keysBatch.length) { // no more results\n      return onBatch();\n    }\n    // fetch next batch, exclusive start\n    var lastKey = keysBatch[keysBatch.length - 1];\n    var newKeyRange;\n    if (keyRange && keyRange.upper) {\n      try {\n        newKeyRange = IDBKeyRange.bound(lastKey, keyRange.upper,\n          true, keyRange.upperOpen);\n      } catch (e) {\n        if (e.name === \"DataError\" && e.code === 0) {\n          return onBatch(); // we're done, startkey and endkey are equal\n        }\n      }\n    } else {\n      newKeyRange = IDBKeyRange.lowerBound(lastKey, true);\n    }\n    keyRange = newKeyRange;\n    keysBatch = null;\n    valuesBatch = null;\n    objectStore.getAll(keyRange, batchSize).onsuccess = onGetAll;\n    objectStore.getAllKeys(keyRange, batchSize).onsuccess = onGetAllKeys;\n  }\n\n  function onCursor(e) {\n    var cursor = e.target.result;\n    if (!cursor) { // done\n      return onBatch();\n    }\n    // regular IDBCursor acts like a batch where batch size is always 1\n    onBatch([cursor.key], [cursor.value], cursor);\n  }\n\n  if (useGetAll) {\n    pseudoCursor = {\"continue\": continuePseudoCursor};\n    objectStore.getAll(keyRange, batchSize).onsuccess = onGetAll;\n    objectStore.getAllKeys(keyRange, batchSize).onsuccess = onGetAllKeys;\n  } else if (descending) {\n    objectStore.openCursor(keyRange, 'prev').onsuccess = onCursor;\n  } else {\n    objectStore.openCursor(keyRange).onsuccess = onCursor;\n  }\n}\n\n// simple shim for objectStore.getAll(), falling back to IDBCursor\nfunction getAll(objectStore, keyRange, onSuccess) {\n  if (typeof objectStore.getAll === 'function') {\n    // use native getAll\n    objectStore.getAll(keyRange).onsuccess = onSuccess;\n    return;\n  }\n  // fall back to cursors\n  var values = [];\n\n  function onCursor(e) {\n    var cursor = e.target.result;\n    if (cursor) {\n      values.push(cursor.value);\n      cursor[\"continue\"]();\n    } else {\n      onSuccess({\n        target: {\n          result: values\n        }\n      });\n    }\n  }\n\n  objectStore.openCursor(keyRange).onsuccess = onCursor;\n}\n\nfunction allDocsKeys(keys, docStore, onBatch) {\n  // It's not guaranted to be returned in right order  \n  var valuesBatch = [];\n  var count = 0;\n  keys.forEach(function (key, index) {\n    docStore.get(key).onsuccess = function (event) {\n      if (event.target.result) {\n        valuesBatch[index] = event.target.result;\n      } else {\n        valuesBatch[index] = {key: key, error: 'not_found'};\n      }\n      count++;\n      if (count === keys.length) {\n        onBatch(keys, valuesBatch, {});\n      }\n    };\n  });\n}\n\nfunction createKeyRange(start, end, inclusiveEnd, key, descending) {\n  try {\n    if (start && end) {\n      if (descending) {\n        return IDBKeyRange.bound(end, start, !inclusiveEnd, false);\n      } else {\n        return IDBKeyRange.bound(start, end, false, !inclusiveEnd);\n      }\n    } else if (start) {\n      if (descending) {\n        return IDBKeyRange.upperBound(start);\n      } else {\n        return IDBKeyRange.lowerBound(start);\n      }\n    } else if (end) {\n      if (descending) {\n        return IDBKeyRange.lowerBound(end, !inclusiveEnd);\n      } else {\n        return IDBKeyRange.upperBound(end, !inclusiveEnd);\n      }\n    } else if (key) {\n      return IDBKeyRange.only(key);\n    }\n  } catch (e) {\n    return {error: e};\n  }\n  return null;\n}\n\nfunction idbAllDocs(opts, idb, callback) {\n  var start = 'startkey' in opts ? opts.startkey : false;\n  var end = 'endkey' in opts ? opts.endkey : false;\n  var key = 'key' in opts ? opts.key : false;\n  var keys = 'keys' in opts ? opts.keys : false; \n  var skip = opts.skip || 0;\n  var limit = typeof opts.limit === 'number' ? opts.limit : -1;\n  var inclusiveEnd = opts.inclusive_end !== false;\n\n  var keyRange; \n  var keyRangeError;\n  if (!keys) {\n    keyRange = createKeyRange(start, end, inclusiveEnd, key, opts.descending);\n    keyRangeError = keyRange && keyRange.error;\n    if (keyRangeError && \n      !(keyRangeError.name === \"DataError\" && keyRangeError.code === 0)) {\n      // DataError with error code 0 indicates start is less than end, so\n      // can just do an empty query. Else need to throw\n      return callback(createError(IDB_ERROR,\n        keyRangeError.name, keyRangeError.message));\n    }\n  }\n\n  var stores = [DOC_STORE, BY_SEQ_STORE, META_STORE];\n\n  if (opts.attachments) {\n    stores.push(ATTACH_STORE);\n  }\n  var txnResult = openTransactionSafely(idb, stores, 'readonly');\n  if (txnResult.error) {\n    return callback(txnResult.error);\n  }\n  var txn = txnResult.txn;\n  txn.oncomplete = onTxnComplete;\n  txn.onabort = idbError(callback);\n  var docStore = txn.objectStore(DOC_STORE);\n  var seqStore = txn.objectStore(BY_SEQ_STORE);\n  var metaStore = txn.objectStore(META_STORE);\n  var docIdRevIndex = seqStore.index('_doc_id_rev');\n  var results = [];\n  var docCount;\n  var updateSeq;\n\n  metaStore.get(META_STORE).onsuccess = function (e) {\n    docCount = e.target.result.docCount;\n  };\n\n  /* istanbul ignore if */\n  if (opts.update_seq) {\n    getMaxUpdateSeq(seqStore, function (e) { \n      if (e.target.result && e.target.result.length > 0) {\n        updateSeq = e.target.result[0];\n      }\n    });\n  }\n\n  function getMaxUpdateSeq(objectStore, onSuccess) {\n    function onCursor(e) {\n      var cursor = e.target.result;\n      var maxKey = undefined;\n      if (cursor && cursor.key) {\n        maxKey = cursor.key;\n      } \n      return onSuccess({\n        target: {\n          result: [maxKey]\n        }\n      });\n    }\n    objectStore.openCursor(null, 'prev').onsuccess = onCursor;\n  }\n\n  // if the user specifies include_docs=true, then we don't\n  // want to block the main cursor while we're fetching the doc\n  function fetchDocAsynchronously(metadata, row, winningRev$$1) {\n    var key = metadata.id + \"::\" + winningRev$$1;\n    docIdRevIndex.get(key).onsuccess =  function onGetDoc(e) {\n      row.doc = decodeDoc(e.target.result);\n      if (opts.conflicts) {\n        var conflicts = collectConflicts(metadata);\n        if (conflicts.length) {\n          row.doc._conflicts = conflicts;\n        }\n      }\n      fetchAttachmentsIfNecessary(row.doc, opts, txn);\n    };\n  }\n\n  function allDocsInner(winningRev$$1, metadata) {\n    var row = {\n      id: metadata.id,\n      key: metadata.id,\n      value: {\n        rev: winningRev$$1\n      }\n    };\n    var deleted = metadata.deleted;\n    if (deleted) {\n      if (keys) {\n        results.push(row);\n        // deleted docs are okay with \"keys\" requests\n        row.value.deleted = true;\n        row.doc = null;\n      }\n    } else if (skip-- <= 0) {\n      results.push(row);\n      if (opts.include_docs) {\n        fetchDocAsynchronously(metadata, row, winningRev$$1);\n      }\n    }\n  }\n\n  function processBatch(batchValues) {\n    for (var i = 0, len = batchValues.length; i < len; i++) {\n      if (results.length === limit) {\n        break;\n      }\n      var batchValue = batchValues[i];\n      if (batchValue.error && keys) {\n        // key was not found with \"keys\" requests\n        results.push(batchValue);\n        continue;\n      }\n      var metadata = decodeMetadata(batchValue);\n      var winningRev$$1 = metadata.winningRev;\n      allDocsInner(winningRev$$1, metadata);\n    }\n  }\n\n  function onBatch(batchKeys, batchValues, cursor) {\n    if (!cursor) {\n      return;\n    }\n    processBatch(batchValues);\n    if (results.length < limit) {\n      cursor[\"continue\"]();\n    }\n  }\n\n  function onGetAll(e) {\n    var values = e.target.result;\n    if (opts.descending) {\n      values = values.reverse();\n    }\n    processBatch(values);\n  }\n\n  function onResultsReady() {\n    var returnVal = {\n      total_rows: docCount,\n      offset: opts.skip,\n      rows: results\n    };\n    \n    /* istanbul ignore if */\n    if (opts.update_seq && updateSeq !== undefined) {\n      returnVal.update_seq = updateSeq;\n    }\n    callback(null, returnVal);\n  }\n\n  function onTxnComplete() {\n    if (opts.attachments) {\n      postProcessAttachments(results, opts.binary).then(onResultsReady);\n    } else {\n      onResultsReady();\n    }\n  }\n\n  // don't bother doing any requests if start > end or limit === 0\n  if (keyRangeError || limit === 0) {\n    return;\n  }\n  if (keys) {\n    return allDocsKeys(opts.keys, docStore, onBatch);\n  }\n  if (limit === -1) { // just fetch everything\n    return getAll(docStore, keyRange, onGetAll);\n  }\n  // else do a cursor\n  // choose a batch size based on the skip, since we'll need to skip that many\n  runBatchedCursor(docStore, keyRange, opts.descending, limit + skip, onBatch);\n}\n\n//\n// Blobs are not supported in all versions of IndexedDB, notably\n// Chrome <37 and Android <5. In those versions, storing a blob will throw.\n//\n// Various other blob bugs exist in Chrome v37-42 (inclusive).\n// Detecting them is expensive and confusing to users, and Chrome 37-42\n// is at very low usage worldwide, so we do a hacky userAgent check instead.\n//\n// content-type bug: https://code.google.com/p/chromium/issues/detail?id=408120\n// 404 bug: https://code.google.com/p/chromium/issues/detail?id=447916\n// FileReader bug: https://code.google.com/p/chromium/issues/detail?id=447836\n//\nfunction checkBlobSupport(txn) {\n  return new PouchPromise(function (resolve) {\n    var blob$$1 = createBlob(['']);\n    var req = txn.objectStore(DETECT_BLOB_SUPPORT_STORE).put(blob$$1, 'key');\n\n    req.onsuccess = function () {\n      var matchedChrome = navigator.userAgent.match(/Chrome\\/(\\d+)/);\n      var matchedEdge = navigator.userAgent.match(/Edge\\//);\n      // MS Edge pretends to be Chrome 42:\n      // https://msdn.microsoft.com/en-us/library/hh869301%28v=vs.85%29.aspx\n      resolve(matchedEdge || !matchedChrome ||\n        parseInt(matchedChrome[1], 10) >= 43);\n    };\n\n    txn.onabort = function (e) {\n      // If the transaction aborts now its due to not being able to\n      // write to the database, likely due to the disk being full\n      e.preventDefault();\n      e.stopPropagation();\n      resolve(false);\n    };\n  })[\"catch\"](function () {\n    return false; // error, so assume unsupported\n  });\n}\n\nfunction countDocs(txn, cb) {\n  var index = txn.objectStore(DOC_STORE).index('deletedOrLocal');\n  index.count(IDBKeyRange.only('0')).onsuccess = function (e) {\n    cb(e.target.result);\n  };\n}\n\n// This task queue ensures that IDB open calls are done in their own tick\n// and sequentially - i.e. we wait for the async IDB open to *fully* complete\n// before calling the next one. This works around IE/Edge race conditions in IDB.\n\nvar running = false;\nvar queue = [];\n\nfunction tryCode(fun, err, res, PouchDB) {\n  try {\n    fun(err, res);\n  } catch (err) {\n    // Shouldn't happen, but in some odd cases\n    // IndexedDB implementations might throw a sync\n    // error, in which case this will at least log it.\n    PouchDB.emit('error', err);\n  }\n}\n\nfunction applyNext() {\n  if (running || !queue.length) {\n    return;\n  }\n  running = true;\n  queue.shift()();\n}\n\nfunction enqueueTask(action, callback, PouchDB) {\n  queue.push(function runAction() {\n    action(function runCallback(err, res) {\n      tryCode(callback, err, res, PouchDB);\n      running = false;\n      nextTick(function runNext() {\n        applyNext(PouchDB);\n      });\n    });\n  });\n  applyNext();\n}\n\nfunction changes(opts, api, dbName, idb) {\n  opts = clone(opts);\n\n  if (opts.continuous) {\n    var id = dbName + ':' + uuid();\n    changesHandler$$1.addListener(dbName, id, api, opts);\n    changesHandler$$1.notify(dbName);\n    return {\n      cancel: function () {\n        changesHandler$$1.removeListener(dbName, id);\n      }\n    };\n  }\n\n  var docIds = opts.doc_ids && new ExportedSet(opts.doc_ids);\n\n  opts.since = opts.since || 0;\n  var lastSeq = opts.since;\n\n  var limit = 'limit' in opts ? opts.limit : -1;\n  if (limit === 0) {\n    limit = 1; // per CouchDB _changes spec\n  }\n  var returnDocs;\n  if ('return_docs' in opts) {\n    returnDocs = opts.return_docs;\n  } else if ('returnDocs' in opts) {\n    // TODO: Remove 'returnDocs' in favor of 'return_docs' in a future release\n    returnDocs = opts.returnDocs;\n  } else {\n    returnDocs = true;\n  }\n\n  var results = [];\n  var numResults = 0;\n  var filter = filterChange(opts);\n  var docIdsToMetadata = new ExportedMap();\n\n  var txn;\n  var bySeqStore;\n  var docStore;\n  var docIdRevIndex;\n\n  function onBatch(batchKeys, batchValues, cursor) {\n    if (!cursor || !batchKeys.length) { // done\n      return;\n    }\n\n    var winningDocs = new Array(batchKeys.length);\n    var metadatas = new Array(batchKeys.length);\n\n    function processMetadataAndWinningDoc(metadata, winningDoc) {\n      var change = opts.processChange(winningDoc, metadata, opts);\n      lastSeq = change.seq = metadata.seq;\n\n      var filtered = filter(change);\n      if (typeof filtered === 'object') { // anything but true/false indicates error\n        return opts.complete(filtered);\n      }\n\n      if (filtered) {\n        numResults++;\n        if (returnDocs) {\n          results.push(change);\n        }\n        // process the attachment immediately\n        // for the benefit of live listeners\n        if (opts.attachments && opts.include_docs) {\n          fetchAttachmentsIfNecessary(winningDoc, opts, txn, function () {\n            postProcessAttachments([change], opts.binary).then(function () {\n              opts.onChange(change);\n            });\n          });\n        } else {\n          opts.onChange(change);\n        }\n      }\n    }\n\n    function onBatchDone() {\n      for (var i = 0, len = winningDocs.length; i < len; i++) {\n        if (numResults === limit) {\n          break;\n        }\n        var winningDoc = winningDocs[i];\n        if (!winningDoc) {\n          continue;\n        }\n        var metadata = metadatas[i];\n        processMetadataAndWinningDoc(metadata, winningDoc);\n      }\n\n      if (numResults !== limit) {\n        cursor[\"continue\"]();\n      }\n    }\n\n    // Fetch all metadatas/winningdocs from this batch in parallel, then process\n    // them all only once all data has been collected. This is done in parallel\n    // because it's faster than doing it one-at-a-time.\n    var numDone = 0;\n    batchValues.forEach(function (value, i) {\n      var doc = decodeDoc(value);\n      var seq = batchKeys[i];\n      fetchWinningDocAndMetadata(doc, seq, function (metadata, winningDoc) {\n        metadatas[i] = metadata;\n        winningDocs[i] = winningDoc;\n        if (++numDone === batchKeys.length) {\n          onBatchDone();\n        }\n      });\n    });\n  }\n\n  function onGetMetadata(doc, seq, metadata, cb) {\n    if (metadata.seq !== seq) {\n      // some other seq is later\n      return cb();\n    }\n\n    if (metadata.winningRev === doc._rev) {\n      // this is the winning doc\n      return cb(metadata, doc);\n    }\n\n    // fetch winning doc in separate request\n    var docIdRev = doc._id + '::' + metadata.winningRev;\n    var req = docIdRevIndex.get(docIdRev);\n    req.onsuccess = function (e) {\n      cb(metadata, decodeDoc(e.target.result));\n    };\n  }\n\n  function fetchWinningDocAndMetadata(doc, seq, cb) {\n    if (docIds && !docIds.has(doc._id)) {\n      return cb();\n    }\n\n    var metadata = docIdsToMetadata.get(doc._id);\n    if (metadata) { // cached\n      return onGetMetadata(doc, seq, metadata, cb);\n    }\n    // metadata not cached, have to go fetch it\n    docStore.get(doc._id).onsuccess = function (e) {\n      metadata = decodeMetadata(e.target.result);\n      docIdsToMetadata.set(doc._id, metadata);\n      onGetMetadata(doc, seq, metadata, cb);\n    };\n  }\n\n  function finish() {\n    opts.complete(null, {\n      results: results,\n      last_seq: lastSeq\n    });\n  }\n\n  function onTxnComplete() {\n    if (!opts.continuous && opts.attachments) {\n      // cannot guarantee that postProcessing was already done,\n      // so do it again\n      postProcessAttachments(results).then(finish);\n    } else {\n      finish();\n    }\n  }\n\n  var objectStores = [DOC_STORE, BY_SEQ_STORE];\n  if (opts.attachments) {\n    objectStores.push(ATTACH_STORE);\n  }\n  var txnResult = openTransactionSafely(idb, objectStores, 'readonly');\n  if (txnResult.error) {\n    return opts.complete(txnResult.error);\n  }\n  txn = txnResult.txn;\n  txn.onabort = idbError(opts.complete);\n  txn.oncomplete = onTxnComplete;\n\n  bySeqStore = txn.objectStore(BY_SEQ_STORE);\n  docStore = txn.objectStore(DOC_STORE);\n  docIdRevIndex = bySeqStore.index('_doc_id_rev');\n\n  var keyRange = (opts.since && !opts.descending) ?\n    IDBKeyRange.lowerBound(opts.since, true) : null;\n\n  runBatchedCursor(bySeqStore, keyRange, opts.descending, limit, onBatch);\n}\n\nvar cachedDBs = new ExportedMap();\nvar blobSupportPromise;\nvar openReqList = new ExportedMap();\n\nfunction IdbPouch(opts, callback) {\n  var api = this;\n\n  enqueueTask(function (thisCallback) {\n    init(api, opts, thisCallback);\n  }, callback, api.constructor);\n}\n\nfunction init(api, opts, callback) {\n\n  var dbName = opts.name;\n\n  var idb = null;\n  api._meta = null;\n\n  // called when creating a fresh new database\n  function createSchema(db) {\n    var docStore = db.createObjectStore(DOC_STORE, {keyPath : 'id'});\n    db.createObjectStore(BY_SEQ_STORE, {autoIncrement: true})\n      .createIndex('_doc_id_rev', '_doc_id_rev', {unique: true});\n    db.createObjectStore(ATTACH_STORE, {keyPath: 'digest'});\n    db.createObjectStore(META_STORE, {keyPath: 'id', autoIncrement: false});\n    db.createObjectStore(DETECT_BLOB_SUPPORT_STORE);\n\n    // added in v2\n    docStore.createIndex('deletedOrLocal', 'deletedOrLocal', {unique : false});\n\n    // added in v3\n    db.createObjectStore(LOCAL_STORE, {keyPath: '_id'});\n\n    // added in v4\n    var attAndSeqStore = db.createObjectStore(ATTACH_AND_SEQ_STORE,\n      {autoIncrement: true});\n    attAndSeqStore.createIndex('seq', 'seq');\n    attAndSeqStore.createIndex('digestSeq', 'digestSeq', {unique: true});\n  }\n\n  // migration to version 2\n  // unfortunately \"deletedOrLocal\" is a misnomer now that we no longer\n  // store local docs in the main doc-store, but whaddyagonnado\n  function addDeletedOrLocalIndex(txn, callback) {\n    var docStore = txn.objectStore(DOC_STORE);\n    docStore.createIndex('deletedOrLocal', 'deletedOrLocal', {unique : false});\n\n    docStore.openCursor().onsuccess = function (event) {\n      var cursor = event.target.result;\n      if (cursor) {\n        var metadata = cursor.value;\n        var deleted = isDeleted(metadata);\n        metadata.deletedOrLocal = deleted ? \"1\" : \"0\";\n        docStore.put(metadata);\n        cursor[\"continue\"]();\n      } else {\n        callback();\n      }\n    };\n  }\n\n  // migration to version 3 (part 1)\n  function createLocalStoreSchema(db) {\n    db.createObjectStore(LOCAL_STORE, {keyPath: '_id'})\n      .createIndex('_doc_id_rev', '_doc_id_rev', {unique: true});\n  }\n\n  // migration to version 3 (part 2)\n  function migrateLocalStore(txn, cb) {\n    var localStore = txn.objectStore(LOCAL_STORE);\n    var docStore = txn.objectStore(DOC_STORE);\n    var seqStore = txn.objectStore(BY_SEQ_STORE);\n\n    var cursor = docStore.openCursor();\n    cursor.onsuccess = function (event) {\n      var cursor = event.target.result;\n      if (cursor) {\n        var metadata = cursor.value;\n        var docId = metadata.id;\n        var local = isLocalId(docId);\n        var rev$$1 = winningRev(metadata);\n        if (local) {\n          var docIdRev = docId + \"::\" + rev$$1;\n          // remove all seq entries\n          // associated with this docId\n          var start = docId + \"::\";\n          var end = docId + \"::~\";\n          var index = seqStore.index('_doc_id_rev');\n          var range = IDBKeyRange.bound(start, end, false, false);\n          var seqCursor = index.openCursor(range);\n          seqCursor.onsuccess = function (e) {\n            seqCursor = e.target.result;\n            if (!seqCursor) {\n              // done\n              docStore[\"delete\"](cursor.primaryKey);\n              cursor[\"continue\"]();\n            } else {\n              var data = seqCursor.value;\n              if (data._doc_id_rev === docIdRev) {\n                localStore.put(data);\n              }\n              seqStore[\"delete\"](seqCursor.primaryKey);\n              seqCursor[\"continue\"]();\n            }\n          };\n        } else {\n          cursor[\"continue\"]();\n        }\n      } else if (cb) {\n        cb();\n      }\n    };\n  }\n\n  // migration to version 4 (part 1)\n  function addAttachAndSeqStore(db) {\n    var attAndSeqStore = db.createObjectStore(ATTACH_AND_SEQ_STORE,\n      {autoIncrement: true});\n    attAndSeqStore.createIndex('seq', 'seq');\n    attAndSeqStore.createIndex('digestSeq', 'digestSeq', {unique: true});\n  }\n\n  // migration to version 4 (part 2)\n  function migrateAttsAndSeqs(txn, callback) {\n    var seqStore = txn.objectStore(BY_SEQ_STORE);\n    var attStore = txn.objectStore(ATTACH_STORE);\n    var attAndSeqStore = txn.objectStore(ATTACH_AND_SEQ_STORE);\n\n    // need to actually populate the table. this is the expensive part,\n    // so as an optimization, check first that this database even\n    // contains attachments\n    var req = attStore.count();\n    req.onsuccess = function (e) {\n      var count = e.target.result;\n      if (!count) {\n        return callback(); // done\n      }\n\n      seqStore.openCursor().onsuccess = function (e) {\n        var cursor = e.target.result;\n        if (!cursor) {\n          return callback(); // done\n        }\n        var doc = cursor.value;\n        var seq = cursor.primaryKey;\n        var atts = Object.keys(doc._attachments || {});\n        var digestMap = {};\n        for (var j = 0; j < atts.length; j++) {\n          var att = doc._attachments[atts[j]];\n          digestMap[att.digest] = true; // uniq digests, just in case\n        }\n        var digests = Object.keys(digestMap);\n        for (j = 0; j < digests.length; j++) {\n          var digest = digests[j];\n          attAndSeqStore.put({\n            seq: seq,\n            digestSeq: digest + '::' + seq\n          });\n        }\n        cursor[\"continue\"]();\n      };\n    };\n  }\n\n  // migration to version 5\n  // Instead of relying on on-the-fly migration of metadata,\n  // this brings the doc-store to its modern form:\n  // - metadata.winningrev\n  // - metadata.seq\n  // - stringify the metadata when storing it\n  function migrateMetadata(txn) {\n\n    function decodeMetadataCompat(storedObject) {\n      if (!storedObject.data) {\n        // old format, when we didn't store it stringified\n        storedObject.deleted = storedObject.deletedOrLocal === '1';\n        return storedObject;\n      }\n      return decodeMetadata(storedObject);\n    }\n\n    // ensure that every metadata has a winningRev and seq,\n    // which was previously created on-the-fly but better to migrate\n    var bySeqStore = txn.objectStore(BY_SEQ_STORE);\n    var docStore = txn.objectStore(DOC_STORE);\n    var cursor = docStore.openCursor();\n    cursor.onsuccess = function (e) {\n      var cursor = e.target.result;\n      if (!cursor) {\n        return; // done\n      }\n      var metadata = decodeMetadataCompat(cursor.value);\n\n      metadata.winningRev = metadata.winningRev ||\n        winningRev(metadata);\n\n      function fetchMetadataSeq() {\n        // metadata.seq was added post-3.2.0, so if it's missing,\n        // we need to fetch it manually\n        var start = metadata.id + '::';\n        var end = metadata.id + '::\\uffff';\n        var req = bySeqStore.index('_doc_id_rev').openCursor(\n          IDBKeyRange.bound(start, end));\n\n        var metadataSeq = 0;\n        req.onsuccess = function (e) {\n          var cursor = e.target.result;\n          if (!cursor) {\n            metadata.seq = metadataSeq;\n            return onGetMetadataSeq();\n          }\n          var seq = cursor.primaryKey;\n          if (seq > metadataSeq) {\n            metadataSeq = seq;\n          }\n          cursor[\"continue\"]();\n        };\n      }\n\n      function onGetMetadataSeq() {\n        var metadataToStore = encodeMetadata(metadata,\n          metadata.winningRev, metadata.deleted);\n\n        var req = docStore.put(metadataToStore);\n        req.onsuccess = function () {\n          cursor[\"continue\"]();\n        };\n      }\n\n      if (metadata.seq) {\n        return onGetMetadataSeq();\n      }\n\n      fetchMetadataSeq();\n    };\n\n  }\n\n  api._remote = false;\n  api.type = function () {\n    return 'idb';\n  };\n\n  api._id = toPromise(function (callback) {\n    callback(null, api._meta.instanceId);\n  });\n\n  api._bulkDocs = function idb_bulkDocs(req, reqOpts, callback) {\n    idbBulkDocs(opts, req, reqOpts, api, idb, callback);\n  };\n\n  // First we look up the metadata in the ids database, then we fetch the\n  // current revision(s) from the by sequence store\n  api._get = function idb_get(id, opts, callback) {\n    var doc;\n    var metadata;\n    var err;\n    var txn = opts.ctx;\n    if (!txn) {\n      var txnResult = openTransactionSafely(idb,\n        [DOC_STORE, BY_SEQ_STORE, ATTACH_STORE], 'readonly');\n      if (txnResult.error) {\n        return callback(txnResult.error);\n      }\n      txn = txnResult.txn;\n    }\n\n    function finish() {\n      callback(err, {doc: doc, metadata: metadata, ctx: txn});\n    }\n\n    txn.objectStore(DOC_STORE).get(id).onsuccess = function (e) {\n      metadata = decodeMetadata(e.target.result);\n      // we can determine the result here if:\n      // 1. there is no such document\n      // 2. the document is deleted and we don't ask about specific rev\n      // When we ask with opts.rev we expect the answer to be either\n      // doc (possibly with _deleted=true) or missing error\n      if (!metadata) {\n        err = createError(MISSING_DOC, 'missing');\n        return finish();\n      }\n\n      var rev$$1;\n      if (!opts.rev) {\n        rev$$1 = metadata.winningRev;\n        var deleted = isDeleted(metadata);\n        if (deleted) {\n          err = createError(MISSING_DOC, \"deleted\");\n          return finish();\n        }\n      } else {\n        rev$$1 = opts.latest ? latest(opts.rev, metadata) : opts.rev;\n      }\n\n      var objectStore = txn.objectStore(BY_SEQ_STORE);\n      var key = metadata.id + '::' + rev$$1;\n\n      objectStore.index('_doc_id_rev').get(key).onsuccess = function (e) {\n        doc = e.target.result;\n        if (doc) {\n          doc = decodeDoc(doc);\n        }\n        if (!doc) {\n          err = createError(MISSING_DOC, 'missing');\n          return finish();\n        }\n        finish();\n      };\n    };\n  };\n\n  api._getAttachment = function (docId, attachId, attachment, opts, callback) {\n    var txn;\n    if (opts.ctx) {\n      txn = opts.ctx;\n    } else {\n      var txnResult = openTransactionSafely(idb,\n        [DOC_STORE, BY_SEQ_STORE, ATTACH_STORE], 'readonly');\n      if (txnResult.error) {\n        return callback(txnResult.error);\n      }\n      txn = txnResult.txn;\n    }\n    var digest = attachment.digest;\n    var type = attachment.content_type;\n\n    txn.objectStore(ATTACH_STORE).get(digest).onsuccess = function (e) {\n      var body = e.target.result.body;\n      readBlobData(body, type, opts.binary, function (blobData) {\n        callback(null, blobData);\n      });\n    };\n  };\n\n  api._info = function idb_info(callback) {\n    var updateSeq;\n    var docCount;\n\n    var txnResult = openTransactionSafely(idb, [META_STORE, BY_SEQ_STORE], 'readonly');\n    if (txnResult.error) {\n      return callback(txnResult.error);\n    }\n    var txn = txnResult.txn;\n    txn.objectStore(META_STORE).get(META_STORE).onsuccess = function (e) {\n      docCount = e.target.result.docCount;\n    };\n    txn.objectStore(BY_SEQ_STORE).openCursor(null, 'prev').onsuccess = function (e) {\n      var cursor = e.target.result;\n      updateSeq = cursor ? cursor.key : 0;\n    };\n\n    txn.oncomplete = function () {\n      callback(null, {\n        doc_count: docCount,\n        update_seq: updateSeq,\n        // for debugging\n        idb_attachment_format: (api._meta.blobSupport ? 'binary' : 'base64')\n      });\n    };\n  };\n\n  api._allDocs = function idb_allDocs(opts, callback) {\n    idbAllDocs(opts, idb, callback);\n  };\n\n  api._changes = function idbChanges(opts) {\n    return changes(opts, api, dbName, idb);\n  };\n\n  api._close = function (callback) {\n    // https://developer.mozilla.org/en-US/docs/IndexedDB/IDBDatabase#close\n    // \"Returns immediately and closes the connection in a separate thread...\"\n    idb.close();\n    cachedDBs[\"delete\"](dbName);\n    callback();\n  };\n\n  api._getRevisionTree = function (docId, callback) {\n    var txnResult = openTransactionSafely(idb, [DOC_STORE], 'readonly');\n    if (txnResult.error) {\n      return callback(txnResult.error);\n    }\n    var txn = txnResult.txn;\n    var req = txn.objectStore(DOC_STORE).get(docId);\n    req.onsuccess = function (event) {\n      var doc = decodeMetadata(event.target.result);\n      if (!doc) {\n        callback(createError(MISSING_DOC));\n      } else {\n        callback(null, doc.rev_tree);\n      }\n    };\n  };\n\n  // This function removes revisions of document docId\n  // which are listed in revs and sets this document\n  // revision to to rev_tree\n  api._doCompaction = function (docId, revs, callback) {\n    var stores = [\n      DOC_STORE,\n      BY_SEQ_STORE,\n      ATTACH_STORE,\n      ATTACH_AND_SEQ_STORE\n    ];\n    var txnResult = openTransactionSafely(idb, stores, 'readwrite');\n    if (txnResult.error) {\n      return callback(txnResult.error);\n    }\n    var txn = txnResult.txn;\n\n    var docStore = txn.objectStore(DOC_STORE);\n\n    docStore.get(docId).onsuccess = function (event) {\n      var metadata = decodeMetadata(event.target.result);\n      traverseRevTree(metadata.rev_tree, function (isLeaf, pos,\n                                                         revHash, ctx, opts) {\n        var rev$$1 = pos + '-' + revHash;\n        if (revs.indexOf(rev$$1) !== -1) {\n          opts.status = 'missing';\n        }\n      });\n      compactRevs(revs, docId, txn);\n      var winningRev$$1 = metadata.winningRev;\n      var deleted = metadata.deleted;\n      txn.objectStore(DOC_STORE).put(\n        encodeMetadata(metadata, winningRev$$1, deleted));\n    };\n    txn.onabort = idbError(callback);\n    txn.oncomplete = function () {\n      callback();\n    };\n  };\n\n\n  api._getLocal = function (id, callback) {\n    var txnResult = openTransactionSafely(idb, [LOCAL_STORE], 'readonly');\n    if (txnResult.error) {\n      return callback(txnResult.error);\n    }\n    var tx = txnResult.txn;\n    var req = tx.objectStore(LOCAL_STORE).get(id);\n\n    req.onerror = idbError(callback);\n    req.onsuccess = function (e) {\n      var doc = e.target.result;\n      if (!doc) {\n        callback(createError(MISSING_DOC));\n      } else {\n        delete doc['_doc_id_rev']; // for backwards compat\n        callback(null, doc);\n      }\n    };\n  };\n\n  api._putLocal = function (doc, opts, callback) {\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    delete doc._revisions; // ignore this, trust the rev\n    var oldRev = doc._rev;\n    var id = doc._id;\n    if (!oldRev) {\n      doc._rev = '0-1';\n    } else {\n      doc._rev = '0-' + (parseInt(oldRev.split('-')[1], 10) + 1);\n    }\n\n    var tx = opts.ctx;\n    var ret;\n    if (!tx) {\n      var txnResult = openTransactionSafely(idb, [LOCAL_STORE], 'readwrite');\n      if (txnResult.error) {\n        return callback(txnResult.error);\n      }\n      tx = txnResult.txn;\n      tx.onerror = idbError(callback);\n      tx.oncomplete = function () {\n        if (ret) {\n          callback(null, ret);\n        }\n      };\n    }\n\n    var oStore = tx.objectStore(LOCAL_STORE);\n    var req;\n    if (oldRev) {\n      req = oStore.get(id);\n      req.onsuccess = function (e) {\n        var oldDoc = e.target.result;\n        if (!oldDoc || oldDoc._rev !== oldRev) {\n          callback(createError(REV_CONFLICT));\n        } else { // update\n          var req = oStore.put(doc);\n          req.onsuccess = function () {\n            ret = {ok: true, id: doc._id, rev: doc._rev};\n            if (opts.ctx) { // return immediately\n              callback(null, ret);\n            }\n          };\n        }\n      };\n    } else { // new doc\n      req = oStore.add(doc);\n      req.onerror = function (e) {\n        // constraint error, already exists\n        callback(createError(REV_CONFLICT));\n        e.preventDefault(); // avoid transaction abort\n        e.stopPropagation(); // avoid transaction onerror\n      };\n      req.onsuccess = function () {\n        ret = {ok: true, id: doc._id, rev: doc._rev};\n        if (opts.ctx) { // return immediately\n          callback(null, ret);\n        }\n      };\n    }\n  };\n\n  api._removeLocal = function (doc, opts, callback) {\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    var tx = opts.ctx;\n    if (!tx) {\n      var txnResult = openTransactionSafely(idb, [LOCAL_STORE], 'readwrite');\n      if (txnResult.error) {\n        return callback(txnResult.error);\n      }\n      tx = txnResult.txn;\n      tx.oncomplete = function () {\n        if (ret) {\n          callback(null, ret);\n        }\n      };\n    }\n    var ret;\n    var id = doc._id;\n    var oStore = tx.objectStore(LOCAL_STORE);\n    var req = oStore.get(id);\n\n    req.onerror = idbError(callback);\n    req.onsuccess = function (e) {\n      var oldDoc = e.target.result;\n      if (!oldDoc || oldDoc._rev !== doc._rev) {\n        callback(createError(MISSING_DOC));\n      } else {\n        oStore[\"delete\"](id);\n        ret = {ok: true, id: id, rev: '0-0'};\n        if (opts.ctx) { // return immediately\n          callback(null, ret);\n        }\n      }\n    };\n  };\n\n  api._destroy = function (opts, callback) {\n    changesHandler$$1.removeAllListeners(dbName);\n\n    //Close open request for \"dbName\" database to fix ie delay.\n    var openReq = openReqList.get(dbName);\n    if (openReq && openReq.result) {\n      openReq.result.close();\n      cachedDBs[\"delete\"](dbName);\n    }\n    var req = indexedDB.deleteDatabase(dbName);\n\n    req.onsuccess = function () {\n      //Remove open request from the list.\n      openReqList[\"delete\"](dbName);\n      if (hasLocalStorage() && (dbName in localStorage)) {\n        delete localStorage[dbName];\n      }\n      callback(null, { 'ok': true });\n    };\n\n    req.onerror = idbError(callback);\n  };\n\n  var cached = cachedDBs.get(dbName);\n\n  if (cached) {\n    idb = cached.idb;\n    api._meta = cached.global;\n    return nextTick(function () {\n      callback(null, api);\n    });\n  }\n\n  var req;\n  if (opts.storage) {\n    req = tryStorageOption(dbName, opts.storage);\n  } else {\n    req = indexedDB.open(dbName, ADAPTER_VERSION);\n  }\n\n  openReqList.set(dbName, req);\n\n  req.onupgradeneeded = function (e) {\n    var db = e.target.result;\n    if (e.oldVersion < 1) {\n      return createSchema(db); // new db, initial schema\n    }\n    // do migrations\n\n    var txn = e.currentTarget.transaction;\n    // these migrations have to be done in this function, before\n    // control is returned to the event loop, because IndexedDB\n\n    if (e.oldVersion < 3) {\n      createLocalStoreSchema(db); // v2 -> v3\n    }\n    if (e.oldVersion < 4) {\n      addAttachAndSeqStore(db); // v3 -> v4\n    }\n\n    var migrations = [\n      addDeletedOrLocalIndex, // v1 -> v2\n      migrateLocalStore,      // v2 -> v3\n      migrateAttsAndSeqs,     // v3 -> v4\n      migrateMetadata         // v4 -> v5\n    ];\n\n    var i = e.oldVersion;\n\n    function next() {\n      var migration = migrations[i - 1];\n      i++;\n      if (migration) {\n        migration(txn, next);\n      }\n    }\n\n    next();\n  };\n\n  req.onsuccess = function (e) {\n\n    idb = e.target.result;\n\n    idb.onversionchange = function () {\n      idb.close();\n      cachedDBs[\"delete\"](dbName);\n    };\n\n    idb.onabort = function (e) {\n      guardedConsole('error', 'Database has a global failure', e.target.error);\n      idb.close();\n      cachedDBs[\"delete\"](dbName);\n    };\n\n    // Do a few setup operations (in parallel as much as possible):\n    // 1. Fetch meta doc\n    // 2. Check blob support\n    // 3. Calculate docCount\n    // 4. Generate an instanceId if necessary\n    // 5. Store docCount and instanceId on meta doc\n\n    var txn = idb.transaction([\n      META_STORE,\n      DETECT_BLOB_SUPPORT_STORE,\n      DOC_STORE\n    ], 'readwrite');\n\n    var storedMetaDoc = false;\n    var metaDoc;\n    var docCount;\n    var blobSupport;\n    var instanceId;\n\n    function completeSetup() {\n      if (typeof blobSupport === 'undefined' || !storedMetaDoc) {\n        return;\n      }\n      api._meta = {\n        name: dbName,\n        instanceId: instanceId,\n        blobSupport: blobSupport\n      };\n\n      cachedDBs.set(dbName, {\n        idb: idb,\n        global: api._meta\n      });\n      callback(null, api);\n    }\n\n    function storeMetaDocIfReady() {\n      if (typeof docCount === 'undefined' || typeof metaDoc === 'undefined') {\n        return;\n      }\n      var instanceKey = dbName + '_id';\n      if (instanceKey in metaDoc) {\n        instanceId = metaDoc[instanceKey];\n      } else {\n        metaDoc[instanceKey] = instanceId = uuid();\n      }\n      metaDoc.docCount = docCount;\n      txn.objectStore(META_STORE).put(metaDoc);\n    }\n\n    //\n    // fetch or generate the instanceId\n    //\n    txn.objectStore(META_STORE).get(META_STORE).onsuccess = function (e) {\n      metaDoc = e.target.result || { id: META_STORE };\n      storeMetaDocIfReady();\n    };\n\n    //\n    // countDocs\n    //\n    countDocs(txn, function (count) {\n      docCount = count;\n      storeMetaDocIfReady();\n    });\n\n    //\n    // check blob support\n    //\n    if (!blobSupportPromise) {\n      // make sure blob support is only checked once\n      blobSupportPromise = checkBlobSupport(txn);\n    }\n\n    blobSupportPromise.then(function (val) {\n      blobSupport = val;\n      completeSetup();\n    });\n\n    // only when the metadata put transaction has completed,\n    // consider the setup done\n    txn.oncomplete = function () {\n      storedMetaDoc = true;\n      completeSetup();\n    };\n    txn.onabort = idbError(callback);\n  };\n\n  req.onerror = function () {\n    var msg = 'Failed to open indexedDB, are you in private browsing mode?';\n    guardedConsole('error', msg);\n    callback(createError(IDB_ERROR, msg));\n  };\n}\n\nIdbPouch.valid = function () {\n  // Issue #2533, we finally gave up on doing bug\n  // detection instead of browser sniffing. Safari brought us\n  // to our knees.\n  var isSafari = typeof openDatabase !== 'undefined' &&\n    /(Safari|iPhone|iPad|iPod)/.test(navigator.userAgent) &&\n    !/Chrome/.test(navigator.userAgent) &&\n    !/BlackBerry/.test(navigator.platform);\n\n  // Safari <10.1 does not meet our requirements for IDB support (#5572)\n  // since Safari 10.1 shipped with fetch, we can use that to detect it\n  var hasFetch = typeof fetch === 'function' &&\n    fetch.toString().indexOf('[native code') !== -1;\n\n  // On Firefox SecurityError is thrown while referencing indexedDB if cookies\n  // are not allowed. `typeof indexedDB` also triggers the error.\n  try {\n    // some outdated implementations of IDB that appear on Samsung\n    // and HTC Android devices <4.4 are missing IDBKeyRange\n    return (!isSafari || hasFetch) && typeof indexedDB !== 'undefined' &&\n      typeof IDBKeyRange !== 'undefined';\n  } catch (e) {\n    return false;\n  }\n};\n\nfunction tryStorageOption(dbName, storage) {\n  try { // option only available in Firefox 26+\n    return indexedDB.open(dbName, {\n      version: ADAPTER_VERSION,\n      storage: storage\n    });\n  } catch (err) {\n      return indexedDB.open(dbName, ADAPTER_VERSION);\n  }\n}\n\nfunction IDBPouch (PouchDB) {\n  PouchDB.adapter('idb', IdbPouch, true);\n}\n\n//\n// Parsing hex strings. Yeah.\n//\n// So basically we need this because of a bug in WebSQL:\n// https://code.google.com/p/chromium/issues/detail?id=422690\n// https://bugs.webkit.org/show_bug.cgi?id=137637\n//\n// UTF-8 and UTF-16 are provided as separate functions\n// for meager performance improvements\n//\n\nfunction decodeUtf8(str) {\n  return decodeURIComponent(escape(str));\n}\n\nfunction hexToInt(charCode) {\n  // '0'-'9' is 48-57\n  // 'A'-'F' is 65-70\n  // SQLite will only give us uppercase hex\n  return charCode < 65 ? (charCode - 48) : (charCode - 55);\n}\n\n\n// Example:\n// pragma encoding=utf8;\n// select hex('A');\n// returns '41'\nfunction parseHexUtf8(str, start, end) {\n  var result = '';\n  while (start < end) {\n    result += String.fromCharCode(\n      (hexToInt(str.charCodeAt(start++)) << 4) |\n        hexToInt(str.charCodeAt(start++)));\n  }\n  return result;\n}\n\n// Example:\n// pragma encoding=utf16;\n// select hex('A');\n// returns '4100'\n// notice that the 00 comes after the 41 (i.e. it's swizzled)\nfunction parseHexUtf16(str, start, end) {\n  var result = '';\n  while (start < end) {\n    // UTF-16, so swizzle the bytes\n    result += String.fromCharCode(\n      (hexToInt(str.charCodeAt(start + 2)) << 12) |\n        (hexToInt(str.charCodeAt(start + 3)) << 8) |\n        (hexToInt(str.charCodeAt(start)) << 4) |\n        hexToInt(str.charCodeAt(start + 1)));\n    start += 4;\n  }\n  return result;\n}\n\nfunction parseHexString(str, encoding) {\n  if (encoding === 'UTF-8') {\n    return decodeUtf8(parseHexUtf8(str, 0, str.length));\n  } else {\n    return parseHexUtf16(str, 0, str.length);\n  }\n}\n\nfunction quote(str) {\n  return \"'\" + str + \"'\";\n}\n\nvar ADAPTER_VERSION$1 = 7; // used to manage migrations\n\n// The object stores created for each database\n// DOC_STORE stores the document meta data, its revision history and state\nvar DOC_STORE$1 = quote('document-store');\n// BY_SEQ_STORE stores a particular version of a document, keyed by its\n// sequence id\nvar BY_SEQ_STORE$1 = quote('by-sequence');\n// Where we store attachments\nvar ATTACH_STORE$1 = quote('attach-store');\nvar LOCAL_STORE$1 = quote('local-store');\nvar META_STORE$1 = quote('metadata-store');\n// where we store many-to-many relations between attachment\n// digests and seqs\nvar ATTACH_AND_SEQ_STORE$1 = quote('attach-seq-store');\n\n// escapeBlob and unescapeBlob are workarounds for a websql bug:\n// https://code.google.com/p/chromium/issues/detail?id=422690\n// https://bugs.webkit.org/show_bug.cgi?id=137637\n// The goal is to never actually insert the \\u0000 character\n// in the database.\nfunction escapeBlob(str) {\n  return str\n    .replace(/\\u0002/g, '\\u0002\\u0002')\n    .replace(/\\u0001/g, '\\u0001\\u0002')\n    .replace(/\\u0000/g, '\\u0001\\u0001');\n}\n\nfunction unescapeBlob(str) {\n  return str\n    .replace(/\\u0001\\u0001/g, '\\u0000')\n    .replace(/\\u0001\\u0002/g, '\\u0001')\n    .replace(/\\u0002\\u0002/g, '\\u0002');\n}\n\nfunction stringifyDoc(doc) {\n  // don't bother storing the id/rev. it uses lots of space,\n  // in persistent map/reduce especially\n  delete doc._id;\n  delete doc._rev;\n  return JSON.stringify(doc);\n}\n\nfunction unstringifyDoc(doc, id, rev$$1) {\n  doc = JSON.parse(doc);\n  doc._id = id;\n  doc._rev = rev$$1;\n  return doc;\n}\n\n// question mark groups IN queries, e.g. 3 -> '(?,?,?)'\nfunction qMarks(num) {\n  var s = '(';\n  while (num--) {\n    s += '?';\n    if (num) {\n      s += ',';\n    }\n  }\n  return s + ')';\n}\n\nfunction select(selector, table, joiner, where, orderBy) {\n  return 'SELECT ' + selector + ' FROM ' +\n    (typeof table === 'string' ? table : table.join(' JOIN ')) +\n    (joiner ? (' ON ' + joiner) : '') +\n    (where ? (' WHERE ' +\n    (typeof where === 'string' ? where : where.join(' AND '))) : '') +\n    (orderBy ? (' ORDER BY ' + orderBy) : '');\n}\n\nfunction compactRevs$1(revs, docId, tx) {\n\n  if (!revs.length) {\n    return;\n  }\n\n  var numDone = 0;\n  var seqs = [];\n\n  function checkDone() {\n    if (++numDone === revs.length) { // done\n      deleteOrphans();\n    }\n  }\n\n  function deleteOrphans() {\n    // find orphaned attachment digests\n\n    if (!seqs.length) {\n      return;\n    }\n\n    var sql = 'SELECT DISTINCT digest AS digest FROM ' +\n      ATTACH_AND_SEQ_STORE$1 + ' WHERE seq IN ' + qMarks(seqs.length);\n\n    tx.executeSql(sql, seqs, function (tx, res) {\n\n      var digestsToCheck = [];\n      for (var i = 0; i < res.rows.length; i++) {\n        digestsToCheck.push(res.rows.item(i).digest);\n      }\n      if (!digestsToCheck.length) {\n        return;\n      }\n\n      var sql = 'DELETE FROM ' + ATTACH_AND_SEQ_STORE$1 +\n        ' WHERE seq IN (' +\n        seqs.map(function () { return '?'; }).join(',') +\n        ')';\n      tx.executeSql(sql, seqs, function (tx) {\n\n        var sql = 'SELECT digest FROM ' + ATTACH_AND_SEQ_STORE$1 +\n          ' WHERE digest IN (' +\n          digestsToCheck.map(function () { return '?'; }).join(',') +\n          ')';\n        tx.executeSql(sql, digestsToCheck, function (tx, res) {\n          var nonOrphanedDigests = new ExportedSet();\n          for (var i = 0; i < res.rows.length; i++) {\n            nonOrphanedDigests.add(res.rows.item(i).digest);\n          }\n          digestsToCheck.forEach(function (digest) {\n            if (nonOrphanedDigests.has(digest)) {\n              return;\n            }\n            tx.executeSql(\n              'DELETE FROM ' + ATTACH_AND_SEQ_STORE$1 + ' WHERE digest=?',\n              [digest]);\n            tx.executeSql(\n              'DELETE FROM ' + ATTACH_STORE$1 + ' WHERE digest=?', [digest]);\n          });\n        });\n      });\n    });\n  }\n\n  // update by-seq and attach stores in parallel\n  revs.forEach(function (rev$$1) {\n    var sql = 'SELECT seq FROM ' + BY_SEQ_STORE$1 +\n      ' WHERE doc_id=? AND rev=?';\n\n    tx.executeSql(sql, [docId, rev$$1], function (tx, res) {\n      if (!res.rows.length) { // already deleted\n        return checkDone();\n      }\n      var seq = res.rows.item(0).seq;\n      seqs.push(seq);\n\n      tx.executeSql(\n        'DELETE FROM ' + BY_SEQ_STORE$1 + ' WHERE seq=?', [seq], checkDone);\n    });\n  });\n}\n\nfunction websqlError(callback) {\n  return function (event) {\n    guardedConsole('error', 'WebSQL threw an error', event);\n    // event may actually be a SQLError object, so report is as such\n    var errorNameMatch = event && event.constructor.toString()\n        .match(/function ([^(]+)/);\n    var errorName = (errorNameMatch && errorNameMatch[1]) || event.type;\n    var errorReason = event.target || event.message;\n    callback(createError(WSQ_ERROR, errorReason, errorName));\n  };\n}\n\nfunction getSize(opts) {\n  if ('size' in opts) {\n    // triggers immediate popup in iOS, fixes #2347\n    // e.g. 5000001 asks for 5 MB, 10000001 asks for 10 MB,\n    return opts.size * 1000000;\n  }\n  // In iOS, doesn't matter as long as it's <= 5000000.\n  // Except that if you request too much, our tests fail\n  // because of the native \"do you accept?\" popup.\n  // In Android <=4.3, this value is actually used as an\n  // honest-to-god ceiling for data, so we need to\n  // set it to a decently high number.\n  var isAndroid = typeof navigator !== 'undefined' &&\n    /Android/.test(navigator.userAgent);\n  return isAndroid ? 5000000 : 1; // in PhantomJS, if you use 0 it will crash\n}\n\nfunction websqlBulkDocs(dbOpts, req, opts, api, db, websqlChanges, callback) {\n  var newEdits = opts.new_edits;\n  var userDocs = req.docs;\n\n  // Parse the docs, give them a sequence number for the result\n  var docInfos = userDocs.map(function (doc) {\n    if (doc._id && isLocalId(doc._id)) {\n      return doc;\n    }\n    var newDoc = parseDoc(doc, newEdits);\n    return newDoc;\n  });\n\n  var docInfoErrors = docInfos.filter(function (docInfo) {\n    return docInfo.error;\n  });\n  if (docInfoErrors.length) {\n    return callback(docInfoErrors[0]);\n  }\n\n  var tx;\n  var results = new Array(docInfos.length);\n  var fetchedDocs = new ExportedMap();\n\n  var preconditionErrored;\n  function complete() {\n    if (preconditionErrored) {\n      return callback(preconditionErrored);\n    }\n    websqlChanges.notify(api._name);\n    callback(null, results);\n  }\n\n  function verifyAttachment(digest, callback) {\n    var sql = 'SELECT count(*) as cnt FROM ' + ATTACH_STORE$1 +\n      ' WHERE digest=?';\n    tx.executeSql(sql, [digest], function (tx, result) {\n      if (result.rows.item(0).cnt === 0) {\n        var err = createError(MISSING_STUB,\n          'unknown stub attachment with digest ' +\n          digest);\n        callback(err);\n      } else {\n        callback();\n      }\n    });\n  }\n\n  function verifyAttachments(finish) {\n    var digests = [];\n    docInfos.forEach(function (docInfo) {\n      if (docInfo.data && docInfo.data._attachments) {\n        Object.keys(docInfo.data._attachments).forEach(function (filename) {\n          var att = docInfo.data._attachments[filename];\n          if (att.stub) {\n            digests.push(att.digest);\n          }\n        });\n      }\n    });\n    if (!digests.length) {\n      return finish();\n    }\n    var numDone = 0;\n    var err;\n\n    function checkDone() {\n      if (++numDone === digests.length) {\n        finish(err);\n      }\n    }\n    digests.forEach(function (digest) {\n      verifyAttachment(digest, function (attErr) {\n        if (attErr && !err) {\n          err = attErr;\n        }\n        checkDone();\n      });\n    });\n  }\n\n  function writeDoc(docInfo, winningRev$$1, winningRevIsDeleted, newRevIsDeleted,\n                    isUpdate, delta, resultsIdx, callback) {\n\n    function finish() {\n      var data = docInfo.data;\n      var deletedInt = newRevIsDeleted ? 1 : 0;\n\n      var id = data._id;\n      var rev = data._rev;\n      var json = stringifyDoc(data);\n      var sql = 'INSERT INTO ' + BY_SEQ_STORE$1 +\n        ' (doc_id, rev, json, deleted) VALUES (?, ?, ?, ?);';\n      var sqlArgs = [id, rev, json, deletedInt];\n\n      // map seqs to attachment digests, which\n      // we will need later during compaction\n      function insertAttachmentMappings(seq, callback) {\n        var attsAdded = 0;\n        var attsToAdd = Object.keys(data._attachments || {});\n\n        if (!attsToAdd.length) {\n          return callback();\n        }\n        function checkDone() {\n          if (++attsAdded === attsToAdd.length) {\n            callback();\n          }\n          return false; // ack handling a constraint error\n        }\n        function add(att) {\n          var sql = 'INSERT INTO ' + ATTACH_AND_SEQ_STORE$1 +\n            ' (digest, seq) VALUES (?,?)';\n          var sqlArgs = [data._attachments[att].digest, seq];\n          tx.executeSql(sql, sqlArgs, checkDone, checkDone);\n          // second callback is for a constaint error, which we ignore\n          // because this docid/rev has already been associated with\n          // the digest (e.g. when new_edits == false)\n        }\n        for (var i = 0; i < attsToAdd.length; i++) {\n          add(attsToAdd[i]); // do in parallel\n        }\n      }\n\n      tx.executeSql(sql, sqlArgs, function (tx, result) {\n        var seq = result.insertId;\n        insertAttachmentMappings(seq, function () {\n          dataWritten(tx, seq);\n        });\n      }, function () {\n        // constraint error, recover by updating instead (see #1638)\n        var fetchSql = select('seq', BY_SEQ_STORE$1, null,\n          'doc_id=? AND rev=?');\n        tx.executeSql(fetchSql, [id, rev], function (tx, res) {\n          var seq = res.rows.item(0).seq;\n          var sql = 'UPDATE ' + BY_SEQ_STORE$1 +\n            ' SET json=?, deleted=? WHERE doc_id=? AND rev=?;';\n          var sqlArgs = [json, deletedInt, id, rev];\n          tx.executeSql(sql, sqlArgs, function (tx) {\n            insertAttachmentMappings(seq, function () {\n              dataWritten(tx, seq);\n            });\n          });\n        });\n        return false; // ack that we've handled the error\n      });\n    }\n\n    function collectResults(attachmentErr) {\n      if (!err) {\n        if (attachmentErr) {\n          err = attachmentErr;\n          callback(err);\n        } else if (recv === attachments.length) {\n          finish();\n        }\n      }\n    }\n\n    var err = null;\n    var recv = 0;\n\n    docInfo.data._id = docInfo.metadata.id;\n    docInfo.data._rev = docInfo.metadata.rev;\n    var attachments = Object.keys(docInfo.data._attachments || {});\n\n\n    if (newRevIsDeleted) {\n      docInfo.data._deleted = true;\n    }\n\n    function attachmentSaved(err) {\n      recv++;\n      collectResults(err);\n    }\n\n    attachments.forEach(function (key) {\n      var att = docInfo.data._attachments[key];\n      if (!att.stub) {\n        var data = att.data;\n        delete att.data;\n        att.revpos = parseInt(winningRev$$1, 10);\n        var digest = att.digest;\n        saveAttachment(digest, data, attachmentSaved);\n      } else {\n        recv++;\n        collectResults();\n      }\n    });\n\n    if (!attachments.length) {\n      finish();\n    }\n\n    function dataWritten(tx, seq) {\n      var id = docInfo.metadata.id;\n\n      var revsToCompact = docInfo.stemmedRevs || [];\n      if (isUpdate && api.auto_compaction) {\n        revsToCompact = compactTree(docInfo.metadata).concat(revsToCompact);\n      }\n      if (revsToCompact.length) {\n        compactRevs$1(revsToCompact, id, tx);\n      }\n\n      docInfo.metadata.seq = seq;\n      var rev = docInfo.metadata.rev;\n      delete docInfo.metadata.rev;\n\n      var sql = isUpdate ?\n      'UPDATE ' + DOC_STORE$1 +\n      ' SET json=?, max_seq=?, winningseq=' +\n      '(SELECT seq FROM ' + BY_SEQ_STORE$1 +\n      ' WHERE doc_id=' + DOC_STORE$1 + '.id AND rev=?) WHERE id=?'\n        : 'INSERT INTO ' + DOC_STORE$1 +\n      ' (id, winningseq, max_seq, json) VALUES (?,?,?,?);';\n      var metadataStr = safeJsonStringify(docInfo.metadata);\n      var params = isUpdate ?\n        [metadataStr, seq, winningRev$$1, id] :\n        [id, seq, seq, metadataStr];\n      tx.executeSql(sql, params, function () {\n        results[resultsIdx] = {\n          ok: true,\n          id: docInfo.metadata.id,\n          rev: rev\n        };\n        fetchedDocs.set(id, docInfo.metadata);\n        callback();\n      });\n    }\n  }\n\n  function websqlProcessDocs() {\n    processDocs(dbOpts.revs_limit, docInfos, api, fetchedDocs, tx,\n                results, writeDoc, opts);\n  }\n\n  function fetchExistingDocs(callback) {\n    if (!docInfos.length) {\n      return callback();\n    }\n\n    var numFetched = 0;\n\n    function checkDone() {\n      if (++numFetched === docInfos.length) {\n        callback();\n      }\n    }\n\n    docInfos.forEach(function (docInfo) {\n      if (docInfo._id && isLocalId(docInfo._id)) {\n        return checkDone(); // skip local docs\n      }\n      var id = docInfo.metadata.id;\n      tx.executeSql('SELECT json FROM ' + DOC_STORE$1 +\n      ' WHERE id = ?', [id], function (tx, result) {\n        if (result.rows.length) {\n          var metadata = safeJsonParse(result.rows.item(0).json);\n          fetchedDocs.set(id, metadata);\n        }\n        checkDone();\n      });\n    });\n  }\n\n  function saveAttachment(digest, data, callback) {\n    var sql = 'SELECT digest FROM ' + ATTACH_STORE$1 + ' WHERE digest=?';\n    tx.executeSql(sql, [digest], function (tx, result) {\n      if (result.rows.length) { // attachment already exists\n        return callback();\n      }\n      // we could just insert before selecting and catch the error,\n      // but my hunch is that it's cheaper not to serialize the blob\n      // from JS to C if we don't have to (TODO: confirm this)\n      sql = 'INSERT INTO ' + ATTACH_STORE$1 +\n      ' (digest, body, escaped) VALUES (?,?,1)';\n      tx.executeSql(sql, [digest, escapeBlob(data)], function () {\n        callback();\n      }, function () {\n        // ignore constaint errors, means it already exists\n        callback();\n        return false; // ack we handled the error\n      });\n    });\n  }\n\n  preprocessAttachments(docInfos, 'binary', function (err) {\n    if (err) {\n      return callback(err);\n    }\n    db.transaction(function (txn) {\n      tx = txn;\n      verifyAttachments(function (err) {\n        if (err) {\n          preconditionErrored = err;\n        } else {\n          fetchExistingDocs(websqlProcessDocs);\n        }\n      });\n    }, websqlError(callback), complete);\n  });\n}\n\nvar cachedDatabases = new ExportedMap();\n\n// openDatabase passed in through opts (e.g. for node-websql)\nfunction openDatabaseWithOpts(opts) {\n  return opts.websql(opts.name, opts.version, opts.description, opts.size);\n}\n\nfunction openDBSafely(opts) {\n  try {\n    return {\n      db: openDatabaseWithOpts(opts)\n    };\n  } catch (err) {\n    return {\n      error: err\n    };\n  }\n}\n\nfunction openDB(opts) {\n  var cachedResult = cachedDatabases.get(opts.name);\n  if (!cachedResult) {\n    cachedResult = openDBSafely(opts);\n    cachedDatabases.set(opts.name, cachedResult);\n  }\n  return cachedResult;\n}\n\nvar websqlChanges = new Changes();\n\nfunction fetchAttachmentsIfNecessary$1(doc, opts, api, txn, cb) {\n  var attachments = Object.keys(doc._attachments || {});\n  if (!attachments.length) {\n    return cb && cb();\n  }\n  var numDone = 0;\n\n  function checkDone() {\n    if (++numDone === attachments.length && cb) {\n      cb();\n    }\n  }\n\n  function fetchAttachment(doc, att) {\n    var attObj = doc._attachments[att];\n    var attOpts = {binary: opts.binary, ctx: txn};\n    api._getAttachment(doc._id, att, attObj, attOpts, function (_, data) {\n      doc._attachments[att] = $inject_Object_assign(\n        pick(attObj, ['digest', 'content_type']),\n        { data: data }\n      );\n      checkDone();\n    });\n  }\n\n  attachments.forEach(function (att) {\n    if (opts.attachments && opts.include_docs) {\n      fetchAttachment(doc, att);\n    } else {\n      doc._attachments[att].stub = true;\n      checkDone();\n    }\n  });\n}\n\nvar POUCH_VERSION = 1;\n\n// these indexes cover the ground for most allDocs queries\nvar BY_SEQ_STORE_DELETED_INDEX_SQL =\n  'CREATE INDEX IF NOT EXISTS \\'by-seq-deleted-idx\\' ON ' +\n  BY_SEQ_STORE$1 + ' (seq, deleted)';\nvar BY_SEQ_STORE_DOC_ID_REV_INDEX_SQL =\n  'CREATE UNIQUE INDEX IF NOT EXISTS \\'by-seq-doc-id-rev\\' ON ' +\n    BY_SEQ_STORE$1 + ' (doc_id, rev)';\nvar DOC_STORE_WINNINGSEQ_INDEX_SQL =\n  'CREATE INDEX IF NOT EXISTS \\'doc-winningseq-idx\\' ON ' +\n  DOC_STORE$1 + ' (winningseq)';\nvar ATTACH_AND_SEQ_STORE_SEQ_INDEX_SQL =\n  'CREATE INDEX IF NOT EXISTS \\'attach-seq-seq-idx\\' ON ' +\n    ATTACH_AND_SEQ_STORE$1 + ' (seq)';\nvar ATTACH_AND_SEQ_STORE_ATTACH_INDEX_SQL =\n  'CREATE UNIQUE INDEX IF NOT EXISTS \\'attach-seq-digest-idx\\' ON ' +\n    ATTACH_AND_SEQ_STORE$1 + ' (digest, seq)';\n\nvar DOC_STORE_AND_BY_SEQ_JOINER = BY_SEQ_STORE$1 +\n  '.seq = ' + DOC_STORE$1 + '.winningseq';\n\nvar SELECT_DOCS = BY_SEQ_STORE$1 + '.seq AS seq, ' +\n  BY_SEQ_STORE$1 + '.deleted AS deleted, ' +\n  BY_SEQ_STORE$1 + '.json AS data, ' +\n  BY_SEQ_STORE$1 + '.rev AS rev, ' +\n  DOC_STORE$1 + '.json AS metadata';\n\nfunction WebSqlPouch(opts, callback) {\n  var api = this;\n  var instanceId = null;\n  var size = getSize(opts);\n  var idRequests = [];\n  var encoding;\n\n  api._name = opts.name;\n\n  // extend the options here, because sqlite plugin has a ton of options\n  // and they are constantly changing, so it's more prudent to allow anything\n  var websqlOpts = $inject_Object_assign({}, opts, {\n    version: POUCH_VERSION,\n    description: opts.name,\n    size: size\n  });\n  var openDBResult = openDB(websqlOpts);\n  if (openDBResult.error) {\n    return websqlError(callback)(openDBResult.error);\n  }\n  var db = openDBResult.db;\n  if (typeof db.readTransaction !== 'function') {\n    // doesn't exist in sqlite plugin\n    db.readTransaction = db.transaction;\n  }\n\n  function dbCreated() {\n    // note the db name in case the browser upgrades to idb\n    if (hasLocalStorage()) {\n      window.localStorage['_pouch__websqldb_' + api._name] = true;\n    }\n    callback(null, api);\n  }\n\n  // In this migration, we added the 'deleted' and 'local' columns to the\n  // by-seq and doc store tables.\n  // To preserve existing user data, we re-process all the existing JSON\n  // and add these values.\n  // Called migration2 because it corresponds to adapter version (db_version) #2\n  function runMigration2(tx, callback) {\n    // index used for the join in the allDocs query\n    tx.executeSql(DOC_STORE_WINNINGSEQ_INDEX_SQL);\n\n    tx.executeSql('ALTER TABLE ' + BY_SEQ_STORE$1 +\n      ' ADD COLUMN deleted TINYINT(1) DEFAULT 0', [], function () {\n      tx.executeSql(BY_SEQ_STORE_DELETED_INDEX_SQL);\n      tx.executeSql('ALTER TABLE ' + DOC_STORE$1 +\n        ' ADD COLUMN local TINYINT(1) DEFAULT 0', [], function () {\n        tx.executeSql('CREATE INDEX IF NOT EXISTS \\'doc-store-local-idx\\' ON ' +\n          DOC_STORE$1 + ' (local, id)');\n\n        var sql = 'SELECT ' + DOC_STORE$1 + '.winningseq AS seq, ' + DOC_STORE$1 +\n          '.json AS metadata FROM ' + BY_SEQ_STORE$1 + ' JOIN ' + DOC_STORE$1 +\n          ' ON ' + BY_SEQ_STORE$1 + '.seq = ' + DOC_STORE$1 + '.winningseq';\n\n        tx.executeSql(sql, [], function (tx, result) {\n\n          var deleted = [];\n          var local = [];\n\n          for (var i = 0; i < result.rows.length; i++) {\n            var item = result.rows.item(i);\n            var seq = item.seq;\n            var metadata = JSON.parse(item.metadata);\n            if (isDeleted(metadata)) {\n              deleted.push(seq);\n            }\n            if (isLocalId(metadata.id)) {\n              local.push(metadata.id);\n            }\n          }\n          tx.executeSql('UPDATE ' + DOC_STORE$1 + 'SET local = 1 WHERE id IN ' +\n            qMarks(local.length), local, function () {\n            tx.executeSql('UPDATE ' + BY_SEQ_STORE$1 +\n              ' SET deleted = 1 WHERE seq IN ' +\n              qMarks(deleted.length), deleted, callback);\n          });\n        });\n      });\n    });\n  }\n\n  // in this migration, we make all the local docs unversioned\n  function runMigration3(tx, callback) {\n    var local = 'CREATE TABLE IF NOT EXISTS ' + LOCAL_STORE$1 +\n      ' (id UNIQUE, rev, json)';\n    tx.executeSql(local, [], function () {\n      var sql = 'SELECT ' + DOC_STORE$1 + '.id AS id, ' +\n        BY_SEQ_STORE$1 + '.json AS data ' +\n        'FROM ' + BY_SEQ_STORE$1 + ' JOIN ' +\n        DOC_STORE$1 + ' ON ' + BY_SEQ_STORE$1 + '.seq = ' +\n        DOC_STORE$1 + '.winningseq WHERE local = 1';\n      tx.executeSql(sql, [], function (tx, res) {\n        var rows = [];\n        for (var i = 0; i < res.rows.length; i++) {\n          rows.push(res.rows.item(i));\n        }\n        function doNext() {\n          if (!rows.length) {\n            return callback(tx);\n          }\n          var row = rows.shift();\n          var rev$$1 = JSON.parse(row.data)._rev;\n          tx.executeSql('INSERT INTO ' + LOCAL_STORE$1 +\n              ' (id, rev, json) VALUES (?,?,?)',\n              [row.id, rev$$1, row.data], function (tx) {\n            tx.executeSql('DELETE FROM ' + DOC_STORE$1 + ' WHERE id=?',\n                [row.id], function (tx) {\n              tx.executeSql('DELETE FROM ' + BY_SEQ_STORE$1 + ' WHERE seq=?',\n                  [row.seq], function () {\n                doNext();\n              });\n            });\n          });\n        }\n        doNext();\n      });\n    });\n  }\n\n  // in this migration, we remove doc_id_rev and just use rev\n  function runMigration4(tx, callback) {\n\n    function updateRows(rows) {\n      function doNext() {\n        if (!rows.length) {\n          return callback(tx);\n        }\n        var row = rows.shift();\n        var doc_id_rev = parseHexString(row.hex, encoding);\n        var idx = doc_id_rev.lastIndexOf('::');\n        var doc_id = doc_id_rev.substring(0, idx);\n        var rev$$1 = doc_id_rev.substring(idx + 2);\n        var sql = 'UPDATE ' + BY_SEQ_STORE$1 +\n          ' SET doc_id=?, rev=? WHERE doc_id_rev=?';\n        tx.executeSql(sql, [doc_id, rev$$1, doc_id_rev], function () {\n          doNext();\n        });\n      }\n      doNext();\n    }\n\n    var sql = 'ALTER TABLE ' + BY_SEQ_STORE$1 + ' ADD COLUMN doc_id';\n    tx.executeSql(sql, [], function (tx) {\n      var sql = 'ALTER TABLE ' + BY_SEQ_STORE$1 + ' ADD COLUMN rev';\n      tx.executeSql(sql, [], function (tx) {\n        tx.executeSql(BY_SEQ_STORE_DOC_ID_REV_INDEX_SQL, [], function (tx) {\n          var sql = 'SELECT hex(doc_id_rev) as hex FROM ' + BY_SEQ_STORE$1;\n          tx.executeSql(sql, [], function (tx, res) {\n            var rows = [];\n            for (var i = 0; i < res.rows.length; i++) {\n              rows.push(res.rows.item(i));\n            }\n            updateRows(rows);\n          });\n        });\n      });\n    });\n  }\n\n  // in this migration, we add the attach_and_seq table\n  // for issue #2818\n  function runMigration5(tx, callback) {\n\n    function migrateAttsAndSeqs(tx) {\n      // need to actually populate the table. this is the expensive part,\n      // so as an optimization, check first that this database even\n      // contains attachments\n      var sql = 'SELECT COUNT(*) AS cnt FROM ' + ATTACH_STORE$1;\n      tx.executeSql(sql, [], function (tx, res) {\n        var count = res.rows.item(0).cnt;\n        if (!count) {\n          return callback(tx);\n        }\n\n        var offset = 0;\n        var pageSize = 10;\n        function nextPage() {\n          var sql = select(\n            SELECT_DOCS + ', ' + DOC_STORE$1 + '.id AS id',\n            [DOC_STORE$1, BY_SEQ_STORE$1],\n            DOC_STORE_AND_BY_SEQ_JOINER,\n            null,\n            DOC_STORE$1 + '.id '\n          );\n          sql += ' LIMIT ' + pageSize + ' OFFSET ' + offset;\n          offset += pageSize;\n          tx.executeSql(sql, [], function (tx, res) {\n            if (!res.rows.length) {\n              return callback(tx);\n            }\n            var digestSeqs = {};\n            function addDigestSeq(digest, seq) {\n              // uniq digest/seq pairs, just in case there are dups\n              var seqs = digestSeqs[digest] = (digestSeqs[digest] || []);\n              if (seqs.indexOf(seq) === -1) {\n                seqs.push(seq);\n              }\n            }\n            for (var i = 0; i < res.rows.length; i++) {\n              var row = res.rows.item(i);\n              var doc = unstringifyDoc(row.data, row.id, row.rev);\n              var atts = Object.keys(doc._attachments || {});\n              for (var j = 0; j < atts.length; j++) {\n                var att = doc._attachments[atts[j]];\n                addDigestSeq(att.digest, row.seq);\n              }\n            }\n            var digestSeqPairs = [];\n            Object.keys(digestSeqs).forEach(function (digest) {\n              var seqs = digestSeqs[digest];\n              seqs.forEach(function (seq) {\n                digestSeqPairs.push([digest, seq]);\n              });\n            });\n            if (!digestSeqPairs.length) {\n              return nextPage();\n            }\n            var numDone = 0;\n            digestSeqPairs.forEach(function (pair) {\n              var sql = 'INSERT INTO ' + ATTACH_AND_SEQ_STORE$1 +\n                ' (digest, seq) VALUES (?,?)';\n              tx.executeSql(sql, pair, function () {\n                if (++numDone === digestSeqPairs.length) {\n                  nextPage();\n                }\n              });\n            });\n          });\n        }\n        nextPage();\n      });\n    }\n\n    var attachAndRev = 'CREATE TABLE IF NOT EXISTS ' +\n      ATTACH_AND_SEQ_STORE$1 + ' (digest, seq INTEGER)';\n    tx.executeSql(attachAndRev, [], function (tx) {\n      tx.executeSql(\n        ATTACH_AND_SEQ_STORE_ATTACH_INDEX_SQL, [], function (tx) {\n          tx.executeSql(\n            ATTACH_AND_SEQ_STORE_SEQ_INDEX_SQL, [],\n            migrateAttsAndSeqs);\n        });\n    });\n  }\n\n  // in this migration, we use escapeBlob() and unescapeBlob()\n  // instead of reading out the binary as HEX, which is slow\n  function runMigration6(tx, callback) {\n    var sql = 'ALTER TABLE ' + ATTACH_STORE$1 +\n      ' ADD COLUMN escaped TINYINT(1) DEFAULT 0';\n    tx.executeSql(sql, [], callback);\n  }\n\n  // issue #3136, in this migration we need a \"latest seq\" as well\n  // as the \"winning seq\" in the doc store\n  function runMigration7(tx, callback) {\n    var sql = 'ALTER TABLE ' + DOC_STORE$1 +\n      ' ADD COLUMN max_seq INTEGER';\n    tx.executeSql(sql, [], function (tx) {\n      var sql = 'UPDATE ' + DOC_STORE$1 + ' SET max_seq=(SELECT MAX(seq) FROM ' +\n        BY_SEQ_STORE$1 + ' WHERE doc_id=id)';\n      tx.executeSql(sql, [], function (tx) {\n        // add unique index after filling, else we'll get a constraint\n        // error when we do the ALTER TABLE\n        var sql =\n          'CREATE UNIQUE INDEX IF NOT EXISTS \\'doc-max-seq-idx\\' ON ' +\n          DOC_STORE$1 + ' (max_seq)';\n        tx.executeSql(sql, [], callback);\n      });\n    });\n  }\n\n  function checkEncoding(tx, cb) {\n    // UTF-8 on chrome/android, UTF-16 on safari < 7.1\n    tx.executeSql('SELECT HEX(\"a\") AS hex', [], function (tx, res) {\n        var hex = res.rows.item(0).hex;\n        encoding = hex.length === 2 ? 'UTF-8' : 'UTF-16';\n        cb();\n      }\n    );\n  }\n\n  function onGetInstanceId() {\n    while (idRequests.length > 0) {\n      var idCallback = idRequests.pop();\n      idCallback(null, instanceId);\n    }\n  }\n\n  function onGetVersion(tx, dbVersion) {\n    if (dbVersion === 0) {\n      // initial schema\n\n      var meta = 'CREATE TABLE IF NOT EXISTS ' + META_STORE$1 +\n        ' (dbid, db_version INTEGER)';\n      var attach = 'CREATE TABLE IF NOT EXISTS ' + ATTACH_STORE$1 +\n        ' (digest UNIQUE, escaped TINYINT(1), body BLOB)';\n      var attachAndRev = 'CREATE TABLE IF NOT EXISTS ' +\n        ATTACH_AND_SEQ_STORE$1 + ' (digest, seq INTEGER)';\n      // TODO: migrate winningseq to INTEGER\n      var doc = 'CREATE TABLE IF NOT EXISTS ' + DOC_STORE$1 +\n        ' (id unique, json, winningseq, max_seq INTEGER UNIQUE)';\n      var seq = 'CREATE TABLE IF NOT EXISTS ' + BY_SEQ_STORE$1 +\n        ' (seq INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT, ' +\n        'json, deleted TINYINT(1), doc_id, rev)';\n      var local = 'CREATE TABLE IF NOT EXISTS ' + LOCAL_STORE$1 +\n        ' (id UNIQUE, rev, json)';\n\n      // creates\n      tx.executeSql(attach);\n      tx.executeSql(local);\n      tx.executeSql(attachAndRev, [], function () {\n        tx.executeSql(ATTACH_AND_SEQ_STORE_SEQ_INDEX_SQL);\n        tx.executeSql(ATTACH_AND_SEQ_STORE_ATTACH_INDEX_SQL);\n      });\n      tx.executeSql(doc, [], function () {\n        tx.executeSql(DOC_STORE_WINNINGSEQ_INDEX_SQL);\n        tx.executeSql(seq, [], function () {\n          tx.executeSql(BY_SEQ_STORE_DELETED_INDEX_SQL);\n          tx.executeSql(BY_SEQ_STORE_DOC_ID_REV_INDEX_SQL);\n          tx.executeSql(meta, [], function () {\n            // mark the db version, and new dbid\n            var initSeq = 'INSERT INTO ' + META_STORE$1 +\n              ' (db_version, dbid) VALUES (?,?)';\n            instanceId = uuid();\n            var initSeqArgs = [ADAPTER_VERSION$1, instanceId];\n            tx.executeSql(initSeq, initSeqArgs, function () {\n              onGetInstanceId();\n            });\n          });\n        });\n      });\n    } else { // version > 0\n\n      var setupDone = function () {\n        var migrated = dbVersion < ADAPTER_VERSION$1;\n        if (migrated) {\n          // update the db version within this transaction\n          tx.executeSql('UPDATE ' + META_STORE$1 + ' SET db_version = ' +\n            ADAPTER_VERSION$1);\n        }\n        // notify db.id() callers\n        var sql = 'SELECT dbid FROM ' + META_STORE$1;\n        tx.executeSql(sql, [], function (tx, result) {\n          instanceId = result.rows.item(0).dbid;\n          onGetInstanceId();\n        });\n      };\n\n      // would love to use promises here, but then websql\n      // ends the transaction early\n      var tasks = [\n        runMigration2,\n        runMigration3,\n        runMigration4,\n        runMigration5,\n        runMigration6,\n        runMigration7,\n        setupDone\n      ];\n\n      // run each migration sequentially\n      var i = dbVersion;\n      var nextMigration = function (tx) {\n        tasks[i - 1](tx, nextMigration);\n        i++;\n      };\n      nextMigration(tx);\n    }\n  }\n\n  function setup() {\n    db.transaction(function (tx) {\n      // first check the encoding\n      checkEncoding(tx, function () {\n        // then get the version\n        fetchVersion(tx);\n      });\n    }, websqlError(callback), dbCreated);\n  }\n\n  function fetchVersion(tx) {\n    var sql = 'SELECT sql FROM sqlite_master WHERE tbl_name = ' + META_STORE$1;\n    tx.executeSql(sql, [], function (tx, result) {\n      if (!result.rows.length) {\n        // database hasn't even been created yet (version 0)\n        onGetVersion(tx, 0);\n      } else if (!/db_version/.test(result.rows.item(0).sql)) {\n        // table was created, but without the new db_version column,\n        // so add it.\n        tx.executeSql('ALTER TABLE ' + META_STORE$1 +\n          ' ADD COLUMN db_version INTEGER', [], function () {\n          // before version 2, this column didn't even exist\n          onGetVersion(tx, 1);\n        });\n      } else { // column exists, we can safely get it\n        tx.executeSql('SELECT db_version FROM ' + META_STORE$1,\n          [], function (tx, result) {\n          var dbVersion = result.rows.item(0).db_version;\n          onGetVersion(tx, dbVersion);\n        });\n      }\n    });\n  }\n\n  setup();\n\n  function getMaxSeq(tx, callback) {\n    var sql = 'SELECT MAX(seq) AS seq FROM ' + BY_SEQ_STORE$1;\n    tx.executeSql(sql, [], function (tx, res) {\n      var updateSeq = res.rows.item(0).seq || 0;\n      callback(updateSeq);\n    });\n  }\n\n  function countDocs(tx, callback) {\n    // count the total rows\n    var sql = select(\n      'COUNT(' + DOC_STORE$1 + '.id) AS \\'num\\'',\n      [DOC_STORE$1, BY_SEQ_STORE$1],\n      DOC_STORE_AND_BY_SEQ_JOINER,\n      BY_SEQ_STORE$1 + '.deleted=0');\n\n    tx.executeSql(sql, [], function (tx, result) {\n      callback(result.rows.item(0).num);\n    });\n  }\n\n  api._remote = false;\n  api.type = function () {\n    return 'websql';\n  };\n\n  api._id = toPromise(function (callback) {\n    callback(null, instanceId);\n  });\n\n  api._info = function (callback) {\n    var seq;\n    var docCount;\n    db.readTransaction(function (tx) {\n      getMaxSeq(tx, function (theSeq) {\n        seq = theSeq;\n      });\n      countDocs(tx, function (theDocCount) {\n        docCount = theDocCount;\n      });\n    }, websqlError(callback), function () {\n      callback(null, {\n        doc_count: docCount,\n        update_seq: seq,\n        websql_encoding: encoding\n      });\n    });\n  };\n\n  api._bulkDocs = function (req, reqOpts, callback) {\n    websqlBulkDocs(opts, req, reqOpts, api, db, websqlChanges, callback);\n  };\n\n  function latest$$1(tx, id, rev$$1, callback, finish) {\n    var sql = select(\n        SELECT_DOCS,\n        [DOC_STORE$1, BY_SEQ_STORE$1],\n        DOC_STORE_AND_BY_SEQ_JOINER,\n        DOC_STORE$1 + '.id=?');\n    var sqlArgs = [id];\n\n    tx.executeSql(sql, sqlArgs, function (a, results) {\n      if (!results.rows.length) {\n        var err = createError(MISSING_DOC, 'missing');\n        return finish(err);\n      }\n      var item = results.rows.item(0);\n      var metadata = safeJsonParse(item.metadata);\n      callback(latest(rev$$1, metadata));\n    });\n  }\n\n  api._get = function (id, opts, callback) {\n    var doc;\n    var metadata;\n    var tx = opts.ctx;\n    if (!tx) {\n      return db.readTransaction(function (txn) {\n        api._get(id, $inject_Object_assign({ctx: txn}, opts), callback);\n      });\n    }\n\n    function finish(err) {\n      callback(err, {doc: doc, metadata: metadata, ctx: tx});\n    }\n\n    var sql;\n    var sqlArgs;\n\n    if (!opts.rev) {\n      sql = select(\n        SELECT_DOCS,\n        [DOC_STORE$1, BY_SEQ_STORE$1],\n        DOC_STORE_AND_BY_SEQ_JOINER,\n        DOC_STORE$1 + '.id=?');\n      sqlArgs = [id];\n    } else if (opts.latest) {\n      latest$$1(tx, id, opts.rev, function (latestRev) {\n        opts.latest = false;\n        opts.rev = latestRev;\n        api._get(id, opts, callback);\n      }, finish);\n      return;\n    } else {\n      sql = select(\n        SELECT_DOCS,\n        [DOC_STORE$1, BY_SEQ_STORE$1],\n        DOC_STORE$1 + '.id=' + BY_SEQ_STORE$1 + '.doc_id',\n        [BY_SEQ_STORE$1 + '.doc_id=?', BY_SEQ_STORE$1 + '.rev=?']);\n      sqlArgs = [id, opts.rev];\n    }\n\n    tx.executeSql(sql, sqlArgs, function (a, results) {\n      if (!results.rows.length) {\n        var missingErr = createError(MISSING_DOC, 'missing');\n        return finish(missingErr);\n      }\n      var item = results.rows.item(0);\n      metadata = safeJsonParse(item.metadata);\n      if (item.deleted && !opts.rev) {\n        var deletedErr = createError(MISSING_DOC, 'deleted');\n        return finish(deletedErr);\n      }\n      doc = unstringifyDoc(item.data, metadata.id, item.rev);\n      finish();\n    });\n  };\n\n  api._allDocs = function (opts, callback) {\n    var results = [];\n    var totalRows;\n    var updateSeq;\n\n    var start = 'startkey' in opts ? opts.startkey : false;\n    var end = 'endkey' in opts ? opts.endkey : false;\n    var key = 'key' in opts ? opts.key : false;\n    var keys = 'keys' in opts ? opts.keys : false;\n    var descending = 'descending' in opts ? opts.descending : false;\n    var limit = 'limit' in opts ? opts.limit : -1;\n    var offset = 'skip' in opts ? opts.skip : 0;\n    var inclusiveEnd = opts.inclusive_end !== false;\n    \n    var sqlArgs = [];\n    var criteria = [];\n\n    if (keys) {\n      var destinctKeys = [];\n      var bindingStr = \"\";\n      keys.forEach(function (key) {\n        if (destinctKeys.indexOf(key) === -1) {\n          destinctKeys.push(key);\n          bindingStr += '?,';\n        }\n      });\n      bindingStr = bindingStr.substring(0, bindingStr.length - 1); // keys is never empty\n      criteria.push(DOC_STORE$1 + '.id IN (' + bindingStr + ')');\n      sqlArgs = sqlArgs.concat(destinctKeys);\n    } else if (key !== false) {\n      criteria.push(DOC_STORE$1 + '.id = ?');\n      sqlArgs.push(key);\n    } else if (start !== false || end !== false) {\n      if (start !== false) {\n        criteria.push(DOC_STORE$1 + '.id ' + (descending ? '<=' : '>=') + ' ?');\n        sqlArgs.push(start);\n      }\n      if (end !== false) {\n        var comparator = descending ? '>' : '<';\n        if (inclusiveEnd) {\n          comparator += '=';\n        }\n        criteria.push(DOC_STORE$1 + '.id ' + comparator + ' ?');\n        sqlArgs.push(end);\n      }\n      if (key !== false) {\n        criteria.push(DOC_STORE$1 + '.id = ?');\n        sqlArgs.push(key);\n      }\n    }\n\n    if (!keys) {\n      // report deleted if keys are specified\n      criteria.push(BY_SEQ_STORE$1 + '.deleted = 0');\n    }\n\n    db.readTransaction(function (tx) {\n      // count the docs in parallel to other operations\n      countDocs(tx, function (docCount) {\n        totalRows = docCount;\n      });\n\n      /* istanbul ignore if */\n      if (opts.update_seq) {\n        // get max sequence in parallel to other operations\n        getMaxSeq(tx, function (theSeq) {\n          updateSeq = theSeq;\n        });\n      }\n\n      if (limit === 0) {\n        return;\n      }\n\n      // do a single query to fetch the documents\n      var sql = select(\n        SELECT_DOCS,\n        [DOC_STORE$1, BY_SEQ_STORE$1],\n        DOC_STORE_AND_BY_SEQ_JOINER,\n        criteria,\n        DOC_STORE$1 + '.id ' + (descending ? 'DESC' : 'ASC')\n        );\n      sql += ' LIMIT ' + limit + ' OFFSET ' + offset;\n\n      tx.executeSql(sql, sqlArgs, function (tx, result) {\n        for (var i = 0, l = result.rows.length; i < l; i++) {\n          var item = result.rows.item(i);\n          var metadata = safeJsonParse(item.metadata);\n          var id = metadata.id;\n          var data = unstringifyDoc(item.data, id, item.rev);\n          var winningRev$$1 = data._rev;\n          var doc = {\n            id: id,\n            key: id,\n            value: {rev: winningRev$$1}\n          };\n          if (opts.include_docs) {\n            doc.doc = data;\n            doc.doc._rev = winningRev$$1;\n            if (opts.conflicts) {\n              var conflicts = collectConflicts(metadata);\n              if (conflicts.length) {\n                doc.doc._conflicts = conflicts;\n              }\n            }\n            fetchAttachmentsIfNecessary$1(doc.doc, opts, api, tx);\n          }\n          if (item.deleted) {\n            if (keys) {\n              doc.value.deleted = true;\n              doc.doc = null;\n            } else {\n              // propably should not happen\n              continue;\n            }\n          }\n          if (!keys) {\n            results.push(doc);\n          } else {\n            var index = keys.indexOf(id, index);\n            do {\n              results[index] = doc;\n              index = keys.indexOf(id, index + 1);\n            } while (index > -1 && index < keys.length);\n          }\n        }\n        if (keys) {\n          keys.forEach(function (key, index) {\n            if (!results[index]) {\n              results[index] = {key: key, error: 'not_found'};\n            }\n          });\n        }\n      });\n    }, websqlError(callback), function () {\n      var returnVal = {\n        total_rows: totalRows,\n        offset: opts.skip,\n        rows: results\n      };\n\n      /* istanbul ignore if */\n      if (opts.update_seq) {\n        returnVal.update_seq = updateSeq;\n      }\n      callback(null, returnVal);\n    });\n  };\n\n  api._changes = function (opts) {\n    opts = clone(opts);\n\n    if (opts.continuous) {\n      var id = api._name + ':' + uuid();\n      websqlChanges.addListener(api._name, id, api, opts);\n      websqlChanges.notify(api._name);\n      return {\n        cancel: function () {\n          websqlChanges.removeListener(api._name, id);\n        }\n      };\n    }\n\n    var descending = opts.descending;\n\n    // Ignore the `since` parameter when `descending` is true\n    opts.since = opts.since && !descending ? opts.since : 0;\n\n    var limit = 'limit' in opts ? opts.limit : -1;\n    if (limit === 0) {\n      limit = 1; // per CouchDB _changes spec\n    }\n\n    var returnDocs;\n    if ('return_docs' in opts) {\n      returnDocs = opts.return_docs;\n    } else if ('returnDocs' in opts) {\n      // TODO: Remove 'returnDocs' in favor of 'return_docs' in a future release\n      returnDocs = opts.returnDocs;\n    } else {\n      returnDocs = true;\n    }\n    var results = [];\n    var numResults = 0;\n\n    function fetchChanges() {\n\n      var selectStmt =\n        DOC_STORE$1 + '.json AS metadata, ' +\n        DOC_STORE$1 + '.max_seq AS maxSeq, ' +\n        BY_SEQ_STORE$1 + '.json AS winningDoc, ' +\n        BY_SEQ_STORE$1 + '.rev AS winningRev ';\n\n      var from = DOC_STORE$1 + ' JOIN ' + BY_SEQ_STORE$1;\n\n      var joiner = DOC_STORE$1 + '.id=' + BY_SEQ_STORE$1 + '.doc_id' +\n        ' AND ' + DOC_STORE$1 + '.winningseq=' + BY_SEQ_STORE$1 + '.seq';\n\n      var criteria = ['maxSeq > ?'];\n      var sqlArgs = [opts.since];\n\n      if (opts.doc_ids) {\n        criteria.push(DOC_STORE$1 + '.id IN ' + qMarks(opts.doc_ids.length));\n        sqlArgs = sqlArgs.concat(opts.doc_ids);\n      }\n\n      var orderBy = 'maxSeq ' + (descending ? 'DESC' : 'ASC');\n\n      var sql = select(selectStmt, from, joiner, criteria, orderBy);\n\n      var filter = filterChange(opts);\n      if (!opts.view && !opts.filter) {\n        // we can just limit in the query\n        sql += ' LIMIT ' + limit;\n      }\n\n      var lastSeq = opts.since || 0;\n      db.readTransaction(function (tx) {\n        tx.executeSql(sql, sqlArgs, function (tx, result) {\n          function reportChange(change) {\n            return function () {\n              opts.onChange(change);\n            };\n          }\n          for (var i = 0, l = result.rows.length; i < l; i++) {\n            var item = result.rows.item(i);\n            var metadata = safeJsonParse(item.metadata);\n            lastSeq = item.maxSeq;\n\n            var doc = unstringifyDoc(item.winningDoc, metadata.id,\n              item.winningRev);\n            var change = opts.processChange(doc, metadata, opts);\n            change.seq = item.maxSeq;\n\n            var filtered = filter(change);\n            if (typeof filtered === 'object') {\n              return opts.complete(filtered);\n            }\n\n            if (filtered) {\n              numResults++;\n              if (returnDocs) {\n                results.push(change);\n              }\n              // process the attachment immediately\n              // for the benefit of live listeners\n              if (opts.attachments && opts.include_docs) {\n                fetchAttachmentsIfNecessary$1(doc, opts, api, tx,\n                  reportChange(change));\n              } else {\n                reportChange(change)();\n              }\n            }\n            if (numResults === limit) {\n              break;\n            }\n          }\n        });\n      }, websqlError(opts.complete), function () {\n        if (!opts.continuous) {\n          opts.complete(null, {\n            results: results,\n            last_seq: lastSeq\n          });\n        }\n      });\n    }\n\n    fetchChanges();\n  };\n\n  api._close = function (callback) {\n    //WebSQL databases do not need to be closed\n    callback();\n  };\n\n  api._getAttachment = function (docId, attachId, attachment, opts, callback) {\n    var res;\n    var tx = opts.ctx;\n    var digest = attachment.digest;\n    var type = attachment.content_type;\n    var sql = 'SELECT escaped, ' +\n      'CASE WHEN escaped = 1 THEN body ELSE HEX(body) END AS body FROM ' +\n      ATTACH_STORE$1 + ' WHERE digest=?';\n    tx.executeSql(sql, [digest], function (tx, result) {\n      // websql has a bug where \\u0000 causes early truncation in strings\n      // and blobs. to work around this, we used to use the hex() function,\n      // but that's not performant. after migration 6, we remove \\u0000\n      // and add it back in afterwards\n      var item = result.rows.item(0);\n      var data = item.escaped ? unescapeBlob(item.body) :\n        parseHexString(item.body, encoding);\n      if (opts.binary) {\n        res = binStringToBluffer(data, type);\n      } else {\n        res = thisBtoa(data);\n      }\n      callback(null, res);\n    });\n  };\n\n  api._getRevisionTree = function (docId, callback) {\n    db.readTransaction(function (tx) {\n      var sql = 'SELECT json AS metadata FROM ' + DOC_STORE$1 + ' WHERE id = ?';\n      tx.executeSql(sql, [docId], function (tx, result) {\n        if (!result.rows.length) {\n          callback(createError(MISSING_DOC));\n        } else {\n          var data = safeJsonParse(result.rows.item(0).metadata);\n          callback(null, data.rev_tree);\n        }\n      });\n    });\n  };\n\n  api._doCompaction = function (docId, revs, callback) {\n    if (!revs.length) {\n      return callback();\n    }\n    db.transaction(function (tx) {\n\n      // update doc store\n      var sql = 'SELECT json AS metadata FROM ' + DOC_STORE$1 + ' WHERE id = ?';\n      tx.executeSql(sql, [docId], function (tx, result) {\n        var metadata = safeJsonParse(result.rows.item(0).metadata);\n        traverseRevTree(metadata.rev_tree, function (isLeaf, pos,\n                                                           revHash, ctx, opts) {\n          var rev$$1 = pos + '-' + revHash;\n          if (revs.indexOf(rev$$1) !== -1) {\n            opts.status = 'missing';\n          }\n        });\n\n        var sql = 'UPDATE ' + DOC_STORE$1 + ' SET json = ? WHERE id = ?';\n        tx.executeSql(sql, [safeJsonStringify(metadata), docId]);\n      });\n\n      compactRevs$1(revs, docId, tx);\n    }, websqlError(callback), function () {\n      callback();\n    });\n  };\n\n  api._getLocal = function (id, callback) {\n    db.readTransaction(function (tx) {\n      var sql = 'SELECT json, rev FROM ' + LOCAL_STORE$1 + ' WHERE id=?';\n      tx.executeSql(sql, [id], function (tx, res) {\n        if (res.rows.length) {\n          var item = res.rows.item(0);\n          var doc = unstringifyDoc(item.json, id, item.rev);\n          callback(null, doc);\n        } else {\n          callback(createError(MISSING_DOC));\n        }\n      });\n    });\n  };\n\n  api._putLocal = function (doc, opts, callback) {\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    delete doc._revisions; // ignore this, trust the rev\n    var oldRev = doc._rev;\n    var id = doc._id;\n    var newRev;\n    if (!oldRev) {\n      newRev = doc._rev = '0-1';\n    } else {\n      newRev = doc._rev = '0-' + (parseInt(oldRev.split('-')[1], 10) + 1);\n    }\n    var json = stringifyDoc(doc);\n\n    var ret;\n    function putLocal(tx) {\n      var sql;\n      var values;\n      if (oldRev) {\n        sql = 'UPDATE ' + LOCAL_STORE$1 + ' SET rev=?, json=? ' +\n          'WHERE id=? AND rev=?';\n        values = [newRev, json, id, oldRev];\n      } else {\n        sql = 'INSERT INTO ' + LOCAL_STORE$1 + ' (id, rev, json) VALUES (?,?,?)';\n        values = [id, newRev, json];\n      }\n      tx.executeSql(sql, values, function (tx, res) {\n        if (res.rowsAffected) {\n          ret = {ok: true, id: id, rev: newRev};\n          if (opts.ctx) { // return immediately\n            callback(null, ret);\n          }\n        } else {\n          callback(createError(REV_CONFLICT));\n        }\n      }, function () {\n        callback(createError(REV_CONFLICT));\n        return false; // ack that we handled the error\n      });\n    }\n\n    if (opts.ctx) {\n      putLocal(opts.ctx);\n    } else {\n      db.transaction(putLocal, websqlError(callback), function () {\n        if (ret) {\n          callback(null, ret);\n        }\n      });\n    }\n  };\n\n  api._removeLocal = function (doc, opts, callback) {\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    var ret;\n\n    function removeLocal(tx) {\n      var sql = 'DELETE FROM ' + LOCAL_STORE$1 + ' WHERE id=? AND rev=?';\n      var params = [doc._id, doc._rev];\n      tx.executeSql(sql, params, function (tx, res) {\n        if (!res.rowsAffected) {\n          return callback(createError(MISSING_DOC));\n        }\n        ret = {ok: true, id: doc._id, rev: '0-0'};\n        if (opts.ctx) { // return immediately\n          callback(null, ret);\n        }\n      });\n    }\n\n    if (opts.ctx) {\n      removeLocal(opts.ctx);\n    } else {\n      db.transaction(removeLocal, websqlError(callback), function () {\n        if (ret) {\n          callback(null, ret);\n        }\n      });\n    }\n  };\n\n  api._destroy = function (opts, callback) {\n    websqlChanges.removeAllListeners(api._name);\n    db.transaction(function (tx) {\n      var stores = [DOC_STORE$1, BY_SEQ_STORE$1, ATTACH_STORE$1, META_STORE$1,\n        LOCAL_STORE$1, ATTACH_AND_SEQ_STORE$1];\n      stores.forEach(function (store) {\n        tx.executeSql('DROP TABLE IF EXISTS ' + store, []);\n      });\n    }, websqlError(callback), function () {\n      if (hasLocalStorage()) {\n        delete window.localStorage['_pouch__websqldb_' + api._name];\n        delete window.localStorage[api._name];\n      }\n      callback(null, {'ok': true});\n    });\n  };\n}\n\nfunction canOpenTestDB() {\n  try {\n    openDatabase('_pouch_validate_websql', 1, '', 1);\n    return true;\n  } catch (err) {\n    return false;\n  }\n}\n\n// WKWebView had a bug where WebSQL would throw a DOM Exception 18\n// (see https://bugs.webkit.org/show_bug.cgi?id=137760 and\n// https://github.com/pouchdb/pouchdb/issues/5079)\n// This has been fixed in latest WebKit, so we try to detect it here.\nfunction isValidWebSQL() {\n  // WKWebView UA:\n  //   Mozilla/5.0 (iPhone; CPU iPhone OS 9_2 like Mac OS X)\n  //   AppleWebKit/601.1.46 (KHTML, like Gecko) Mobile/13C75\n  // Chrome for iOS UA:\n  //   Mozilla/5.0 (iPhone; U; CPU iPhone OS 5_1_1 like Mac OS X; en)\n  //   AppleWebKit/534.46.0 (KHTML, like Gecko) CriOS/19.0.1084.60\n  //   Mobile/9B206 Safari/7534.48.3\n  // Firefox for iOS UA:\n  //   Mozilla/5.0 (iPhone; CPU iPhone OS 8_3 like Mac OS X) AppleWebKit/600.1.4\n  //   (KHTML, like Gecko) FxiOS/1.0 Mobile/12F69 Safari/600.1.4\n\n  // indexedDB is null on some UIWebViews and undefined in others\n  // see: https://bugs.webkit.org/show_bug.cgi?id=137034\n  if (typeof indexedDB === 'undefined' || indexedDB === null ||\n      !/iP(hone|od|ad)/.test(navigator.userAgent)) {\n    // definitely not WKWebView, avoid creating an unnecessary database\n    return true;\n  }\n  // Cache the result in LocalStorage. Reason we do this is because if we\n  // call openDatabase() too many times, Safari craps out in SauceLabs and\n  // starts throwing DOM Exception 14s.\n  var hasLS = hasLocalStorage();\n  // Include user agent in the hash, so that if Safari is upgraded, we don't\n  // continually think it's broken.\n  var localStorageKey = '_pouch__websqldb_valid_' + navigator.userAgent;\n  if (hasLS && localStorage[localStorageKey]) {\n    return localStorage[localStorageKey] === '1';\n  }\n  var openedTestDB = canOpenTestDB();\n  if (hasLS) {\n    localStorage[localStorageKey] = openedTestDB ? '1' : '0';\n  }\n  return openedTestDB;\n}\n\nfunction valid() {\n  if (typeof openDatabase !== 'function') {\n    return false;\n  }\n  return isValidWebSQL();\n}\n\nfunction openDB$2(name, version, description, size) {\n  // Traditional WebSQL API\n  return openDatabase(name, version, description, size);\n}\n\nfunction WebSQLPouch(opts, callback) {\n  var msg = 'WebSQL is deprecated and will be removed in future releases of PouchDB. ' +\n      'Please migrate to IndexedDB: https://pouchdb.com/2018/01/23/pouchdb-6.4.2.html';\n  guardedConsole('warn', msg);\n  var _opts = $inject_Object_assign({\n    websql: openDB$2\n  }, opts);\n\n  WebSqlPouch.call(this, _opts, callback);\n}\n\nWebSQLPouch.valid = valid;\n\nWebSQLPouch.use_prefix = true;\n\nfunction WebSqlPouch$1 (PouchDB) {\n  PouchDB.adapter('websql', WebSQLPouch, true);\n}\n\n/* global fetch */\n/* global Headers */\nfunction wrappedFetch() {\n  var wrappedPromise = {};\n\n  var promise = new PouchPromise(function (resolve, reject) {\n    wrappedPromise.resolve = resolve;\n    wrappedPromise.reject = reject;\n  });\n\n  var args = new Array(arguments.length);\n\n  for (var i = 0; i < args.length; i++) {\n    args[i] = arguments[i];\n  }\n\n  wrappedPromise.promise = promise;\n\n  PouchPromise.resolve().then(function () {\n    return fetch.apply(null, args);\n  }).then(function (response) {\n    wrappedPromise.resolve(response);\n  })[\"catch\"](function (error) {\n    wrappedPromise.reject(error);\n  });\n\n  return wrappedPromise;\n}\n\nfunction fetchRequest(options, callback) {\n  var wrappedPromise, timer, response;\n\n  var headers = new Headers();\n\n  var fetchOptions = {\n    method: options.method,\n    credentials: 'include',\n    headers: headers\n  };\n\n  if (options.json) {\n    headers.set('Accept', 'application/json');\n    headers.set('Content-Type', options.headers['Content-Type'] ||\n      'application/json');\n  }\n\n  if (options.body &&\n      options.processData &&\n      typeof options.body !== 'string') {\n    fetchOptions.body = JSON.stringify(options.body);\n  } else if ('body' in options) {\n    fetchOptions.body = options.body;\n  } else {\n    fetchOptions.body = null;\n  }\n\n  Object.keys(options.headers).forEach(function (key) {\n    if (options.headers.hasOwnProperty(key)) {\n      headers.set(key, options.headers[key]);\n    }\n  });\n\n  wrappedPromise = wrappedFetch(options.url, fetchOptions);\n\n  if (options.timeout > 0) {\n    timer = setTimeout(function () {\n      wrappedPromise.reject(new Error('Load timeout for resource: ' +\n        options.url));\n    }, options.timeout);\n  }\n\n  wrappedPromise.promise.then(function (fetchResponse) {\n    response = {\n      statusCode: fetchResponse.status\n    };\n\n    if (options.timeout > 0) {\n      clearTimeout(timer);\n    }\n\n    if (response.statusCode >= 200 && response.statusCode < 300) {\n      return options.binary ? fetchResponse.blob() : fetchResponse.text();\n    }\n\n    return fetchResponse.json();\n  }).then(function (result) {\n    if (response.statusCode >= 200 && response.statusCode < 300) {\n      callback(null, response, result);\n    } else {\n      result.status = response.statusCode;\n      callback(result);\n    }\n  })[\"catch\"](function (error) {\n    if (!error) {\n      // this happens when the listener is canceled\n      error = new Error('canceled');\n    }\n    callback(error);\n  });\n\n  return {abort: wrappedPromise.reject};\n}\n\nfunction xhRequest(options, callback) {\n\n  var xhr, timer;\n  var timedout = false;\n\n  var abortReq = function () {\n    xhr.abort();\n    cleanUp();\n  };\n\n  var timeoutReq = function () {\n    timedout = true;\n    xhr.abort();\n    cleanUp();\n  };\n\n  var ret = {abort: abortReq};\n\n  var cleanUp = function () {\n    clearTimeout(timer);\n    ret.abort = function () {};\n    if (xhr) {\n      xhr.onprogress = undefined;\n      if (xhr.upload) {\n        xhr.upload.onprogress = undefined;\n      }\n      xhr.onreadystatechange = undefined;\n      xhr = undefined;\n    }\n  };\n\n  if (options.xhr) {\n    xhr = new options.xhr();\n  } else {\n    xhr = new XMLHttpRequest();\n  }\n\n  try {\n    xhr.open(options.method, options.url);\n  } catch (exception) {\n    return callback(new Error(exception.name || 'Url is invalid'));\n  }\n\n  xhr.withCredentials = ('withCredentials' in options) ?\n    options.withCredentials : true;\n\n  if (options.method === 'GET') {\n    delete options.headers['Content-Type'];\n  } else if (options.json) {\n    options.headers.Accept = 'application/json';\n    options.headers['Content-Type'] = options.headers['Content-Type'] ||\n      'application/json';\n    if (options.body &&\n        options.processData &&\n        typeof options.body !== \"string\") {\n      options.body = JSON.stringify(options.body);\n    }\n  }\n\n  if (options.binary) {\n    xhr.responseType = 'arraybuffer';\n  }\n\n  if (!('body' in options)) {\n    options.body = null;\n  }\n\n  for (var key in options.headers) {\n    if (options.headers.hasOwnProperty(key)) {\n      xhr.setRequestHeader(key, options.headers[key]);\n    }\n  }\n\n  if (options.timeout > 0) {\n    timer = setTimeout(timeoutReq, options.timeout);\n    xhr.onprogress = function () {\n      clearTimeout(timer);\n      if (xhr.readyState !== 4) {\n        timer = setTimeout(timeoutReq, options.timeout);\n      }\n    };\n    if (typeof xhr.upload !== 'undefined') { // does not exist in ie9\n      xhr.upload.onprogress = xhr.onprogress;\n    }\n  }\n\n  xhr.onreadystatechange = function () {\n    if (xhr.readyState !== 4) {\n      return;\n    }\n\n    var response = {\n      statusCode: xhr.status\n    };\n\n    if (xhr.status >= 200 && xhr.status < 300) {\n      var data;\n      if (options.binary) {\n        data = createBlob([xhr.response || ''], {\n          type: xhr.getResponseHeader('Content-Type')\n        });\n      } else {\n        data = xhr.responseText;\n      }\n      callback(null, response, data);\n    } else {\n      var err = {};\n      if (timedout) {\n        err = new Error('ETIMEDOUT');\n        err.code = 'ETIMEDOUT';\n      } else if (typeof xhr.response === 'string' && xhr.response !== '') {\n        try {\n          err = JSON.parse(xhr.response);\n        } catch (e) {}\n      }\n\n      err.status = xhr.status;\n\n      callback(err);\n    }\n    cleanUp();\n  };\n\n  if (options.body && (options.body instanceof Blob)) {\n    readAsArrayBuffer(options.body, function (arrayBuffer) {\n      xhr.send(arrayBuffer);\n    });\n  } else {\n    xhr.send(options.body);\n  }\n\n  return ret;\n}\n\nfunction testXhr() {\n  try {\n    new XMLHttpRequest();\n    return true;\n  } catch (err) {\n    return false;\n  }\n}\n\nvar hasXhr = testXhr();\n\nfunction ajax(options, callback) {\n  if (!false && (hasXhr || options.xhr)) {\n    return xhRequest(options, callback);\n  } else {\n    return fetchRequest(options, callback);\n  }\n}\n\n// the blob already has a type; do nothing\n\nfunction defaultBody() {\n  return '';\n}\n\nfunction ajaxCore(options, callback) {\n\n  options = clone(options);\n\n  var defaultOptions = {\n    method : \"GET\",\n    headers: {},\n    json: true,\n    processData: true,\n    timeout: 10000,\n    cache: false\n  };\n\n  options = $inject_Object_assign(defaultOptions, options);\n\n  function onSuccess(obj, resp, cb) {\n    if (!options.binary && options.json && typeof obj === 'string') {\n      /* istanbul ignore next */\n      try {\n        obj = JSON.parse(obj);\n      } catch (e) {\n        // Probably a malformed JSON from server\n        return cb(e);\n      }\n    }\n    if (Array.isArray(obj)) {\n      obj = obj.map(function (v) {\n        if (v.error || v.missing) {\n          return generateErrorFromResponse(v);\n        } else {\n          return v;\n        }\n      });\n    }\n    if (options.binary) {\n      \n    }\n    cb(null, obj, resp);\n  }\n\n  if (options.json) {\n    if (!options.binary) {\n      options.headers.Accept = 'application/json';\n    }\n    options.headers['Content-Type'] = options.headers['Content-Type'] ||\n      'application/json';\n  }\n\n  if (options.binary) {\n    options.encoding = null;\n    options.json = false;\n  }\n\n  if (!options.processData) {\n    options.json = false;\n  }\n\n  return ajax(options, function (err, response, body) {\n\n    if (err) {\n      return callback(generateErrorFromResponse(err));\n    }\n\n    var error;\n    var content_type = response.headers && response.headers['content-type'];\n    var data = body || defaultBody();\n\n    // CouchDB doesn't always return the right content-type for JSON data, so\n    // we check for ^{ and }$ (ignoring leading/trailing whitespace)\n    if (!options.binary && (options.json || !options.processData) &&\n        typeof data !== 'object' &&\n        (/json/.test(content_type) ||\n         (/^[\\s]*\\{/.test(data) && /\\}[\\s]*$/.test(data)))) {\n      try {\n        data = JSON.parse(data.toString());\n      } catch (e) {}\n    }\n\n    if (response.statusCode >= 200 && response.statusCode < 300) {\n      onSuccess(data, response, callback);\n    } else {\n      error = generateErrorFromResponse(data);\n      error.status = response.statusCode;\n      callback(error);\n    }\n  });\n}\n\nfunction ajax$1(opts, callback) {\n\n  // cache-buster, specifically designed to work around IE's aggressive caching\n  // see http://www.dashbay.com/2011/05/internet-explorer-caches-ajax/\n  // Also Safari caches POSTs, so we need to cache-bust those too.\n  var ua = (navigator && navigator.userAgent) ?\n    navigator.userAgent.toLowerCase() : '';\n\n  var isSafari = ua.indexOf('safari') !== -1 && ua.indexOf('chrome') === -1;\n  var isIE = ua.indexOf('msie') !== -1;\n  var isTrident = ua.indexOf('trident') !== -1;\n  var isEdge = ua.indexOf('edge') !== -1;\n\n  // it appears the new version of safari also caches GETs,\n  // see https://github.com/pouchdb/pouchdb/issues/5010\n  var shouldCacheBust = (isSafari ||\n    ((isIE || isTrident || isEdge) && opts.method === 'GET'));\n\n  var cache = 'cache' in opts ? opts.cache : true;\n\n  var isBlobUrl = /^blob:/.test(opts.url); // don't append nonces for blob URLs\n\n  if (!isBlobUrl && (shouldCacheBust || !cache)) {\n    var hasArgs = opts.url.indexOf('?') !== -1;\n    opts.url += (hasArgs ? '&' : '?') + '_nonce=' + Date.now();\n  }\n\n  return ajaxCore(opts, callback);\n}\n\n// dead simple promise pool, inspired by https://github.com/timdp/es6-promise-pool\n// but much smaller in code size. limits the number of concurrent promises that are executed\n\n\nfunction pool(promiseFactories, limit) {\n  return new PouchPromise(function (resolve, reject) {\n    var running = 0;\n    var current = 0;\n    var done = 0;\n    var len = promiseFactories.length;\n    var err;\n\n    function runNext() {\n      running++;\n      promiseFactories[current++]().then(onSuccess, onError);\n    }\n\n    function doNext() {\n      if (++done === len) {\n        /* istanbul ignore if */\n        if (err) {\n          reject(err);\n        } else {\n          resolve();\n        }\n      } else {\n        runNextBatch();\n      }\n    }\n\n    function onSuccess() {\n      running--;\n      doNext();\n    }\n\n    /* istanbul ignore next */\n    function onError(thisErr) {\n      running--;\n      err = err || thisErr;\n      doNext();\n    }\n\n    function runNextBatch() {\n      while (running < limit && current < len) {\n        runNext();\n      }\n    }\n\n    runNextBatch();\n  });\n}\n\nvar CHANGES_BATCH_SIZE = 25;\nvar MAX_SIMULTANEOUS_REVS = 50;\nvar CHANGES_TIMEOUT_BUFFER = 5000;\nvar DEFAULT_HEARTBEAT = 10000;\n\nvar supportsBulkGetMap = {};\n\nfunction readAttachmentsAsBlobOrBuffer(row) {\n  var doc = row.doc || row.ok;\n  var atts = doc._attachments;\n  if (!atts) {\n    return;\n  }\n  Object.keys(atts).forEach(function (filename) {\n    var att = atts[filename];\n    att.data = b64ToBluffer(att.data, att.content_type);\n  });\n}\n\nfunction encodeDocId(id) {\n  if (/^_design/.test(id)) {\n    return '_design/' + encodeURIComponent(id.slice(8));\n  }\n  if (/^_local/.test(id)) {\n    return '_local/' + encodeURIComponent(id.slice(7));\n  }\n  return encodeURIComponent(id);\n}\n\nfunction preprocessAttachments$2(doc) {\n  if (!doc._attachments || !Object.keys(doc._attachments)) {\n    return PouchPromise.resolve();\n  }\n\n  return PouchPromise.all(Object.keys(doc._attachments).map(function (key) {\n    var attachment = doc._attachments[key];\n    if (attachment.data && typeof attachment.data !== 'string') {\n      return new PouchPromise(function (resolve) {\n        blobToBase64(attachment.data, resolve);\n      }).then(function (b64) {\n        attachment.data = b64;\n      });\n    }\n  }));\n}\n\nfunction hasUrlPrefix(opts) {\n  if (!opts.prefix) {\n    return false;\n  }\n\n  var protocol = parseUri(opts.prefix).protocol;\n\n  return protocol === 'http' || protocol === 'https';\n}\n\n// Get all the information you possibly can about the URI given by name and\n// return it as a suitable object.\nfunction getHost(name, opts) {\n\n  // encode db name if opts.prefix is a url (#5574)\n  if (hasUrlPrefix(opts)) {\n    var dbName = opts.name.substr(opts.prefix.length);\n    name = opts.prefix + encodeURIComponent(dbName);\n  }\n\n  // Prase the URI into all its little bits\n  var uri = parseUri(name);\n\n  // Store the user and password as a separate auth object\n  if (uri.user || uri.password) {\n    uri.auth = {username: uri.user, password: uri.password};\n  }\n\n  // Split the path part of the URI into parts using '/' as the delimiter\n  // after removing any leading '/' and any trailing '/'\n  var parts = uri.path.replace(/(^\\/|\\/$)/g, '').split('/');\n\n  // Store the first part as the database name and remove it from the parts\n  // array\n  uri.db = parts.pop();\n  // Prevent double encoding of URI component\n  if (uri.db.indexOf('%') === -1) {\n    uri.db = encodeURIComponent(uri.db);\n  }\n\n  // Restore the path by joining all the remaining parts (all the parts\n  // except for the database name) with '/'s\n  uri.path = parts.join('/');\n\n  return uri;\n}\n\n// Generate a URL with the host data given by opts and the given path\nfunction genDBUrl(opts, path) {\n  return genUrl(opts, opts.db + '/' + path);\n}\n\n// Generate a URL with the host data given by opts and the given path\nfunction genUrl(opts, path) {\n  // If the host already has a path, then we need to have a path delimiter\n  // Otherwise, the path delimiter is the empty string\n  var pathDel = !opts.path ? '' : '/';\n\n  // If the host already has a path, then we need to have a path delimiter\n  // Otherwise, the path delimiter is the empty string\n  return opts.protocol + '://' + opts.host +\n         (opts.port ? (':' + opts.port) : '') +\n         '/' + opts.path + pathDel + path;\n}\n\nfunction paramsToStr(params) {\n  return '?' + Object.keys(params).map(function (k) {\n    return k + '=' + encodeURIComponent(params[k]);\n  }).join('&');\n}\n\n// Implements the PouchDB API for dealing with CouchDB instances over HTTP\nfunction HttpPouch(opts, callback) {\n\n  // The functions that will be publicly available for HttpPouch\n  var api = this;\n\n  var host = getHost(opts.name, opts);\n  var dbUrl = genDBUrl(host, '');\n\n  opts = clone(opts);\n  var ajaxOpts = opts.ajax || {};\n\n  if (opts.auth || host.auth) {\n    var nAuth = opts.auth || host.auth;\n    var str = nAuth.username + ':' + nAuth.password;\n    var token = thisBtoa(unescape(encodeURIComponent(str)));\n    ajaxOpts.headers = ajaxOpts.headers || {};\n    ajaxOpts.headers.Authorization = 'Basic ' + token;\n  }\n\n  // Not strictly necessary, but we do this because numerous tests\n  // rely on swapping ajax in and out.\n  api._ajax = ajax$1;\n\n  function ajax(userOpts, options, callback) {\n    var reqAjax = (userOpts || {}).ajax || {};\n    var reqOpts = $inject_Object_assign(clone(ajaxOpts), reqAjax, options);\n    var defaultHeaders = clone(ajaxOpts.headers || {});\n    reqOpts.headers = $inject_Object_assign(defaultHeaders, reqAjax.headers,\n      options.headers || {});\n    /* istanbul ignore if */\n    if (api.constructor.listeners('debug').length) {\n      api.constructor.emit('debug', ['http', reqOpts.method, reqOpts.url]);\n    }\n    return api._ajax(reqOpts, callback);\n  }\n\n  function ajaxPromise(userOpts, opts) {\n    return new PouchPromise(function (resolve, reject) {\n      ajax(userOpts, opts, function (err, res) {\n        /* istanbul ignore if */\n        if (err) {\n          return reject(err);\n        }\n        resolve(res);\n      });\n    });\n  }\n\n  function adapterFun$$1(name, fun) {\n    return adapterFun(name, getArguments(function (args) {\n      setup().then(function () {\n        return fun.apply(this, args);\n      })[\"catch\"](function (e) {\n        var callback = args.pop();\n        callback(e);\n      });\n    }));\n  }\n\n  var setupPromise;\n\n  function setup() {\n    // TODO: Remove `skipSetup` in favor of `skip_setup` in a future release\n    if (opts.skipSetup || opts.skip_setup) {\n      return PouchPromise.resolve();\n    }\n\n    // If there is a setup in process or previous successful setup\n    // done then we will use that\n    // If previous setups have been rejected we will try again\n    if (setupPromise) {\n      return setupPromise;\n    }\n\n    var checkExists = {method: 'GET', url: dbUrl};\n    setupPromise = ajaxPromise({}, checkExists)[\"catch\"](function (err) {\n      if (err && err.status && err.status === 404) {\n        // Doesnt exist, create it\n        explainError(404, 'PouchDB is just detecting if the remote exists.');\n        return ajaxPromise({}, {method: 'PUT', url: dbUrl});\n      } else {\n        return PouchPromise.reject(err);\n      }\n    })[\"catch\"](function (err) {\n      // If we try to create a database that already exists, skipped in\n      // istanbul since its catching a race condition.\n      /* istanbul ignore if */\n      if (err && err.status && err.status === 412) {\n        return true;\n      }\n      return PouchPromise.reject(err);\n    });\n\n    setupPromise[\"catch\"](function () {\n      setupPromise = null;\n    });\n\n    return setupPromise;\n  }\n\n  nextTick(function () {\n    callback(null, api);\n  });\n\n  api._remote = true;\n  /* istanbul ignore next */\n  api.type = function () {\n    return 'http';\n  };\n\n  api.id = adapterFun$$1('id', function (callback) {\n    ajax({}, {method: 'GET', url: genUrl(host, '')}, function (err, result) {\n      var uuid$$1 = (result && result.uuid) ?\n        (result.uuid + host.db) : genDBUrl(host, '');\n      callback(null, uuid$$1);\n    });\n  });\n\n  api.request = adapterFun$$1('request', function (options, callback) {\n    options.url = genDBUrl(host, options.url);\n    ajax({}, options, callback);\n  });\n\n  // Sends a POST request to the host calling the couchdb _compact function\n  //    version: The version of CouchDB it is running\n  api.compact = adapterFun$$1('compact', function (opts, callback) {\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    opts = clone(opts);\n    ajax(opts, {\n      url: genDBUrl(host, '_compact'),\n      method: 'POST'\n    }, function () {\n      function ping() {\n        api.info(function (err, res) {\n          // CouchDB may send a \"compact_running:true\" if it's\n          // already compacting. PouchDB Server doesn't.\n          /* istanbul ignore else */\n          if (res && !res.compact_running) {\n            callback(null, {ok: true});\n          } else {\n            setTimeout(ping, opts.interval || 200);\n          }\n        });\n      }\n      // Ping the http if it's finished compaction\n      ping();\n    });\n  });\n\n  api.bulkGet = adapterFun('bulkGet', function (opts, callback) {\n    var self = this;\n\n    function doBulkGet(cb) {\n      var params = {};\n      if (opts.revs) {\n        params.revs = true;\n      }\n      if (opts.attachments) {\n        /* istanbul ignore next */\n        params.attachments = true;\n      }\n      if (opts.latest) {\n        params.latest = true;\n      }\n      ajax(opts, {\n        url: genDBUrl(host, '_bulk_get' + paramsToStr(params)),\n        method: 'POST',\n        body: { docs: opts.docs}\n      }, function (err, result) {\n        if (!err && opts.attachments && opts.binary) {\n          result.results.forEach(function (res) {\n            res.docs.forEach(readAttachmentsAsBlobOrBuffer);\n          });\n        }\n        cb(err, result);\n      });\n    }\n\n    /* istanbul ignore next */\n    function doBulkGetShim() {\n      // avoid \"url too long error\" by splitting up into multiple requests\n      var batchSize = MAX_SIMULTANEOUS_REVS;\n      var numBatches = Math.ceil(opts.docs.length / batchSize);\n      var numDone = 0;\n      var results = new Array(numBatches);\n\n      function onResult(batchNum) {\n        return function (err, res) {\n          // err is impossible because shim returns a list of errs in that case\n          results[batchNum] = res.results;\n          if (++numDone === numBatches) {\n            callback(null, {results: flatten(results)});\n          }\n        };\n      }\n\n      for (var i = 0; i < numBatches; i++) {\n        var subOpts = pick(opts, ['revs', 'attachments', 'binary', 'latest']);\n        subOpts.ajax = ajaxOpts;\n        subOpts.docs = opts.docs.slice(i * batchSize,\n          Math.min(opts.docs.length, (i + 1) * batchSize));\n        bulkGet(self, subOpts, onResult(i));\n      }\n    }\n\n    // mark the whole database as either supporting or not supporting _bulk_get\n    var dbUrl = genUrl(host, '');\n    var supportsBulkGet = supportsBulkGetMap[dbUrl];\n\n    /* istanbul ignore next */\n    if (typeof supportsBulkGet !== 'boolean') {\n      // check if this database supports _bulk_get\n      doBulkGet(function (err, res) {\n        if (err) {\n          supportsBulkGetMap[dbUrl] = false;\n          explainError(\n            err.status,\n            'PouchDB is just detecting if the remote ' +\n            'supports the _bulk_get API.'\n          );\n          doBulkGetShim();\n        } else {\n          supportsBulkGetMap[dbUrl] = true;\n          callback(null, res);\n        }\n      });\n    } else if (supportsBulkGet) {\n      doBulkGet(callback);\n    } else {\n      doBulkGetShim();\n    }\n  });\n\n  // Calls GET on the host, which gets back a JSON string containing\n  //    couchdb: A welcome string\n  //    version: The version of CouchDB it is running\n  api._info = function (callback) {\n    setup().then(function () {\n      ajax({}, {\n        method: 'GET',\n        url: genDBUrl(host, '')\n      }, function (err, res) {\n        /* istanbul ignore next */\n        if (err) {\n        return callback(err);\n        }\n        res.host = genDBUrl(host, '');\n        callback(null, res);\n      });\n    })[\"catch\"](callback);\n  };\n\n  // Get the document with the given id from the database given by host.\n  // The id could be solely the _id in the database, or it may be a\n  // _design/ID or _local/ID path\n  api.get = adapterFun$$1('get', function (id, opts, callback) {\n    // If no options were given, set the callback to the second parameter\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    opts = clone(opts);\n\n    // List of parameters to add to the GET request\n    var params = {};\n\n    if (opts.revs) {\n      params.revs = true;\n    }\n\n    if (opts.revs_info) {\n      params.revs_info = true;\n    }\n\n    if (opts.latest) {\n      params.latest = true;\n    }\n\n    if (opts.open_revs) {\n      if (opts.open_revs !== \"all\") {\n        opts.open_revs = JSON.stringify(opts.open_revs);\n      }\n      params.open_revs = opts.open_revs;\n    }\n\n    if (opts.rev) {\n      params.rev = opts.rev;\n    }\n\n    if (opts.conflicts) {\n      params.conflicts = opts.conflicts;\n    }\n\n    /* istanbul ignore if */\n    if (opts.update_seq) {\n      params.update_seq = opts.update_seq;\n    }\n\n    id = encodeDocId(id);\n\n    // Set the options for the ajax call\n    var options = {\n      method: 'GET',\n      url: genDBUrl(host, id + paramsToStr(params))\n    };\n\n    function fetchAttachments(doc) {\n      var atts = doc._attachments;\n      var filenames = atts && Object.keys(atts);\n      if (!atts || !filenames.length) {\n        return;\n      }\n      // we fetch these manually in separate XHRs, because\n      // Sync Gateway would normally send it back as multipart/mixed,\n      // which we cannot parse. Also, this is more efficient than\n      // receiving attachments as base64-encoded strings.\n      function fetch(filename) {\n        var att = atts[filename];\n        var path = encodeDocId(doc._id) + '/' + encodeAttachmentId(filename) +\n          '?rev=' + doc._rev;\n        return ajaxPromise(opts, {\n          method: 'GET',\n          url: genDBUrl(host, path),\n          binary: true\n        }).then(function (blob) {\n          if (opts.binary) {\n            return blob;\n          }\n          return new PouchPromise(function (resolve) {\n            blobToBase64(blob, resolve);\n          });\n        }).then(function (data) {\n          delete att.stub;\n          delete att.length;\n          att.data = data;\n        });\n      }\n\n      var promiseFactories = filenames.map(function (filename) {\n        return function () {\n          return fetch(filename);\n        };\n      });\n\n      // This limits the number of parallel xhr requests to 5 any time\n      // to avoid issues with maximum browser request limits\n      return pool(promiseFactories, 5);\n    }\n\n    function fetchAllAttachments(docOrDocs) {\n      if (Array.isArray(docOrDocs)) {\n        return PouchPromise.all(docOrDocs.map(function (doc) {\n          if (doc.ok) {\n            return fetchAttachments(doc.ok);\n          }\n        }));\n      }\n      return fetchAttachments(docOrDocs);\n    }\n\n    ajaxPromise(opts, options).then(function (res) {\n      return PouchPromise.resolve().then(function () {\n        if (opts.attachments) {\n          return fetchAllAttachments(res);\n        }\n      }).then(function () {\n        callback(null, res);\n      });\n    })[\"catch\"](function (e) {\n      e.docId = id;\n      callback(e);\n    });\n  });\n\n  // Delete the document given by doc from the database given by host.\n  api.remove = adapterFun$$1('remove',\n      function (docOrId, optsOrRev, opts, callback) {\n    var doc;\n    if (typeof optsOrRev === 'string') {\n      // id, rev, opts, callback style\n      doc = {\n        _id: docOrId,\n        _rev: optsOrRev\n      };\n      if (typeof opts === 'function') {\n        callback = opts;\n        opts = {};\n      }\n    } else {\n      // doc, opts, callback style\n      doc = docOrId;\n      if (typeof optsOrRev === 'function') {\n        callback = optsOrRev;\n        opts = {};\n      } else {\n        callback = opts;\n        opts = optsOrRev;\n      }\n    }\n\n    var rev$$1 = (doc._rev || opts.rev);\n\n    // Delete the document\n    ajax(opts, {\n      method: 'DELETE',\n      url: genDBUrl(host, encodeDocId(doc._id)) + '?rev=' + rev$$1\n    }, callback);\n  });\n\n  function encodeAttachmentId(attachmentId) {\n    return attachmentId.split(\"/\").map(encodeURIComponent).join(\"/\");\n  }\n\n  // Get the attachment\n  api.getAttachment =\n    adapterFun$$1('getAttachment', function (docId, attachmentId, opts,\n                                                callback) {\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    var params = opts.rev ? ('?rev=' + opts.rev) : '';\n    var url = genDBUrl(host, encodeDocId(docId)) + '/' +\n      encodeAttachmentId(attachmentId) + params;\n    ajax(opts, {\n      method: 'GET',\n      url: url,\n      binary: true\n    }, callback);\n  });\n\n  // Remove the attachment given by the id and rev\n  api.removeAttachment =\n    adapterFun$$1('removeAttachment', function (docId, attachmentId, rev$$1,\n                                                   callback) {\n\n    var url = genDBUrl(host, encodeDocId(docId) + '/' +\n      encodeAttachmentId(attachmentId)) + '?rev=' + rev$$1;\n\n    ajax({}, {\n      method: 'DELETE',\n      url: url\n    }, callback);\n  });\n\n  // Add the attachment given by blob and its contentType property\n  // to the document with the given id, the revision given by rev, and\n  // add it to the database given by host.\n  api.putAttachment =\n    adapterFun$$1('putAttachment', function (docId, attachmentId, rev$$1, blob,\n                                                type, callback) {\n    if (typeof type === 'function') {\n      callback = type;\n      type = blob;\n      blob = rev$$1;\n      rev$$1 = null;\n    }\n    var id = encodeDocId(docId) + '/' + encodeAttachmentId(attachmentId);\n    var url = genDBUrl(host, id);\n    if (rev$$1) {\n      url += '?rev=' + rev$$1;\n    }\n\n    if (typeof blob === 'string') {\n      // input is assumed to be a base64 string\n      var binary;\n      try {\n        binary = thisAtob(blob);\n      } catch (err) {\n        return callback(createError(BAD_ARG,\n                        'Attachment is not a valid base64 string'));\n      }\n      blob = binary ? binStringToBluffer(binary, type) : '';\n    }\n\n    var opts = {\n      headers: {'Content-Type': type},\n      method: 'PUT',\n      url: url,\n      processData: false,\n      body: blob,\n      timeout: ajaxOpts.timeout || 60000\n    };\n    // Add the attachment\n    ajax({}, opts, callback);\n  });\n\n  // Update/create multiple documents given by req in the database\n  // given by host.\n  api._bulkDocs = function (req, opts, callback) {\n    // If new_edits=false then it prevents the database from creating\n    // new revision numbers for the documents. Instead it just uses\n    // the old ones. This is used in database replication.\n    req.new_edits = opts.new_edits;\n\n    setup().then(function () {\n      return PouchPromise.all(req.docs.map(preprocessAttachments$2));\n    }).then(function () {\n      // Update/create the documents\n      ajax(opts, {\n        method: 'POST',\n        url: genDBUrl(host, '_bulk_docs'),\n        timeout: opts.timeout,\n        body: req\n      }, function (err, results) {\n        if (err) {\n          return callback(err);\n        }\n        results.forEach(function (result) {\n          result.ok = true; // smooths out cloudant not adding this\n        });\n        callback(null, results);\n      });\n    })[\"catch\"](callback);\n  };\n\n\n  // Update/create document\n  api._put = function (doc, opts, callback) {\n    setup().then(function () {\n      return preprocessAttachments$2(doc);\n    }).then(function () {\n      // Update/create the document\n      ajax(opts, {\n        method: 'PUT',\n        url: genDBUrl(host, encodeDocId(doc._id)),\n        body: doc\n      }, function (err, result) {\n        if (err) {\n          err.docId = doc && doc._id;\n          return callback(err);\n        }\n        callback(null, result);\n      });\n    })[\"catch\"](callback);\n  };\n\n\n  // Get a listing of the documents in the database given\n  // by host and ordered by increasing id.\n  api.allDocs = adapterFun$$1('allDocs', function (opts, callback) {\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    opts = clone(opts);\n\n    // List of parameters to add to the GET request\n    var params = {};\n    var body;\n    var method = 'GET';\n\n    if (opts.conflicts) {\n      params.conflicts = true;\n    }\n\n    /* istanbul ignore if */\n    if (opts.update_seq) {\n      params.update_seq = true;\n    }\n\n    if (opts.descending) {\n      params.descending = true;\n    }\n\n    if (opts.include_docs) {\n      params.include_docs = true;\n    }\n\n    // added in CouchDB 1.6.0\n    if (opts.attachments) {\n      params.attachments = true;\n    }\n\n    if (opts.key) {\n      params.key = JSON.stringify(opts.key);\n    }\n\n    if (opts.start_key) {\n      opts.startkey = opts.start_key;\n    }\n\n    if (opts.startkey) {\n      params.startkey = JSON.stringify(opts.startkey);\n    }\n\n    if (opts.end_key) {\n      opts.endkey = opts.end_key;\n    }\n\n    if (opts.endkey) {\n      params.endkey = JSON.stringify(opts.endkey);\n    }\n\n    if (typeof opts.inclusive_end !== 'undefined') {\n      params.inclusive_end = !!opts.inclusive_end;\n    }\n\n    if (typeof opts.limit !== 'undefined') {\n      params.limit = opts.limit;\n    }\n\n    if (typeof opts.skip !== 'undefined') {\n      params.skip = opts.skip;\n    }\n\n    var paramStr = paramsToStr(params);\n\n    if (typeof opts.keys !== 'undefined') {\n      method = 'POST';\n      body = {keys: opts.keys};\n    }\n\n    // Get the document listing\n    ajaxPromise(opts, {\n      method: method,\n      url: genDBUrl(host, '_all_docs' + paramStr),\n      body: body\n    }).then(function (res) {\n      if (opts.include_docs && opts.attachments && opts.binary) {\n        res.rows.forEach(readAttachmentsAsBlobOrBuffer);\n      }\n      callback(null, res);\n    })[\"catch\"](callback);\n  });\n\n  // Get a list of changes made to documents in the database given by host.\n  // TODO According to the README, there should be two other methods here,\n  // api.changes.addListener and api.changes.removeListener.\n  api._changes = function (opts) {\n\n    // We internally page the results of a changes request, this means\n    // if there is a large set of changes to be returned we can start\n    // processing them quicker instead of waiting on the entire\n    // set of changes to return and attempting to process them at once\n    var batchSize = 'batch_size' in opts ? opts.batch_size : CHANGES_BATCH_SIZE;\n\n    opts = clone(opts);\n\n    if (opts.continuous && !('heartbeat' in opts)) {\n      opts.heartbeat = DEFAULT_HEARTBEAT;\n    }\n\n    var requestTimeout = ('timeout' in opts) ? opts.timeout :\n      ('timeout' in ajaxOpts) ? ajaxOpts.timeout :\n      30 * 1000;\n\n    // ensure CHANGES_TIMEOUT_BUFFER applies\n    if ('timeout' in opts && opts.timeout &&\n      (requestTimeout - opts.timeout) < CHANGES_TIMEOUT_BUFFER) {\n        requestTimeout = opts.timeout + CHANGES_TIMEOUT_BUFFER;\n    }\n\n    if ('heartbeat' in opts && opts.heartbeat &&\n       (requestTimeout - opts.heartbeat) < CHANGES_TIMEOUT_BUFFER) {\n        requestTimeout = opts.heartbeat + CHANGES_TIMEOUT_BUFFER;\n    }\n\n    var params = {};\n    if ('timeout' in opts && opts.timeout) {\n      params.timeout = opts.timeout;\n    }\n\n    var limit = (typeof opts.limit !== 'undefined') ? opts.limit : false;\n    var returnDocs;\n    if ('return_docs' in opts) {\n      returnDocs = opts.return_docs;\n    } else if ('returnDocs' in opts) {\n      // TODO: Remove 'returnDocs' in favor of 'return_docs' in a future release\n      returnDocs = opts.returnDocs;\n    } else {\n      returnDocs = true;\n    }\n    //\n    var leftToFetch = limit;\n\n    if (opts.style) {\n      params.style = opts.style;\n    }\n\n    if (opts.include_docs || opts.filter && typeof opts.filter === 'function') {\n      params.include_docs = true;\n    }\n\n    if (opts.attachments) {\n      params.attachments = true;\n    }\n\n    if (opts.continuous) {\n      params.feed = 'longpoll';\n    }\n\n    if (opts.seq_interval) {\n      params.seq_interval = opts.seq_interval;\n    }\n\n    if (opts.conflicts) {\n      params.conflicts = true;\n    }\n\n    if (opts.descending) {\n      params.descending = true;\n    }\n    \n    /* istanbul ignore if */\n    if (opts.update_seq) {\n      params.update_seq = true;\n    }\n\n    if ('heartbeat' in opts) {\n      // If the heartbeat value is false, it disables the default heartbeat\n      if (opts.heartbeat) {\n        params.heartbeat = opts.heartbeat;\n      }\n    }\n\n    if (opts.filter && typeof opts.filter === 'string') {\n      params.filter = opts.filter;\n    }\n\n    if (opts.view && typeof opts.view === 'string') {\n      params.filter = '_view';\n      params.view = opts.view;\n    }\n\n    // If opts.query_params exists, pass it through to the changes request.\n    // These parameters may be used by the filter on the source database.\n    if (opts.query_params && typeof opts.query_params === 'object') {\n      for (var param_name in opts.query_params) {\n        /* istanbul ignore else */\n        if (opts.query_params.hasOwnProperty(param_name)) {\n          params[param_name] = opts.query_params[param_name];\n        }\n      }\n    }\n\n    var method = 'GET';\n    var body;\n\n    if (opts.doc_ids) {\n      // set this automagically for the user; it's annoying that couchdb\n      // requires both a \"filter\" and a \"doc_ids\" param.\n      params.filter = '_doc_ids';\n      method = 'POST';\n      body = {doc_ids: opts.doc_ids };\n    }\n    /* istanbul ignore next */\n    else if (opts.selector) {\n      // set this automagically for the user, similar to above\n      params.filter = '_selector';\n      method = 'POST';\n      body = {selector: opts.selector };\n    }\n\n    var xhr;\n    var lastFetchedSeq;\n\n    // Get all the changes starting wtih the one immediately after the\n    // sequence number given by since.\n    var fetch = function (since, callback) {\n      if (opts.aborted) {\n        return;\n      }\n      params.since = since;\n      // \"since\" can be any kind of json object in Coudant/CouchDB 2.x\n      /* istanbul ignore next */\n      if (typeof params.since === \"object\") {\n        params.since = JSON.stringify(params.since);\n      }\n\n      if (opts.descending) {\n        if (limit) {\n          params.limit = leftToFetch;\n        }\n      } else {\n        params.limit = (!limit || leftToFetch > batchSize) ?\n          batchSize : leftToFetch;\n      }\n\n      // Set the options for the ajax call\n      var xhrOpts = {\n        method: method,\n        url: genDBUrl(host, '_changes' + paramsToStr(params)),\n        timeout: requestTimeout,\n        body: body\n      };\n      lastFetchedSeq = since;\n\n      /* istanbul ignore if */\n      if (opts.aborted) {\n        return;\n      }\n\n      // Get the changes\n      setup().then(function () {\n        xhr = ajax(opts, xhrOpts, callback);\n      })[\"catch\"](callback);\n    };\n\n    // If opts.since exists, get all the changes from the sequence\n    // number given by opts.since. Otherwise, get all the changes\n    // from the sequence number 0.\n    var results = {results: []};\n\n    var fetched = function (err, res) {\n      if (opts.aborted) {\n        return;\n      }\n      var raw_results_length = 0;\n      // If the result of the ajax call (res) contains changes (res.results)\n      if (res && res.results) {\n        raw_results_length = res.results.length;\n        results.last_seq = res.last_seq;\n        var pending = null;\n        var lastSeq = null;\n        // Attach 'pending' property if server supports it (CouchDB 2.0+)\n        /* istanbul ignore if */\n        if (typeof res.pending === 'number') {\n          pending = res.pending;\n        }\n        if (typeof results.last_seq === 'string' || typeof results.last_seq === 'number') {\n          lastSeq = results.last_seq;\n        }\n        // For each change\n        var req = {};\n        req.query = opts.query_params;\n        res.results = res.results.filter(function (c) {\n          leftToFetch--;\n          var ret = filterChange(opts)(c);\n          if (ret) {\n            if (opts.include_docs && opts.attachments && opts.binary) {\n              readAttachmentsAsBlobOrBuffer(c);\n            }\n            if (returnDocs) {\n              results.results.push(c);\n            }\n            opts.onChange(c, pending, lastSeq);\n          }\n          return ret;\n        });\n      } else if (err) {\n        // In case of an error, stop listening for changes and call\n        // opts.complete\n        opts.aborted = true;\n        opts.complete(err);\n        return;\n      }\n\n      // The changes feed may have timed out with no results\n      // if so reuse last update sequence\n      if (res && res.last_seq) {\n        lastFetchedSeq = res.last_seq;\n      }\n\n      var finished = (limit && leftToFetch <= 0) ||\n        (res && raw_results_length < batchSize) ||\n        (opts.descending);\n\n      if ((opts.continuous && !(limit && leftToFetch <= 0)) || !finished) {\n        // Queue a call to fetch again with the newest sequence number\n        nextTick(function () { fetch(lastFetchedSeq, fetched); });\n      } else {\n        // We're done, call the callback\n        opts.complete(null, results);\n      }\n    };\n\n    fetch(opts.since || 0, fetched);\n\n    // Return a method to cancel this method from processing any more\n    return {\n      cancel: function () {\n        opts.aborted = true;\n        if (xhr) {\n          xhr.abort();\n        }\n      }\n    };\n  };\n\n  // Given a set of document/revision IDs (given by req), tets the subset of\n  // those that do NOT correspond to revisions stored in the database.\n  // See http://wiki.apache.org/couchdb/HttpPostRevsDiff\n  api.revsDiff = adapterFun$$1('revsDiff', function (req, opts, callback) {\n    // If no options were given, set the callback to be the second parameter\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n\n    // Get the missing document/revision IDs\n    ajax(opts, {\n      method: 'POST',\n      url: genDBUrl(host, '_revs_diff'),\n      body: req\n    }, callback);\n  });\n\n  api._close = function (callback) {\n    callback();\n  };\n\n  api._destroy = function (options, callback) {\n    ajax(options, {\n      url: genDBUrl(host, ''),\n      method: 'DELETE'\n    }, function (err, resp) {\n      if (err && err.status && err.status !== 404) {\n        return callback(err);\n      }\n      callback(null, resp);\n    });\n  };\n}\n\n// HttpPouch is a valid adapter.\nHttpPouch.valid = function () {\n  return true;\n};\n\nfunction HttpPouch$1 (PouchDB) {\n  PouchDB.adapter('http', HttpPouch, false);\n  PouchDB.adapter('https', HttpPouch, false);\n}\n\nfunction QueryParseError(message) {\n  this.status = 400;\n  this.name = 'query_parse_error';\n  this.message = message;\n  this.error = true;\n  try {\n    Error.captureStackTrace(this, QueryParseError);\n  } catch (e) {}\n}\n\ninherits(QueryParseError, Error);\n\nfunction NotFoundError(message) {\n  this.status = 404;\n  this.name = 'not_found';\n  this.message = message;\n  this.error = true;\n  try {\n    Error.captureStackTrace(this, NotFoundError);\n  } catch (e) {}\n}\n\ninherits(NotFoundError, Error);\n\nfunction BuiltInError(message) {\n  this.status = 500;\n  this.name = 'invalid_value';\n  this.message = message;\n  this.error = true;\n  try {\n    Error.captureStackTrace(this, BuiltInError);\n  } catch (e) {}\n}\n\ninherits(BuiltInError, Error);\n\nfunction promisedCallback(promise, callback) {\n  if (callback) {\n    promise.then(function (res) {\n      nextTick(function () {\n        callback(null, res);\n      });\n    }, function (reason) {\n      nextTick(function () {\n        callback(reason);\n      });\n    });\n  }\n  return promise;\n}\n\nfunction callbackify(fun) {\n  return getArguments(function (args) {\n    var cb = args.pop();\n    var promise = fun.apply(this, args);\n    if (typeof cb === 'function') {\n      promisedCallback(promise, cb);\n    }\n    return promise;\n  });\n}\n\n// Promise finally util similar to Q.finally\nfunction fin(promise, finalPromiseFactory) {\n  return promise.then(function (res) {\n    return finalPromiseFactory().then(function () {\n      return res;\n    });\n  }, function (reason) {\n    return finalPromiseFactory().then(function () {\n      throw reason;\n    });\n  });\n}\n\nfunction sequentialize(queue, promiseFactory) {\n  return function () {\n    var args = arguments;\n    var that = this;\n    return queue.add(function () {\n      return promiseFactory.apply(that, args);\n    });\n  };\n}\n\n// uniq an array of strings, order not guaranteed\n// similar to underscore/lodash _.uniq\nfunction uniq(arr) {\n  var theSet = new ExportedSet(arr);\n  var result = new Array(theSet.size);\n  var index = -1;\n  theSet.forEach(function (value) {\n    result[++index] = value;\n  });\n  return result;\n}\n\nfunction mapToKeysArray(map) {\n  var result = new Array(map.size);\n  var index = -1;\n  map.forEach(function (value, key) {\n    result[++index] = key;\n  });\n  return result;\n}\n\nfunction createBuiltInError(name) {\n  var message = 'builtin ' + name +\n    ' function requires map values to be numbers' +\n    ' or number arrays';\n  return new BuiltInError(message);\n}\n\nfunction sum(values) {\n  var result = 0;\n  for (var i = 0, len = values.length; i < len; i++) {\n    var num = values[i];\n    if (typeof num !== 'number') {\n      if (Array.isArray(num)) {\n        // lists of numbers are also allowed, sum them separately\n        result = typeof result === 'number' ? [result] : result;\n        for (var j = 0, jLen = num.length; j < jLen; j++) {\n          var jNum = num[j];\n          if (typeof jNum !== 'number') {\n            throw createBuiltInError('_sum');\n          } else if (typeof result[j] === 'undefined') {\n            result.push(jNum);\n          } else {\n            result[j] += jNum;\n          }\n        }\n      } else { // not array/number\n        throw createBuiltInError('_sum');\n      }\n    } else if (typeof result === 'number') {\n      result += num;\n    } else { // add number to array\n      result[0] += num;\n    }\n  }\n  return result;\n}\n\nvar log = guardedConsole.bind(null, 'log');\nvar isArray = Array.isArray;\nvar toJSON = JSON.parse;\n\nfunction evalFunctionWithEval(func, emit) {\n  return scopeEval(\n    \"return (\" + func.replace(/;\\s*$/, \"\") + \");\",\n    {\n      emit: emit,\n      sum: sum,\n      log: log,\n      isArray: isArray,\n      toJSON: toJSON\n    }\n  );\n}\n\n/*\n * Simple task queue to sequentialize actions. Assumes\n * callbacks will eventually fire (once).\n */\n\n\nfunction TaskQueue$2() {\n  this.promise = new PouchPromise(function (fulfill) {fulfill(); });\n}\nTaskQueue$2.prototype.add = function (promiseFactory) {\n  this.promise = this.promise[\"catch\"](function () {\n    // just recover\n  }).then(function () {\n    return promiseFactory();\n  });\n  return this.promise;\n};\nTaskQueue$2.prototype.finish = function () {\n  return this.promise;\n};\n\nfunction stringify(input) {\n  if (!input) {\n    return 'undefined'; // backwards compat for empty reduce\n  }\n  // for backwards compat with mapreduce, functions/strings are stringified\n  // as-is. everything else is JSON-stringified.\n  switch (typeof input) {\n    case 'function':\n      // e.g. a mapreduce map\n      return input.toString();\n    case 'string':\n      // e.g. a mapreduce built-in _reduce function\n      return input.toString();\n    default:\n      // e.g. a JSON object in the case of mango queries\n      return JSON.stringify(input);\n  }\n}\n\n/* create a string signature for a view so we can cache it and uniq it */\nfunction createViewSignature(mapFun, reduceFun) {\n  // the \"undefined\" part is for backwards compatibility\n  return stringify(mapFun) + stringify(reduceFun) + 'undefined';\n}\n\nfunction createView(sourceDB, viewName, mapFun, reduceFun, temporary, localDocName) {\n  var viewSignature = createViewSignature(mapFun, reduceFun);\n\n  var cachedViews;\n  if (!temporary) {\n    // cache this to ensure we don't try to update the same view twice\n    cachedViews = sourceDB._cachedViews = sourceDB._cachedViews || {};\n    if (cachedViews[viewSignature]) {\n      return cachedViews[viewSignature];\n    }\n  }\n\n  var promiseForView = sourceDB.info().then(function (info) {\n\n    var depDbName = info.db_name + '-mrview-' +\n      (temporary ? 'temp' : stringMd5(viewSignature));\n\n    // save the view name in the source db so it can be cleaned up if necessary\n    // (e.g. when the _design doc is deleted, remove all associated view data)\n    function diffFunction(doc) {\n      doc.views = doc.views || {};\n      var fullViewName = viewName;\n      if (fullViewName.indexOf('/') === -1) {\n        fullViewName = viewName + '/' + viewName;\n      }\n      var depDbs = doc.views[fullViewName] = doc.views[fullViewName] || {};\n      /* istanbul ignore if */\n      if (depDbs[depDbName]) {\n        return; // no update necessary\n      }\n      depDbs[depDbName] = true;\n      return doc;\n    }\n    return upsert(sourceDB, '_local/' + localDocName, diffFunction).then(function () {\n      return sourceDB.registerDependentDatabase(depDbName).then(function (res) {\n        var db = res.db;\n        db.auto_compaction = true;\n        var view = {\n          name: depDbName,\n          db: db,\n          sourceDB: sourceDB,\n          adapter: sourceDB.adapter,\n          mapFun: mapFun,\n          reduceFun: reduceFun\n        };\n        return view.db.get('_local/lastSeq')[\"catch\"](function (err) {\n          /* istanbul ignore if */\n          if (err.status !== 404) {\n            throw err;\n          }\n        }).then(function (lastSeqDoc) {\n          view.seq = lastSeqDoc ? lastSeqDoc.seq : 0;\n          if (cachedViews) {\n            view.db.once('destroyed', function () {\n              delete cachedViews[viewSignature];\n            });\n          }\n          return view;\n        });\n      });\n    });\n  });\n\n  if (cachedViews) {\n    cachedViews[viewSignature] = promiseForView;\n  }\n  return promiseForView;\n}\n\nvar persistentQueues = {};\nvar tempViewQueue = new TaskQueue$2();\nvar CHANGES_BATCH_SIZE$1 = 50;\n\nfunction parseViewName(name) {\n  // can be either 'ddocname/viewname' or just 'viewname'\n  // (where the ddoc name is the same)\n  return name.indexOf('/') === -1 ? [name, name] : name.split('/');\n}\n\nfunction isGenOne(changes) {\n  // only return true if the current change is 1-\n  // and there are no other leafs\n  return changes.length === 1 && /^1-/.test(changes[0].rev);\n}\n\nfunction emitError(db, e) {\n  try {\n    db.emit('error', e);\n  } catch (err) {\n    guardedConsole('error',\n      'The user\\'s map/reduce function threw an uncaught error.\\n' +\n      'You can debug this error by doing:\\n' +\n      'myDatabase.on(\\'error\\', function (err) { debugger; });\\n' +\n      'Please double-check your map/reduce function.');\n    guardedConsole('error', e);\n  }\n}\n\n/**\n * Returns an \"abstract\" mapreduce object of the form:\n *\n *   {\n *     query: queryFun,\n *     viewCleanup: viewCleanupFun\n *   }\n *\n * Arguments are:\n *\n * localDoc: string\n *   This is for the local doc that gets saved in order to track the\n *   \"dependent\" DBs and clean them up for viewCleanup. It should be\n *   unique, so that indexer plugins don't collide with each other.\n * mapper: function (mapFunDef, emit)\n *   Returns a map function based on the mapFunDef, which in the case of\n *   normal map/reduce is just the de-stringified function, but may be\n *   something else, such as an object in the case of pouchdb-find.\n * reducer: function (reduceFunDef)\n *   Ditto, but for reducing. Modules don't have to support reducing\n *   (e.g. pouchdb-find).\n * ddocValidator: function (ddoc, viewName)\n *   Throws an error if the ddoc or viewName is not valid.\n *   This could be a way to communicate to the user that the configuration for the\n *   indexer is invalid.\n */\nfunction createAbstractMapReduce(localDocName, mapper, reducer, ddocValidator) {\n\n  function tryMap(db, fun, doc) {\n    // emit an event if there was an error thrown by a map function.\n    // putting try/catches in a single function also avoids deoptimizations.\n    try {\n      fun(doc);\n    } catch (e) {\n      emitError(db, e);\n    }\n  }\n\n  function tryReduce(db, fun, keys, values, rereduce) {\n    // same as above, but returning the result or an error. there are two separate\n    // functions to avoid extra memory allocations since the tryCode() case is used\n    // for custom map functions (common) vs this function, which is only used for\n    // custom reduce functions (rare)\n    try {\n      return {output : fun(keys, values, rereduce)};\n    } catch (e) {\n      emitError(db, e);\n      return {error: e};\n    }\n  }\n\n  function sortByKeyThenValue(x, y) {\n    var keyCompare = collate(x.key, y.key);\n    return keyCompare !== 0 ? keyCompare : collate(x.value, y.value);\n  }\n\n  function sliceResults(results, limit, skip) {\n    skip = skip || 0;\n    if (typeof limit === 'number') {\n      return results.slice(skip, limit + skip);\n    } else if (skip > 0) {\n      return results.slice(skip);\n    }\n    return results;\n  }\n\n  function rowToDocId(row) {\n    var val = row.value;\n    // Users can explicitly specify a joined doc _id, or it\n    // defaults to the doc _id that emitted the key/value.\n    var docId = (val && typeof val === 'object' && val._id) || row.id;\n    return docId;\n  }\n\n  function readAttachmentsAsBlobOrBuffer(res) {\n    res.rows.forEach(function (row) {\n      var atts = row.doc && row.doc._attachments;\n      if (!atts) {\n        return;\n      }\n      Object.keys(atts).forEach(function (filename) {\n        var att = atts[filename];\n        atts[filename].data = b64ToBluffer(att.data, att.content_type);\n      });\n    });\n  }\n\n  function postprocessAttachments(opts) {\n    return function (res) {\n      if (opts.include_docs && opts.attachments && opts.binary) {\n        readAttachmentsAsBlobOrBuffer(res);\n      }\n      return res;\n    };\n  }\n\n  function addHttpParam(paramName, opts, params, asJson) {\n    // add an http param from opts to params, optionally json-encoded\n    var val = opts[paramName];\n    if (typeof val !== 'undefined') {\n      if (asJson) {\n        val = encodeURIComponent(JSON.stringify(val));\n      }\n      params.push(paramName + '=' + val);\n    }\n  }\n\n  function coerceInteger(integerCandidate) {\n    if (typeof integerCandidate !== 'undefined') {\n      var asNumber = Number(integerCandidate);\n      // prevents e.g. '1foo' or '1.1' being coerced to 1\n      if (!isNaN(asNumber) && asNumber === parseInt(integerCandidate, 10)) {\n        return asNumber;\n      } else {\n        return integerCandidate;\n      }\n    }\n  }\n\n  function coerceOptions(opts) {\n    opts.group_level = coerceInteger(opts.group_level);\n    opts.limit = coerceInteger(opts.limit);\n    opts.skip = coerceInteger(opts.skip);\n    return opts;\n  }\n\n  function checkPositiveInteger(number) {\n    if (number) {\n      if (typeof number !== 'number') {\n        return  new QueryParseError('Invalid value for integer: \"' +\n          number + '\"');\n      }\n      if (number < 0) {\n        return new QueryParseError('Invalid value for positive integer: ' +\n          '\"' + number + '\"');\n      }\n    }\n  }\n\n  function checkQueryParseError(options, fun) {\n    var startkeyName = options.descending ? 'endkey' : 'startkey';\n    var endkeyName = options.descending ? 'startkey' : 'endkey';\n\n    if (typeof options[startkeyName] !== 'undefined' &&\n      typeof options[endkeyName] !== 'undefined' &&\n      collate(options[startkeyName], options[endkeyName]) > 0) {\n      throw new QueryParseError('No rows can match your key range, ' +\n        'reverse your start_key and end_key or set {descending : true}');\n    } else if (fun.reduce && options.reduce !== false) {\n      if (options.include_docs) {\n        throw new QueryParseError('{include_docs:true} is invalid for reduce');\n      } else if (options.keys && options.keys.length > 1 &&\n        !options.group && !options.group_level) {\n        throw new QueryParseError('Multi-key fetches for reduce views must use ' +\n          '{group: true}');\n      }\n    }\n    ['group_level', 'limit', 'skip'].forEach(function (optionName) {\n      var error = checkPositiveInteger(options[optionName]);\n      if (error) {\n        throw error;\n      }\n    });\n  }\n\n  function httpQuery(db, fun, opts) {\n    // List of parameters to add to the PUT request\n    var params = [];\n    var body;\n    var method = 'GET';\n\n    // If opts.reduce exists and is defined, then add it to the list\n    // of parameters.\n    // If reduce=false then the results are that of only the map function\n    // not the final result of map and reduce.\n    addHttpParam('reduce', opts, params);\n    addHttpParam('include_docs', opts, params);\n    addHttpParam('attachments', opts, params);\n    addHttpParam('limit', opts, params);\n    addHttpParam('descending', opts, params);\n    addHttpParam('group', opts, params);\n    addHttpParam('group_level', opts, params);\n    addHttpParam('skip', opts, params);\n    addHttpParam('stale', opts, params);\n    addHttpParam('conflicts', opts, params);\n    addHttpParam('startkey', opts, params, true);\n    addHttpParam('start_key', opts, params, true);\n    addHttpParam('endkey', opts, params, true);\n    addHttpParam('end_key', opts, params, true);\n    addHttpParam('inclusive_end', opts, params);\n    addHttpParam('key', opts, params, true);\n    addHttpParam('update_seq', opts, params);\n\n    // Format the list of parameters into a valid URI query string\n    params = params.join('&');\n    params = params === '' ? '' : '?' + params;\n\n    // If keys are supplied, issue a POST to circumvent GET query string limits\n    // see http://wiki.apache.org/couchdb/HTTP_view_API#Querying_Options\n    if (typeof opts.keys !== 'undefined') {\n      var MAX_URL_LENGTH = 2000;\n      // according to http://stackoverflow.com/a/417184/680742,\n      // the de facto URL length limit is 2000 characters\n\n      var keysAsString =\n        'keys=' + encodeURIComponent(JSON.stringify(opts.keys));\n      if (keysAsString.length + params.length + 1 <= MAX_URL_LENGTH) {\n        // If the keys are short enough, do a GET. we do this to work around\n        // Safari not understanding 304s on POSTs (see pouchdb/pouchdb#1239)\n        params += (params[0] === '?' ? '&' : '?') + keysAsString;\n      } else {\n        method = 'POST';\n        if (typeof fun === 'string') {\n          body = {keys: opts.keys};\n        } else { // fun is {map : mapfun}, so append to this\n          fun.keys = opts.keys;\n        }\n      }\n    }\n\n    // We are referencing a query defined in the design doc\n    if (typeof fun === 'string') {\n      var parts = parseViewName(fun);\n      return db.request({\n        method: method,\n        url: '_design/' + parts[0] + '/_view/' + parts[1] + params,\n        body: body\n      }).then(\n        /* istanbul ignore next */\n        function (result) {\n          // fail the entire request if the result contains an error\n          result.rows.forEach(function (row) {\n            if (row.value && row.value.error && row.value.error === \"builtin_reduce_error\") {\n              throw new Error(row.reason);\n            }\n          });\n\n          return result;\n      })\n      .then(postprocessAttachments(opts));\n    }\n\n    // We are using a temporary view, terrible for performance, good for testing\n    body = body || {};\n    Object.keys(fun).forEach(function (key) {\n      if (Array.isArray(fun[key])) {\n        body[key] = fun[key];\n      } else {\n        body[key] = fun[key].toString();\n      }\n    });\n    return db.request({\n      method: 'POST',\n      url: '_temp_view' + params,\n      body: body\n    }).then(postprocessAttachments(opts));\n  }\n\n  // custom adapters can define their own api._query\n  // and override the default behavior\n  /* istanbul ignore next */\n  function customQuery(db, fun, opts) {\n    return new PouchPromise(function (resolve, reject) {\n      db._query(fun, opts, function (err, res) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(res);\n      });\n    });\n  }\n\n  // custom adapters can define their own api._viewCleanup\n  // and override the default behavior\n  /* istanbul ignore next */\n  function customViewCleanup(db) {\n    return new PouchPromise(function (resolve, reject) {\n      db._viewCleanup(function (err, res) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(res);\n      });\n    });\n  }\n\n  function defaultsTo(value) {\n    return function (reason) {\n      /* istanbul ignore else */\n      if (reason.status === 404) {\n        return value;\n      } else {\n        throw reason;\n      }\n    };\n  }\n\n  // returns a promise for a list of docs to update, based on the input docId.\n  // the order doesn't matter, because post-3.2.0, bulkDocs\n  // is an atomic operation in all three adapters.\n  function getDocsToPersist(docId, view, docIdsToChangesAndEmits) {\n    var metaDocId = '_local/doc_' + docId;\n    var defaultMetaDoc = {_id: metaDocId, keys: []};\n    var docData = docIdsToChangesAndEmits.get(docId);\n    var indexableKeysToKeyValues = docData[0];\n    var changes = docData[1];\n\n    function getMetaDoc() {\n      if (isGenOne(changes)) {\n        // generation 1, so we can safely assume initial state\n        // for performance reasons (avoids unnecessary GETs)\n        return PouchPromise.resolve(defaultMetaDoc);\n      }\n      return view.db.get(metaDocId)[\"catch\"](defaultsTo(defaultMetaDoc));\n    }\n\n    function getKeyValueDocs(metaDoc) {\n      if (!metaDoc.keys.length) {\n        // no keys, no need for a lookup\n        return PouchPromise.resolve({rows: []});\n      }\n      return view.db.allDocs({\n        keys: metaDoc.keys,\n        include_docs: true\n      });\n    }\n\n    function processKeyValueDocs(metaDoc, kvDocsRes) {\n      var kvDocs = [];\n      var oldKeys = new ExportedSet();\n\n      for (var i = 0, len = kvDocsRes.rows.length; i < len; i++) {\n        var row = kvDocsRes.rows[i];\n        var doc = row.doc;\n        if (!doc) { // deleted\n          continue;\n        }\n        kvDocs.push(doc);\n        oldKeys.add(doc._id);\n        doc._deleted = !indexableKeysToKeyValues.has(doc._id);\n        if (!doc._deleted) {\n          var keyValue = indexableKeysToKeyValues.get(doc._id);\n          if ('value' in keyValue) {\n            doc.value = keyValue.value;\n          }\n        }\n      }\n      var newKeys = mapToKeysArray(indexableKeysToKeyValues);\n      newKeys.forEach(function (key) {\n        if (!oldKeys.has(key)) {\n          // new doc\n          var kvDoc = {\n            _id: key\n          };\n          var keyValue = indexableKeysToKeyValues.get(key);\n          if ('value' in keyValue) {\n            kvDoc.value = keyValue.value;\n          }\n          kvDocs.push(kvDoc);\n        }\n      });\n      metaDoc.keys = uniq(newKeys.concat(metaDoc.keys));\n      kvDocs.push(metaDoc);\n\n      return kvDocs;\n    }\n\n    return getMetaDoc().then(function (metaDoc) {\n      return getKeyValueDocs(metaDoc).then(function (kvDocsRes) {\n        return processKeyValueDocs(metaDoc, kvDocsRes);\n      });\n    });\n  }\n\n  // updates all emitted key/value docs and metaDocs in the mrview database\n  // for the given batch of documents from the source database\n  function saveKeyValues(view, docIdsToChangesAndEmits, seq) {\n    var seqDocId = '_local/lastSeq';\n    return view.db.get(seqDocId)[\n      \"catch\"](defaultsTo({_id: seqDocId, seq: 0}))\n      .then(function (lastSeqDoc) {\n        var docIds = mapToKeysArray(docIdsToChangesAndEmits);\n        return PouchPromise.all(docIds.map(function (docId) {\n          return getDocsToPersist(docId, view, docIdsToChangesAndEmits);\n        })).then(function (listOfDocsToPersist) {\n          var docsToPersist = flatten(listOfDocsToPersist);\n          lastSeqDoc.seq = seq;\n          docsToPersist.push(lastSeqDoc);\n          // write all docs in a single operation, update the seq once\n          return view.db.bulkDocs({docs : docsToPersist});\n        });\n      });\n  }\n\n  function getQueue(view) {\n    var viewName = typeof view === 'string' ? view : view.name;\n    var queue = persistentQueues[viewName];\n    if (!queue) {\n      queue = persistentQueues[viewName] = new TaskQueue$2();\n    }\n    return queue;\n  }\n\n  function updateView(view) {\n    return sequentialize(getQueue(view), function () {\n      return updateViewInQueue(view);\n    })();\n  }\n\n  function updateViewInQueue(view) {\n    // bind the emit function once\n    var mapResults;\n    var doc;\n\n    function emit(key, value) {\n      var output = {id: doc._id, key: normalizeKey(key)};\n      // Don't explicitly store the value unless it's defined and non-null.\n      // This saves on storage space, because often people don't use it.\n      if (typeof value !== 'undefined' && value !== null) {\n        output.value = normalizeKey(value);\n      }\n      mapResults.push(output);\n    }\n\n    var mapFun = mapper(view.mapFun, emit);\n\n    var currentSeq = view.seq || 0;\n\n    function processChange(docIdsToChangesAndEmits, seq) {\n      return function () {\n        return saveKeyValues(view, docIdsToChangesAndEmits, seq);\n      };\n    }\n\n    var queue = new TaskQueue$2();\n\n    function processNextBatch() {\n      return view.sourceDB.changes({\n        conflicts: true,\n        include_docs: true,\n        style: 'all_docs',\n        since: currentSeq,\n        limit: CHANGES_BATCH_SIZE$1\n      }).then(processBatch);\n    }\n\n    function processBatch(response) {\n      var results = response.results;\n      if (!results.length) {\n        return;\n      }\n      var docIdsToChangesAndEmits = createDocIdsToChangesAndEmits(results);\n      queue.add(processChange(docIdsToChangesAndEmits, currentSeq));\n      if (results.length < CHANGES_BATCH_SIZE$1) {\n        return;\n      }\n      return processNextBatch();\n    }\n\n    function createDocIdsToChangesAndEmits(results) {\n      var docIdsToChangesAndEmits = new ExportedMap();\n      for (var i = 0, len = results.length; i < len; i++) {\n        var change = results[i];\n        if (change.doc._id[0] !== '_') {\n          mapResults = [];\n          doc = change.doc;\n\n          if (!doc._deleted) {\n            tryMap(view.sourceDB, mapFun, doc);\n          }\n          mapResults.sort(sortByKeyThenValue);\n\n          var indexableKeysToKeyValues = createIndexableKeysToKeyValues(mapResults);\n          docIdsToChangesAndEmits.set(change.doc._id, [\n            indexableKeysToKeyValues,\n            change.changes\n          ]);\n        }\n        currentSeq = change.seq;\n      }\n      return docIdsToChangesAndEmits;\n    }\n\n    function createIndexableKeysToKeyValues(mapResults) {\n      var indexableKeysToKeyValues = new ExportedMap();\n      var lastKey;\n      for (var i = 0, len = mapResults.length; i < len; i++) {\n        var emittedKeyValue = mapResults[i];\n        var complexKey = [emittedKeyValue.key, emittedKeyValue.id];\n        if (i > 0 && collate(emittedKeyValue.key, lastKey) === 0) {\n          complexKey.push(i); // dup key+id, so make it unique\n        }\n        indexableKeysToKeyValues.set(toIndexableString(complexKey), emittedKeyValue);\n        lastKey = emittedKeyValue.key;\n      }\n      return indexableKeysToKeyValues;\n    }\n\n    return processNextBatch().then(function () {\n      return queue.finish();\n    }).then(function () {\n      view.seq = currentSeq;\n    });\n  }\n\n  function reduceView(view, results, options) {\n    if (options.group_level === 0) {\n      delete options.group_level;\n    }\n\n    var shouldGroup = options.group || options.group_level;\n\n    var reduceFun = reducer(view.reduceFun);\n\n    var groups = [];\n    var lvl = isNaN(options.group_level) ? Number.POSITIVE_INFINITY :\n      options.group_level;\n    results.forEach(function (e) {\n      var last = groups[groups.length - 1];\n      var groupKey = shouldGroup ? e.key : null;\n\n      // only set group_level for array keys\n      if (shouldGroup && Array.isArray(groupKey)) {\n        groupKey = groupKey.slice(0, lvl);\n      }\n\n      if (last && collate(last.groupKey, groupKey) === 0) {\n        last.keys.push([e.key, e.id]);\n        last.values.push(e.value);\n        return;\n      }\n      groups.push({\n        keys: [[e.key, e.id]],\n        values: [e.value],\n        groupKey: groupKey\n      });\n    });\n    results = [];\n    for (var i = 0, len = groups.length; i < len; i++) {\n      var e = groups[i];\n      var reduceTry = tryReduce(view.sourceDB, reduceFun, e.keys, e.values, false);\n      if (reduceTry.error && reduceTry.error instanceof BuiltInError) {\n        // CouchDB returns an error if a built-in errors out\n        throw reduceTry.error;\n      }\n      results.push({\n        // CouchDB just sets the value to null if a non-built-in errors out\n        value: reduceTry.error ? null : reduceTry.output,\n        key: e.groupKey\n      });\n    }\n    // no total_rows/offset when reducing\n    return {rows: sliceResults(results, options.limit, options.skip)};\n  }\n\n  function queryView(view, opts) {\n    return sequentialize(getQueue(view), function () {\n      return queryViewInQueue(view, opts);\n    })();\n  }\n\n  function queryViewInQueue(view, opts) {\n    var totalRows;\n    var shouldReduce = view.reduceFun && opts.reduce !== false;\n    var skip = opts.skip || 0;\n    if (typeof opts.keys !== 'undefined' && !opts.keys.length) {\n      // equivalent query\n      opts.limit = 0;\n      delete opts.keys;\n    }\n\n    function fetchFromView(viewOpts) {\n      viewOpts.include_docs = true;\n      return view.db.allDocs(viewOpts).then(function (res) {\n        totalRows = res.total_rows;\n        return res.rows.map(function (result) {\n\n          // implicit migration - in older versions of PouchDB,\n          // we explicitly stored the doc as {id: ..., key: ..., value: ...}\n          // this is tested in a migration test\n          /* istanbul ignore next */\n          if ('value' in result.doc && typeof result.doc.value === 'object' &&\n            result.doc.value !== null) {\n            var keys = Object.keys(result.doc.value).sort();\n            // this detection method is not perfect, but it's unlikely the user\n            // emitted a value which was an object with these 3 exact keys\n            var expectedKeys = ['id', 'key', 'value'];\n            if (!(keys < expectedKeys || keys > expectedKeys)) {\n              return result.doc.value;\n            }\n          }\n\n          var parsedKeyAndDocId = parseIndexableString(result.doc._id);\n          return {\n            key: parsedKeyAndDocId[0],\n            id: parsedKeyAndDocId[1],\n            value: ('value' in result.doc ? result.doc.value : null)\n          };\n        });\n      });\n    }\n\n    function onMapResultsReady(rows) {\n      var finalResults;\n      if (shouldReduce) {\n        finalResults = reduceView(view, rows, opts);\n      } else {\n        finalResults = {\n          total_rows: totalRows,\n          offset: skip,\n          rows: rows\n        };\n      }\n      /* istanbul ignore if */\n      if (opts.update_seq) {\n        finalResults.update_seq = view.seq;\n      }\n      if (opts.include_docs) {\n        var docIds = uniq(rows.map(rowToDocId));\n\n        return view.sourceDB.allDocs({\n          keys: docIds,\n          include_docs: true,\n          conflicts: opts.conflicts,\n          attachments: opts.attachments,\n          binary: opts.binary\n        }).then(function (allDocsRes) {\n          var docIdsToDocs = new ExportedMap();\n          allDocsRes.rows.forEach(function (row) {\n            docIdsToDocs.set(row.id, row.doc);\n          });\n          rows.forEach(function (row) {\n            var docId = rowToDocId(row);\n            var doc = docIdsToDocs.get(docId);\n            if (doc) {\n              row.doc = doc;\n            }\n          });\n          return finalResults;\n        });\n      } else {\n        return finalResults;\n      }\n    }\n\n    if (typeof opts.keys !== 'undefined') {\n      var keys = opts.keys;\n      var fetchPromises = keys.map(function (key) {\n        var viewOpts = {\n          startkey : toIndexableString([key]),\n          endkey   : toIndexableString([key, {}])\n        };\n        /* istanbul ignore if */\n        if (opts.update_seq) {\n          viewOpts.update_seq = true;\n        }\n        return fetchFromView(viewOpts);\n      });\n      return PouchPromise.all(fetchPromises).then(flatten).then(onMapResultsReady);\n    } else { // normal query, no 'keys'\n      var viewOpts = {\n        descending : opts.descending\n      };\n      /* istanbul ignore if */\n      if (opts.update_seq) {\n        viewOpts.update_seq = true;\n      }\n      var startkey;\n      var endkey;\n      if ('start_key' in opts) {\n        startkey = opts.start_key;\n      }\n      if ('startkey' in opts) {\n        startkey = opts.startkey;\n      }\n      if ('end_key' in opts) {\n        endkey = opts.end_key;\n      }\n      if ('endkey' in opts) {\n        endkey = opts.endkey;\n      }\n      if (typeof startkey !== 'undefined') {\n        viewOpts.startkey = opts.descending ?\n          toIndexableString([startkey, {}]) :\n          toIndexableString([startkey]);\n      }\n      if (typeof endkey !== 'undefined') {\n        var inclusiveEnd = opts.inclusive_end !== false;\n        if (opts.descending) {\n          inclusiveEnd = !inclusiveEnd;\n        }\n\n        viewOpts.endkey = toIndexableString(\n          inclusiveEnd ? [endkey, {}] : [endkey]);\n      }\n      if (typeof opts.key !== 'undefined') {\n        var keyStart = toIndexableString([opts.key]);\n        var keyEnd = toIndexableString([opts.key, {}]);\n        if (viewOpts.descending) {\n          viewOpts.endkey = keyStart;\n          viewOpts.startkey = keyEnd;\n        } else {\n          viewOpts.startkey = keyStart;\n          viewOpts.endkey = keyEnd;\n        }\n      }\n      if (!shouldReduce) {\n        if (typeof opts.limit === 'number') {\n          viewOpts.limit = opts.limit;\n        }\n        viewOpts.skip = skip;\n      }\n      return fetchFromView(viewOpts).then(onMapResultsReady);\n    }\n  }\n\n  function httpViewCleanup(db) {\n    return db.request({\n      method: 'POST',\n      url: '_view_cleanup'\n    });\n  }\n\n  function localViewCleanup(db) {\n    return db.get('_local/' + localDocName).then(function (metaDoc) {\n      var docsToViews = new ExportedMap();\n      Object.keys(metaDoc.views).forEach(function (fullViewName) {\n        var parts = parseViewName(fullViewName);\n        var designDocName = '_design/' + parts[0];\n        var viewName = parts[1];\n        var views = docsToViews.get(designDocName);\n        if (!views) {\n          views = new ExportedSet();\n          docsToViews.set(designDocName, views);\n        }\n        views.add(viewName);\n      });\n      var opts = {\n        keys : mapToKeysArray(docsToViews),\n        include_docs : true\n      };\n      return db.allDocs(opts).then(function (res) {\n        var viewsToStatus = {};\n        res.rows.forEach(function (row) {\n          var ddocName = row.key.substring(8); // cuts off '_design/'\n          docsToViews.get(row.key).forEach(function (viewName) {\n            var fullViewName = ddocName + '/' + viewName;\n            /* istanbul ignore if */\n            if (!metaDoc.views[fullViewName]) {\n              // new format, without slashes, to support PouchDB 2.2.0\n              // migration test in pouchdb's browser.migration.js verifies this\n              fullViewName = viewName;\n            }\n            var viewDBNames = Object.keys(metaDoc.views[fullViewName]);\n            // design doc deleted, or view function nonexistent\n            var statusIsGood = row.doc && row.doc.views &&\n              row.doc.views[viewName];\n            viewDBNames.forEach(function (viewDBName) {\n              viewsToStatus[viewDBName] =\n                viewsToStatus[viewDBName] || statusIsGood;\n            });\n          });\n        });\n        var dbsToDelete = Object.keys(viewsToStatus).filter(\n          function (viewDBName) { return !viewsToStatus[viewDBName]; });\n        var destroyPromises = dbsToDelete.map(function (viewDBName) {\n          return sequentialize(getQueue(viewDBName), function () {\n            return new db.constructor(viewDBName, db.__opts).destroy();\n          })();\n        });\n        return PouchPromise.all(destroyPromises).then(function () {\n          return {ok: true};\n        });\n      });\n    }, defaultsTo({ok: true}));\n  }\n\n  function queryPromised(db, fun, opts) {\n    /* istanbul ignore next */\n    if (typeof db._query === 'function') {\n      return customQuery(db, fun, opts);\n    }\n    if (isRemote(db)) {\n      return httpQuery(db, fun, opts);\n    }\n    \n    if (typeof fun !== 'string') {\n      // temp_view\n      checkQueryParseError(opts, fun);\n\n      tempViewQueue.add(function () {\n        var createViewPromise = createView(\n          /* sourceDB */ db,\n          /* viewName */ 'temp_view/temp_view',\n          /* mapFun */ fun.map,\n          /* reduceFun */ fun.reduce,\n          /* temporary */ true,\n          /* localDocName */ localDocName);\n        return createViewPromise.then(function (view) {\n          return fin(updateView(view).then(function () {\n            return queryView(view, opts);\n          }), function () {\n            return view.db.destroy();\n          });\n        });\n      });\n      return tempViewQueue.finish();\n    } else {\n      // persistent view\n      var fullViewName = fun;\n      var parts = parseViewName(fullViewName);\n      var designDocName = parts[0];\n      var viewName = parts[1];\n      return db.get('_design/' + designDocName).then(function (doc) {\n        var fun = doc.views && doc.views[viewName];\n\n        if (!fun) {\n          // basic validator; it's assumed that every subclass would want this\n          throw new NotFoundError('ddoc ' + doc._id + ' has no view named ' +\n            viewName);\n        }\n\n        ddocValidator(doc, viewName);\n        checkQueryParseError(opts, fun);\n\n        var createViewPromise = createView(\n          /* sourceDB */ db,\n          /* viewName */ fullViewName,\n          /* mapFun */ fun.map,\n          /* reduceFun */ fun.reduce,\n          /* temporary */ false,\n          /* localDocName */ localDocName);\n        return createViewPromise.then(function (view) {\n          if (opts.stale === 'ok' || opts.stale === 'update_after') {\n            if (opts.stale === 'update_after') {\n              nextTick(function () {\n                updateView(view);\n              });\n            }\n            return queryView(view, opts);\n          } else { // stale not ok\n            return updateView(view).then(function () {\n              return queryView(view, opts);\n            });\n          }\n        });\n      });\n    }\n  }\n\n  function abstractQuery(fun, opts, callback) {\n    var db = this;\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    opts = opts ? coerceOptions(opts) : {};\n\n    if (typeof fun === 'function') {\n      fun = {map : fun};\n    }\n\n    var promise = PouchPromise.resolve().then(function () {\n      return queryPromised(db, fun, opts);\n    });\n    promisedCallback(promise, callback);\n    return promise;\n  }\n\n  var abstractViewCleanup = callbackify(function () {\n    var db = this;\n    /* istanbul ignore next */\n    if (typeof db._viewCleanup === 'function') {\n      return customViewCleanup(db);\n    }\n    if (isRemote(db)) {\n      return httpViewCleanup(db);\n    }\n    return localViewCleanup(db);\n  });\n\n  return {\n    query: abstractQuery,\n    viewCleanup: abstractViewCleanup\n  };\n}\n\nvar builtInReduce = {\n  _sum: function (keys, values) {\n    return sum(values);\n  },\n\n  _count: function (keys, values) {\n    return values.length;\n  },\n\n  _stats: function (keys, values) {\n    // no need to implement rereduce=true, because Pouch\n    // will never call it\n    function sumsqr(values) {\n      var _sumsqr = 0;\n      for (var i = 0, len = values.length; i < len; i++) {\n        var num = values[i];\n        _sumsqr += (num * num);\n      }\n      return _sumsqr;\n    }\n    return {\n      sum     : sum(values),\n      min     : Math.min.apply(null, values),\n      max     : Math.max.apply(null, values),\n      count   : values.length,\n      sumsqr : sumsqr(values)\n    };\n  }\n};\n\nfunction getBuiltIn(reduceFunString) {\n  if (/^_sum/.test(reduceFunString)) {\n    return builtInReduce._sum;\n  } else if (/^_count/.test(reduceFunString)) {\n    return builtInReduce._count;\n  } else if (/^_stats/.test(reduceFunString)) {\n    return builtInReduce._stats;\n  } else if (/^_/.test(reduceFunString)) {\n    throw new Error(reduceFunString + ' is not a supported reduce function.');\n  }\n}\n\nfunction mapper(mapFun, emit) {\n  // for temp_views one can use emit(doc, emit), see #38\n  if (typeof mapFun === \"function\" && mapFun.length === 2) {\n    var origMap = mapFun;\n    return function (doc) {\n      return origMap(doc, emit);\n    };\n  } else {\n    return evalFunctionWithEval(mapFun.toString(), emit);\n  }\n}\n\nfunction reducer(reduceFun) {\n  var reduceFunString = reduceFun.toString();\n  var builtIn = getBuiltIn(reduceFunString);\n  if (builtIn) {\n    return builtIn;\n  } else {\n    return evalFunctionWithEval(reduceFunString);\n  }\n}\n\nfunction ddocValidator(ddoc, viewName) {\n  var fun = ddoc.views && ddoc.views[viewName];\n  if (typeof fun.map !== 'string') {\n    throw new NotFoundError('ddoc ' + ddoc._id + ' has no string view named ' +\n      viewName + ', instead found object of type: ' + typeof fun.map);\n  }\n}\n\nvar localDocName = 'mrviews';\nvar abstract = createAbstractMapReduce(localDocName, mapper, reducer, ddocValidator);\n\nfunction query(fun, opts, callback) {\n  return abstract.query.call(this, fun, opts, callback);\n}\n\nfunction viewCleanup(callback) {\n  return abstract.viewCleanup.call(this, callback);\n}\n\nvar mapreduce = {\n  query: query,\n  viewCleanup: viewCleanup\n};\n\nfunction isGenOne$1(rev$$1) {\n  return /^1-/.test(rev$$1);\n}\n\nfunction fileHasChanged(localDoc, remoteDoc, filename) {\n  return !localDoc._attachments ||\n         !localDoc._attachments[filename] ||\n         localDoc._attachments[filename].digest !== remoteDoc._attachments[filename].digest;\n}\n\nfunction getDocAttachments(db, doc) {\n  var filenames = Object.keys(doc._attachments);\n  return PouchPromise.all(filenames.map(function (filename) {\n    return db.getAttachment(doc._id, filename, {rev: doc._rev});\n  }));\n}\n\nfunction getDocAttachmentsFromTargetOrSource(target, src, doc) {\n  var doCheckForLocalAttachments = isRemote(src) && !isRemote(target);\n  var filenames = Object.keys(doc._attachments);\n\n  if (!doCheckForLocalAttachments) {\n    return getDocAttachments(src, doc);\n  }\n\n  return target.get(doc._id).then(function (localDoc) {\n    return PouchPromise.all(filenames.map(function (filename) {\n      if (fileHasChanged(localDoc, doc, filename)) {\n        return src.getAttachment(doc._id, filename);\n      }\n\n      return target.getAttachment(localDoc._id, filename);\n    }));\n  })[\"catch\"](function (error) {\n    /* istanbul ignore if */\n    if (error.status !== 404) {\n      throw error;\n    }\n\n    return getDocAttachments(src, doc);\n  });\n}\n\nfunction createBulkGetOpts(diffs) {\n  var requests = [];\n  Object.keys(diffs).forEach(function (id) {\n    var missingRevs = diffs[id].missing;\n    missingRevs.forEach(function (missingRev) {\n      requests.push({\n        id: id,\n        rev: missingRev\n      });\n    });\n  });\n\n  return {\n    docs: requests,\n    revs: true,\n    latest: true\n  };\n}\n\n//\n// Fetch all the documents from the src as described in the \"diffs\",\n// which is a mapping of docs IDs to revisions. If the state ever\n// changes to \"cancelled\", then the returned promise will be rejected.\n// Else it will be resolved with a list of fetched documents.\n//\nfunction getDocs(src, target, diffs, state) {\n  diffs = clone(diffs); // we do not need to modify this\n\n  var resultDocs = [],\n      ok = true;\n\n  function getAllDocs() {\n\n    var bulkGetOpts = createBulkGetOpts(diffs);\n\n    if (!bulkGetOpts.docs.length) { // optimization: skip empty requests\n      return;\n    }\n\n    return src.bulkGet(bulkGetOpts).then(function (bulkGetResponse) {\n      /* istanbul ignore if */\n      if (state.cancelled) {\n        throw new Error('cancelled');\n      }\n      return PouchPromise.all(bulkGetResponse.results.map(function (bulkGetInfo) {\n        return PouchPromise.all(bulkGetInfo.docs.map(function (doc) {\n          var remoteDoc = doc.ok;\n\n          if (doc.error) {\n            // when AUTO_COMPACTION is set, docs can be returned which look\n            // like this: {\"missing\":\"1-7c3ac256b693c462af8442f992b83696\"}\n            ok = false;\n          }\n\n          if (!remoteDoc || !remoteDoc._attachments) {\n            return remoteDoc;\n          }\n\n          return getDocAttachmentsFromTargetOrSource(target, src, remoteDoc)\n                   .then(function (attachments) {\n                           var filenames = Object.keys(remoteDoc._attachments);\n                           attachments\n                             .forEach(function (attachment, i) {\n                                        var att = remoteDoc._attachments[filenames[i]];\n                                        delete att.stub;\n                                        delete att.length;\n                                        att.data = attachment;\n                                      });\n\n                                      return remoteDoc;\n                                    });\n        }));\n      }))\n\n      .then(function (results) {\n        resultDocs = resultDocs.concat(flatten(results).filter(Boolean));\n      });\n    });\n  }\n\n  function hasAttachments(doc) {\n    return doc._attachments && Object.keys(doc._attachments).length > 0;\n  }\n\n  function hasConflicts(doc) {\n    return doc._conflicts && doc._conflicts.length > 0;\n  }\n\n  function fetchRevisionOneDocs(ids) {\n    // Optimization: fetch gen-1 docs and attachments in\n    // a single request using _all_docs\n    return src.allDocs({\n      keys: ids,\n      include_docs: true,\n      conflicts: true\n    }).then(function (res) {\n      if (state.cancelled) {\n        throw new Error('cancelled');\n      }\n      res.rows.forEach(function (row) {\n        if (row.deleted || !row.doc || !isGenOne$1(row.value.rev) ||\n            hasAttachments(row.doc) || hasConflicts(row.doc)) {\n          // if any of these conditions apply, we need to fetch using get()\n          return;\n        }\n\n        // strip _conflicts array to appease CSG (#5793)\n        /* istanbul ignore if */\n        if (row.doc._conflicts) {\n          delete row.doc._conflicts;\n        }\n\n        // the doc we got back from allDocs() is sufficient\n        resultDocs.push(row.doc);\n        delete diffs[row.id];\n      });\n    });\n  }\n\n  function getRevisionOneDocs() {\n    // filter out the generation 1 docs and get them\n    // leaving the non-generation one docs to be got otherwise\n    var ids = Object.keys(diffs).filter(function (id) {\n      var missing = diffs[id].missing;\n      return missing.length === 1 && isGenOne$1(missing[0]);\n    });\n    if (ids.length > 0) {\n      return fetchRevisionOneDocs(ids);\n    }\n  }\n\n  function returnResult() {\n    return { ok:ok, docs:resultDocs };\n  }\n\n  return PouchPromise.resolve()\n    .then(getRevisionOneDocs)\n    .then(getAllDocs)\n    .then(returnResult);\n}\n\nvar CHECKPOINT_VERSION = 1;\nvar REPLICATOR = \"pouchdb\";\n// This is an arbitrary number to limit the\n// amount of replication history we save in the checkpoint.\n// If we save too much, the checkpoing docs will become very big,\n// if we save fewer, we'll run a greater risk of having to\n// read all the changes from 0 when checkpoint PUTs fail\n// CouchDB 2.0 has a more involved history pruning,\n// but let's go for the simple version for now.\nvar CHECKPOINT_HISTORY_SIZE = 5;\nvar LOWEST_SEQ = 0;\n\nfunction updateCheckpoint(db, id, checkpoint, session, returnValue) {\n  return db.get(id)[\"catch\"](function (err) {\n    if (err.status === 404) {\n      if (db.adapter === 'http' || db.adapter === 'https') {\n        explainError(\n          404, 'PouchDB is just checking if a remote checkpoint exists.'\n        );\n      }\n      return {\n        session_id: session,\n        _id: id,\n        history: [],\n        replicator: REPLICATOR,\n        version: CHECKPOINT_VERSION\n      };\n    }\n    throw err;\n  }).then(function (doc) {\n    if (returnValue.cancelled) {\n      return;\n    }\n\n    // if the checkpoint has not changed, do not update\n    if (doc.last_seq === checkpoint) {\n      return;\n    }\n\n    // Filter out current entry for this replication\n    doc.history = (doc.history || []).filter(function (item) {\n      return item.session_id !== session;\n    });\n\n    // Add the latest checkpoint to history\n    doc.history.unshift({\n      last_seq: checkpoint,\n      session_id: session\n    });\n\n    // Just take the last pieces in history, to\n    // avoid really big checkpoint docs.\n    // see comment on history size above\n    doc.history = doc.history.slice(0, CHECKPOINT_HISTORY_SIZE);\n\n    doc.version = CHECKPOINT_VERSION;\n    doc.replicator = REPLICATOR;\n\n    doc.session_id = session;\n    doc.last_seq = checkpoint;\n\n    return db.put(doc)[\"catch\"](function (err) {\n      if (err.status === 409) {\n        // retry; someone is trying to write a checkpoint simultaneously\n        return updateCheckpoint(db, id, checkpoint, session, returnValue);\n      }\n      throw err;\n    });\n  });\n}\n\nfunction Checkpointer(src, target, id, returnValue, opts) {\n  this.src = src;\n  this.target = target;\n  this.id = id;\n  this.returnValue = returnValue;\n  this.opts = opts || {};\n}\n\nCheckpointer.prototype.writeCheckpoint = function (checkpoint, session) {\n  var self = this;\n  return this.updateTarget(checkpoint, session).then(function () {\n    return self.updateSource(checkpoint, session);\n  });\n};\n\nCheckpointer.prototype.updateTarget = function (checkpoint, session) {\n  if (this.opts.writeTargetCheckpoint) {\n    return updateCheckpoint(this.target, this.id, checkpoint,\n      session, this.returnValue);\n  } else {\n    return PouchPromise.resolve(true);\n  }\n};\n\nCheckpointer.prototype.updateSource = function (checkpoint, session) {\n  if (this.opts.writeSourceCheckpoint) {\n    var self = this;\n    return updateCheckpoint(this.src, this.id, checkpoint,\n      session, this.returnValue)[\n      \"catch\"](function (err) {\n        if (isForbiddenError(err)) {\n          self.opts.writeSourceCheckpoint = false;\n          return true;\n        }\n        throw err;\n      });\n  } else {\n    return PouchPromise.resolve(true);\n  }\n};\n\nvar comparisons = {\n  \"undefined\": function (targetDoc, sourceDoc) {\n    // This is the previous comparison function\n    if (collate(targetDoc.last_seq, sourceDoc.last_seq) === 0) {\n      return sourceDoc.last_seq;\n    }\n    /* istanbul ignore next */\n    return 0;\n  },\n  \"1\": function (targetDoc, sourceDoc) {\n    // This is the comparison function ported from CouchDB\n    return compareReplicationLogs(sourceDoc, targetDoc).last_seq;\n  }\n};\n\nCheckpointer.prototype.getCheckpoint = function () {\n  var self = this;\n\n  if (self.opts && self.opts.writeSourceCheckpoint && !self.opts.writeTargetCheckpoint) {\n    return self.src.get(self.id).then(function (sourceDoc) {\n      return sourceDoc.last_seq || LOWEST_SEQ;\n    })[\"catch\"](function (err) {\n      /* istanbul ignore if */\n      if (err.status !== 404) {\n        throw err;\n      }\n      return LOWEST_SEQ;\n    });\n  }\n\n  return self.target.get(self.id).then(function (targetDoc) {\n    if (self.opts && self.opts.writeTargetCheckpoint && !self.opts.writeSourceCheckpoint) {\n      return targetDoc.last_seq || LOWEST_SEQ;\n    }\n\n    return self.src.get(self.id).then(function (sourceDoc) {\n      // Since we can't migrate an old version doc to a new one\n      // (no session id), we just go with the lowest seq in this case\n      /* istanbul ignore if */\n      if (targetDoc.version !== sourceDoc.version) {\n        return LOWEST_SEQ;\n      }\n\n      var version;\n      if (targetDoc.version) {\n        version = targetDoc.version.toString();\n      } else {\n        version = \"undefined\";\n      }\n\n      if (version in comparisons) {\n        return comparisons[version](targetDoc, sourceDoc);\n      }\n      /* istanbul ignore next */\n      return LOWEST_SEQ;\n    }, function (err) {\n      if (err.status === 404 && targetDoc.last_seq) {\n        return self.src.put({\n          _id: self.id,\n          last_seq: LOWEST_SEQ\n        }).then(function () {\n          return LOWEST_SEQ;\n        }, function (err) {\n          if (isForbiddenError(err)) {\n            self.opts.writeSourceCheckpoint = false;\n            return targetDoc.last_seq;\n          }\n          /* istanbul ignore next */\n          return LOWEST_SEQ;\n        });\n      }\n      throw err;\n    });\n  })[\"catch\"](function (err) {\n    if (err.status !== 404) {\n      throw err;\n    }\n    return LOWEST_SEQ;\n  });\n};\n// This checkpoint comparison is ported from CouchDBs source\n// they come from here:\n// https://github.com/apache/couchdb-couch-replicator/blob/master/src/couch_replicator.erl#L863-L906\n\nfunction compareReplicationLogs(srcDoc, tgtDoc) {\n  if (srcDoc.session_id === tgtDoc.session_id) {\n    return {\n      last_seq: srcDoc.last_seq,\n      history: srcDoc.history\n    };\n  }\n\n  return compareReplicationHistory(srcDoc.history, tgtDoc.history);\n}\n\nfunction compareReplicationHistory(sourceHistory, targetHistory) {\n  // the erlang loop via function arguments is not so easy to repeat in JS\n  // therefore, doing this as recursion\n  var S = sourceHistory[0];\n  var sourceRest = sourceHistory.slice(1);\n  var T = targetHistory[0];\n  var targetRest = targetHistory.slice(1);\n\n  if (!S || targetHistory.length === 0) {\n    return {\n      last_seq: LOWEST_SEQ,\n      history: []\n    };\n  }\n\n  var sourceId = S.session_id;\n  /* istanbul ignore if */\n  if (hasSessionId(sourceId, targetHistory)) {\n    return {\n      last_seq: S.last_seq,\n      history: sourceHistory\n    };\n  }\n\n  var targetId = T.session_id;\n  if (hasSessionId(targetId, sourceRest)) {\n    return {\n      last_seq: T.last_seq,\n      history: targetRest\n    };\n  }\n\n  return compareReplicationHistory(sourceRest, targetRest);\n}\n\nfunction hasSessionId(sessionId, history) {\n  var props = history[0];\n  var rest = history.slice(1);\n\n  if (!sessionId || history.length === 0) {\n    return false;\n  }\n\n  if (sessionId === props.session_id) {\n    return true;\n  }\n\n  return hasSessionId(sessionId, rest);\n}\n\nfunction isForbiddenError(err) {\n  return typeof err.status === 'number' && Math.floor(err.status / 100) === 4;\n}\n\nvar STARTING_BACK_OFF = 0;\n\nfunction backOff(opts, returnValue, error, callback) {\n  if (opts.retry === false) {\n    returnValue.emit('error', error);\n    returnValue.removeAllListeners();\n    return;\n  }\n  if (typeof opts.back_off_function !== 'function') {\n    opts.back_off_function = defaultBackOff;\n  }\n  returnValue.emit('requestError', error);\n  if (returnValue.state === 'active' || returnValue.state === 'pending') {\n    returnValue.emit('paused', error);\n    returnValue.state = 'stopped';\n    var backOffSet = function backoffTimeSet() {\n      opts.current_back_off = STARTING_BACK_OFF;\n    };\n    var removeBackOffSetter = function removeBackOffTimeSet() {\n      returnValue.removeListener('active', backOffSet);\n    };\n    returnValue.once('paused', removeBackOffSetter);\n    returnValue.once('active', backOffSet);\n  }\n\n  opts.current_back_off = opts.current_back_off || STARTING_BACK_OFF;\n  opts.current_back_off = opts.back_off_function(opts.current_back_off);\n  setTimeout(callback, opts.current_back_off);\n}\n\nfunction sortObjectPropertiesByKey(queryParams) {\n  return Object.keys(queryParams).sort(collate).reduce(function (result, key) {\n    result[key] = queryParams[key];\n    return result;\n  }, {});\n}\n\n// Generate a unique id particular to this replication.\n// Not guaranteed to align perfectly with CouchDB's rep ids.\nfunction generateReplicationId(src, target, opts) {\n  var docIds = opts.doc_ids ? opts.doc_ids.sort(collate) : '';\n  var filterFun = opts.filter ? opts.filter.toString() : '';\n  var queryParams = '';\n  var filterViewName =  '';\n  var selector = '';\n\n  // possibility for checkpoints to be lost here as behaviour of\n  // JSON.stringify is not stable (see #6226)\n  /* istanbul ignore if */\n  if (opts.selector) {\n    selector = JSON.stringify(opts.selector);\n  }\n\n  if (opts.filter && opts.query_params) {\n    queryParams = JSON.stringify(sortObjectPropertiesByKey(opts.query_params));\n  }\n\n  if (opts.filter && opts.filter === '_view') {\n    filterViewName = opts.view.toString();\n  }\n\n  return PouchPromise.all([src.id(), target.id()]).then(function (res) {\n    var queryData = res[0] + res[1] + filterFun + filterViewName +\n      queryParams + docIds + selector;\n    return new PouchPromise(function (resolve) {\n      binaryMd5(queryData, resolve);\n    });\n  }).then(function (md5sum) {\n    // can't use straight-up md5 alphabet, because\n    // the char '/' is interpreted as being for attachments,\n    // and + is also not url-safe\n    md5sum = md5sum.replace(/\\//g, '.').replace(/\\+/g, '_');\n    return '_local/' + md5sum;\n  });\n}\n\nfunction replicate(src, target, opts, returnValue, result) {\n  var batches = [];               // list of batches to be processed\n  var currentBatch;               // the batch currently being processed\n  var pendingBatch = {\n    seq: 0,\n    changes: [],\n    docs: []\n  }; // next batch, not yet ready to be processed\n  var writingCheckpoint = false;  // true while checkpoint is being written\n  var changesCompleted = false;   // true when all changes received\n  var replicationCompleted = false; // true when replication has completed\n  var last_seq = 0;\n  var continuous = opts.continuous || opts.live || false;\n  var batch_size = opts.batch_size || 100;\n  var batches_limit = opts.batches_limit || 10;\n  var changesPending = false;     // true while src.changes is running\n  var doc_ids = opts.doc_ids;\n  var selector = opts.selector;\n  var repId;\n  var checkpointer;\n  var changedDocs = [];\n  // Like couchdb, every replication gets a unique session id\n  var session = uuid();\n  var seq_interval = opts.seq_interval;\n\n  result = result || {\n    ok: true,\n    start_time: new Date(),\n    docs_read: 0,\n    docs_written: 0,\n    doc_write_failures: 0,\n    errors: []\n  };\n\n  var changesOpts = {};\n  returnValue.ready(src, target);\n\n  function initCheckpointer() {\n    if (checkpointer) {\n      return PouchPromise.resolve();\n    }\n    return generateReplicationId(src, target, opts).then(function (res) {\n      repId = res;\n\n      var checkpointOpts = {};\n      if (opts.checkpoint === false) {\n        checkpointOpts = { writeSourceCheckpoint: false, writeTargetCheckpoint: false };\n      } else if (opts.checkpoint === 'source') {\n        checkpointOpts = { writeSourceCheckpoint: true, writeTargetCheckpoint: false };\n      } else if (opts.checkpoint === 'target') {\n        checkpointOpts = { writeSourceCheckpoint: false, writeTargetCheckpoint: true };\n      } else {\n        checkpointOpts = { writeSourceCheckpoint: true, writeTargetCheckpoint: true };\n      }\n\n      checkpointer = new Checkpointer(src, target, repId, returnValue, checkpointOpts);\n    });\n  }\n\n  function writeDocs() {\n    changedDocs = [];\n\n    if (currentBatch.docs.length === 0) {\n      return;\n    }\n    var docs = currentBatch.docs;\n    var bulkOpts = {timeout: opts.timeout};\n    return target.bulkDocs({docs: docs, new_edits: false}, bulkOpts).then(function (res) {\n      /* istanbul ignore if */\n      if (returnValue.cancelled) {\n        completeReplication();\n        throw new Error('cancelled');\n      }\n\n      // `res` doesn't include full documents (which live in `docs`), so we create a map of \n      // (id -> error), and check for errors while iterating over `docs`\n      var errorsById = Object.create(null);\n      res.forEach(function (res) {\n        if (res.error) {\n          errorsById[res.id] = res;\n        }\n      });\n\n      var errorsNo = Object.keys(errorsById).length;\n      result.doc_write_failures += errorsNo;\n      result.docs_written += docs.length - errorsNo;\n\n      docs.forEach(function (doc) {\n        var error = errorsById[doc._id];\n        if (error) {\n          result.errors.push(error);\n          // Normalize error name. i.e. 'Unauthorized' -> 'unauthorized' (eg Sync Gateway)\n          var errorName = (error.name || '').toLowerCase();\n          if (errorName === 'unauthorized' || errorName === 'forbidden') {\n            returnValue.emit('denied', clone(error));\n          } else {\n            throw error;\n          }\n        } else {\n          changedDocs.push(doc);\n        }\n      });\n\n    }, function (err) {\n      result.doc_write_failures += docs.length;\n      throw err;\n    });\n  }\n\n  function finishBatch() {\n    if (currentBatch.error) {\n      throw new Error('There was a problem getting docs.');\n    }\n    result.last_seq = last_seq = currentBatch.seq;\n    var outResult = clone(result);\n    if (changedDocs.length) {\n      outResult.docs = changedDocs;\n      // Attach 'pending' property if server supports it (CouchDB 2.0+)\n      /* istanbul ignore if */\n      if (typeof currentBatch.pending === 'number') {\n        outResult.pending = currentBatch.pending;\n        delete currentBatch.pending;\n      }\n      returnValue.emit('change', outResult);\n    }\n    writingCheckpoint = true;\n    return checkpointer.writeCheckpoint(currentBatch.seq,\n        session).then(function () {\n      writingCheckpoint = false;\n      /* istanbul ignore if */\n      if (returnValue.cancelled) {\n        completeReplication();\n        throw new Error('cancelled');\n      }\n      currentBatch = undefined;\n      getChanges();\n    })[\"catch\"](function (err) {\n      onCheckpointError(err);\n      throw err;\n    });\n  }\n\n  function getDiffs() {\n    var diff = {};\n    currentBatch.changes.forEach(function (change) {\n      // Couchbase Sync Gateway emits these, but we can ignore them\n      /* istanbul ignore if */\n      if (change.id === \"_user/\") {\n        return;\n      }\n      diff[change.id] = change.changes.map(function (x) {\n        return x.rev;\n      });\n    });\n    return target.revsDiff(diff).then(function (diffs) {\n      /* istanbul ignore if */\n      if (returnValue.cancelled) {\n        completeReplication();\n        throw new Error('cancelled');\n      }\n      // currentBatch.diffs elements are deleted as the documents are written\n      currentBatch.diffs = diffs;\n    });\n  }\n\n  function getBatchDocs() {\n    return getDocs(src, target, currentBatch.diffs, returnValue).then(function (got) {\n      currentBatch.error = !got.ok;\n      got.docs.forEach(function (doc) {\n        delete currentBatch.diffs[doc._id];\n        result.docs_read++;\n        currentBatch.docs.push(doc);\n      });\n    });\n  }\n\n  function startNextBatch() {\n    if (returnValue.cancelled || currentBatch) {\n      return;\n    }\n    if (batches.length === 0) {\n      processPendingBatch(true);\n      return;\n    }\n    currentBatch = batches.shift();\n    getDiffs()\n      .then(getBatchDocs)\n      .then(writeDocs)\n      .then(finishBatch)\n      .then(startNextBatch)[\n      \"catch\"](function (err) {\n        abortReplication('batch processing terminated with error', err);\n      });\n  }\n\n\n  function processPendingBatch(immediate) {\n    if (pendingBatch.changes.length === 0) {\n      if (batches.length === 0 && !currentBatch) {\n        if ((continuous && changesOpts.live) || changesCompleted) {\n          returnValue.state = 'pending';\n          returnValue.emit('paused');\n        }\n        if (changesCompleted) {\n          completeReplication();\n        }\n      }\n      return;\n    }\n    if (\n      immediate ||\n      changesCompleted ||\n      pendingBatch.changes.length >= batch_size\n    ) {\n      batches.push(pendingBatch);\n      pendingBatch = {\n        seq: 0,\n        changes: [],\n        docs: []\n      };\n      if (returnValue.state === 'pending' || returnValue.state === 'stopped') {\n        returnValue.state = 'active';\n        returnValue.emit('active');\n      }\n      startNextBatch();\n    }\n  }\n\n\n  function abortReplication(reason, err) {\n    if (replicationCompleted) {\n      return;\n    }\n    if (!err.message) {\n      err.message = reason;\n    }\n    result.ok = false;\n    result.status = 'aborting';\n    batches = [];\n    pendingBatch = {\n      seq: 0,\n      changes: [],\n      docs: []\n    };\n    completeReplication(err);\n  }\n\n\n  function completeReplication(fatalError) {\n    if (replicationCompleted) {\n      return;\n    }\n    /* istanbul ignore if */\n    if (returnValue.cancelled) {\n      result.status = 'cancelled';\n      if (writingCheckpoint) {\n        return;\n      }\n    }\n    result.status = result.status || 'complete';\n    result.end_time = new Date();\n    result.last_seq = last_seq;\n    replicationCompleted = true;\n\n    if (fatalError) {\n      // need to extend the error because Firefox considers \".result\" read-only\n      fatalError = createError(fatalError);\n      fatalError.result = result;\n\n      // Normalize error name. i.e. 'Unauthorized' -> 'unauthorized' (eg Sync Gateway)\n      var errorName = (fatalError.name || '').toLowerCase();\n      if (errorName === 'unauthorized' || errorName === 'forbidden') {\n        returnValue.emit('error', fatalError);\n        returnValue.removeAllListeners();\n      } else {\n        backOff(opts, returnValue, fatalError, function () {\n          replicate(src, target, opts, returnValue);\n        });\n      }\n    } else {\n      returnValue.emit('complete', result);\n      returnValue.removeAllListeners();\n    }\n  }\n\n\n  function onChange(change, pending, lastSeq) {\n    /* istanbul ignore if */\n    if (returnValue.cancelled) {\n      return completeReplication();\n    }\n    // Attach 'pending' property if server supports it (CouchDB 2.0+)\n    /* istanbul ignore if */\n    if (typeof pending === 'number') {\n      pendingBatch.pending = pending;\n    }\n\n    var filter = filterChange(opts)(change);\n    if (!filter) {\n      return;\n    }\n    pendingBatch.seq = change.seq || lastSeq;\n    pendingBatch.changes.push(change);\n    processPendingBatch(batches.length === 0 && changesOpts.live);\n  }\n\n\n  function onChangesComplete(changes) {\n    changesPending = false;\n    /* istanbul ignore if */\n    if (returnValue.cancelled) {\n      return completeReplication();\n    }\n\n    // if no results were returned then we're done,\n    // else fetch more\n    if (changes.results.length > 0) {\n      changesOpts.since = changes.last_seq;\n      getChanges();\n      processPendingBatch(true);\n    } else {\n\n      var complete = function () {\n        if (continuous) {\n          changesOpts.live = true;\n          getChanges();\n        } else {\n          changesCompleted = true;\n        }\n        processPendingBatch(true);\n      };\n\n      // update the checkpoint so we start from the right seq next time\n      if (!currentBatch && changes.results.length === 0) {\n        writingCheckpoint = true;\n        checkpointer.writeCheckpoint(changes.last_seq,\n            session).then(function () {\n          writingCheckpoint = false;\n          result.last_seq = last_seq = changes.last_seq;\n          complete();\n        })[\n        \"catch\"](onCheckpointError);\n      } else {\n        complete();\n      }\n    }\n  }\n\n\n  function onChangesError(err) {\n    changesPending = false;\n    /* istanbul ignore if */\n    if (returnValue.cancelled) {\n      return completeReplication();\n    }\n    abortReplication('changes rejected', err);\n  }\n\n\n  function getChanges() {\n    if (!(\n      !changesPending &&\n      !changesCompleted &&\n      batches.length < batches_limit\n      )) {\n      return;\n    }\n    changesPending = true;\n    function abortChanges() {\n      changes.cancel();\n    }\n    function removeListener() {\n      returnValue.removeListener('cancel', abortChanges);\n    }\n\n    if (returnValue._changes) { // remove old changes() and listeners\n      returnValue.removeListener('cancel', returnValue._abortChanges);\n      returnValue._changes.cancel();\n    }\n    returnValue.once('cancel', abortChanges);\n\n    var changes = src.changes(changesOpts)\n      .on('change', onChange);\n    changes.then(removeListener, removeListener);\n    changes.then(onChangesComplete)[\n      \"catch\"](onChangesError);\n\n    if (opts.retry) {\n      // save for later so we can cancel if necessary\n      returnValue._changes = changes;\n      returnValue._abortChanges = abortChanges;\n    }\n  }\n\n\n  function startChanges() {\n    initCheckpointer().then(function () {\n      /* istanbul ignore if */\n      if (returnValue.cancelled) {\n        completeReplication();\n        return;\n      }\n      return checkpointer.getCheckpoint().then(function (checkpoint) {\n        last_seq = checkpoint;\n        changesOpts = {\n          since: last_seq,\n          limit: batch_size,\n          batch_size: batch_size,\n          style: 'all_docs',\n          doc_ids: doc_ids,\n          selector: selector,\n          return_docs: true // required so we know when we're done\n        };\n        if (seq_interval !== false) {\n          changesOpts.seq_interval = seq_interval || batch_size;\n        }\n        if (opts.filter) {\n          if (typeof opts.filter !== 'string') {\n            // required for the client-side filter in onChange\n            changesOpts.include_docs = true;\n          } else { // ddoc filter\n            changesOpts.filter = opts.filter;\n          }\n        }\n        if ('heartbeat' in opts) {\n          changesOpts.heartbeat = opts.heartbeat;\n        }\n        if ('timeout' in opts) {\n          changesOpts.timeout = opts.timeout;\n        }\n        if (opts.query_params) {\n          changesOpts.query_params = opts.query_params;\n        }\n        if (opts.view) {\n          changesOpts.view = opts.view;\n        }\n        getChanges();\n      });\n    })[\"catch\"](function (err) {\n      abortReplication('getCheckpoint rejected with ', err);\n    });\n  }\n\n  /* istanbul ignore next */\n  function onCheckpointError(err) {\n    writingCheckpoint = false;\n    abortReplication('writeCheckpoint completed with error', err);\n  }\n\n  /* istanbul ignore if */\n  if (returnValue.cancelled) { // cancelled immediately\n    completeReplication();\n    return;\n  }\n\n  if (!returnValue._addedListeners) {\n    returnValue.once('cancel', completeReplication);\n\n    if (typeof opts.complete === 'function') {\n      returnValue.once('error', opts.complete);\n      returnValue.once('complete', function (result) {\n        opts.complete(null, result);\n      });\n    }\n    returnValue._addedListeners = true;\n  }\n\n  if (typeof opts.since === 'undefined') {\n    startChanges();\n  } else {\n    initCheckpointer().then(function () {\n      writingCheckpoint = true;\n      return checkpointer.writeCheckpoint(opts.since, session);\n    }).then(function () {\n      writingCheckpoint = false;\n      /* istanbul ignore if */\n      if (returnValue.cancelled) {\n        completeReplication();\n        return;\n      }\n      last_seq = opts.since;\n      startChanges();\n    })[\"catch\"](onCheckpointError);\n  }\n}\n\n// We create a basic promise so the caller can cancel the replication possibly\n// before we have actually started listening to changes etc\ninherits(Replication, events.EventEmitter);\nfunction Replication() {\n  events.EventEmitter.call(this);\n  this.cancelled = false;\n  this.state = 'pending';\n  var self = this;\n  var promise = new PouchPromise(function (fulfill, reject) {\n    self.once('complete', fulfill);\n    self.once('error', reject);\n  });\n  self.then = function (resolve, reject) {\n    return promise.then(resolve, reject);\n  };\n  self[\"catch\"] = function (reject) {\n    return promise[\"catch\"](reject);\n  };\n  // As we allow error handling via \"error\" event as well,\n  // put a stub in here so that rejecting never throws UnhandledError.\n  self[\"catch\"](function () {});\n}\n\nReplication.prototype.cancel = function () {\n  this.cancelled = true;\n  this.state = 'cancelled';\n  this.emit('cancel');\n};\n\nReplication.prototype.ready = function (src, target) {\n  var self = this;\n  if (self._readyCalled) {\n    return;\n  }\n  self._readyCalled = true;\n\n  function onDestroy() {\n    self.cancel();\n  }\n  src.once('destroyed', onDestroy);\n  target.once('destroyed', onDestroy);\n  function cleanup() {\n    src.removeListener('destroyed', onDestroy);\n    target.removeListener('destroyed', onDestroy);\n  }\n  self.once('complete', cleanup);\n};\n\nfunction toPouch(db, opts) {\n  var PouchConstructor = opts.PouchConstructor;\n  if (typeof db === 'string') {\n    return new PouchConstructor(db, opts);\n  } else {\n    return db;\n  }\n}\n\nfunction replicateWrapper(src, target, opts, callback) {\n\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  if (typeof opts === 'undefined') {\n    opts = {};\n  }\n\n  if (opts.doc_ids && !Array.isArray(opts.doc_ids)) {\n    throw createError(BAD_REQUEST,\n                       \"`doc_ids` filter parameter is not a list.\");\n  }\n\n  opts.complete = callback;\n  opts = clone(opts);\n  opts.continuous = opts.continuous || opts.live;\n  opts.retry = ('retry' in opts) ? opts.retry : false;\n  /*jshint validthis:true */\n  opts.PouchConstructor = opts.PouchConstructor || this;\n  var replicateRet = new Replication(opts);\n  var srcPouch = toPouch(src, opts);\n  var targetPouch = toPouch(target, opts);\n  replicate(srcPouch, targetPouch, opts, replicateRet);\n  return replicateRet;\n}\n\ninherits(Sync, events.EventEmitter);\nfunction sync$1(src, target, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  if (typeof opts === 'undefined') {\n    opts = {};\n  }\n  opts = clone(opts);\n  /*jshint validthis:true */\n  opts.PouchConstructor = opts.PouchConstructor || this;\n  src = toPouch(src, opts);\n  target = toPouch(target, opts);\n  return new Sync(src, target, opts, callback);\n}\n\nfunction Sync(src, target, opts, callback) {\n  var self = this;\n  this.canceled = false;\n\n  var optsPush = opts.push ? $inject_Object_assign({}, opts, opts.push) : opts;\n  var optsPull = opts.pull ? $inject_Object_assign({}, opts, opts.pull) : opts;\n\n  this.push = replicateWrapper(src, target, optsPush);\n  this.pull = replicateWrapper(target, src, optsPull);\n\n  this.pushPaused = true;\n  this.pullPaused = true;\n\n  function pullChange(change) {\n    self.emit('change', {\n      direction: 'pull',\n      change: change\n    });\n  }\n  function pushChange(change) {\n    self.emit('change', {\n      direction: 'push',\n      change: change\n    });\n  }\n  function pushDenied(doc) {\n    self.emit('denied', {\n      direction: 'push',\n      doc: doc\n    });\n  }\n  function pullDenied(doc) {\n    self.emit('denied', {\n      direction: 'pull',\n      doc: doc\n    });\n  }\n  function pushPaused() {\n    self.pushPaused = true;\n    /* istanbul ignore if */\n    if (self.pullPaused) {\n      self.emit('paused');\n    }\n  }\n  function pullPaused() {\n    self.pullPaused = true;\n    /* istanbul ignore if */\n    if (self.pushPaused) {\n      self.emit('paused');\n    }\n  }\n  function pushActive() {\n    self.pushPaused = false;\n    /* istanbul ignore if */\n    if (self.pullPaused) {\n      self.emit('active', {\n        direction: 'push'\n      });\n    }\n  }\n  function pullActive() {\n    self.pullPaused = false;\n    /* istanbul ignore if */\n    if (self.pushPaused) {\n      self.emit('active', {\n        direction: 'pull'\n      });\n    }\n  }\n\n  var removed = {};\n\n  function removeAll(type) { // type is 'push' or 'pull'\n    return function (event, func) {\n      var isChange = event === 'change' &&\n        (func === pullChange || func === pushChange);\n      var isDenied = event === 'denied' &&\n        (func === pullDenied || func === pushDenied);\n      var isPaused = event === 'paused' &&\n        (func === pullPaused || func === pushPaused);\n      var isActive = event === 'active' &&\n        (func === pullActive || func === pushActive);\n\n      if (isChange || isDenied || isPaused || isActive) {\n        if (!(event in removed)) {\n          removed[event] = {};\n        }\n        removed[event][type] = true;\n        if (Object.keys(removed[event]).length === 2) {\n          // both push and pull have asked to be removed\n          self.removeAllListeners(event);\n        }\n      }\n    };\n  }\n\n  if (opts.live) {\n    this.push.on('complete', self.pull.cancel.bind(self.pull));\n    this.pull.on('complete', self.push.cancel.bind(self.push));\n  }\n\n  function addOneListener(ee, event, listener) {\n    if (ee.listeners(event).indexOf(listener) == -1) {\n      ee.on(event, listener);\n    }\n  }\n\n  this.on('newListener', function (event) {\n    if (event === 'change') {\n      addOneListener(self.pull, 'change', pullChange);\n      addOneListener(self.push, 'change', pushChange);\n    } else if (event === 'denied') {\n      addOneListener(self.pull, 'denied', pullDenied);\n      addOneListener(self.push, 'denied', pushDenied);\n    } else if (event === 'active') {\n      addOneListener(self.pull, 'active', pullActive);\n      addOneListener(self.push, 'active', pushActive);\n    } else if (event === 'paused') {\n      addOneListener(self.pull, 'paused', pullPaused);\n      addOneListener(self.push, 'paused', pushPaused);\n    }\n  });\n\n  this.on('removeListener', function (event) {\n    if (event === 'change') {\n      self.pull.removeListener('change', pullChange);\n      self.push.removeListener('change', pushChange);\n    } else if (event === 'denied') {\n      self.pull.removeListener('denied', pullDenied);\n      self.push.removeListener('denied', pushDenied);\n    } else if (event === 'active') {\n      self.pull.removeListener('active', pullActive);\n      self.push.removeListener('active', pushActive);\n    } else if (event === 'paused') {\n      self.pull.removeListener('paused', pullPaused);\n      self.push.removeListener('paused', pushPaused);\n    }\n  });\n\n  this.pull.on('removeListener', removeAll('pull'));\n  this.push.on('removeListener', removeAll('push'));\n\n  var promise = PouchPromise.all([\n    this.push,\n    this.pull\n  ]).then(function (resp) {\n    var out = {\n      push: resp[0],\n      pull: resp[1]\n    };\n    self.emit('complete', out);\n    if (callback) {\n      callback(null, out);\n    }\n    self.removeAllListeners();\n    return out;\n  }, function (err) {\n    self.cancel();\n    if (callback) {\n      // if there's a callback, then the callback can receive\n      // the error event\n      callback(err);\n    } else {\n      // if there's no callback, then we're safe to emit an error\n      // event, which would otherwise throw an unhandled error\n      // due to 'error' being a special event in EventEmitters\n      self.emit('error', err);\n    }\n    self.removeAllListeners();\n    if (callback) {\n      // no sense throwing if we're already emitting an 'error' event\n      throw err;\n    }\n  });\n\n  this.then = function (success, err) {\n    return promise.then(success, err);\n  };\n\n  this[\"catch\"] = function (err) {\n    return promise[\"catch\"](err);\n  };\n}\n\nSync.prototype.cancel = function () {\n  if (!this.canceled) {\n    this.canceled = true;\n    this.push.cancel();\n    this.pull.cancel();\n  }\n};\n\nfunction replication(PouchDB) {\n  PouchDB.replicate = replicateWrapper;\n  PouchDB.sync = sync$1;\n\n  Object.defineProperty(PouchDB.prototype, 'replicate', {\n    get: function () {\n      var self = this;\n      if (typeof this.replicateMethods === 'undefined') {\n        this.replicateMethods = {\n          from: function (other, opts, callback) {\n            return self.constructor.replicate(other, self, opts, callback);\n          },\n          to: function (other, opts, callback) {\n            return self.constructor.replicate(self, other, opts, callback);\n          }\n        };\n      }\n      return this.replicateMethods;\n    }\n  });\n\n  PouchDB.prototype.sync = function (dbName, opts, callback) {\n    return this.constructor.sync(this, dbName, opts, callback);\n  };\n}\n\nPouchDB.plugin(IDBPouch)\n  .plugin(WebSqlPouch$1)\n  .plugin(HttpPouch$1)\n  .plugin(mapreduce)\n  .plugin(replication);\n\n// Pull from src because pouchdb-node/pouchdb-browser themselves\n// are aggressively optimized and jsnext:main would normally give us this\n// aggressive bundle.\n\nmodule.exports = PouchDB;\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"1\":1,\"10\":10,\"11\":11,\"16\":16,\"2\":2,\"4\":4,\"5\":5,\"6\":6,\"7\":7}]},{},[17])(17)\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/pouchdb/dist/pouchdb.js\n// module id = 22\n// module chunks = 0","import Events from '../../_events';\nimport Routie from \"routie\";\n\n$(window).on(`${Events.AJAX} ${Events.LOADED}`, () => {\n    Routie({\n        'navigation': function() {\n            $('#NavbarCollapse').addClass('in');\n        },\n        'carousel:id:num': function(id, num) {\n            $(`#Carousel${  id}`).carousel(num);\n        },\n    });\n});\n\n\n// WEBPACK FOOTER //\n// ./app/client/src/js/_components/routes/index.js","\"use strict\";\n\nvar path = require('path');\n\nvar methods = ['get', 'post', 'put', 'patch', 'delete', 'del', 'all'];\n\nvar __slice = [].slice;\n\nmodule.exports = function (map) {\n    var args, root, _map, cb;\n    args = __slice.call(arguments, 1);\n\n    if (typeof args[args.length - 1] === \"function\") cb = args.pop();\n\n    root = path.join.apply(path, args);\n    _map = {};\n    methods.forEach(function (m) {\n        _map[m] = function (subpath) {\n            var args = __slice.call(arguments);\n            args.length < 2 ? args.unshift(root) : args[0] = root + args[0];\n            return map[m].apply(map, args);\n        }\n    });\n    if (cb) cb(_map);\n    return _map;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/routie/index.js\n// module id = 24\n// module chunks = 0","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// resolves . and .. elements in a path array with directory names there\n// must be no slashes, empty elements, or device names (c:\\) in the array\n// (so also no leading and trailing slashes - it does not distinguish\n// relative and absolute paths)\nfunction normalizeArray(parts, allowAboveRoot) {\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = parts.length - 1; i >= 0; i--) {\n    var last = parts[i];\n    if (last === '.') {\n      parts.splice(i, 1);\n    } else if (last === '..') {\n      parts.splice(i, 1);\n      up++;\n    } else if (up) {\n      parts.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (allowAboveRoot) {\n    for (; up--; up) {\n      parts.unshift('..');\n    }\n  }\n\n  return parts;\n}\n\n// Split a filename into [root, dir, basename, ext], unix version\n// 'root' is just a slash, or nothing.\nvar splitPathRe =\n    /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\nvar splitPath = function(filename) {\n  return splitPathRe.exec(filename).slice(1);\n};\n\n// path.resolve([from ...], to)\n// posix version\nexports.resolve = function() {\n  var resolvedPath = '',\n      resolvedAbsolute = false;\n\n  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n    var path = (i >= 0) ? arguments[i] : process.cwd();\n\n    // Skip empty and invalid entries\n    if (typeof path !== 'string') {\n      throw new TypeError('Arguments to path.resolve must be strings');\n    } else if (!path) {\n      continue;\n    }\n\n    resolvedPath = path + '/' + resolvedPath;\n    resolvedAbsolute = path.charAt(0) === '/';\n  }\n\n  // At this point the path should be resolved to a full absolute path, but\n  // handle relative paths to be safe (might happen when process.cwd() fails)\n\n  // Normalize the path\n  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {\n    return !!p;\n  }), !resolvedAbsolute).join('/');\n\n  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n};\n\n// path.normalize(path)\n// posix version\nexports.normalize = function(path) {\n  var isAbsolute = exports.isAbsolute(path),\n      trailingSlash = substr(path, -1) === '/';\n\n  // Normalize the path\n  path = normalizeArray(filter(path.split('/'), function(p) {\n    return !!p;\n  }), !isAbsolute).join('/');\n\n  if (!path && !isAbsolute) {\n    path = '.';\n  }\n  if (path && trailingSlash) {\n    path += '/';\n  }\n\n  return (isAbsolute ? '/' : '') + path;\n};\n\n// posix version\nexports.isAbsolute = function(path) {\n  return path.charAt(0) === '/';\n};\n\n// posix version\nexports.join = function() {\n  var paths = Array.prototype.slice.call(arguments, 0);\n  return exports.normalize(filter(paths, function(p, index) {\n    if (typeof p !== 'string') {\n      throw new TypeError('Arguments to path.join must be strings');\n    }\n    return p;\n  }).join('/'));\n};\n\n\n// path.relative(from, to)\n// posix version\nexports.relative = function(from, to) {\n  from = exports.resolve(from).substr(1);\n  to = exports.resolve(to).substr(1);\n\n  function trim(arr) {\n    var start = 0;\n    for (; start < arr.length; start++) {\n      if (arr[start] !== '') break;\n    }\n\n    var end = arr.length - 1;\n    for (; end >= 0; end--) {\n      if (arr[end] !== '') break;\n    }\n\n    if (start > end) return [];\n    return arr.slice(start, end - start + 1);\n  }\n\n  var fromParts = trim(from.split('/'));\n  var toParts = trim(to.split('/'));\n\n  var length = Math.min(fromParts.length, toParts.length);\n  var samePartsLength = length;\n  for (var i = 0; i < length; i++) {\n    if (fromParts[i] !== toParts[i]) {\n      samePartsLength = i;\n      break;\n    }\n  }\n\n  var outputParts = [];\n  for (var i = samePartsLength; i < fromParts.length; i++) {\n    outputParts.push('..');\n  }\n\n  outputParts = outputParts.concat(toParts.slice(samePartsLength));\n\n  return outputParts.join('/');\n};\n\nexports.sep = '/';\nexports.delimiter = ':';\n\nexports.dirname = function(path) {\n  var result = splitPath(path),\n      root = result[0],\n      dir = result[1];\n\n  if (!root && !dir) {\n    // No dirname whatsoever\n    return '.';\n  }\n\n  if (dir) {\n    // It has a dirname, strip trailing slash\n    dir = dir.substr(0, dir.length - 1);\n  }\n\n  return root + dir;\n};\n\n\nexports.basename = function(path, ext) {\n  var f = splitPath(path)[2];\n  // TODO: make this comparison case-insensitive on windows?\n  if (ext && f.substr(-1 * ext.length) === ext) {\n    f = f.substr(0, f.length - ext.length);\n  }\n  return f;\n};\n\n\nexports.extname = function(path) {\n  return splitPath(path)[3];\n};\n\nfunction filter (xs, f) {\n    if (xs.filter) return xs.filter(f);\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        if (f(xs[i], i, xs)) res.push(xs[i]);\n    }\n    return res;\n}\n\n// String.prototype.substr - negative index don't work in IE8\nvar substr = 'ab'.substr(-1) === 'b'\n    ? function (str, start, len) { return str.substr(start, len) }\n    : function (str, start, len) {\n        if (start < 0) start = str.length + start;\n        return str.substr(start, len);\n    }\n;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/path-browserify/index.js\n// module id = 25\n// module chunks = 0","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/node_modules/process/browser.js\n// module id = 26\n// module chunks = 0","/*! smooth-scroll v14.2.0 | (c) 2018 Chris Ferdinandi | MIT License | http://github.com/cferdinandi/smooth-scroll */\n!(function(e,t){\"function\"==typeof define&&define.amd?define([],(function(){return t(e)})):\"object\"==typeof exports?module.exports=t(e):e.SmoothScroll=t(e)})(\"undefined\"!=typeof global?global:\"undefined\"!=typeof window?window:this,(function(e){\"use strict\";var t={ignore:\"[data-scroll-ignore]\",header:null,topOnEmptyHash:!0,speed:500,clip:!0,offset:0,easing:\"easeInOutCubic\",customEasing:null,updateURL:!0,popstate:!0,emitEvents:!0},n=function(){return\"querySelector\"in document&&\"addEventListener\"in e&&\"requestAnimationFrame\"in e&&\"closest\"in e.Element.prototype},o=function(){for(var e={},t=0;t<arguments.length;t++)!(function(t){for(var n in t)t.hasOwnProperty(n)&&(e[n]=t[n])})(arguments[t]);return e},r=function(t){return!!(\"matchMedia\"in e&&e.matchMedia(\"(prefers-reduced-motion)\").matches)},a=function(t){return parseInt(e.getComputedStyle(t).height,10)},i=function(e){var t;try{t=decodeURIComponent(e)}catch(n){t=e}return t},c=function(e){\"#\"===e.charAt(0)&&(e=e.substr(1));for(var t,n=String(e),o=n.length,r=-1,a=\"\",i=n.charCodeAt(0);++r<o;){if(0===(t=n.charCodeAt(r)))throw new InvalidCharacterError(\"Invalid character: the input contains U+0000.\");t>=1&&t<=31||127==t||0===r&&t>=48&&t<=57||1===r&&t>=48&&t<=57&&45===i?a+=\"\\\\\"+t.toString(16)+\" \":a+=t>=128||45===t||95===t||t>=48&&t<=57||t>=65&&t<=90||t>=97&&t<=122?n.charAt(r):\"\\\\\"+n.charAt(r)}var c;try{c=decodeURIComponent(\"#\"+a)}catch(e){c=\"#\"+a}return c},u=function(e,t){var n;return\"easeInQuad\"===e.easing&&(n=t*t),\"easeOutQuad\"===e.easing&&(n=t*(2-t)),\"easeInOutQuad\"===e.easing&&(n=t<.5?2*t*t:(4-2*t)*t-1),\"easeInCubic\"===e.easing&&(n=t*t*t),\"easeOutCubic\"===e.easing&&(n=--t*t*t+1),\"easeInOutCubic\"===e.easing&&(n=t<.5?4*t*t*t:(t-1)*(2*t-2)*(2*t-2)+1),\"easeInQuart\"===e.easing&&(n=t*t*t*t),\"easeOutQuart\"===e.easing&&(n=1- --t*t*t*t),\"easeInOutQuart\"===e.easing&&(n=t<.5?8*t*t*t*t:1-8*--t*t*t*t),\"easeInQuint\"===e.easing&&(n=t*t*t*t*t),\"easeOutQuint\"===e.easing&&(n=1+--t*t*t*t*t),\"easeInOutQuint\"===e.easing&&(n=t<.5?16*t*t*t*t*t:1+16*--t*t*t*t*t),e.customEasing&&(n=e.customEasing(t)),n||t},s=function(){return Math.max(document.body.scrollHeight,document.documentElement.scrollHeight,document.body.offsetHeight,document.documentElement.offsetHeight,document.body.clientHeight,document.documentElement.clientHeight)},l=function(t,n,o,r){var a=0;if(t.offsetParent)do{a+=t.offsetTop,t=t.offsetParent}while(t);return a=Math.max(a-n-o,0),r&&(a=Math.min(a,s()-e.innerHeight)),a},d=function(e){return e?a(e)+e.offsetTop:0},f=function(e,t,n){t||history.pushState&&n.updateURL&&history.pushState({smoothScroll:JSON.stringify(n),anchor:e.id},document.title,e===document.documentElement?\"#top\":\"#\"+e.id)},m=function(t,n,o){0===t&&document.body.focus(),o||(t.focus(),document.activeElement!==t&&(t.setAttribute(\"tabindex\",\"-1\"),t.focus(),t.style.outline=\"none\"),e.scrollTo(0,n))},h=function(t,n,o,r){if(n.emitEvents&&\"function\"==typeof e.CustomEvent){var a=new CustomEvent(t,{bubbles:!0,detail:{anchor:o,toggle:r}});document.dispatchEvent(a)}};return function(a,p){var g,v,y,S,E,b,O,I={};I.cancelScroll=function(e){cancelAnimationFrame(O),O=null,e||h(\"scrollCancel\",g)},I.animateScroll=function(n,r,a){var i=o(g||t,a||{}),c=\"[object Number]\"===Object.prototype.toString.call(n),p=c||!n.tagName?null:n;if(c||p){var v=e.pageYOffset;i.header&&!S&&(S=document.querySelector(i.header)),E||(E=d(S));var y,b,C,w=c?n:l(p,E,parseInt(\"function\"==typeof i.offset?i.offset(n,r):i.offset,10),i.clip),L=w-v,A=s(),H=0,q=function(t,o){var a=e.pageYOffset;if(t==o||a==o||(v<o&&e.innerHeight+a)>=A)return I.cancelScroll(!0),m(n,o,c),h(\"scrollStop\",i,n,r),y=null,O=null,!0},Q=function(t){y||(y=t),H+=t-y,b=H/parseInt(i.speed,10),b=b>1?1:b,C=v+L*u(i,b),e.scrollTo(0,Math.floor(C)),q(C,w)||(O=e.requestAnimationFrame(Q),y=t)};0===e.pageYOffset&&e.scrollTo(0,0),f(n,c,i),h(\"scrollStart\",i,n,r),I.cancelScroll(!0),e.requestAnimationFrame(Q)}};var C=function(t){if(!r()&&0===t.button&&!t.metaKey&&!t.ctrlKey&&\"closest\"in t.target&&(y=t.target.closest(a))&&\"a\"===y.tagName.toLowerCase()&&!t.target.closest(g.ignore)&&y.hostname===e.location.hostname&&y.pathname===e.location.pathname&&/#/.test(y.href)){var n=c(i(y.hash)),o=g.topOnEmptyHash&&\"#\"===n?document.documentElement:document.querySelector(n);o=o||\"#top\"!==n?o:document.documentElement,o&&(t.preventDefault(),I.animateScroll(o,y))}},w=function(e){if(history.state.smoothScroll&&history.state.smoothScroll===JSON.stringify(g)&&history.state.anchor){var t=document.querySelector(c(i(history.state.anchor)));t&&I.animateScroll(t,null,{updateURL:!1})}},L=function(e){b||(b=setTimeout((function(){b=null,E=d(S)}),66))};return I.destroy=function(){g&&(document.removeEventListener(\"click\",C,!1),e.removeEventListener(\"resize\",L,!1),e.removeEventListener(\"popstate\",w,!1),I.cancelScroll(),g=null,v=null,y=null,S=null,E=null,b=null,O=null)},I.init=function(r){if(!n())throw\"Smooth Scroll: This browser does not support the required JavaScript methods and browser APIs.\";I.destroy(),g=o(t,r||{}),S=g.header?document.querySelector(g.header):null,E=d(S),document.addEventListener(\"click\",C,!1),S&&e.addEventListener(\"resize\",L,!1),g.updateURL&&g.popstate&&e.addEventListener(\"popstate\",w,!1)},I.init(p),I}}));\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/smooth-scroll/dist/smooth-scroll.min.js\n// module id = 27\n// module chunks = 0","var map = {\n\t\"./icon-cfpb.png\": 29,\n\t\"./icon-lender.png\": 30,\n\t\"./logo.png\": 31\n};\nfunction webpackContext(req) {\n\treturn __webpack_require__(webpackContextResolve(req));\n};\nfunction webpackContextResolve(req) {\n\tvar id = map[req];\n\tif(!(id + 1)) // check for number or string\n\t\tthrow new Error(\"Cannot find module '\" + req + \"'.\");\n\treturn id;\n};\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = 28;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/client/src/img nonrecursive \\.(png|jpe?g|svg)$\n// module id = 28\n// module chunks = 0","module.exports = \"../img/icon-cfpb.png\";\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/client/src/img/icon-cfpb.png\n// module id = 29\n// module chunks = 0","module.exports = \"../img/icon-lender.png\";\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/client/src/img/icon-lender.png\n// module id = 30\n// module chunks = 0","module.exports = \"../img/logo.png\";\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/client/src/img/logo.png\n// module id = 31\n// module chunks = 0","function webpackEmptyContext(req) {\n\tthrow new Error(\"Cannot find module '\" + req + \"'.\");\n}\nwebpackEmptyContext.keys = function() { return []; };\nwebpackEmptyContext.resolve = webpackEmptyContext;\nmodule.exports = webpackEmptyContext;\nwebpackEmptyContext.id = 32;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/font-awesome nonrecursive \\.(otf|eot|svg|ttf|woff|woff2)$\n// module id = 32\n// module chunks = 0"],"sourceRoot":""}